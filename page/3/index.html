<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ShifuDong" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="记录生活， 记录学习， 分享知识">
<meta name="keywords" content="生活，C++, C, go, java, OS, 网络， 存储， 联邦学习， 机器学习，python">
<meta property="og:type" content="website">
<meta property="og:title" content="ShifuDong">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;3&#x2F;index.html">
<meta property="og:site_name" content="ShifuDong">
<meta property="og:description" content="记录生活， 记录学习， 分享知识">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ShifuDong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShifuDong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Knowledge Sharing</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/21/mysql_2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/mysql_2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">mysql日志系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-21 21:29:27" itemprop="dateCreated datePublished" datetime="2020-12-21T21:29:27+08:00">2020-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-30 13:43:39" itemprop="dateModified" datetime="2021-03-30T13:43:39+08:00">2021-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h3><p>MySQL可以恢复到半个月内任意一秒的状态，这是怎样做到的？</p>
<p>考虑一条更新语句的执行流程？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>
<p>更新语句会与查询语句有很多相似地方(连接、缓存查询，分析等)，与查询流程不一样的是，<strong>更新流程还涉及两个重要的日志模块</strong>：<code>redo log</code>（重做日志）和 <code>binlog</code>（归档日志）。</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>在MySQL里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了WAL技术，<strong>WAL的全称是Write-Ahead Logging，它的关键点是先写日志，再写磁盘。</strong></p>
<p>具体来说，当有一条记录需要更新的时候，<strong>InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做</strong>。</p>
<p>InnoDB的<strong>redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作</strong>。<strong>从头开始写，写到末尾就又回到开头循环写，如下面这个图所示：</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/fa0cd9fa-4d34-4017-b30d-84b7b04d3c4f-11197877.jpg" alt="redo_log"></p>
<p>write pos是<strong>当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头</strong>。checkpoint是<strong>当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</strong></p>
<p>write pos和checkpoint之间的是还空着的部分（write pos后面以及checkpoint前面的部分），可以用来记录新的操作。<strong>如果write pos追上checkpoint，表示log满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下</strong>。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<p><code>innodb_flush_log_at_trx_commit</code>这个参数设置成1的时候，表示<strong>每次事务的redo log都直接持久化到磁盘</strong>。这个参数建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p><strong>redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</strong></p>
<p>会有两份日志？因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，<strong>binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</strong></p>
<p>两种日志的不同点：</p>
<ul>
<li><p>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</p>
</li>
<li><p>redo log是<strong>物理日志，记录的是“在某个数据页上做了什么修改”</strong>；binlog是<strong>逻辑日志，记录的是这个语句的原始逻辑</strong>，比如“给ID=2这一行的c字段加1 ”。</p>
</li>
<li><p>redo log是<strong>循环写</strong>的，<strong>空间固定会用完</strong>；binlog是<strong>可以追加写入</strong>的。“追加写”是指<strong>binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</strong>。</p>
</li>
</ul>
<p><code>sync_binlog</code>这个参数设置成1的时候，表示<strong>每次事务的binlog都持久化到磁盘。这个参数建议设置成1，这样可以保证MySQL异常重启之后binlog不丢失</strong>。</p>
<p>执行器和InnoDB引擎在执行一个简单的update(<code>update T set c=c+1 where ID=2</code>)语句时的内部流程：</p>
<ul>
<li><p>执行器先找引擎取ID=2这一行。ID是<strong>主键</strong>，引擎直接用<strong>树搜索</strong>找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li><p>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，<strong>得到新的一行数据，再调用引擎接口写入这行新数据。</strong></p>
</li>
<li><p>引擎将这行<strong>新数据更新到内存中，同时将这个更新操作记录到redo log里面</strong>，此时<strong>redo log处于prepare状态</strong>。然后告知执行器执行完成了，随时可以提交事务。</p>
</li>
<li><p><strong>执行器生成这个操作的binlog，并把binlog写入磁盘。</strong></p>
</li>
<li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成<strong>提交（commit）状态，更新完成。</strong></p>
</li>
</ul>
<p>将redo log的写入拆成了两个步骤：prepare和commit，这就是<strong>“两阶段提交”</strong>。</p>
<h4 id="redo-log的两阶段提交"><a href="#redo-log的两阶段提交" class="headerlink" title="redo log的两阶段提交"></a>redo log的两阶段提交</h4><p>两阶段提交的目的是<strong>为了让两份日志之间的逻辑一致</strong>。</p>
<p>反证法：</p>
<p>仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p>
<ul>
<li><p><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。前面说过，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后会发现，<strong>如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</strong></p>
</li>
<li><p><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，<strong>由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</strong></p>
</li>
</ul>
<p>可以看到，<strong>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</strong></p>
<p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，可以这么做：</p>
<ul>
<li>首先，<strong>找到最近的一次全量备份</strong>，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到<strong>临时库</strong>；</li>
<li>然后，<strong>从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</strong></li>
</ul>
<p>这样临时库就跟误删之前的线上库一样了，然后可以<strong>把表数据从临时库取出来，按需要恢复到线上库去。</strong>不只是误操作后需要用这个过程来恢复数据。当需要<strong>扩容</strong>的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用<strong>全量备份加上应用binlog来实现的</strong>，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p>
<p>简单说，<strong>redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/20/mysql-5mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-mvcc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/20/mysql-5mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-mvcc/" class="post-title-link" itemprop="url">mysql性能优化-mvcc</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-20 17:02:01" itemprop="dateCreated datePublished" datetime="2020-12-20T17:02:01+08:00">2020-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-17 21:34:36" itemprop="dateModified" datetime="2021-03-17T21:34:36+08:00">2021-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>实验1:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> autocommit=<span class="keyword">off</span>;  </span><br><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> lastUpdate=<span class="keyword">now</span>() <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">--在未做commit/rollback操作之前  </span></span><br><span class="line"><span class="comment">--在其他的事务能不能进行对应数据的查询(特别是加上了X锁的数据)  </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">1</span>; </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>实验2:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> lastUpdate=<span class="keyword">now</span>() <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>两个实验从结果上来看是一致的，底层实现是一样的吗？跟MVCC有什么关系？ </p>
<h4 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC"></a>MVCC</h4><p>multiversion concurrency control （多版本并发控制）：并发访问(读或写)数据库时,对正在事务内处理的数据做多版本的管理。达到避免写操作的堵塞，从而引发读操作的并发问题。</p>
<p>MVCC插入逻辑流程 ：</p>
<p><img src="https://api2.mubu.com/v3/document_image/de8de1d3-76d7-4062-bbcd-82146470f0be-11197877.jpg" alt="MVCC插入逻辑流程"></p>
<p>MVCC删除逻辑流程：</p>
<p><img src="https://api2.mubu.com/v3/document_image/8e3f45d4-6284-44e3-a785-09c59fdeb861-11197877.jpg" alt="MVCC删除逻辑流程"></p>
<p>MVCC修改逻辑流程：</p>
<p><img src="https://api2.mubu.com/v3/document_image/d80ca7d4-6d88-495a-a294-2cf1e6d1d949-11197877.jpg" alt="MVCC修改逻辑流程"></p>
<p>MVCC查询逻辑流程:</p>
<p><img src="https://api2.mubu.com/v3/document_image/6bfce1c3-7ec8-4023-ad62-e14a1689f4e2-11197877.jpg" alt="MVCC查询逻辑流程"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/17/mysql-4mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/17/mysql-4mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%94%81/" class="post-title-link" itemprop="url">mysql性能优化-事务及锁</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-17 10:46:03" itemprop="dateCreated datePublished" datetime="2020-12-17T10:46:03+08:00">2020-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-17 21:31:54" itemprop="dateModified" datetime="2021-03-17T21:31:54+08:00">2021-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h4><ul>
<li>原子性(Atomicity) <strong>最小的工作单元</strong>，整个工作单元要么<strong>一起提交成功，要么全部失败回滚</strong>。  </li>
<li>一致性(Consistency) <strong>事务中操作的数据及状态改变是一致的</strong>，即写入资料的结果必须完全符合预设的规则，不会因为出现系统意外等原因导致状态的不一致。  </li>
<li>隔离性(Isolation) <strong>一个事务所操作的数据在提交之前，对其他事务的可见性设定(一般设定为不可见)。</strong>  </li>
<li>持久性(Durability) 事务所做的修改就会<strong>永久保存</strong>，不会因为系统意外导致数据的丢失。 </li>
</ul>
<h4 id="事务并发带来的的问题"><a href="#事务并发带来的的问题" class="headerlink" title="事务并发带来的的问题"></a>事务并发带来的的问题</h4><ul>
<li>脏读:<strong>在不同事务下，当前事务可以读到另外事务未提交的数据</strong>。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/1d32ed1d-7caa-4b42-9156-29eba926152b-11197877.jpg" alt="脏读"></p>
<ul>
<li>不可重复读：在<strong>一个事务内多次读取同一数据集合</strong>。<strong>在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。</strong></li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/e0c73513-4f11-4041-adfd-d9f751c73566-11197877.jpg" alt="不可重复读"></p>
<ul>
<li>幻读:本质上也属于不可重复读的情况，T1读取某个范围的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/7a4e33c7-588d-4c8e-a48c-ddbe6a23c54f-11197877.jpg" alt="幻读"></p>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul>
<li>未提交读：<strong>事务中的修改，即使没有提交，对其它事务也是可见的</strong><ul>
<li>存在脏读，不能解决并发问题</li>
</ul>
</li>
<li>Read Committed(提交读)：一个事务开始之后，只能看到自己提交的事务所做的修改。<ul>
<li>解决了脏读问题，没有解决不可重复读(nonrepeatable read) 问题</li>
</ul>
</li>
<li>Repeatable Read (可重复读)：在同一个事务中多次读取同样的数据结果是一样的。<ul>
<li>解决不可重复读问题，未定义解决幻读的问题</li>
</ul>
</li>
<li>Serializable (串行化)：解决所有问题 最高的隔离级别，通过强制事务的<strong>串行执行</strong> </li>
</ul>
<p>查看mysql的设置的事务隔离级别:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@tx_isolation; <span class="comment">--默认为REPEATABLE-READ</span></span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/69afe5ec-ba61-48fe-903e-063c2bf57fcc-11197877.jpg" alt="mysql事务隔离级别"></p>
<h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><h4 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h4><p>锁用于管理<strong>不同事务对共享资源的并发访问</strong>。</p>
<p>表锁与行锁的区别: </p>
<ul>
<li>锁定粒度:表锁 &gt; 行锁  </li>
<li>加锁效率:表锁 &gt; 行锁  </li>
<li>冲突概率:表锁 &gt; 行锁  </li>
<li>并发性能:表锁 &lt; 行锁  </li>
</ul>
<h4 id="InnoDB锁类型"><a href="#InnoDB锁类型" class="headerlink" title="InnoDB锁类型"></a>InnoDB锁类型</h4><p>InnoDB存储引擎支持行锁和表锁(另类的行锁)。</p>
<ul>
<li>共享锁(行锁):Shared Locks  <ul>
<li>又称为<strong>读锁</strong>，简称S锁，顾名思义，共享锁就是<strong>多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改</strong>； </li>
</ul>
</li>
<li>排它锁(行锁):Exclusive Locks  <ul>
<li>又称为<strong>写锁</strong>，简称X锁，<strong>排他锁不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的锁</strong>(共享锁、排他锁)，只有该获取了排他锁的事务是可以对数据行进行读取和修改，(<strong>其他事务要读取数据可来自于快照</strong>)。  </li>
</ul>
</li>
<li>意向锁共享锁(表锁):Intention Shared Locks  </li>
<li>意向锁排它锁(表锁):Intention Exclusive Locks  </li>
<li>自增锁:AUTO-INC Locks</li>
</ul>
<h5 id="表锁操作"><a href="#表锁操作" class="headerlink" title="表锁操作"></a>表锁操作</h5><p>共享锁加锁释放锁语法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;   </span><br><span class="line"><span class="keyword">commit</span>/<span class="keyword">rollback</span></span><br></pre></td></tr></table></figure>
<p>排它锁加锁释锁方式:  </p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> / <span class="keyword">update</span> / <span class="keyword">insert</span> 默认加上X锁  </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>  </span><br><span class="line"><span class="keyword">commit</span>/<span class="keyword">rollback</span></span><br></pre></td></tr></table></figure>
<p>行锁的算法：</p>
<ul>
<li>记录锁 Record Locks  </li>
<li>间隙锁 Gap Locks  </li>
<li>临键锁 Next-key Locks</li>
</ul>
<h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><ul>
<li>InnoDB的行锁是通过<strong>给索引上的索引项加锁</strong>来实现的。   </li>
<li><strong>只有通过索引条件进行数据检索，InnoDB才使用行级锁，</strong>否则，InnoDB 将使用表锁(锁住索引的所有记录)</li>
<li><p><strong>使用二级索引(辅助索引)去更新数据，会把二级索引和聚集索引都上锁</strong>。  </p>
</li>
<li><p>意向共享锁(IS)  ：表示事务<strong>准备</strong>给数据行加入共享锁，即<strong>一个数据行加共享锁前必须先取得该表的IS锁，意向共享锁之间是可以相互兼容的。</strong>  </p>
</li>
<li>意向排它锁(IX)  ：表示事务准备给数据行加入排他锁，即一个数据行加排他锁前必须先取得该表的IX锁，意向排它锁之间是可以相互兼容的。</li>
</ul>
<p>意向锁(IS、IX)是InnoDB数据操作之前<strong>自动加</strong>的，<strong>不需要用户干预</strong>。  </p>
<p>意义：当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁。 </p>
<h5 id="自增锁-AUTO-INC-Locks"><a href="#自增锁-AUTO-INC-Locks" class="headerlink" title="自增锁:AUTO-INC Locks"></a>自增锁:AUTO-INC Locks</h5><ul>
<li>针对<strong>自增列自增长</strong>的一个特殊的<strong>表级</strong>别锁  </li>
<li><code>show variables like &#39;innodb_autoinc_lock_mode&#39;;</code></li>
<li><strong>默认取值1，代表连续，事务未提交ID永久丢失</strong></li>
</ul>
<h5 id="临键锁Next-key-locks"><a href="#临键锁Next-key-locks" class="headerlink" title="临键锁Next-key locks"></a>临键锁Next-key locks</h5><p><img src="https://api2.mubu.com/v3/document_image/efa963f1-d97a-41c2-9151-53d963a0b882-11197877.jpg" alt="临键锁"></p>
<ul>
<li>锁住记录+区间(左开右闭)  </li>
<li><strong>当sql执行按照索引进行数据的检索时,查询条件为范围查找(between and、&lt;、&gt;等)并有数据命中则此时SQL语句加上的锁为Next-key locks，锁住索引的记录+区间(左开右闭)</strong> </li>
</ul>
<h5 id="间隙锁Gap-locks"><a href="#间隙锁Gap-locks" class="headerlink" title="间隙锁Gap locks"></a>间隙锁Gap locks</h5><p><img src="https://api2.mubu.com/v3/document_image/7a70a939-fb7c-4389-8bb2-ec5fb753a9d1-11197877.jpg" alt="间隙锁"></p>
<ul>
<li><strong>锁住数据不存在的区间</strong>(左开右开)  </li>
<li>当sql执行按照索引进行数据的检索时，<strong>查询条件的数据不存在，这时SQL语句加上的锁即为 Gap locks，锁住索引不存在的区间(左开右开)</strong>  </li>
</ul>
<h5 id="记录锁Record-locks"><a href="#记录锁Record-locks" class="headerlink" title="记录锁Record locks"></a>记录锁Record locks</h5><p><img src="https://api2.mubu.com/v3/document_image/bed5f5dc-376c-44a6-9022-d45a8da2b91c-11197877.jpg" alt="记录锁"></p>
<ul>
<li>锁住<strong>具体的索引项</strong>  </li>
<li>当sql执行<strong>按照唯一性(Primary key、Unique key)索引进行数据的检索</strong>时，查询条件等值匹 配且查询的数据存在，这时SQL语句加上的锁即为记录锁Record locks，<strong>锁住具体的索引项</strong>  </li>
</ul>
<h4 id="利用锁解决并发问题"><a href="#利用锁解决并发问题" class="headerlink" title="利用锁解决并发问题"></a>利用锁解决并发问题</h4><p>解决脏读 :</p>
<p><img src="https://api2.mubu.com/v3/document_image/e2cf51fb-3076-418d-a9dd-5316ed372267-11197877.jpg" alt="解决脏读"></p>
<p>解决不可重复读  :</p>
<p><img src="https://api2.mubu.com/v3/document_image/632f11ea-acd7-4adc-b2d3-819bb46c924c-11197877.jpg" alt="解决不可重复读"></p>
<p>解决幻读:</p>
<p><img src="https://api2.mubu.com/v3/document_image/cf157ef6-11cd-4f0c-befe-00c8ac992a70-11197877.jpg" alt="解决幻读"></p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul>
<li>多个并发事务(2个或者以上);  </li>
<li>每个事务都持有锁(或者是已经在等待锁);  </li>
<li>每个事务都需要再继续持有锁;  </li>
<li><strong>事务之间产生加锁的循环等待，形成死锁</strong>。</li>
</ul>
<h4 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h4><ul>
<li>类似的业务逻辑以<strong>固定的顺序访问表和行</strong>。  </li>
<li>大事务拆小。大事务更倾向于死锁，如果业务允许，<strong>将大事务拆小</strong>。  </li>
<li>在<strong>同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。</strong>  </li>
<li><strong>降低隔离级别</strong>，如果业务允许，将隔离级别调低也是较好的选择  </li>
<li>为表添加<strong>合理的索引</strong>。可以看到<strong>如果不走索引将会为表的每一行记录添 加上锁(或者说是表锁)</strong>  </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/14/mysql-3mysql%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%9C%BA%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/14/mysql-3mysql%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%9C%BA%E7%90%86/" class="post-title-link" itemprop="url">mysql性能分析-体系结构及运行机理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-14 09:38:25" itemprop="dateCreated datePublished" datetime="2020-12-14T09:38:25+08:00">2020-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-17 21:23:07" itemprop="dateModified" datetime="2021-03-17T21:23:07+08:00">2021-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Mysql体系结构"><a href="#Mysql体系结构" class="headerlink" title="Mysql体系结构"></a>Mysql体系结构</h3><p><img src="https://api2.mubu.com/v3/document_image/a1619f89-f86a-4530-ab7c-6db518222e98-11197877.jpg" alt="mysql体系结构"></p>
<ul>
<li><p>Client Connectors  </p>
<ul>
<li>接入方 支持协议很多  </li>
<li>Management Serveices &amp; Utilities 系统管理和控制工具，mysql dump、 mysql复制集群、分区管理等  </li>
</ul>
</li>
<li><p>Connection Pool  </p>
<ul>
<li>连接池:管理缓冲用户连接、用户名、<strong>密码、权限校验</strong>、线程处理等需要缓存的需求  </li>
</ul>
</li>
<li><p>SQL Interface  </p>
<ul>
<li>SQL接口:接受用户的SQL命令，并且返回用户需要查询的结果  </li>
</ul>
</li>
<li><p>Parser  </p>
<ul>
<li>解析器，SQL命令传递到解析器的时候会被<strong>解析器验证和解析</strong>。解析器是由Lex和YACC实现的  </li>
</ul>
</li>
<li><p>Optimizer  </p>
<ul>
<li>查询优化器，<strong>SQL语句在查询之前会使用查询优化器对查询进行优化</strong>  </li>
</ul>
</li>
<li><p>Cache和Buffer(高速缓存区)  </p>
<ul>
<li>查询缓存，如果<strong>查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据</strong>  </li>
</ul>
</li>
<li><p>pluggable storage Engines </p>
<ul>
<li>插件式存储引擎。<strong>存储引擎是MySql中具体的与文件打交道的子系统</strong>  </li>
</ul>
</li>
<li><p>file system  </p>
<ul>
<li>文件系统，数据、日志(redo，undo)、索引、错误日志、查询记录、慢查询等</li>
</ul>
</li>
</ul>
<h3 id="Mysql查询优化"><a href="#Mysql查询优化" class="headerlink" title="Mysql查询优化"></a>Mysql查询优化</h3><p><img src="https://api2.mubu.com/v3/document_image/38b5c5c9-ec61-4671-80ff-2eb68bbd83f1-11197877.jpg" alt="查询过程"></p>
<h4 id="client-server通信"><a href="#client-server通信" class="headerlink" title="client/server通信"></a>client/server通信</h4><p>Mysql客户端与服务端的通信方式是<strong>“半双工”;</strong>  </p>
<ul>
<li>全双工:双向通信，发送同时也可以接收(tcp握手过程)  </li>
<li>半双工:<strong>双向通信，同时只能接收或者是发送，无法同时做操作</strong>  <ul>
<li>半双工通信: 在任何一个时刻，要么是有服务器向客户端发送数据，要么是客户端向服务端发送数据，这<strong>两个动作不能同时发生</strong>。所以我们无法也无需将一个消息切成小块进行传输。  </li>
<li>特点和限制: 客户端一旦开始发送消息，另一端要接收完整个消息才能响应。  </li>
<li>客户端一旦开始接收数据没法停下来发送指令。  </li>
</ul>
</li>
<li>单工:只能单一方向传送  </li>
</ul>
<h4 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h4><p>对于一个mysql连接，或者说一个线程，时刻都有一个状态来标识这个连接正在做什么。</p>
<p>查看命令 <code>show full processlist / show processlist</code>  </p>
<p><img src="https://api2.mubu.com/v3/document_image/4e83270b-5e57-4839-8470-5e4141670dfc-11197877.jpg" alt="查询参数"></p>
<ul>
<li>Sleep:线程正在等待客户端发送数据  </li>
<li>Query:连接线程正在执行查询</li>
<li>Locked:线程正在等待表锁的释放  </li>
<li>Sorting result:线程正在对结果进行排序  </li>
<li>Sending data:向请求端返回数据</li>
</ul>
<p>可通过<code>kill {id}</code>的方式进行连接的杀掉 </p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><ul>
<li>工作原理:<ul>
<li>缓存SELECT操作的结果集和SQL语句</li>
<li>新的SELECT语句，先去查询缓存，判断是否存在可用的记录集</li>
</ul>
</li>
<li>判断标准: <ul>
<li>与缓存的SQL语句，<strong>是否完全一样</strong>，区分大小写(简单认为存储了一个key-value结构，<strong>key为sql，value为sql查询结果集</strong>)。</li>
</ul>
</li>
<li>几个关键字<ul>
<li>query_cache_type<ul>
<li>值:0 -– <strong>不启用</strong>查询缓存，<strong>默认值</strong></li>
<li>值:1 -– 启用查询缓存，<strong>只要符合查询缓存的要求，客户端的查询语句和记录集都可以缓存起来，供其他客户端使用，加上SQL_NO_CACHE将不缓存</strong></li>
<li>值:2 -– 启用查询缓存，只要<strong>查询语句中添加了参数:SQL_CACHE，且符合查询缓存的要求</strong>，客户端的查询语句和记录集，则可以缓存起来，供其他客户端使用</li>
</ul>
</li>
<li>query_cache_size  <ul>
<li>允许设置query_cache_size的值最小为40K，默认1M，推荐设置为:64M/128M</li>
</ul>
</li>
<li>query_cache_limit <ul>
<li>限制查询缓存区最大能缓存的查询记录集，默认设置为1M </li>
<li><code>show status like &#39;Qcache%&#39;</code>命令可查看缓存情况。  </li>
</ul>
</li>
</ul>
</li>
<li><p>不会缓存的情况</p>
<ul>
<li>当查询语句中有一些不确定的数据时，则不会被缓存。如包含函数NOW()，CURRENT_DATE()等类似的函数，或者用户自定义的函数，存储函数，用户变量等都不会被缓存。</li>
<li>当查询的结果大于query_cache_limit设置的值时，结果不会被缓存。</li>
<li>对于InnoDB引擎来说，<strong>当一个语句在事务中修改了某个表，那么在这个事务提交之前，所有与这个表相关的查询都无法被缓存。因此长时间执行事务，会大大降低缓存命中率。</strong>  </li>
<li>查询的表是系统表  </li>
<li>查询语句不涉及到表</li>
</ul>
</li>
<li><p>为什么mysql默认关闭了缓存开启  </p>
<ul>
<li>在查询之前必须<strong>先检查是否命中缓存,浪费计算资源。</strong></li>
<li>如果这个查询可以被缓存，那么执行完成后，MySQL发现查询缓存中没有这个查询，则会将结果存入查询缓存，这会带来额外的系统消耗。</li>
<li>针对表进行<strong>写入或更新数据时，将对应表的所有缓存都设置失效。</strong> </li>
<li>如果<strong>查询缓存很大或者碎片很多</strong>时，这个操作可能带来很大的系统消耗。</li>
</ul>
</li>
<li><p>缓存适用业务场景</p>
<ul>
<li>以<strong>读为主的业务</strong>，数据生成之后就不常改变的业务</li>
<li>比如门户类、新闻类、报表类、论坛类等  </li>
</ul>
</li>
</ul>
<h4 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h4><p>查询优化处理的三个阶段:  </p>
<ul>
<li>解析:解析sql通过lex<strong>词法分析</strong>，yacc语法分析将sql语句解析成<strong>解析树</strong>。</li>
<li>预处理阶段：根据mysql的语法的规则<strong>进一步检查解析树的合法性</strong>，如：<strong>检查数据的表和列是否存在，解析名字和别名的设置，还会进行权限的验证</strong>。</li>
<li>查询优化器 ：优化器的主要作用就是<strong>找到最优的执行计划</strong>。</li>
</ul>
<p>查询优化器如何找到最优执行计划：</p>
<ul>
<li>使用等价变化规则  <ul>
<li>数据表的关联并不总是按照查询语句的顺序进行。 </li>
<li>5=5 and a&gt;5 改写成 a&gt;5  ，a<b and a=5 改写成 b>5 and a=5  </li>
</ul>
</li>
<li>将外连接转化为内连接 <ul>
<li>并不是所有的OUTER JOIN都必须以外链接的方式进行。  </li>
</ul>
</li>
<li>优化count 、min、max等函数<ul>
<li>min函数只需找索引<strong>最左边</strong></li>
<li>max函数只需找索引最右边 </li>
<li>myisam引擎count(*)  </li>
</ul>
</li>
<li>覆盖索引扫描  </li>
<li>子查询优化</li>
<li>提前终止查询  <ul>
<li>用了<strong>limit关键字</strong>或者使用<strong>不存在的条件</strong></li>
</ul>
</li>
<li>IN的优化<ul>
<li>先进行<strong>排序</strong>，再采用<strong>二分查找</strong>的方式</li>
</ul>
</li>
</ul>
<p>Mysql的查询优化器基于<strong>成本计算</strong>的原则，会尝试各种执行计划，<strong>以数据抽样的方式进行试验(随机的读取一个4K的数据块进行分析)。</strong>可用explain来进行分析。</p>
<h4 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h4><p>调用插件式的存储引擎的原子API的功能进行执行计划的执行。 </p>
<h4 id="返回客户端"><a href="#返回客户端" class="headerlink" title="返回客户端"></a>返回客户端</h4><ul>
<li>有需要做缓存的，执行缓存操作。  </li>
<li>增量的返回结果：<strong>开始生成第一条结果时，mysql就开始往请求方逐步返回数据</strong>。  <ul>
<li>好处: mysql服务器无须保存过多的数据，浪费内存；用户体验好，马上就拿到了数据。 </li>
</ul>
</li>
</ul>
<h4 id="慢SQL"><a href="#慢SQL" class="headerlink" title="慢SQL"></a>慢SQL</h4><p>定位慢SQL:</p>
<ul>
<li>业务驱动  </li>
<li>测试驱动  </li>
<li>慢查询日志  </li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show variables like 'slow_query_log';</span><br><span class="line">set global slow_query_log = on;</span><br><span class="line">set global slow_query_log_file = '/var/lib/mysql/test-slow.log';   </span><br><span class="line">set global log_queries_not_using_indexes = on;</span><br><span class="line">set global long_query_time = 0.1;</span><br></pre></td></tr></table></figure>
<ul>
<li>慢查询日志分析</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/b4851df7-e19f-44fa-8b14-87d44517f53e-11197877.jpg" alt="慢查询日志分析"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time :日志记录的时间  </span><br><span class="line">User@Host:执行的用户及主机  </span><br><span class="line">Query_time:查询耗费时间  </span><br><span class="line">Lock_time 锁表时间  </span><br><span class="line">Rows_sent 发送给请求方的记录条数  </span><br><span class="line">Rows_examined 语句扫描的记录条数  </span><br><span class="line"><span class="keyword">SET</span> <span class="built_in">timestamp</span> 语句执行的时间点  </span><br><span class="line"><span class="keyword">select</span> .... 执行的具体语句</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -t 10 -s at /var/lib/mysql/test-slow.log</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/e937e8cb-5a7b-4587-89ba-fba600203b88-11197877.jpg" alt="慢查询工具"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/12/mysql-2mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/12/mysql-2mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">mysql性能优化-存储引擎</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-12 09:05:57" itemprop="dateCreated datePublished" datetime="2020-12-12T09:05:57+08:00">2020-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-30 13:42:00" itemprop="dateModified" datetime="2021-03-30T13:42:00+08:00">2021-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Mysql插拔式存储引擎"><a href="#Mysql插拔式存储引擎" class="headerlink" title="Mysql插拔式存储引擎"></a>Mysql插拔式存储引擎</h3><h4 id="mysql存储引擎简介"><a href="#mysql存储引擎简介" class="headerlink" title="mysql存储引擎简介"></a>mysql存储引擎简介</h4><ul>
<li>插拔式的插件方式。  </li>
<li><strong>存储引擎是指定在表之上的</strong>，即<strong>一个库中的每一个表都可以指定专用的存储引擎。</strong>  </li>
<li>不管表采用什么样的存储引擎，都会在数据区产生对应的一个<strong>frm文件(表结构定义描述文件)。</strong></li>
</ul>
<h4 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h4><ul>
<li><p>Mysql5.5及以后版本的默认存储引擎  </p>
</li>
<li><p>Key Advantages:  </p>
<ul>
<li>Its DML operations follow the ACID model [<strong>事务ACID</strong>]  </li>
<li>Row-level locking[<strong>行级锁</strong>]  </li>
<li>InnoDB tables arrange your data on disk to optimize queries based on primary keys[<strong>聚集索引(主键索引)方式进行数据存储</strong>]  </li>
<li>To maintain data integrity, InnoDB supports FOREIGN KEY constraints[<strong>支持外键关系保证数据完整性</strong>]  </li>
</ul>
</li>
</ul>
<h4 id="Myisam"><a href="#Myisam" class="headerlink" title="Myisam"></a>Myisam</h4><ul>
<li><p>Mysql5.5版本之前的默认存储引擎 ,较多的系统表也还是使用这个存储引,系统临时表也会用到Myisam存储引擎  </p>
</li>
<li><p>特点:  </p>
<ul>
<li>select count(*) from table 无需进行数据的扫描  </li>
<li>数据(MYD)和索引(MYI)分开存储  </li>
<li>表级锁  </li>
<li>不支持事务  </li>
</ul>
</li>
</ul>
<h4 id="Memory存储引擎"><a href="#Memory存储引擎" class="headerlink" title="Memory存储引擎"></a>Memory存储引擎</h4><ul>
<li><strong>数据都是存储在内存中，IO效率要比其他引擎高很多。</strong>  </li>
<li><p><strong>服务重启数据丢失，内存数据表默认只有16M</strong>。  </p>
</li>
<li><p>特点:  </p>
<ul>
<li>支持hash索引，B tree索引，<strong>默认hash(查找复杂度0(1))</strong>  </li>
<li>字段长度都是固定长度varchar(32)=char(32)   </li>
<li>不支持大数据存储类型字段如 blog，text  </li>
<li>表级锁  </li>
</ul>
</li>
<li><p>应用场景:  </p>
<ul>
<li>等值查找热度较高数据  </li>
<li>查询结果内存中的计算，大多数都是采用这种存储引擎  </li>
<li>作为临时表存储需计算的数据  </li>
</ul>
</li>
</ul>
<h4 id="Archive存储引擎"><a href="#Archive存储引擎" class="headerlink" title="Archive存储引擎"></a>Archive存储引擎</h4><ul>
<li><p>压缩协议进行数据的存储 ,数据存储为ARZ文件格式  </p>
</li>
<li><p>特点:  </p>
<ul>
<li>只支持insert和select两种操作   </li>
<li>只允许自增ID列建立索引  </li>
<li>行级锁  </li>
<li>不支持事务  </li>
<li>数据占用磁盘少  </li>
</ul>
</li>
<li><p>应用场景:  </p>
<ul>
<li>日志系统  </li>
<li>大量的设备数据采集 </li>
</ul>
</li>
</ul>
<h4 id="CSV存储引擎"><a href="#CSV存储引擎" class="headerlink" title="CSV存储引擎"></a>CSV存储引擎</h4><ul>
<li>数据存储以CSV文件  </li>
<li><p>特点:  </p>
<ul>
<li>不能定义索引、列定义必须为NOT NULL、不能设置自增列 —&gt;不适用大表或者数据的在线处理   </li>
<li>CSV数据的存储用,隔开，可直接编辑CSV文件进行数据的编排 —&gt;数据安全性低  </li>
<li>注:编辑之后，要生效使用flush table XXX 命令  </li>
</ul>
</li>
<li><p>应用场景:  </p>
<ul>
<li>数据的快速导出导入 表格直接转换成CSV  </li>
</ul>
</li>
</ul>
<h4 id="各引擎对比"><a href="#各引擎对比" class="headerlink" title="各引擎对比"></a>各引擎对比</h4><p><img src="https://api2.mubu.com/v3/document_image/6091bb4c-98c4-4513-8069-954152ee02e8-11197877.jpg" alt="各引擎对比"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/10/mysql-1mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90-%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/10/mysql-1mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90-%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">mysql性能优化分析-索引</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-10 21:29:27" itemprop="dateCreated datePublished" datetime="2020-12-10T21:29:27+08:00">2020-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-30 13:42:03" itemprop="dateModified" datetime="2021-03-30T13:42:03+08:00">2021-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p><strong>正确的</strong>创建<strong>合适的</strong>索引是提升数据库查询性能的基础。  </p>
<h4 id="索引定义"><a href="#索引定义" class="headerlink" title="索引定义"></a>索引定义</h4><p>索引是为了<strong>加速对表中数据行的检索</strong>而创建的一种<strong>分散存储的数据结构</strong>(<strong>硬盘</strong>级)。</p>
<p><img src="https://api2.mubu.com/v3/document_image/7363550a-3c61-48ae-8f12-2b19a0acbc57-11197877.jpg" alt="索引"> </p>
<h4 id="使用索引意义"><a href="#使用索引意义" class="headerlink" title="使用索引意义"></a>使用索引意义</h4><ul>
<li>索引能极大的<strong>减少存储引擎需要扫描的数据</strong>量。  </li>
<li>索引可以把<strong>随机IO变成顺序IO</strong>。  </li>
<li>索引可以帮助我们在<strong>进行分组、排序等操作时，避免使用临时表</strong>。  </li>
</ul>
<h4 id="使用B-树的意义"><a href="#使用B-树的意义" class="headerlink" title="使用B+树的意义"></a>使用B+树的意义</h4><p>二叉查找树 Binary Search Tree  </p>
<p><img src="https://api2.mubu.com/v3/document_image/235038cb-5681-4ac4-ada2-df8ae2529089-11197877.jpg" alt="二叉树"></p>
<p>平衡二叉查找树 Balanced Binary Search Tree  </p>
<p><img src="https://api2.mubu.com/v3/document_image/cec150e9-957e-46d3-ac69-76bf683d7573-11197877.jpg" alt="平衡二叉查找树"></p>
<p>二叉树和平衡二叉树的缺点：  </p>
<ul>
<li>树结构<strong>太深</strong>  </li>
<li><p>因为<strong>每个节点都存有数据，数据处的(高)深度决定着他的IO操作次数，IO操作耗时大。</strong>  </p>
</li>
<li><p><strong>数据存储太小</strong>  </p>
</li>
<li><strong>每一个磁盘块(节点/页，单位4kb)保存的数据量(远远不足4k)太小了</strong>  </li>
<li>没有很好的利用操作<strong>磁盘IO的数据交换特性</strong>，也没有利用好<strong>磁盘IO的预读能力(空间局部性原理，预读8k、12k等)</strong>，从而带来频繁的IO操作。  </li>
</ul>
<p>多路平衡查找树 B-Tree  :</p>
<p><img src="https://api2.mubu.com/v3/document_image/5ea41241-12e1-4f23-8550-dee925ffdcc7-11197877.jpg" alt="绝对平衡树"></p>
<p>平衡查找树的分支数量与关键字大小有关，可以大致认为：<strong>磁盘块的容量/关键字大小 = 平衡树分支数量。</strong>  </p>
<p>加强版的多路平衡查找树 Mysql的B+Tree  :</p>
<p><img src="https://api2.mubu.com/v3/document_image/9988480f-165b-4407-afda-33033bab14ff-11197877.jpg" alt="B+树"></p>
<p>B+Tree与B-Tree的区别  </p>
<ul>
<li>B+节点关键字搜索采用<strong>闭合区间</strong>  </li>
<li>B+<strong>非叶节点不保存数据相关信息，只保存关键字和子节点的引用</strong>  </li>
<li>B+<strong>关键字对应的数据保存在叶子节点中</strong>  </li>
<li>B+<strong>叶子节点是顺序排列</strong>的，并且<strong>相邻节点具有顺序引用的关系</strong>  </li>
</ul>
<p>选择B+树的原因：</p>
<ul>
<li>B+树是B-树的变种(PLUS版)多路绝对平衡查找树，他拥有B-树的优势  </li>
<li>B+树扫库、表能力更强  </li>
<li>B+树的磁盘读写能力更强  </li>
<li>B+树的排序能力更强   </li>
<li>B+树的查询效率更加稳定  </li>
</ul>
<h4 id="MySql中B-Tree索引的体现形式"><a href="#MySql中B-Tree索引的体现形式" class="headerlink" title="MySql中B+Tree索引的体现形式"></a>MySql中B+Tree索引的体现形式</h4><p>Myisam:数据和索引分开存储，<strong>数据保存在MYD文件，索引文件为MYI。</strong>  </p>
<p><img src="https://api2.mubu.com/v3/document_image/faa0f796-3dc4-4e06-892d-d76725f55e48-11197877.jpg" alt="myisam索引"></p>
<p>Myisam双索引：</p>
<p><img src="https://api2.mubu.com/v3/document_image/7899eede-8cc3-43b1-9ecc-466708913605-11197877.jpg" alt="Myisam双索引"></p>
<p>Innodb 索引结构：</p>
<p><img src="https://api2.mubu.com/v3/document_image/e94761d0-7249-4401-8958-13f6657ec61b-11197877.jpg" alt="Innodb聚集索引"></p>
<p>未指定索引的情况下InnoDB会自动生成隐式索引:</p>
<p><img src="https://api2.mubu.com/v3/document_image/ae632bb5-2312-4aa3-9e8e-522939f7e909-11197877.jpg" alt="innoDB双索引"></p>
<p>使用辅助索引查询某项具体信息时，需要反向到主键索引中查找相关信息（<strong>回表操作</strong>）。</p>
<p>这样设计的好处就是在数据迁移的时候辅助索引可以不做作相应的指向改变。<br>对于InnoDB的辅助索引，它的<strong>叶子节点存储的是索引值和指向主键索引的位置</strong>。  </p>
<p>Myisam 与InnoDB对比：</p>
<p><img src="https://api2.mubu.com/v3/document_image/81003d7c-27fd-4ca2-b277-7a7176dda226-11197877.jpg" alt="索引对比">)</p>
<h4 id="索引知识点汇总"><a href="#索引知识点汇总" class="headerlink" title="索引知识点汇总"></a>索引知识点汇总</h4><ul>
<li>列的离散性 ：</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/1ecf984c-7986-43eb-8435-a2148c5b1988-11197877.jpg" alt="列的离散性"></p>
<p><strong>离散性低的索引会造成选择性差，无法寻找合适的分支，数库会使用全局扫描。</strong>类似男女这种字段如果简历索引则要遍历位图索引。  </p>
<ul>
<li>最左匹配原则</li>
</ul>
<p>对索引中<strong>关键字进行计算(对比)，一定是从左往右依次进行(每一位)，且不可跳过。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/f040342e-bf46-4385-9ac8-be9aee20578e-11197877.jpg" alt="最左匹配原则"></p>
<ul>
<li>联合索引  <ul>
<li>单列索引：节点中关键字[name]  </li>
<li>联合索引：节点中关键字[name,phoneNum]  </li>
<li>单列索引是特殊的联合索引  </li>
</ul>
</li>
<li><p>联合索引列选择原则  :</p>
<ul>
<li><strong>经常用的列优先</strong> 【最左匹配原则】  </li>
<li><strong>选择性(离散度)高的列优先</strong>【离散度高原则】  </li>
<li><strong>宽度小的列优先</strong>【最少空间原则】 </li>
</ul>
</li>
<li><p>覆盖索引  </p>
<ul>
<li>如果<strong>索引包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)，也就是平时所说的不需要回表操作。</strong>  </li>
<li>使用explain，可以通过输出的extra列来判断，<strong>对于一个索引覆盖查询，显示为using index，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询。</strong>  </li>
<li>覆盖索引可<strong>减少数据库IO，将随机IO变为顺序IO，可提高查询性能</strong>。</li>
</ul>
</li>
</ul>
<h4 id="索引使用的注意点"><a href="#索引使用的注意点" class="headerlink" title="索引使用的注意点"></a>索引使用的注意点</h4><ul>
<li>索引列的数据长度能少则少。  </li>
<li>索引一定不是越多越好，越全越好，一定是建合适的。  </li>
<li>匹配列前缀可用到索引 like 9999%，like %9999%、like %9999用不到索引; Where 条件中 not in 和 &lt;&gt;操作无法使用索引;  </li>
<li>匹配范围值，order by 也可用到索引;   </li>
<li>多用指定列查询，只返回自己想到的数据列，少用select *;   </li>
<li>联合索引中如果不是按照索引最左列开始查找，无法使用索引;   </li>
<li>联合索引中精确匹配最左前列并范围匹配另外一列可以用到索引;   </li>
<li>联合索引中如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引;  </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/08/mysql_1%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/08/mysql_1%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/" class="post-title-link" itemprop="url">mysql基础架构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-08 21:29:27" itemprop="dateCreated datePublished" datetime="2020-12-08T21:29:27+08:00">2020-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-30 13:41:27" itemprop="dateModified" datetime="2021-03-30T13:41:27+08:00">2021-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h3><p><img src="https://api2.mubu.com/v3/document_image/08f1e89c-7fc6-45d9-a506-b955bfd6d01b-11197877.jpg" alt="MySQL逻辑架构"></p>
<h3 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h3><p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p>
<h4 id="Server层"><a href="#Server层" class="headerlink" title="Server层"></a>Server层</h4><p>包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有<strong>跨存储引擎的功能都在这一层实现</strong>，比如存储过程、触发器、视图等。</p>
<h5 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h5><p>第一步，先连接到这个数据库上，这时打交道的是连接器。<strong>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</strong>连接命令一般是这么写的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h<span class="variable">$ip</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> -p</span><br></pre></td></tr></table></figure>
<p>输完命令之后，需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄露。如果连的是生产服务器，不应该这么做。</p>
<p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证身份，这个时候用用的是输入的用户名和密码。</p>
<ul>
<li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li>
<li>如果用户名密码认证通过，<strong>连接器会到权限表里面查出你拥有的权限</strong>。之后，<strong>这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</strong></li>
</ul>
<p>这就意味着，一个用户成功建立连接后，<strong>即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</strong></p>
<p>连接完成后，如果没有后续的动作，这个连接就处于空闲状态，可以用<code>show processlist</code>命令进行查看。<strong>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数<code>wait_timeout</code>控制的，默认值是8小时。</strong>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒：<code>Lost connection to MySQL server during query</code>。这时候如果要继续，就需要重连，然后再执行请求。</p>
<p>数据库里面，<strong>长连接</strong>是指连接成功后，<strong>如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</strong>。建立连接的过程通常比较复杂，所以建议<strong>在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</strong></p>
<p>全部使用长连接后，可能会发现，有些时候<strong>MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM）</strong>，从现象看就是MySQL异常重启。</p>
<p>解决长连接问题的两种方案：</p>
<ul>
<li><p><strong>定期断开长连接</strong>。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p>
</li>
<li><p>如果用的是MySQL 5.7或更新版本，可以在<strong>每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection</code>来重新初始化连接资源</strong>。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p>
</li>
</ul>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>连接建立完成后，可以执行select语句。执行逻辑会来到第二步：查询缓存。</p>
<p>MySQL拿到一个查询请求后，会<strong>先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。</strong>如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。<strong>执行完成后，执行结果会被存入查询缓存中。</strong>可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>
<p><strong>但是大多数情况下建议不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>
<p>查询缓存的<strong>失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能费劲地把结果存起来，还没使用，就被一个更新全清空了</strong>。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>
<p>好在MySQL也提供了这种“按需使用”的方式。可以将参数<code>query_cache_type</code>设置成<code>DEMAND</code>，这样<strong>对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用<code>SQL_CACHE</code>显式指定</strong>，像下面这个语句一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure>
<p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>如果没有命中查询缓存，就要开始真正执行语句。首先，MySQL需要知道要做什么，因此需要<strong>对SQL语句做解析</strong>。</p>
<p>分析器先会做<strong>“词法分析”</strong>。<strong>输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么</strong>。</p>
<p>MySQL从输入的”select”关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p>
<p>做完了这些识别以后，就要做<strong>“语法分析</strong>”。<strong>根据词法分析的结果，语法分析器会根据语法规则，判断输入的这个SQL语句是否满足MySQL语法</strong>。</p>
<p>如果语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID=1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; <span class="keyword">check</span> the <span class="keyword">manual</span> that corresponds <span class="keyword">to</span> your MySQL <span class="keyword">server</span> <span class="keyword">version</span> <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> <span class="keyword">use</span> near <span class="string">'elect * from t where ID=1'</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>一般语法错误会提示第一个出现错误的位置，所以要关注的是紧接“use near”的内容。</strong></p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>经过分析器，MySQL就知道要做什么。在开始执行之前，还要先经过优化器的处理。</p>
<p><strong>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</strong>比如执行下面这样的语句，这个语句是执行两个表的join：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure>
<ul>
<li>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li>
<li>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li>
</ul>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，<strong>而优化器的作用就是决定选择使用哪一个方案。</strong></p>
<p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>MySQL通过分析器知道了<strong>要做什么</strong>，通过优化器知道了<strong>该怎么做</strong>，于是就进入了执行器阶段，开始<strong>执行语句</strong>。</p>
<p>开始执行的时候，要先判断一下对这个表T有没有执行查询的<strong>权限</strong>，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &apos;b&apos;@&apos;localhost&apos; for table &apos;T&apos;</span><br></pre></td></tr></table></figure>
<p><strong>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</strong></p>
<p>比如这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p>
<ul>
<li><p>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</p>
</li>
<li><p>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</p>
</li>
<li><p><strong>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</strong></p>
</li>
</ul>
<p>至此，这个语句就执行完成。</p>
<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。可以在数据库的<strong>慢查询日志</strong>中看到一个<code>rows_examined</code>的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong></p>
<h4 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h4><p>负责<strong>数据的存储和提取</strong>。其架构模式是<strong>插件式</strong>的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。执行create table建表的时候，<strong>如果不指定引擎类型，默认使用的就是InnoDB</strong>。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用<code>engine=memory</code>来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p>
<p>不同的存储引擎共用一个<strong>Server层</strong>，也就是从连接器到执行器的部分。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/10/tcp-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/10/tcp-2/" class="post-title-link" itemprop="url">TCP可靠传输</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-10 19:29:16" itemprop="dateCreated datePublished" datetime="2020-06-10T19:29:16+08:00">2020-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-13 09:48:31" itemprop="dateModified" datetime="2021-05-13T09:48:31+08:00">2021-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="TCP可靠传输保障"><a href="#TCP可靠传输保障" class="headerlink" title="TCP可靠传输保障"></a>TCP可靠传输保障</h3><p>TCP 通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p>
<h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。但在错综复杂的网络，并不一定能顺利、正常的传输数据，万一数据在传输过程中丢失(也即出现TCP数据包丢失)，此时可用<strong>重传机制</strong>解决：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
<li>SACK</li>
<li>D-SACK</li>
</ul>
<h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>重传机制的其中一个方式，就是在发送数据时，设定一个<strong>定时器</strong>，当<strong>超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据</strong>，也就是我们常说的<strong>超时重传</strong>。</p>
<p>TCP 会在以下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<h5 id="超时时间的设置"><a href="#超时时间的设置" class="headerlink" title="超时时间的设置"></a>超时时间的设置</h5><p>RTT：<strong>数据从网络一端传送到另一端所需的时间</strong>，也就是包的<strong>往返</strong>时间。超时重传时间以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。</p>
<p>两种超时时间不同的情况：</p>
<ul>
<li>当超时时间 <strong>RTO 较大</strong>时，网络的空隙时间增大，重发就慢，丢了很长时间才重发，没有效率，性能差；</li>
<li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发从而造成不必要的重传，虽然重发的快，但会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p><strong>超时重传时间 RTO 的值应该略大于报文往返  RTT 的值</strong>。但报文往返 RTT 的值是经常变化的，因为网络也是时常变化的。也就因为报文往返 RTT 的值 是经常波动变化的，所以超时重传时间 RTO 的值应该是一个<strong>动态变化的值</strong>。</p>
<h5 id="linux下RTO的计算"><a href="#linux下RTO的计算" class="headerlink" title="linux下RTO的计算"></a>linux下RTO的计算</h5><p>估计往返时间，通常需要采样以下两个：</p>
<ul>
<li>需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个<strong>平滑 RTT 的值</strong>，而且这个值还是要不断变化的，因为网络状况不断地变化。</li>
<li>除了采样 RTT，还要采样 <strong>RTT 的波动范围</strong>，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。</li>
</ul>
<p>如果超时重发的数据，再次超时又需要重传的时候，TCP 的策略是<strong>超时间隔加倍。</strong>也就是<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>超时触发重传存在的问题是，超时周期可能相对较长。TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p>
<p><img src="https://api2.mubu.com/v3/document_image/2ef91143-7ab8-4f5d-9985-d36c801b433b-11197877.jpg" alt="快速重传"></p>
<p>在上图，发送方发出了 1，2，3，4，5 份数据：</p>
<ul>
<li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li>
<li>最后，接收到收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ul>
<p>所以，<strong>快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</strong></p>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传之前的一个，还是重传所有的问题。</strong></p>
<p>比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p>
<p>根据 TCP 不同的实现，以上两种情况都是有可能的。可见，这是一把双刃剑。</p>
<h4 id="SACK方法"><a href="#SACK方法" class="headerlink" title="SACK方法"></a>SACK方法</h4><p>为了解决不知道该重传哪些 TCP 报文，于是就有 <code>SACK Selective Acknowledgment 选择性确认）</code> 方法。</p>
<p>这种方式需要在 TCP 头部选项字段里加一个 <code>SACK</code> 的东西，它<strong>可以将缓存的数据区间发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<p>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 <code>SACK</code> 信息发现只有 <code>200~299</code> 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p>
<p><img src="https://api2.mubu.com/v3/document_image/9449c55b-c8fb-45bf-95c7-3b1d35ae3ca3-11197877.jpg" alt="选择性确认"></p>
<p>如果要支持 <code>SACK</code>，必须双方都要支持。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<h4 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h4><p>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉发送方有哪些数据被重复接收了。</strong>下面举例两个例子，来说明 <code>D-SACK</code> 的作用。</p>
<p>例子1： ACK丢包</p>
<p><img src="https://api2.mubu.com/v3/document_image/e0401e31-c9ae-428a-aa62-02cf22da70ab-11197877.jpg" alt=" ACK丢包"></p>
<ul>
<li>接收方发给发送方的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）</li>
<li><strong>于是接收方发现数据是重复收到的，于是回了一个 SACK = 3000~3500</strong>，告诉发送方3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 <code>D-SACK</code>。</li>
<li>这样发送方就知道了，数据没有丢，是接收方的 ACK 确认报文丢了。</li>
</ul>
<p>例子二：网络延时</p>
<p><img src="https://api2.mubu.com/v3/document_image/db55cd10-03f8-4ba1-b9db-54eb8f2e07fd-11197877.jpg" alt="网络延时"></p>
<ul>
<li>数据包（1000~1499） 被网络延迟，导致发送方没有收到 Ack 1500 的确认报文。</li>
<li>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了接收方；</li>
<li><strong>所以接收方回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</strong></li>
<li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。</li>
</ul>
<p>可见，<code>D-SACK</code> 有这么几个好处：</p>
<ol>
<li><strong>可以让发送方知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</strong></li>
<li><strong>可以知道是不是发送方的数据包被网络延迟了;</strong></li>
<li><strong>可以知道网络中是不是把发送方的数据包给复制了;</strong></li>
</ol>
<p>在 Linux 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启/关闭这个功能（Linux 2.4 后默认打开）。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>TCP 是<strong>每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。</strong>但这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。</p>
<p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。<strong>即使在往返时间较长的情况下，它也不会降低网络通信的效率。</strong>有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p>
<p>窗口的实现实际上是操作系统开辟的一个<strong>缓存空间</strong>，<strong>发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</strong></p>
<p><strong>假设窗口大小为 <code>3</code> 个 TCP 段，那么发送方就可以连续发送 <code>3</code> 个 TCP 段，并且中途若有 ACK 丢失，可以通过下一个确认应答进行确认</strong>。如下图：</p>
<p><img src="https://api2.mubu.com/v3/document_image/b1fb9943-9efc-4297-927b-894047c329ac-11197877.jpg" alt="滑动窗口方式并行处理"></p>
<p>图中的 ACK 600 确认应答报文丢失，也没关系，因为<strong>可以通话下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据接收方都收到了</strong>。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p>
<h4 id="窗口大小的决定方"><a href="#窗口大小的决定方" class="headerlink" title="窗口大小的决定方"></a>窗口大小的决定方</h4><p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。<strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p>
<p>所以，<strong>通常窗口的大小是由接收方的决定的</strong>。发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<h4 id="发送方的滑动窗口"><a href="#发送方的滑动窗口" class="headerlink" title="发送方的滑动窗口"></a>发送方的滑动窗口</h4><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/Tc09ovdNacOtnMOMeRc_uA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Tc09ovdNacOtnMOMeRc_uA</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/09/Go_%E6%8E%A5%E5%8F%A3_8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/09/Go_%E6%8E%A5%E5%8F%A3_8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">Go 编译器自动检测类型是否实现接口</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-09 20:29:16" itemprop="dateCreated datePublished" datetime="2020-06-09T20:29:16+08:00">2020-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 10:59:39" itemprop="dateModified" datetime="2021-04-08T10:59:39+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Go-编译器自动检测类型是否实现接口"><a href="#Go-编译器自动检测类型是否实现接口" class="headerlink" title="Go 编译器自动检测类型是否实现接口"></a>Go 编译器自动检测类型是否实现接口</h3><p>开源库里会有一些类似下面这种奇怪的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。<strong>编译器会由此检查 <code>*myWriter</code> 类型是否实现了 <code>io.Writer</code> 接口。</strong></p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"io"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myWriter <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*func (w myWriter) Write(p []byte) (n int, err error) &#123;</span></span><br><span class="line"><span class="comment">	return</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查 *myWriter 类型是否实现了 io.Writer 接口</span></span><br><span class="line">    <span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 myWriter 类型是否实现了 io.Writer 接口</span></span><br><span class="line">    <span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释掉为 myWriter 定义的 Write 函数后，运行程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">command</span>-line-arguments</span></span><br><span class="line">src/learn/tongbu/tongbu.go:14:6: cannot use (*myWriter)(nil) (type *myWriter) as type io.Writer in assignment:</span><br><span class="line">	*myWriter does not implement io.Writer (missing Write method)</span><br><span class="line">src/learn/tongbu/tongbu.go:17:6: cannot use myWriter&#123;&#125; (type myWriter) as type io.Writer in assignment:</span><br><span class="line">	myWriter does not implement io.Writer (missing Write method)</span><br></pre></td></tr></table></figure>
<p>报错信息：<strong>*myWriter/myWriter 未实现 io.Writer 接口，也就是未实现 Write 方法。</strong></p>
<p>解除注释后，运行程序不报错。</p>
<p>实际上，上述赋值语句会发生<strong>隐式地类型转换</strong>，<strong>在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。</strong></p>
<p>总结: 可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/08/Go%E6%8E%A5%E5%8F%A3_7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%96%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/08/Go%E6%8E%A5%E5%8F%A3_7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%96%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Go 类型转换和断言</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-08 22:29:16" itemprop="dateCreated datePublished" datetime="2020-06-08T22:29:16+08:00">2020-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 10:59:47" itemprop="dateModified" datetime="2021-04-08T10:59:47+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Go-类型转换和断言"><a href="#Go-类型转换和断言" class="headerlink" title="Go 类型转换和断言"></a>Go 类型转换和断言</h3><p>Go 语言中不允许隐式类型转换，<strong>也就是说 <code>=</code> 两边，不允许出现类型不相同的变量</strong>。</p>
<p>类型转换<code>、</code>类型断言本质都是把一个类型转换成另外一个类型。不同之处在于，<strong>类型断言是对接口变量进行的操作。</strong></p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>对于<code>类型转换</code>而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：</p>
<blockquote>
<p>&lt;结果类型&gt; := &lt;目标类型&gt; ( &lt;表达式&gt; )</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> f <span class="keyword">float64</span></span><br><span class="line">	f = <span class="keyword">float64</span>(i)</span><br><span class="line">	fmt.Printf(<span class="string">"%T, %v\n"</span>, f, f) <span class="comment">//float64, 9</span></span><br><span class="line"></span><br><span class="line">	f = <span class="number">10.8</span></span><br><span class="line">	a := <span class="keyword">int</span>(f)</span><br><span class="line">	fmt.Printf(<span class="string">"%T, %v\n"</span>, a, a) <span class="comment">//int, 10</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// s := []int(i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码里，定义了一个 <code>int</code> 型和 <code>float64</code> 型的变量，尝试在它们之间相互转换，结果是成功的：<code>int</code> 型和 <code>float64</code> 是相互兼容的。</p>
<p>把最后一行代码的注释去掉，编译器会报告类型不兼容的错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert i (type int) to type []int</span><br></pre></td></tr></table></figure>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>前面说过，因为<strong>空接口 <code>interface{}</code> 没有定义任何函数</strong>，因此 <strong>Go 中所有类型都实现了空接口</strong>。<strong>当一个函数的形参是 <code>interface{}</code>，那么在函数中，需要对形参进行断言，从而得到它的真实类型。</strong></p>
<p>断言的语法为：</p>
<blockquote>
<p>&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) // <strong>安全类型断言</strong><br>&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )　　//<strong>非安全类型断言</strong></p>
</blockquote>
<p>类型转换和类型断言有些相似，不同之处，在于<strong>类型断言是对接口进行的操作</strong>。</p>
<p>还是来看一个简短的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br><span class="line">	s := i.(Student)</span><br><span class="line">	</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: interface conversion: interface &#123;&#125; is *main.Student, not main.Student</span><br></pre></td></tr></table></figure>
<p>直接 <code>panic</code> 了，这是因为 <strong><code>i</code> 是 <code>*Student</code> 类型，并非 <code>Student</code> 类型，断言失败</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安全断言</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br><span class="line">	s, ok := i.(Student)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，<strong>即使断言失败也不会 <code>panic</code>。</strong></p>
<h4 id="switch语句判断接口类型"><a href="#switch语句判断接口类型" class="headerlink" title="switch语句判断接口类型"></a>switch语句判断接口类型</h4><p>断言其实还有另一种形式，就是<strong>利用 <code>switch</code> 语句判断接口的类型。每一个 <code>case</code> 会被顺序地考虑。当命中一个 <code>case</code> 时，就会执行 <code>case</code> 中的语句，因此 <code>case</code> 语句的顺序是很重要的，因为很有可能会有多个 <code>case</code> 匹配的情况。</strong></p>
<p>代码示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//var i interface&#123;&#125; = new(Student)</span></span><br><span class="line">	<span class="comment">//var i interface&#123;&#125; = (*Student)(nil)</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;i, i)</span><br><span class="line"></span><br><span class="line">	judge(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">judge</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> v := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">		fmt.Printf(<span class="string">"nil type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> Student:</span><br><span class="line">		fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">		fmt.Printf(<span class="string">"Student type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> *Student:</span><br><span class="line">		fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">		fmt.Printf(<span class="string">"*Student type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">		fmt.Printf(<span class="string">"unknow\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code> 函数里有三行不同的声明，<strong>每次运行一行，注释另外两行，得到三组运行结果：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// --- var i interface&#123;&#125; = new(Student)</span><br><span class="line">0xc000010240 &amp;&#123; 0&#125;</span><br><span class="line">0xc000010260 &amp;&#123; 0&#125;</span><br><span class="line">0xc00000e030 &amp;&#123; 0&#125;</span><br><span class="line">*Student type[*main.Student] &amp;&#123; 0&#125;</span><br><span class="line"></span><br><span class="line">// --- var i interface&#123;&#125; = (*Student)(nil)</span><br><span class="line">0xc000010240 &lt;nil&gt;</span><br><span class="line">0xc000010250 &lt;nil&gt;</span><br><span class="line">0xc00000e030 &lt;nil&gt;</span><br><span class="line">*Student type[*main.Student] &lt;nil&gt;</span><br><span class="line"></span><br><span class="line">// --- var i interface&#123;&#125;</span><br><span class="line">0xc00010a220 &lt;nil&gt;</span><br><span class="line">0xc00010a230 &lt;nil&gt;</span><br><span class="line">0xc00010a240 &lt;nil&gt;</span><br><span class="line">nil type[&lt;nil&gt;] &lt;nil&gt;</span><br></pre></td></tr></table></figure>
<p>对于第一行语句：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br></pre></td></tr></table></figure>
<p><strong><code>i</code> 是一个 <code>*Student</code> 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 <code>main</code> 函数里有一个局部变量 <code>i</code>；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 <code>v</code>，它是 <code>i</code> 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。</strong></p>
<p>对于第二行语句：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = (*Student)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这里想说明的其实是 <strong><code>i</code> 在这里动态类型是 <code>(*Student)</code>, 数据为 <code>nil</code>，它的类型并不是 <code>nil</code>，它与 <code>nil</code> 作比较的时候，得到的结果也是 <code>false</code>。</strong></p>
<p>最后一行语句：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这回 <code>i</code> 才是 <code>nil</code> 类型。</p>
<p>【引申1】<br><strong><code>fmt.Println</code> 函数的参数是 <code>interface</code>。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印。而对于自定义类型，首先确定该类型是否实现了 <code>String()</code> 方法，如果实现了，则直接打印输出 <code>String()</code> 方法的结果；否则，会通过反射来遍历对象的成员进行打印。</strong></p>
<p>再来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s = Student&#123;</span><br><span class="line">		Name: <span class="string">"qcrao"</span>,</span><br><span class="line">		Age: <span class="number">18</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>Student</code> 结构体没有实现 <code>String()</code> 方法，<strong>所以 <code>fmt.Println</code> 会利用反射挨个打印成员变量：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;qcrao 18&#125;</span><br></pre></td></tr></table></figure>
<p><strong>增加一个 <code>String()</code> 方法的实现：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"[Name: %s], [Age: %d]"</span>, s.Name, s.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Name: qcrao], [Age: 18]</span><br></pre></td></tr></table></figure>
<p>按照我们自定义的方法来打印了。</p>
<p>【引申2】<br>针对上面的例子，如果改一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"[Name: %s], [Age: %d]"</span>, s.Name, s.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意看两个函数的接受者类型不同，现在 <code>Student</code> 结构体只有一个接受者类型为 <code>指针类型</code> 的 <code>String()</code> 函数，打印结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;qcrao 18&#125;</span><br></pre></td></tr></table></figure>
<p>为什么？</p>
<blockquote>
<p><strong>类型 <code>T</code> 只有接受者是 <code>T</code> 的方法；而类型 <code>*T</code> 拥有接受者是 <code>T</code> 和 <code>*T</code> 的方法。语法上 <code>T</code> 能直接调 <code>*T</code> 的方法仅仅是 <code>Go</code> 的语法糖。</strong></p>
</blockquote>
<p>当 <strong><code>Student</code> 结构体定义了接受者类型是值类型的 <code>String()</code> 方法时</strong>，通过</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(&amp;s)</span><br></pre></td></tr></table></figure>
<p>均可以按照自定义的格式来打印。</p>
<p>如果 <code>Student</code> 结构体定义了<strong>接受者类型是指针类型的 <code>String()</code> 方法时</strong>，只有通过</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&amp;s)</span><br></pre></td></tr></table></figure>
<p>才能按照自定义的格式打印。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【类型转换和断言】<a href="https://www.cnblogs.com/zrtqsk/p/4157350.html" target="_blank" rel="noopener">https://www.cnblogs.com/zrtqsk/p/4157350.html</a></p>
<p>【断言】<a href="https://studygolang.com/articles/11419" target="_blank" rel="noopener">https://studygolang.com/articles/11419</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShifuDong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShifuDong</p>
  <div class="site-description" itemprop="description">记录生活， 记录学习， 分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/mailto:sfd_w@foxmail.com" title="E-Mail → mailto:sfd_w@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShifuDong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  



    </div>
</body>
</html>
