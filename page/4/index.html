<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ShifuDong" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="记录生活， 记录学习， 分享知识">
<meta name="keywords" content="生活，C++, C, go, java, OS, 网络， 存储， 联邦学习， 机器学习，python">
<meta property="og:type" content="website">
<meta property="og:title" content="ShifuDong">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;4&#x2F;index.html">
<meta property="og:site_name" content="ShifuDong">
<meta property="og:description" content="记录生活， 记录学习， 分享知识">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ShifuDong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShifuDong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Knowledge Sharing</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/linux_%E7%BD%91%E7%BB%9C02%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/06/linux_%E7%BD%91%E7%BB%9C02%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-1/" class="post-title-link" itemprop="url">网络基础-2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-06 20:29:16" itemprop="dateCreated datePublished" datetime="2020-05-06T20:29:16+08:00">2020-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-23 16:05:35" itemprop="dateModified" datetime="2021-03-23T16:05:35+08:00">2021-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h3><h4 id="数据包封装"><a href="#数据包封装" class="headerlink" title="数据包封装"></a>数据包封装</h4><p>传输层及其以下的机制由<strong>内核提供</strong>，<strong>应用层由用户进程提供</strong>。<strong>应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。</strong> <strong>应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation）</strong>，如下图所示：</p>
<p><img src="https://api2.mubu.com/v3/document_image/7a16bfec-d9d8-4761-859b-ef3d41e926eb-11197877.jpg" alt="数据包封装"></p>
<p>不同的协议层对数据包有不同的称谓，<strong>在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）</strong>。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p>
<h4 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h4><p><img src="https://api2.mubu.com/v3/document_image/9a2d9254-993e-4bbb-a0fe-8b85772ffe44-11197877.jpg" alt="以太网帧格式"></p>
<p>其中的源地址和目的地址是指网卡的硬件地址（也叫<strong>MAC地址</strong>），长度是48位，是在网卡出厂时<strong>固化</strong>的。可在shell中使用ifconfig命令查看，“<strong>00:50:56:c0:00:01</strong>”部分就是硬件地址。类型字段有三种值，<strong>分别对应IP、ARP、RARP。帧尾是CRC校验码。</strong></p>
<p>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。<strong>最大值1500称为以太网的最大传输单元（MTU）</strong>，不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行<strong>分片</strong>（fragmentation）。ifconfig命令输出中也<strong>MTU:1500</strong>.注意，<strong>MTU指指数据帧中有效载荷的最大长度，不包括帧头长度。</strong></p>
<h4 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a>ARP数据报格式</h4><p>在网络通讯时，<strong>源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址</strong>。ARP协议就起到这个作用。<strong>源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。</strong></p>
<p>每台主机都维护一个ARP缓存表，可以用arp -a命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。</p>
<p>ARP数据报的格式如下所示：</p>
<p><img src="https://api2.mubu.com/v3/document_image/0ce112c7-08bb-498d-ad2e-412cf17cbd90-11197877.jpg" alt="ARP数据报格式"></p>
<p>源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但<strong>如果链路层是其它类型的网络则有可能是必要的</strong>。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），op字段为1表示ARP请求，op字段为2表示ARP应答。</p>
<p>看一个具体的例子。</p>
<p>请求帧如下（为了清晰在每行的前面加了字节计数，每行16个字节）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">以太网首部（14字节）</span><br><span class="line"></span><br><span class="line">0000: ff ff ff ff ff ff 00 05 5d 61 58 a8 08 06</span><br><span class="line"></span><br><span class="line">ARP帧（28字节）</span><br><span class="line"></span><br><span class="line">0000: 00 01</span><br><span class="line"></span><br><span class="line">0010: 08 00 06 04 00 01 00 05 5d 61 58 a8 c0 a8 00 37</span><br><span class="line"></span><br><span class="line">0020: 00 00 00 00 00 00 c0 a8 00 02</span><br><span class="line"></span><br><span class="line">填充位（18字节）</span><br><span class="line"></span><br><span class="line">0020: 00 77 31 d2 50 10</span><br><span class="line"></span><br><span class="line">0030: fd 78 41 d3 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>以太网首部：<strong>目的主机采用广播地址</strong>，源主机的MAC地址是00:05:5d:61:58:a8，上层协议类型0x0806表示ARP。</p>
<p>ARP帧：硬件类型0x0001表示<strong>以太网</strong>，协议类型0x0800表示<strong>IP协议</strong>，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0001表示请求目的主机的MAC地址，源主机MAC地址为00:05:5d:61:58:a8，源主机IP地址为c0 a8 00 37（192.168.0.55）<strong>，目的主机MAC地址全0待填写，目的主机IP地址为c0 a8 00 02（192.168.0.2）。</strong></p>
<p>由于以太网规定最小数据长度为46字节，ARP帧长度只有28字节，因此有18字节填充位，填充位的内容没有定义，与具体实现相关。</p>
<p><strong>应答帧</strong>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">以太网首部</span><br><span class="line"></span><br><span class="line">0000: **00 05 5d 61 58 a8** 00 05 5d a1 b8 40 08 06</span><br><span class="line"></span><br><span class="line">ARP帧</span><br><span class="line"></span><br><span class="line">0000: 00 01</span><br><span class="line"></span><br><span class="line">0010: 08 00 06 04 00 02 **00 05 5d a1 b8 40** c0 a8 00 02</span><br><span class="line"></span><br><span class="line">0020: 00 05 5d 61 58 a8 c0 a8 00 37</span><br><span class="line"></span><br><span class="line">填充位</span><br><span class="line"></span><br><span class="line">0020: 00 77 31 d2 50 10</span><br><span class="line"></span><br><span class="line">0030: fd 78 41 d3 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>以太网首部：<strong>目的主机的MAC地址是00:05:5d:61:58:a8，源主机的MAC地址是00:05:5d:a1:b8:40，</strong>上层协议类型0x0806表示ARP。</p>
<p>ARP帧：硬件类型0x0001表示以太网，协议类型0x0800表示IP协议，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0002表示应答，源主机MAC地址为00:05:5d:a1:b8:40，源主机IP地址为c0 a8 00 02（192.168.0.2），目的主机MAC地址为00:05:5d:61:58:a8，目的主机IP地址为c0 a8 00 37（192.168.0.55）。</p>
<p>如果源主机和目的主机不在同一网段，ARP请求的广播帧无法穿过路由器，源主机如何与目的主机通信？</p>
<p>在网段通信时，数据包中的地址就是源IP，目标IP，源MAC，目标MAC，根本用不到网关，而当检测到需要把数据包发到远程网络时，这时，目标MAC就必须改变了，<strong>在还没有出内网时，目标MAC必须写成网关的MAC地址发出去，当网关收到时，再把目标MAC地址改成下一跳的MAC地址发出去，而源IP和源MAC以及目标IP不曾改变，就算到达了公网上，目标MAC仍然在不断改变着，直到最后，这个数据包到达目标IP的网络，最终通信结束！</strong></p>
<p><strong>不同网段的主机通信时，主机会封装网关（通常是路由器）的mac地址，然后主机将数据发送给路由器，后续路由进行路由转发，通过arp解析目标地址的mac地址，然后将数据包送达目的地。</strong>可参考：<a href="https://blog.csdn.net/weixin_43166958/article/details/86503506" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43166958/article/details/86503506</a></p>
<h4 id="IP段格式"><a href="#IP段格式" class="headerlink" title="IP段格式"></a>IP段格式</h4><p><img src="https://api2.mubu.com/v3/document_image/abc2bc1c-12b7-4366-a5d5-053a9e911fb8-11197877.jpg" alt="IP段格式"></p>
<ul>
<li><p>IP数据报的首部长度和数据长度都是可变长的，<strong>但总是4字节的整数倍</strong>。对于IPv4，4位版本字段是4。</p>
</li>
<li><p>4位首部长度的数值是以4字节为单位的，<strong>最小值为5</strong>，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说<strong>首部长度最大是60字节</strong>。</p>
</li>
<li>8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大吞吐量、最大可靠性、最小成本），还有一个位总是0。</li>
<li>总长度是整个数据报（包括IP首部和IP层payload）的字节数。</li>
<li><strong>每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。</strong></li>
<li><strong>3位标志和13位片偏移用于分片。</strong></li>
<li>TTL（Time to live)是这样用的：源主机为数据包设定一个<strong>生存时间</strong>，比如64，<strong>每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。</strong></li>
<li>协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。</li>
<li>校验和，<strong>只校验IP首部，数据的校验由更高层协议负责。</strong>IPv4的IP地址长度为32位。</li>
</ul>
<h4 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h4><p><img src="https://api2.mubu.com/v3/document_image/f556e6c8-4549-481f-963d-a43f8dc9e303-11197877.jpg" alt="udp数据报格式"></p>
<p>下面分析一帧<strong>基于UDP的TFTP协议帧</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">以太网首部</span><br><span class="line"></span><br><span class="line">0000: 00 05 5d 67 d0 b1 00 05 5d 61 58 a8 08 00</span><br><span class="line"></span><br><span class="line">IP首部</span><br><span class="line"></span><br><span class="line">0000: 45 00</span><br><span class="line"></span><br><span class="line">0010: 00 53 93 25 00 00 80 11 25 ec c0 a8 00 37 c0 a8</span><br><span class="line"></span><br><span class="line">0020: 00 01</span><br><span class="line"></span><br><span class="line">UDP首部</span><br><span class="line"></span><br><span class="line">0020： 05 d4 00 45 00 3f ac 40</span><br><span class="line"></span><br><span class="line">TFTP协议</span><br><span class="line"></span><br><span class="line">0020: 00 01 &apos;c&apos;&apos;:&apos;&apos;\&apos;&apos;q&apos;</span><br><span class="line"></span><br><span class="line">0030: &apos;w&apos;&apos;e&apos;&apos;r&apos;&apos;q&apos;&apos;.&apos;&apos;q&apos;&apos;w&apos;&apos;e&apos;00 &apos;n&apos;&apos;e&apos;&apos;t&apos;&apos;a&apos;&apos;s&apos;&apos;c&apos;&apos;i&apos;</span><br><span class="line"></span><br><span class="line">0040: &apos;i&apos;00 &apos;b&apos;&apos;l&apos;&apos;k&apos;&apos;s&apos;&apos;i&apos;&apos;z&apos;&apos;e&apos;00 &apos;5&apos;&apos;1&apos;&apos;2&apos;00 &apos;t&apos;&apos;i&apos;</span><br><span class="line"></span><br><span class="line">0050: &apos;m&apos;&apos;e&apos;&apos;o&apos;&apos;u&apos;&apos;t&apos;00 &apos;1&apos;&apos;0&apos;00 &apos;t&apos;&apos;s&apos;&apos;i&apos;&apos;z&apos;&apos;e&apos;00 &apos;0&apos;</span><br><span class="line"></span><br><span class="line">0060: 00</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以太网首部：源MAC地址是00:05:5d:61:58:a8，目的MAC地址是00:05:5d:67:d0:b1，上层协议类型0x0800表示IP。</p>
</li>
<li><p>IP首部：</p>
<ul>
<li>每一个字节45包含4位版本号和4位首部长度，版本号为4，即IPv4。</li>
<li><strong>首部长度为5，说明IP首部不带有选项字段</strong>。</li>
<li>服务类型为0，没有使用服务。</li>
<li>16位总长度字段（<strong>包括IP首部和IP层payload的长度</strong>）为0x0053，即83字节，加上以太网首部14字节可知整个帧长度是97字节。</li>
<li>IP报标识是0x9325</li>
<li>标志字段和片偏移字段设置为0x0000，就是DF=0允许分片，MF=0此数据报没有更多分片，没有分片偏移。</li>
<li>TTL是0x80，也就是128。</li>
<li>上层协议0x11表示UDP协议。</li>
<li>IP首部校验和为0x25ec</li>
<li>源主机IP是c0 a8 00 37（192.168.0.55）</li>
<li>目的主机IP是c0 a8 00 01（192.168.0.1）。</li>
</ul>
</li>
<li><p>UDP首部：</p>
<ul>
<li>源端口号0x05d4（1492）是客户端的端口号</li>
<li>目的端口号0x0045（69）是TFTP服务的well-known端口号。</li>
<li>UDP报长度为0x003f，即63字节，包括UDP首部和UDP层pay-load的长度。</li>
<li>UDP首部和UDP层payload的校验和为0xac40。</li>
</ul>
</li>
<li><p>TFTP是基于文本的协议，各字段之间用字节0分隔，开头的00 01表示请求读取一个文件，接下来的各字段是：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c:\qwerq.qwe</span><br><span class="line">netascii</span><br><span class="line">blksize 512</span><br><span class="line">timeout 10</span><br><span class="line">tsize 0</span><br></pre></td></tr></table></figure>
<p>一般的网络通信都是像TFTP协议这样，通信的双方分别是客户端和服务器，<strong>客户端主动发起请求（上面的例子就是客户端发起的请求帧），而服务器被动地等待、接收和应答请求。</strong></p>
<p>客户端的<strong>IP地址和端口号唯一标识了该主机上的TFTP客户端进程</strong>，<strong>服务器的IP地址和端口号唯一标识了该主机上的TFTP服务进程</strong>，由于客户端是主动发起请求的一方，它必须知道服务器的IP地址和TFTP服务进程的端口号，所以，<strong>一些常见的网络协议有默认的服务器端口，例如HTTP服务默认TCP协议的80端口，FTP服务默认TCP协议的21端口，TFTP服务默认UDP协议的69端口</strong>。</p>
<p>在使用客户端程序时，必须指定服务器的主机名或IP地址，如果不明确指定端口号则采用默认端口，请读者查阅ftp、tftp等程序的man page了解如何指定端口号。</p>
<p>/etc/services中列出了所有well-known的服务端口和对应的传输层协议，这是由IANA（Internet Assigned Numbers Authority）规定的，其中有些服务既可以用TCP也可以用UDP，为了清晰，IANA规定这样的服务采用相同的TCP或UDP默认端口号，而另外一些TCP和UDP的相同端口号却对应不同的服务。</p>
<p><strong>很多服务有well-known的端口号，然而客户端程序的端口号却不必是well-known的，往往是每次运行客户端程序时由系统自动分配一个空闲的端口号，用完就释放掉，称为ephemeral的端口号</strong>。</p>
<p>前面提过，UDP协议不面向连接，也不保证传输的可靠性，例如：</p>
<p>发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，<strong>UDP协议层也不会给应用层返回任何错误信息。</strong></p>
<p>接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，<strong>UDP协议层也不保证按发送时的顺序交给应用层。</strong></p>
<p>通常接收端的UDP协议层将收到的数据放在一个固定大小的<strong>缓冲区</strong>中等待应用程序来提取和处理，<strong>如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误。</strong></p>
<p>因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。<strong>一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。</strong>例如，基于UDP的TFTP协议一般只用于传送小文件（所以才叫trivial的ftp），而基于TCP的FTP协议适用于各种文件的传输。</p>
<h4 id="TCP数据报格式"><a href="#TCP数据报格式" class="headerlink" title="TCP数据报格式"></a>TCP数据报格式</h4><p><img src="https://api2.mubu.com/v3/document_image/fc32ff01-d771-4a37-9284-5b7e4e0c35a5-11197877.jpg" alt="TCP数据报格式"></p>
<p>与UDP协议一样也有<strong>源端口号和目的端口号</strong>，通讯的双方由<strong>IP地址和端口号标识</strong>。32位<strong>序号</strong>、32位<strong>确认序号</strong>、窗口大小稍后详细解释。<strong>4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节，如果没有选项字段，TCP协议头最短20字节。</strong>URG、ACK、PSH、RST、SYN、FIN是六个<strong>控制位</strong>。16位检验和将TCP协议头和数据都计算在内。</p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="TCP通信时序"><a href="#TCP通信时序" class="headerlink" title="TCP通信时序"></a>TCP通信时序</h4><p>下图是一次TCP通讯的时序图。TCP连接建立断开。包含熟知的<strong>三次握手和四次挥手</strong>。</p>
<p><img src="https://api2.mubu.com/v3/document_image/ec55030e-d0f1-4e59-b845-cb997dce3d16-11197877.jpg" alt="TCP通信时序"></p>
<p>在这个例子中，首先客户端主动发起连接、发送请求，然后服务器端响应请求，然后客户端主动关闭连接。两条竖线表示通讯的两端，从上到下表示时间的先后顺序，注意，数据从一端传到网络的另一端也需要时间，所以图中的箭头都是斜的。双方发送的段按时间顺序编号为1-10，各段中的主要信息在箭头上标出，例如段2的箭头上标着SYN, 8000(0), ACK 1001，表示该段中的SYN位置1，32位<strong>序号</strong>是8000，<strong>该段不携带有效载荷（数据字节数为0）</strong>，ACK位置1，32位<strong>确认序号是1001</strong>，<strong>带有一个mss（Maximum Segment Size，最大报文长度）选项值为1024。</strong></p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul>
<li><p>客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1</p>
<ul>
<li>客户端发出段1，<strong>SYN位表示连接请求</strong>。</li>
<li><strong>序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况</strong></li>
<li><strong>规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001(段4)</strong>。</li>
<li>mss表示最大段尺寸，<strong>如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片</strong>，为了避免这种情况，<strong>客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。</strong></li>
</ul>
</li>
<li><p>服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它<strong>表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。</strong></p>
<ul>
<li>服务器发出段2，也带有SYN位，<strong>同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。</strong></li>
</ul>
</li>
<li><p>客户必须再次回应服务器端一个ACK报文，这是报文段3。</p>
<ul>
<li>客户端发出段3，对服务器的连接请求进行应答，<strong>确认序号</strong>是8001。在这个过程中，<strong>客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为“三方握手（three-way-handshake）”。</strong>在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。</li>
</ul>
</li>
</ul>
<p>在TCP通讯中，<strong>如果一方收到另一方发来的段，读出其中的目的端口号，发现本机并没有任何进程使用这个端口，就会应答一个包含RST位的段给另一方</strong>。例如，服务器并没有任何进程使用8080端口，我们却用telnet客户端去连接它，服务器收到客户端发来的SYN段就会应答一个RST段，<strong>客户端的telnet程序收到RST段后报告错误Connection refused：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> telnet 192.168.0.200 8080</span></span><br><span class="line"></span><br><span class="line">Trying 192.168.0.200...</span><br><span class="line"></span><br><span class="line">telnet: Unable to connect to remote host: Connection refused</span><br></pre></td></tr></table></figure>
<h4 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h4><ul>
<li><p>客户端发出段4，包含从序号1001开始的20个字节数据。</p>
</li>
<li><p>服务器发出段5，<strong>确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback。</strong></p>
</li>
<li><p>客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。</p>
</li>
</ul>
<p>在数据传输过程中，<strong>ACK和确认序号</strong>是非常重要的，<strong>应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。</strong></p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>由于TCP连接是<strong>全双工</strong>的，因此<strong>每个方向都必须单独进行关闭</strong>。这原则是<strong>当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭</strong>。</p>
<ul>
<li><p>客户端发出段7，FIN位表示关闭连接的请求。</p>
</li>
<li><p>服务器发出段8，应答客户端的关闭连接请求。</p>
</li>
<li><p>服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。</p>
</li>
<li><p>客户端发出段10，应答服务器的关闭连接请求。</p>
</li>
</ul>
<p>建立连接的过程是三次握手，而关闭连接通常需要4个段，<strong>服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据（ACK是可以的，只是没有数据）给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。</strong></p>
<h4 id="滑动窗口-TCP流量控制"><a href="#滑动窗口-TCP流量控制" class="headerlink" title="滑动窗口(TCP流量控制)"></a>滑动窗口(TCP流量控制)</h4><p>介绍UDP时描述了这样的问题：<strong>如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会丢失数据。TCP协议通过“滑动窗口（Sliding Window）”机制解决这一问题</strong>。看下图的通讯过程：</p>
<p><img src="https://api2.mubu.com/v3/document_image/c4a7fc97-b1d8-4801-b5c0-9292f30ef408-11197877.jpg" alt="滑动窗口"></p>
<ul>
<li><p>发送端发起连接，声明最大段尺寸是1460，初始序号是0，<strong>窗口大小是4K，表示“我的接收缓冲区还有4K字节空闲，你发的数据不要超过4K”</strong>。接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三次握手结束。</p>
</li>
<li><p>发送端发出段4-9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。</p>
</li>
<li><p>接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K。</p>
</li>
<li><p>接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。</p>
</li>
<li><p>发送端发出段12-13，每个段带2K数据，段13同时还包含FIN位。</p>
</li>
<li><p>接收端应答接收到的2K数据（6145-8192），<strong>再加上FIN位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。</strong></p>
</li>
<li><p>接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。</p>
</li>
<li><p>接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。</p>
</li>
<li><p>接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连接完全关闭。</p>
</li>
</ul>
<p>上图在接收端用小方块表示1K数据，实心的小方块表示已接收到的数据，<strong>虚线框表示接收缓冲区</strong>，因此套在虚线框中的空心小方块表示窗口大小，从图中可以看出，<strong>随着应用程序提走数据，虚线框是向右滑动的，因此称为滑动窗口。</strong></p>
<p>从这个例子还可以看出，发送端每次发送1KB数据，而接收端的应用程序可以每次提走2KB数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据。也就是说，<strong>应用程序所看到的数据是一个整体，或说是一个流（stream），在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。</strong>而UDP是面向消息的协议，<strong>每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据</strong>，这一点和TCP是很不同的。</p>
<h4 id="TCP-状态转移"><a href="#TCP-状态转移" class="headerlink" title="TCP 状态转移"></a>TCP 状态转移</h4><p><img src="https://api2.mubu.com/v3/document_image/698596cd-0a9b-4644-9503-9c3d7ab1f397-11197877.jpg" alt="TCP状态转移"></p>
<ul>
<li><p>实线部分：主动发起连接，主动关闭连接。主动发起连接才会出现FIN_WAIT_2状态。TIME_WAIT的时间：不确定对方是否收到发送的ACK。</p>
</li>
<li><p>虚线部分：被动发起连接，被动关闭连接</p>
</li>
<li><p>小细线部分：两端同时操作</p>
</li>
</ul>
<p>状态解读：</p>
<ul>
<li><p><strong>CLOSED：</strong>表示初始状态。</p>
</li>
<li><p><strong>LISTEN：</strong>该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</p>
</li>
<li><p><strong>SYN_SENT：</strong>这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</p>
</li>
<li><p><strong>SYN_RCVD:</strong> 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂<strong>。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</strong></p>
</li>
<li><p><strong>ESTABLISHED：</strong>表示连接已经建立。</p>
</li>
<li><p><strong>FIN_WAIT_1:</strong> FIN_WAIT_1和FIN_WAIT_2状态的真正含义<strong>都是表示等待对方的FIN报文</strong>。区别是：</p>
<ul>
<li><p>FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。</p>
</li>
<li><p>FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，<strong>而FIN_WAIT_2状态可用netstat看到。</strong></p>
</li>
</ul>
</li>
<li><p><strong>FIN_WAIT_2：</strong> <strong>主动关闭链接的一方，发出FIN收到ACK以后进入该状态</strong>。称之为<strong>半连接或半关闭状态</strong>。该<strong>状态下的socket只能接收数据，不能发。</strong></p>
</li>
<li><p><strong>TIME_WAIT:</strong> 表示<strong>收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态</strong>。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</p>
</li>
<li><p><strong>CLOSING:</strong> 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。<strong>但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。</strong>什么情况下会出现此种情况？如果<strong>双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</strong></p>
</li>
<li><p><strong>CLOSE_WAIT:</strong> 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。<strong>所以在CLOSE_WAIT状态下，需要关闭连接</strong>。</p>
</li>
<li><p><strong>LAST_ACK:</strong> 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入的到CLOSED可用状态。</p>
</li>
</ul>
<h4 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h4><p><strong>当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。</strong></p>
<p>从程序的角度，可以使用API来控制实现半连接状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br><span class="line"></span><br><span class="line">sockfd: 需要关闭的socket的描述符</span><br><span class="line"></span><br><span class="line">how:允许为<span class="built_in">shutdown</span>操作选择以下几种方式:</span><br><span class="line"></span><br><span class="line">SHUT_RD(<span class="number">0</span>)：	关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line"></span><br><span class="line">SHUT_WR(<span class="number">1</span>): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。</span><br><span class="line"></span><br><span class="line">SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用<span class="built_in">shutdown</span>两次：首先是以SHUT_RD,然后以SHUT_WR。</span><br></pre></td></tr></table></figure>
<p><strong>使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。</strong></p>
<p><strong>shutdown不考虑描述符的引用计数，直接关闭描述符</strong>。也可选择中止一个方向的连接，只中止读或只中止写。</p>
<p>注意:</p>
<ul>
<li><p>如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。 </p>
</li>
<li><p>在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但，如果一个进程close(sfd)将不会影响到其它进程。</p>
</li>
</ul>
<h4 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h4><p>2MSL (Maximum Segment Lifetime) TIME_WAIT状态的存在有两个理由：</p>
<ul>
<li><p><strong>让4次握手关闭流程更加可靠</strong>:4次握手的最后一个ACK是是由主动关闭方发送出去的<strong>，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。</strong></p>
</li>
<li><p>防止lost duplicate对后续新建正常链接的传输造成破坏。</p>
<ul>
<li>lost uplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，<strong>要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地</strong>。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。</li>
<li>另外一个概念叫做incarnation connection，<strong>指跟上次的socket pair一摸一样的新连接，</strong>叫做incarnation of previous connection。lost duplicate加上incarnation connection，则会对的传输造成致命的错误。</li>
</ul>
</li>
</ul>
<p>TCP是流式的，所有包到达的顺序是不一致的，依靠序列号由TCP协议栈做顺序的拼接；假设一个incarnation connection这时收到的seq=1000, 来了一个lost duplicate为seq=1000，len=1000, 则TCP认为这个lost duplicate合法，并存放入了receive buffer，导致传输出现错误。<strong>通过一个2MSL TIME_WAIT状态，确保所有的lost duplicate都会消失掉，避免对新连接造成错误。</strong></p>
<p>该状态为什么设计在<strong>主动关闭这一方</strong>：</p>
<ul>
<li><p>发最后ACK的是主动关闭一方。</p>
</li>
<li><p>只要有一方保持TIME_WAIT状态<strong>，就能起到避免incarnation connection在2MSL内的重新建立，不需要两方都有。</strong></p>
</li>
</ul>
<p>如何正确对待2MSL TIME_WAIT?</p>
<ul>
<li><p>RFC要求socket pair在处于TIME_WAIT时，不能再起一个incarnation connection。<strong>但绝大部分TCP实现，强加了更为严格的限制。在2MSL等待期间，socket中使用的本地端口在默认情况下不能再被使用。</strong></p>
</li>
<li><p>若A 10.234.5.5 : 1234和B 10.55.55.60 : 6666建立了连接，A主动关闭，那么在A端只要port为1234，无论对方的port和ip是什么，都不允许再起服务。这甚至比RFC限制更为严格，RFC仅仅是要求socket pair不一致，而<strong>实现当中只要这个port处于TIME_WAIT，就不允许起连接。这个限制对主动打开方来说是无所谓的，因为一般用的是临时端口</strong>；但对于被动打开方，一般是server，就悲剧了，因为server一般是熟知端口。比如http，一般端口是80，不可能允许这个服务在2MSL内不能起来。</p>
</li>
</ul>
<p>解决方案:</p>
<ul>
<li><p><strong>给服务器的socket设置SO_REUSEADDR选项，这样的话就算熟知端口处于TIME_WAIT状态，在这个端口上依旧可以将服务启动</strong>。当然，虽然有了SO_REUSEADDR选项，但sockt pair这个限制依旧存在。比如上面的例子，A通过SO_REUSEADDR选项依旧在1234端口上起了监听，但这时若是从B通过6666端口去连它，T<strong>CP协议会告诉我们连接失败，原因为Address already in use.</strong></p>
</li>
<li><p>RFC 793中规定<strong>MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</strong></p>
</li>
</ul>
<h4 id="程序设计中的问题"><a href="#程序设计中的问题" class="headerlink" title="程序设计中的问题"></a><strong>程序设计中的问题</strong></h4><p>做一个测试，首先启动server，然后启动client，用Ctrl-C终止server，马上再运行server，运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./server</span></span><br><span class="line">bind error: Address already in use</span><br></pre></td></tr></table></figure>
<p>这是因为，<strong>虽然server的应用程序终止了，但TCP协议层的连接并没有完全断开，因此不能再次监听同样的server端口</strong>。用netstat命令可以查看：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -apn |grep <span class="number">6666</span></span><br><span class="line">tcp  <span class="number">1</span>  <span class="number">0</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">38103</span>    <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">6666</span>   CLOSE_WAIT  <span class="number">3525</span>/client   </span><br><span class="line">tcp  <span class="number">0</span>  <span class="number">0</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">6666</span>    <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span>:<span class="number">38103</span>   FIN_WAIT2  -</span><br></pre></td></tr></table></figure>
<p>server终止时，socket描述符会自动关闭并发FIN段给client，client收到FIN后处于CLOSE_WAIT状态，但是client并没有终止，也没有关闭socket描述符，因此不会发FIN给server，因此server的TCP连接处于FIN_WAIT2状态。</p>
<p>现在用Ctrl-C把client也终止掉，再观察现象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> netstat -apn |grep 6666</span></span><br><span class="line">tcp  0  0 192.168.1.11:6666    192.168.1.11:38104    TIME_WAIT  -</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./server</span></span><br><span class="line">bind error: Address already in use</span><br></pre></td></tr></table></figure>
<p>client终止时自动关闭socket描述符，server的TCP连接收到client发的FIN段后处于TIME_WAIT状态。TCP协议规定，<strong>主动关闭连接的一方要处于TIME_WAIT状态</strong>，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态，因为先Ctrl-C终止了server，所以server是主动关闭连接的一方，在TIME_WAIT期间仍然不能再次监听同样的server端口。</p>
<p>MSL在RFC 1122中规定为两分钟，但是各操作系统的实现不同，在Linux上一般经过半分钟后就可以再次启动server了。</p>
<h4 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a><strong>端口复用</strong></h4><p>在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为<strong>，TCP连接没有完全断开指的是connfd（127.0.0.1:6666）没有完全断开，而我们重新监听的是listenfd（0.0.0.0:6666），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。</strong></p>
<p>在server代码的socket()和bind()调用之间插入如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/linux_%E7%BD%91%E7%BB%9C01%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/06/linux_%E7%BD%91%E7%BB%9C01%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">网络基础-1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-06 19:29:16" itemprop="dateCreated datePublished" datetime="2020-05-06T19:29:16+08:00">2020-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-23 16:05:27" itemprop="dateModified" datetime="2021-03-23T16:05:27+08:00">2021-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>从应用的角度出发，协议可理解为“规则”，是数据传输和数据解释的规则。</p>
<p>协议双发之间遵守的协议中可以称为<strong>原始协议</strong>。当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、完整的协议，被广泛应用于各种应用中，此时该协议就可以成为一个<strong>标准协议</strong>。</p>
<p>TCP协议注重数据的<strong>传输</strong>。http协议着重于数据的<strong>解释</strong>。</p>
<h4 id="典型协议"><a href="#典型协议" class="headerlink" title="典型协议"></a>典型协议</h4><ul>
<li>应用层 常见的协议有HTTP协议，FTP协议。<ul>
<li>HTTP(超文本传输协议，Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议</li>
<li>FTP文件传输协议（File Transfer Protocol）。</li>
</ul>
</li>
<li><p>传输层 常见协议有TCP/UDP协议。</p>
<ul>
<li>TCP（传输控制协议，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</li>
<li>UDP用户数据报协议（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</li>
</ul>
</li>
<li><p>网络层 常见协议有IP协议、ICMP协议、IGMP协议。</p>
<ul>
<li>IP协议是因特网互联协议（Internet Protocol）。</li>
<li>ICMP协议是Internet控制报文协议（Internet Control Message Protocol）它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</li>
<li>IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。</li>
</ul>
</li>
<li><p>网络接口层 常见协议有ARP协议、RARP协议。</p>
<ul>
<li>ARP协议是正向地址解析协议Address Resolution Protocol，通过已知的IP，寻找对应主机的MAC</li>
<li>RARP是反向地址转换协议，通过MAC地址确定IP地址。</li>
</ul>
</li>
</ul>
<h3 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h3><h4 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h4><p>传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要<strong>在通讯两端各自部署客户机和服务器来完成数据通信。</strong></p>
<p>优点：</p>
<ul>
<li><p>客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而<strong>提高数据传输效率</strong>。</p>
</li>
<li><p>c端和s端都需要自己定义，协议使用灵活</p>
</li>
<li>可以提前在本地进行<strong>大量数据的缓存处理，</strong>从而提高观感</li>
</ul>
<p>缺点：</p>
<ul>
<li>从用户角度出发，需要将客户端安插至用户主机上，对用户主机的<strong>安全性构成威胁</strong>。</li>
<li>开发工作量大，调试困难</li>
</ul>
<h4 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a>B/S模式</h4><p>浏览器(browser)/服务器(server)模式。只需在<strong>一端部署服务器</strong>，而另外一端使用每台PC都默认配置的<strong>浏览器</strong>即可完成数据的传输。</p>
<p>优点：</p>
<ul>
<li>使用标准浏览器作为客户端，其工作<strong>开发量较小</strong>。<strong>只需开发服务器端</strong>即可。</li>
<li>由于其采用浏览器显示数据，因此<strong>移植性非常好</strong>，<strong>不受平台限制</strong>。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>网络应用支持受限</strong>。</li>
<li>没有客户端放到对方主机上，<strong>缓存数据不尽如人意</strong>，从而传输数据量受到限制。应用的观感大打折扣。</li>
<li>必须与浏览器一样，采用标准http协议进行通信，<strong>协议选择不灵活</strong>。</li>
</ul>
<h3 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h3><p><img src="https://api2.mubu.com/v3/document_image/806d08e7-d28c-4cc1-9784-558e8eefb40a-11197877.jpg" alt="分层模型图"></p>
<p>四层模型(TCP/IP模型)：</p>
<p><img src="https://api2.mubu.com/v3/document_image/bae0285c-aefa-4557-820d-6eeff80268c4-11197877.jpg" alt="四层模型"></p>
<p>一般在应用开发过程中，讨论最多的是TCP/IP模型。</p>
<h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><p>两台计算机通过TCP/IP协议通讯的过程如下所示：</p>
<p><img src="https://api2.mubu.com/v3/document_image/e9f87650-9716-4dce-9291-db97a7402993-11197877.jpg" alt="两台计算机通过TCP/IP协议通讯的过程"></p>
<p>上图对应两台计算机在<strong>同一网段中</strong>的情况，如果<strong>两台计算机在不同的网段</strong>中，那么数据<strong>从一台计算机到另一台计算机传输过程中要经过一个或多个路由器</strong>，如下图所示：</p>
<p><img src="https://api2.mubu.com/v3/document_image/090da69d-d159-4666-a1ce-34b7423cce4a-11197877.jpg" alt="不同网段通信过程"></p>
<h5 id="链路层工作"><a href="#链路层工作" class="headerlink" title="链路层工作"></a>链路层工作</h5><p>链路层有<strong>以太网、令牌环网</strong>等标准，<strong>链路层负责网卡设备的驱动、帧同步</strong>（即从网线上检测到什么信号算作新帧的开始）、<strong>冲突检测</strong>（如果检测到冲突就自动重发）、<strong>数据差错校验</strong>等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同<strong>，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。</strong></p>
<h5 id="网络层工作"><a href="#网络层工作" class="headerlink" title="网络层工作"></a>网络层工作</h5><p>网络层的IP协议是构成Internet的基础。<strong>Internet上的主机通过IP地址来标识</strong>，Internet上有大量<strong>路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器</strong>。<strong>路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。</strong> <strong>IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。</strong></p>
<p>网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器）</p>
<h5 id="传输层工作"><a href="#传输层工作" class="headerlink" title="传输层工作"></a>传输层工作</h5><p>传输层负责<strong>端到端</strong>（end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。</p>
<p>TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。<strong>也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。</strong></p>
<p>UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。<strong>使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。</strong></p>
<p>目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示：</p>
<p><img src="https://api2.mubu.com/v3/document_image/edf682ef-36c8-4a46-a688-74775983ccbb-11197877.jpg" alt="数据包传输过程"></p>
<p>以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（<strong>payload，指除去协议首部之外实际传输的数据</strong>）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。<strong>假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。</strong></p>
<p>虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/03/linux-%E7%B3%BB%E7%BB%9F-11%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/03/linux-%E7%B3%BB%E7%BB%9F-11%E9%94%81/" class="post-title-link" itemprop="url">linux系统-11锁</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-03 19:13:29" itemprop="dateCreated datePublished" datetime="2020-04-03T19:13:29+08:00">2020-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-30 14:33:17" itemprop="dateModified" datetime="2021-03-30T14:33:17+08:00">2021-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>linux中提供了互斥锁(<code>mutex</code>,互斥量)。<strong>每个线程在对资源进行操作前都会尝试先加锁，成功加锁才能操作，操作结束解锁。资源还是共享的，线程间也还存在竞争。但通过”锁”可以将资源的访问变成互斥操作，而后与时间有关的错误也将不会再产生。</strong></p>
<p>应该注意：<strong>同一时刻，只能有一个线程持有该锁</strong>。</p>
<p>当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B会阻塞。C线程不加锁而直接访问该全局变量，此时依然能够访问，但会出现数据混乱。</p>
<p>互斥锁实质上是操作系统提供的一把<strong>建议锁（又称”协同锁”）</strong>，当程序中有多线程访问共享资源的时候需要使用该机制。但是<strong>没有强制的限定</strong>。</p>
<h4 id="借助互斥锁管理共享数据实现同步"><a href="#借助互斥锁管理共享数据实现同步" class="headerlink" title="借助互斥锁管理共享数据实现同步"></a>借助互斥锁管理共享数据实现同步</h4><p><code>C</code>关键词<strong><code>restrict</code>用来限定指针变量，被该关键字限定的指针变量所指向的内存操作必须由本指针完成</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> lock; <span class="comment">//创建锁</span></span><br><span class="line">pthread_mutex_init; <span class="comment">//初始化</span></span><br><span class="line">pthread_mutex_lock; <span class="comment">//加锁</span></span><br><span class="line">访问共享数据(<span class="built_in">stdout</span>)</span><br><span class="line">pthread_mutex_unlock(); <span class="comment">//解锁</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/01/linux-%E7%B3%BB%E7%BB%9F-10%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/linux-%E7%B3%BB%E7%BB%9F-10%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">linux系统-线程及其管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 15:12:58" itemprop="dateCreated datePublished" datetime="2020-04-01T15:12:58+08:00">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-26 19:16:28" itemprop="dateModified" datetime="2021-03-26T19:16:28+08:00">2021-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><ul>
<li><p>LWP： light weight process, 轻量级进程，<strong>本质仍是进程（在linux下)</strong></p>
</li>
<li><p>进程：<strong>独立地址空间，拥有PCB</strong></p>
</li>
<li><p>线程：<strong>也有PCB，但没有独立的地址空间（共享）</strong></p>
</li>
<li><p>区别：在于是否共享地址空间。进程独居，线程合租。</p>
</li>
</ul>
<p>Linux下：</p>
<ul>
<li>线程为最小<strong>执行单位（cpu获得效率）</strong></li>
<li>进程为最小<strong>资源分配单位</strong>，<strong>可看作只有一个线程的进程。</strong></li>
</ul>
<p>查看LWP号: <code>ps -Lf pid</code>查看指定线程的lwp号</p>
<h4 id="linux内核线程实现"><a href="#linux内核线程实现" class="headerlink" title="linux内核线程实现"></a>linux内核线程实现</h4><p>linux中进程和线程关系密切</p>
<ul>
<li><p>线程是轻量级进程（light weight process)，<strong>也有PCB,创建线程使用的底层函数和进程一样，都是<code>clone</code></strong></p>
</li>
<li><p><strong>从内核里看进程和线程是一样的，都有各自不同的PCB，但PCB中指向的内存资源的三级页表是相同的</strong></p>
</li>
<li><p>进程可以蜕变为线程</p>
</li>
<li><p><strong>线程可以看作寄存器和栈（主要体现在函数调用,每个线程的stack空间不一样）的集合</strong></p>
</li>
<li><p>在linux下，<strong>线程是最小执行单位，进程是最小资源分配单位</strong></p>
</li>
</ul>
<h4 id="三级页表"><a href="#三级页表" class="headerlink" title="三级页表"></a>三级页表</h4><p>PCB中持有<strong>当前进程的页目录表的指针, 页目录表中每一项指向一个个页表, 用页表检索物理内存页面</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/a7768bae-b28c-4fe2-98ec-941805f1f5cb-11197877.jpg" alt="三级页表"></p>
<p><img src="https://api2.mubu.com/v3/document_image/001da9ee-605d-4d7c-a0a7-100200b52c6e-11197877.jpg" alt="程序运行内存情况"></p>
<h4 id="线程之间共享的资源"><a href="#线程之间共享的资源" class="headerlink" title="线程之间共享的资源"></a>线程之间共享的资源</h4><ul>
<li><strong>文件描述符表</strong></li>
<li>每种<strong>信号的处理方式(线程和信号最好不要一起使用)</strong></li>
<li>当前<strong>工作目录</strong></li>
<li><strong>用户ID和组ID</strong></li>
<li><strong>内存地址空间(<code>.text/ .data/ .bss/ heap/共享库</code>)</strong></li>
</ul>
<h4 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h4><ul>
<li><strong>线程id</strong></li>
<li><strong>处理器现场和栈指针(内核栈)</strong></li>
<li><strong>独立的栈空间（用户空间栈）</strong></li>
<li>errno变量</li>
<li><strong>信号屏蔽字</strong></li>
<li>调度<strong>优先级</strong></li>
</ul>
<h4 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h4><p>优点： <strong>提高程序并发性，开销小，数据通信、共享数据方便</strong></p>
<p>缺点：库函数不稳定，调试编写困难、gdb不支持，对信号支持不好</p>
<p>linux下的实现方法使得进程和线程的差别不是很大。但<strong>可以通过在一个进程中开多个线程来达到抢占cpu的目的。</strong></p>
<h3 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h3><h4 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h4><p><strong>获取线程ID。其作用对应进程中getpid()函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>线程ID：<strong><code>pthread_t</code>类型，本质：在Linux下为无符号整数(<code>lu%</code>),其他系统中可能是结构体实现</strong></p>
<p>线程ID是进程内部的识别标志。(<strong>两个进程间的线程ID允许相同</strong>)</p>
<p>创建线程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread,<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr,<span class="keyword">void</span>* (*start_routine)(<span class="keyword">void</span>* ),<span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0, 失败返回errno;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p>不应使用全局变量<code>pthread_t tid</code>, 而应使用<code>pthread_self</code></p>
</li>
<li><p><strong>在子线程中通过<code>pthread_create</code>传出参数来获取线程ID</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread id is: %lu\n"</span>,pthread_self()); <span class="comment">//线程还没来得及输出进程就结束了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in main, thread id = %lu\n"</span>,pthread_self());</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>,thread_func,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthred_create error: %s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*父进程等待1秒,否则父进程一旦退出,地址空间被释放,子线程没机会执行*/</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="循环创建线程"><a href="#循环创建线程" class="headerlink" title="循环创建线程"></a>循环创建线程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int i = *(int *)arg; //注意传地址最后取出来的值</span></span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%dth thread id is: %lu\n"</span>,i,pthread_self()); <span class="comment">//线程还没来得及输出进程就结束了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret, i;</span><br><span class="line">    <span class="comment">// printf("in main, thread id = %lu\n",pthread_self());</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = pthread_create(&amp;tid, <span class="literal">NULL</span>,thread_func,(<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthred_create error: %s\n"</span>,strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//将当强进程退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意参数传递方式, <strong>先将int型的i强转成void*传入, 用到时再强转回int型</strong></p>
<h5 id="线程参数传递"><a href="#线程参数传递" class="headerlink" title="线程参数传递"></a>线程参数传递</h5><p>如果使<code>void*</code>过程中不用强转, 看似规规矩矩的传地址再解引用, 会出现问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这是一个出错的版本*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=*((<span class="keyword">int</span>*)arg);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I'm %dth thread,pid=%d,tid=%lu\n"</span>,i+<span class="number">1</span>,getpid(),pthread_self());</span><br><span class="line">	sleep(i);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">		ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="keyword">void</span>*)&amp;i);</span><br><span class="line">		<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">			perr_exit(<span class="string">"pthread_create error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sleep(i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/8c997c3d-e2c3-4946-b95c-ce9e924dd04e-11197877.jpg" alt="stack地址"></p>
<p>错误分析：<strong><code>main</code>中给<code>tfn</code>传入的是它的函数栈帧中局部变量<code>i</code>的地址, 这样<code>tfn</code>能随时访问到i的值, 考虑到线程之间是并发执行的, 每次中<code>main</code>中固定的地址中拿数据, 相当于各个线程共享了这块地址, 由于访问时刻随机, 所以访问到的各个值也是很随机的</strong></p>
<p><strong>使用强转可以保证变量<code>i</code>的实时性(C语言值传递的特性)</strong></p>
<h5 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h5><p><strong>线程默认共享数据段, 代码段等地址空间, 常用的是全局变量, 而进程不共享全局变量, 只能借助<code>mmap</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    var = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"befor pthread_create, var = %d\n"</span>,var);</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    tid = pthread_create(&amp;tid, <span class="literal">NULL</span>,fun, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after pthread_create, var = %d\n"</span>,var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h4><p>将单个线程退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* rerval)</span></span>;<span class="comment">//参数：retval表示线程退出状态，通常传NULL</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>exit()</code>函数用来<strong>退出当前进程, 不可以用在线程中</strong>, 否则全部退出（<strong>exit退出会使进程退出</strong>）</p>
</li>
<li><p><code>pthread_exit()</code>函数才是用来<strong>将单个的线程退出</strong></p>
</li>
<li><p><code>pthread_exit</code>或者<code>return</code>返回的指针所指向的内存单元必须是<strong>全局的或者<code>malloc</code>分配的</strong>, <strong>不能在线程函数的栈上分配, 因为其他线程得到这个返回指针时线程函数已经退出了</strong></p>
</li>
</ul>
<p><code>return</code>和<code>exit</code>的区别：</p>
<ul>
<li><strong>return是返回到调用者处，exit为退出进程</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread id is: %lu\n"</span>,pthread_self()); <span class="comment">//线程还没来得及输出进程就结束了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in main, thread id = %lu\n"</span>,pthread_self());</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>,thread_func,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthred_create error: %s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sleep(1);</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); <span class="comment">//主线程退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h4><p><strong>阻塞等待线程退出，获取进程退出状态</strong>。其作用对应进程中的<code>waitpid()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread,<span class="keyword">void</span>** retval)</span></span>;<span class="comment">//成功返回0，失败返回错误号.线程的退出状态是void*, 回收时传的就是void**</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回收子线程并获得返回值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">64</span>];</span><br><span class="line">&#125;<span class="keyword">exit_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thred_func</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">/*在堆区创建一个结构体*/</span></span><br><span class="line">    <span class="keyword">exit_t</span>* retvar = (<span class="keyword">exit_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">exit_t</span>));</span><br><span class="line">    retvar-&gt;ch = <span class="string">'m'</span>;</span><br><span class="line">    retvar-&gt;var = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(retvar-&gt;str,<span class="string">"my thread\n"</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)retvar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">exit_t</span> *val;</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thred_func,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/*pthread_join回收子线程*/</span></span><br><span class="line">    pthread_join(tid,(<span class="keyword">void</span>**)&amp;val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ch = %c, var = %d, str = %s\n"</span>,val-&gt;ch,val-&gt;var,val-&gt;str);</span><br><span class="line">    <span class="built_in">free</span>(val);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*在堆区创建一个结构体*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> <span class="title">tval</span>;</span></span><br><span class="line">	<span class="comment">/*给结构体赋值*/</span></span><br><span class="line">	tval.var=<span class="number">100</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(tval.str,<span class="string">"love you"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span>*)&amp;tval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不能将子线程的回调函数的局部变量返回, 由于该函数执行完毕返回后, 其栈帧消失, 栈上的局部变量也就消失, 返回的是无意义的</strong>。<strong>可以在main函数中创建局部变量</strong></p>
<h4 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h4><p>实现线程分离, <strong>线程终止会自动清理pcb, 无需回收</strong>，子线程分离后不能再调用<code>pthread_join</code>回收了。（<strong><code>detach</code>相当于自动回收, <code>join</code>相当于手动回收</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>; <span class="comment">//成功返回0，失败返回错误号</span></span><br></pre></td></tr></table></figure>
<p>线程分离状态：指定该状态，<strong>线程主动与主控线程断开关系</strong>。<strong>线程结束后，其退出状态不由其他线程获取，而是直接自己主动释放。网络、多线程服务器常用。</strong></p>
<p>进程若有该机制，将不会产生僵尸进程。<strong>僵尸进程的产生主要是由于进程死后，大部分资源被释放，一点残留资源仍然在系统中，导致内核以为该进程仍然存在。</strong></p>
<p>也可以使用<code>pthread_create</code> 函数的第2个参数来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n =<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread count %d\n"</span>,n);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr; <span class="comment">//通过线程属性来设置游离态</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    pthread_create(&amp;tid,&amp;attr, tfn,<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// pthread_detach(tid); //让线程分离，自动退出，无系统残留资源</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        err = pthread_join(tid, &amp;tret); <span class="comment">//阻塞等待子线程回收</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"--------------err = %d\n"</span>,err);</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"thread %s\n"</span>, strerror(err));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"thread exit code %d\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，线程终止后，其终止状态一直保留到其他线程调用<code>pthread_join</code>获取其状态为止。但是<strong>线程也可以被设置为<code>detach</code>状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。</strong></p>
<h4 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h4><p><strong>杀死（取消）线程， 作用对应于进程中的<code>kill()</code>函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;<span class="comment">//成功返回0,失败返回错误号</span></span><br></pre></td></tr></table></figure>
<p>注意：线程的取消并<strong>不是实时的，而是有一定的延时，需要等待线程到达某一个取消点(检查点，进入内核的契机），所以如果一个线程一直使用系统调用(一直不进内核), cancel就无法杀死该线程</strong></p>
<p>取消点：<strong>线程检查是否被取消，并按请求进行动作的一个位置：通常是一些系统调用</strong><code>create, open , pause, close, read, write...</code>执行命令<code>man 7 pthreads</code>可以查看具备这些取消点的系统调用列表。</p>
<p>可以粗略认为一个系统调用（进入内核）为一个取消点。<strong>如果线程中没有取消点，可以通过调用<code>pthread_testcancel</code>函数自行设置一个取消点。</strong></p>
<p>被取消的线程，退出值定义在linux的<code>pthread</code>库中。常数<code>PTHREAD_CANCELED</code>的值是-1,可在头文件pthread.h中找到定义：<code>#define PTHREAD_CANCELED((void*)-1)</code>。因此<strong>当对一个已经被取消的线程使用<code>pthread_join</code>回收时，得到的返回值为-1。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn1</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 1 returing\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn2</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 2 exiting\n"</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">222</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn3</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printf("thread 3: I'm going to die in 3 seconds...\n"); //取消点</span></span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">666</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span>* tret = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid, &amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 1 exit code = %d\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid, &amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 2 exit code = %d\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn3, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 3 exit code = %d\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">thread 1 returing</span></span><br><span class="line"><span class="comment">thread 1 exit code = 111</span></span><br><span class="line"><span class="comment">thread 2 exiting</span></span><br><span class="line"><span class="comment">thread 2 exit code = 222</span></span><br><span class="line"><span class="comment">thread 3: I'm going to die in 3 seconds...</span></span><br><span class="line"><span class="comment">thread 3 exit code = 666*/</span></span><br></pre></td></tr></table></figure>
<h4 id="pthread-equal"><a href="#pthread-equal" class="headerlink" title="pthread_equal"></a>pthread_equal</h4><p>比较<strong>两个线程ID是否相等</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_eaqul</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>linux下<strong>线程的属性可以根据实际项目需求来设置</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> stuct </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>     etachstate; <span class="comment">//线程的分离状态</span></span><br><span class="line">    <span class="keyword">int</span>     schedpolicy; <span class="comment">//线程的调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span>  <span class="title">schedparam</span>;</span> <span class="comment">//线程的调度参数</span></span><br><span class="line">    <span class="keyword">int</span>     inheritsched; <span class="comment">//线程的继承性</span></span><br><span class="line">    <span class="keyword">int</span>     scope; <span class="comment">//线程的作用域</span></span><br><span class="line">    <span class="keyword">size_t</span>  guardsize; <span class="comment">//线程末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span>     stackaddr_set;<span class="comment">//线程的栈设置</span></span><br><span class="line">    <span class="keyword">void</span>*   stackaddr; <span class="comment">//线程栈的位置</span></span><br><span class="line">    <span class="keyword">size_t</span>  stacksize; <span class="comment">//线程栈的大小</span></span><br><span class="line">&#125;<span class="keyword">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure>
<p><strong>默认情况为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</strong></p>
<p>线程<strong>栈大小查看命令</strong>：<code>ulimit -a</code></p>
<h4 id="线程属性初始化"><a href="#线程属性初始化" class="headerlink" title="线程属性初始化"></a>线程属性初始化</h4><p><strong>应先初始化线程属性，再pthread_create创建线程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>; <span class="comment">//成功返回0,失败返回错误号</span></span><br></pre></td></tr></table></figure>
<p><strong>销毁线程属性所占用的资源</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;<span class="comment">//成功返回0,失败返回错误号</span></span><br></pre></td></tr></table></figure>
<h4 id="线程的分离状态"><a href="#线程的分离状态" class="headerlink" title="线程的分离状态"></a>线程的分离状态</h4><p>调用<code>pthread_detach()</code>函数或者通过属性设置可以使线程分离。<strong>如果一个线程为分离线程，而这个线程又运行非常之快，它很可能在<code>pthread_create</code>函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用<code>pthread_create</code>的线程就得到了错误的线程号。要避免这种情况的发生可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用<code>pthread_cond_timewait</code>函数，让这个线程等待一会，留出足够的时间让函数pthread_create返回</strong>。设置一段等待时间，是在多线程中常用的方法。但注意<strong>不要使用<code>wait()</code>之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设置线程属性:分离或非分离*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span>* attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="comment">/*获取线程属性*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr, <span class="keyword">int</span>* detachstate)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">detachstate取值:</span></span><br><span class="line"><span class="comment">PTHREAD_CREATE_DETACHED</span></span><br><span class="line"><span class="comment">PTHREAD_CREATE_JOINABLE	*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">	<span class="comment">/*初始化属性结构体*/</span></span><br><span class="line">	ret=pthread_attr_init(&amp;attr);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"pthread_attr_init error"</span>,ret);</span><br><span class="line">	<span class="comment">/*给属性结构体添加分离属性*/</span></span><br><span class="line">	pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"pthread_attr_setdetachstate error"</span>,ret);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main:pid=%d,tid=%lu\n"</span>,getpid(),pthread_self());</span><br><span class="line">	<span class="comment">/*创建子线程*/</span></span><br><span class="line">	ret=pthread_create(&amp;tid,&amp;attr,tfn,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"pthread_create error"</span>,ret);</span><br><span class="line">	<span class="comment">/*join试一下,由于线程已经分离了,会出错*/</span></span><br><span class="line">	ret=pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"pthread_join error"</span>,ret);</span><br><span class="line">	<span class="comment">/*销毁线程属性结构体*/</span></span><br><span class="line">	ret=pthread_attr_destroy(&amp;attr);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"pthread_attr_destory error"</span>,ret);</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程的栈地址"><a href="#线程的栈地址" class="headerlink" title="线程的栈地址"></a>线程的栈地址</h4><p><strong>当进程栈空间地址不够用时，指定新建线程使用由<code>malloc</code>分配的空间作为自己的栈空间（各个子线程会均分进程的栈空间, 但是线程的栈空间大小是可以调整的）</strong>。通过<code>pthread_attr_setstack</code>和<code>pthread_attr_getstack</code>两个函数分别设置和获取进程的栈地址。</p>
<h4 id="线程的栈大小"><a href="#线程的栈大小" class="headerlink" title="线程的栈大小"></a>线程的栈大小</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_atrt_getstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> *stacksize)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h4 id="同步概念"><a href="#同步概念" class="headerlink" title="同步概念"></a>同步概念</h4><p>同步，即同时起步，协调一致。不同的对象，对同步的理解方式不同。例如：设备同步指在两个设备之间规定一个共同的时间参考。 数据库同步指让两个或多个数据库内容保持一致，或者按需要部分保持一致。文件一致指让两个或多个文件夹中的文件保持一致。</p>
<h4 id="线程同步-1"><a href="#线程同步-1" class="headerlink" title="线程同步"></a>线程同步</h4><p><strong>一个线程发出某一功能调用时，再没有得到结果之前，该调用不返回。同时其他线程为保证数据的一致性，不能调用该功能。</strong></p>
<p>避免产生<strong>与时间有关的错误</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/31/linux-%E7%B3%BB%E7%BB%9F-09%E4%BC%9A%E8%AF%9D%E5%8F%8A%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/31/linux-%E7%B3%BB%E7%BB%9F-09%E4%BC%9A%E8%AF%9D%E5%8F%8A%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">linux系统-会话及守护进程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-31 15:12:40" itemprop="dateCreated datePublished" datetime="2020-03-31T15:12:40+08:00">2020-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-26 16:04:14" itemprop="dateModified" datetime="2021-03-26T16:04:14+08:00">2021-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>多个<strong>进程组的集合</strong>。</p>
<p>创建一个会话需要注意的点：</p>
<ul>
<li>调用进程不能是进程组组长，该进程变成会话首进程(<code>session header</code>)「</li>
<li>该进程成为一个新进程组的组长进程</li>
<li>需要<code>root</code>权限(ubuntu不需要)</li>
<li><strong>新会话丢弃原有的控制终端，该会话没有控制终端</strong></li>
<li>该调用进程是组长进程，则出错返回</li>
<li>建立新会话时，先调用<code>fork</code>,父进程终止，子进程调用<code>setsid</code></li>
</ul>
<p><code>setsid</code>函数:</p>
<p>创建一个会话, 并以自己的ID设置进程组ID, 同时也是新会话的ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//成功返回调用进程的会话ID, 失败返回-1并设置errno</span></span><br></pre></td></tr></table></figure>
<p><strong>调用了<code>setsid</code>函数的进程, 既是新的会长, 也是新的组长</strong></p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>Daemon(精灵)进程，是Linux中的<strong>后台服务进程</strong>，<strong>通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件</strong>。一般采用d结尾的名字。</p>
<p>Linux后台的一些系统服务进程，<strong>没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行</strong>。这些进程属于守护进程。如：预读入缓输出机制的实现，<code>ftp</code>服务器，<code>nfs</code>服务器等。</p>
<p>创建守护进程，最关键的步骤：调用<code>setsid</code>函数创建一个新的Session,并成为Session Leader.</p>
<h4 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h4><ul>
<li><p>创建子进程, 父进程退出: 所有工作在子进程中形式上脱离了控制终端</p>
</li>
<li><p><strong>在子进程中创建新会话: <code>setsid()</code>函数, 使子进程完全独立出来, 脱离控制</strong></p>
</li>
<li><p><strong>改变当前工作目录位置: <code>chdir()</code>函数, 防止占用可卸载的文件系统</strong></p>
</li>
<li><p>重设<strong>文件权限掩码</strong>: <code>umask()</code>函数, <strong>防止继承的文件创建屏蔽字拒绝某些权限</strong></p>
</li>
<li><p>关闭文件描述符: <strong>继承的打开文件不会用到, 浪费系统资源, 无法卸载</strong></p>
</li>
<li><p>开始执行守护进程核心工作</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建守护进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*创建新会话*/</span></span><br><span class="line">	pid=setsid();</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"setsid error"</span>);</span><br><span class="line"></span><br><span class="line">	ret=chdir(<span class="string">"/home/dongshifu"</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"chdir error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*重设文件权限掩码*/</span></span><br><span class="line">	umask(<span class="number">0022</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*关闭标准输入*/</span></span><br><span class="line">	<span class="built_in">close</span>(STDIN_FILENO);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*将标准输出和标准出错重定向到文件黑洞*/</span></span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">"/dev/null"</span>,O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"open error"</span>);</span><br><span class="line">	dup2(fd,STDOUT_FILENO);</span><br><span class="line">	dup2(fd,STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*模拟业务逻辑*/</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/28/linux-%E7%B3%BB%E7%BB%9F-08%E4%BF%A1%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/28/linux-%E7%B3%BB%E7%BB%9F-08%E4%BF%A1%E5%8F%B7/" class="post-title-link" itemprop="url">linux系统-信号</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-28 16:54:01" itemprop="dateCreated datePublished" datetime="2020-03-28T16:54:01+08:00">2020-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-26 15:33:59" itemprop="dateModified" datetime="2021-03-26T15:33:59+08:00">2021-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="基本概念及机制"><a href="#基本概念及机制" class="headerlink" title="基本概念及机制"></a>基本概念及机制</h4><p>信号的共性:</p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足特性条件才能发送</li>
</ul>
<p>特质：A给B发送信号，B收到信号之前执行自己的代码，<strong>收到信号后，不管执行到程序的什么位置，都要暂停运行去处理信号，处理完毕之后再继续执行。</strong>与硬件中断类似——异步模式。但信号是软件层面上的实现的中断，早期被称为”软中断”。</p>
<p>信号的特质：由于<strong>信号通过软件方法实现，其实现手段导致信号有很强的延时性</strong>。但对于用户来说，这个延迟时间非常短，不易察觉。</p>
<p><strong>所有信号的产生和处理, 都是由内核完成的</strong>。</p>
<h4 id="与信号相关的事件和状态"><a href="#与信号相关的事件和状态" class="headerlink" title="与信号相关的事件和状态"></a>与信号相关的事件和状态</h4><p>产生信号:</p>
<ul>
<li><p><strong>按键</strong>产生:<code>Ctrl+c, Ctrl+z, Ctrl+\</code></p>
</li>
<li><p><strong>系统调用</strong>产生:<code>kill, raise, abort</code></p>
</li>
<li><p><strong>软件条件产生</strong>:定时器<code>alarm</code></p>
</li>
<li><p><strong>硬件异常</strong>产生:非法访问内存(段错误), 除0(浮点数例外), 内存对齐错误(总线错误);</p>
</li>
<li><p><strong>命令</strong>产生:<code>kill</code>命令</p>
</li>
</ul>
<p>递达: 内核发出的信号<strong>递送并且到达</strong>进程</p>
<p>未决: 产生和递达之间的状态, 主要由于<strong>阻塞(屏蔽)导致该状态</strong></p>
<p>信号的处理方式:</p>
<ul>
<li><p>执行<strong>默认动作</strong></p>
</li>
<li><p><strong>丢弃</strong>(忽略)</p>
</li>
<li><p><strong>捕捉</strong>(调用户处理函数)</p>
</li>
</ul>
<h4 id="信号屏蔽字和未决信号集"><a href="#信号屏蔽字和未决信号集" class="headerlink" title="信号屏蔽字和未决信号集"></a>信号屏蔽字和未决信号集</h4><p>Linux内核的进程控制块PCB是一个结构体，<code>task_struct</code>除了包含进程<code>id</code>，状态，工作目录，用户<code>id</code>，组<code>id</code>，文件描述符，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。</p>
<p>阻塞态：用<strong>阻塞信号集（信号屏蔽字）</strong>来描述</p>
<p><code>PCB</code>中<strong>阻塞信号集影响未决信号集</strong></p>
<p>阻塞信号集（信号屏蔽字）<strong>：将某些信号加入集合，对他们设置屏蔽，当屏蔽<code>x</code>信号后，再收到该信号，该信号的处理将推后（解除屏蔽字后）</strong></p>
<p>未决信号集：</p>
<ul>
<li>信号产生，<strong>未决信号集中描述该信号的位立刻翻转为1,表示信号处于未决状态，当信号被处理后，对应位翻转回为0，</strong>这一时刻往往非常短暂。</li>
<li><strong>信号产生后由于某些原因（主要是阻塞）不能抵达</strong>。这类信号的集合称为未决信号集。在屏蔽解除前，信号一直处于未决状态。</li>
</ul>
<h4 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h4><ul>
<li><p>编号：信号有自己的编号，不存在为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号）。34-64为实时信号，驱动编程与硬件相关，名字上区别不大。而前32个名字各不相同。</p>
</li>
<li><p>名称</p>
</li>
<li><p>事件</p>
</li>
<li><p>默认处理动作</p>
<ul>
<li>Term：终止进程</li>
<li>Ign：<strong>忽略</strong>信号（默认即时对该种信号忽略操作）</li>
<li>Core：<strong>终止</strong>进程，生成Core文件（查验进程死亡原因，用于gdb调试）</li>
<li>Stop：停止（<strong>暂停</strong>）进程</li>
<li>Cont：<strong>继续运行</strong>进程</li>
</ul>
</li>
</ul>
<p><code>man 7 signal</code>可以查看帮助文档</p>
<p><strong>特别强调：9)SIGKILL和19)SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其其设置为阻塞。</strong></p>
<p>只有每个信号所对应的事件发生了, 该信号才会被递送(但不一定递达), 不应该乱发信号</p>
<h4 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h4><p>给指定进程发送指定信号（不一定杀死）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;<span class="comment">//成功：0， 失败：-1（ID非法，普通用户杀init进程等权级问题），设置errno</span></span><br><span class="line"><span class="comment">//sig:不推荐使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致</span></span><br><span class="line"><span class="comment">//pid &gt;0; //发送信号给指定的进程</span></span><br><span class="line"><span class="comment">//pid = 0; //发送信号给与调用kill函数进程属于同一进程组的所有进程</span></span><br><span class="line"><span class="comment">//pid &lt; 0;//取|pid|发给对应进程组:kill -9 -10698 :杀死10698进程组的所有进程;</span></span><br><span class="line"><span class="comment">//pid = -1;//发送给进程有权限发送的系统中所有进程</span></span><br></pre></td></tr></table></figure>
<p>进程组：每个进程都属于一个进程组，<strong>进程组是一个或多个进程集合，它们互相关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组<code>ID</code>与进程组长<code>ID</code>相同。</strong></p>
<p>权限保护：<strong><code>super</code>用户（<code>root</code>）可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。<code>kill -9</code> (<code>root</code>用户的<code>pid</code>)是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。只能向自己创建的进程发送信号，普通用户基本规则是：发送者实际或有效用户<code>ID == 接收者实际或有效用户ID</code>。</strong></p>
<h4 id="raise和abort函数"><a href="#raise和abort函数" class="headerlink" title="raise和abort函数"></a>raise和abort函数</h4><p><code>raise</code>函数：给当前进程发送指定信号（自己给自己发）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">raise(signo) == kill(getpid(), signo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;<span class="comment">//成功：0</span></span><br></pre></td></tr></table></figure>
<p><code>abort</code>函数：给自己发送异常终止信号。<code>SIGABRT</code>信号，终止并产生core文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//该函数无返回</span></span><br></pre></td></tr></table></figure>
<h4 id="软件条件产生信号（定时产生信号）"><a href="#软件条件产生信号（定时产生信号）" class="headerlink" title="软件条件产生信号（定时产生信号）"></a>软件条件产生信号（定时产生信号）</h4><p><code>alarm</code>函数：设置定时器（闹钟），在指定<code>seconds</code>后，内核会给当前进程发送<code>14)SIGALRM</code>信号。<strong>进程收到该信号，默认动作终止</strong>。</p>
<p><strong>每个进程都有且只有唯一个定时器。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;<span class="comment">//返回0或剩余的秒数，无失败</span></span><br></pre></td></tr></table></figure>
<p>常用：取消定时器<code>alarm(0)</code>,返回旧闹钟余下秒数</p>
<p><strong>定时，与进程无关（自然定时法）！无论进程处于何种状态（就绪、运行、挂起、终止、僵尸…)，<code>alarm</code>都计时</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试一秒钟数多少个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用time命令测试程序运行时间</span></span><br><span class="line"><span class="comment">//real    0m1.003s</span></span><br><span class="line"><span class="comment">//user    0m0.074s</span></span><br><span class="line"><span class="comment">//sys     0m0.217s</span></span><br></pre></td></tr></table></figure>
<p><code>time ./alarm</code>可以统计<code>alarm</code>的运算时间。</p>
<p>使用<code>time</code>命令查看程序执行的时间。<strong>程序运行的瓶颈在<code>IO</code>，优化程序，首先优化<code>IO</code></strong></p>
<p><strong>实际执行时间 = 系统时间+用户时间+等待时间</strong></p>
<p><code>setitimer</code>函数：<strong>设置定时器（闹钟），可以替代<code>alarm</code>函数，精度微秒<code>（us）</code>，可以实现周期定时</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getitimer</span><span class="params">(<span class="keyword">int</span> which, struct itimerval *curr_value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">const</span> struct itimerval *new_value, struct itimerval *old_value)</span></span>;</span><br><span class="line"><span class="comment">//参数which:指定定时方式。</span></span><br><span class="line"><span class="comment">//自然定时：ITIMER_REAL:14) SIGLARM 计算自然定时</span></span><br><span class="line"><span class="comment">//虚拟空间计时（用户空间，只计算进程占用CPU的时间）：ITIMER_VIRTUAL 26) SIGVIRTUAL 只计算进程占用cpu时间</span></span><br><span class="line"><span class="comment">//运行时计时（用户+内核）： ITIMER_PROF 27)SIGPROF 计算cpu及执行系统调用的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*精确到us的时间结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="keyword">time_t</span>	tv_sec;        		 <span class="comment">/* seconds */</span></span><br><span class="line">	<span class="keyword">suseconds_t</span>	tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><p><code>it_interva</code>l :用来设定<strong>两次定时任务之间间隔的时间</strong></p>
</li>
<li><p><code>it_value</code>:<strong>定时的时长</strong></p>
</li>
<li><p>两个参数都设置为0,即清0操作</p>
</li>
</ul>
<p>signal捕捉信号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*信号捕捉回调函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello signal\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*it为传入参数,进行初始化*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">    <span class="comment">//信号捕捉函数是一个回调函数</span></span><br><span class="line">    signal(SIGALRM, myfun);<span class="comment">//注册SIGALRM信号的捕捉处理函数，捕捉由内核完成</span></span><br><span class="line"></span><br><span class="line">    it.it_value.tv_sec = <span class="number">5</span>;</span><br><span class="line">    it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    it.it_interval.tv_sec = <span class="number">3</span>;</span><br><span class="line">    it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(setitimer(ITIMER_REAL,&amp;it, &amp;oldit) == <span class="number">-1</span>) <span class="comment">//自然定时</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"settimer error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*手动让程序阻塞*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h3><p>内核通过<strong>读取未决信号集来判断信号是否应该被处理，信号屏蔽字<code>mask</code>可以影响未决信集</strong>。可以在应用程序中<strong>自定义<code>set</code>来改变<code>mask</code>以达到屏蔽指定信号的目的。</strong></p>
<h4 id="操作信号集的若干步骤"><a href="#操作信号集的若干步骤" class="headerlink" title="操作信号集的若干步骤"></a>操作信号集的若干步骤</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建一个自定义信号集*/</span></span><br><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"><span class="comment">/*清空自定义信号集*/</span></span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">/*向自定义信号集添加信号*/</span></span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"><span class="comment">/*用自定义信号集操作内核信号集*/</span></span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">/*查看未决信号集*/</span></span><br><span class="line">sigpending(&amp;myset);</span><br></pre></td></tr></table></figure>
<h4 id="信号集设定"><a href="#信号集设定" class="headerlink" title="信号集设定"></a>信号集设定</h4><p><code>sigset_t</code> 类型的本质是<strong>位图</strong>。但不应该直接使用位操作，而应该使用下列函数，<strong>保证跨系统操作有效</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>; <span class="comment">//typedef unsigned long sigset_t</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//将某个信号集清0,成功0,失败-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//将某个信号集置1, 成功0,失败-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;<span class="comment">//将某个信号加入信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;<span class="comment">//将某个信号清出信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;<span class="comment">//判断某个信号是否在信号集中，返回值：在集合：1,不在集合：0</span></span><br></pre></td></tr></table></figure>
<h4 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h4><p>用来<strong>屏蔽信号、解除屏蔽</strong>也使用该函数。其<strong>本质为读取或修改进程的信号屏蔽字(<code>PCB</code>中).</strong></p>
<p>注意：<strong>屏蔽信号只是将信号处理延后执行（延至解除屏蔽），而忽略表示将信号丢弃处理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> sigset *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;<span class="comment">//成功，0,失败-1,设置errno</span></span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//how参数取值：假设当前的信号屏蔽字为mask</span></span><br><span class="line"><span class="comment">//1.SIG_BLOCK:当how设置为此值，set表示需要屏蔽的信号。相当于mask = mask|set(设置阻塞, set表示需要屏蔽的信号)</span></span><br><span class="line"><span class="comment">//2.SIG_UNBLOCK:当how设置为此值，set表示需要解除屏蔽的信号，相当于mask = mask&amp;~set(设置非阻塞, set表示需要解除屏蔽的信号;)</span></span><br><span class="line"><span class="comment">//3.SIG_SETMASK:set表示用于替代原始屏蔽集的新屏蔽集：相当于mask = set。若调用sigprocmask解除了对当前若干个信号的阻塞。则在sigprocmask返回前，至少将其中一个信号递达。(用set替换原始屏蔽集)</span></span><br><span class="line"><span class="comment">//set：传入参数，是一个位图，set中哪个位置为1,就表示当前进程屏蔽哪个信号</span></span><br><span class="line"><span class="comment">//oldset:传出参数，保留旧的信号屏蔽集</span></span><br></pre></td></tr></table></figure>
<h4 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h4><p><strong>读取当前进程的未决信号集</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(sigset *<span class="built_in">set</span>)</span> </span>;<span class="comment">//set传出参数。</span></span><br><span class="line"><span class="comment">//返回：成功:0，失败-1,设置errno</span></span><br></pre></td></tr></table></figure>
<p>打印未决信号集：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printped</span><span class="params">(<span class="keyword">sigset_t</span> *ped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;<span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sigismember(ped,i) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> myset, ped, oldset; <span class="comment">//自定义集合类型</span></span><br><span class="line">    sigemptyset(&amp;myset);	<span class="comment">/*清空自定义信号集*/</span></span><br><span class="line">    sigaddset(&amp;myset,SIGQUIT);<span class="comment">/*向自定义信号集添加信号*/</span></span><br><span class="line">    sigaddset(&amp;myset,SIGINT); <span class="comment">//程序终止信号，通常Ctrl+c</span></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;myset, &amp;oldset);<span class="comment">/*用自定义信号集操作内核信号集*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sigpending(&amp;ped);</span><br><span class="line">        printped(&amp;ped);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简易信号捕捉"><a href="#简易信号捕捉" class="headerlink" title="简易信号捕捉"></a>简易信号捕捉</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catchsigint</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------catch\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sighandler_t</span> handler;</span><br><span class="line">    handler = signal(SIGINT,catchsigint);</span><br><span class="line">    <span class="keyword">if</span>(handler == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"signal error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sigaction函数注册捕捉"><a href="#sigaction函数注册捕捉" class="headerlink" title="sigaction函数注册捕捉"></a>sigaction函数注册捕捉</h4><p><strong>sigaction函数的功能是检查或修改与指定信号相关联的处理动作（可同时两种操作）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction* act, struct sigaction* oldact)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);	<span class="comment">//不用</span></span><br><span class="line">	<span class="keyword">sigset_t</span>   sa_mask;		<span class="comment">//只工作于信号捕捉函数执行期间,相当于中断屏蔽</span></span><br><span class="line">	<span class="keyword">int</span>        sa_flags;	<span class="comment">//本信号默认屏蔽</span></span><br><span class="line">	<span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);			<span class="comment">//废弃</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">docatch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d signal is catched\n"</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = docatch;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaddset(&amp;act.sa_mask,SIGQUIT);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;<span class="comment">//默认属性，信号捕捉函数执行期间自动屏蔽本信号</span></span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGINT,&amp;act,<span class="literal">NULL</span>); <span class="comment">//程序终止信号</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a>信号捕捉特性</h4><ul>
<li><p>进程正常运行时，默认<strong>PCB中有一个信号屏蔽字</strong>，假定为<code>x</code>，它<strong>决定了进程自动屏蔽哪些信号</strong>。当注册了某个信号捕捉函数，捕捉到该信号之后，要调用该函数。而该函数有可能执行很长时间，<strong>在这期间所屏蔽的信号不能由<code>x</code>来指定。而是用<code>sa_mask</code>来指定。调用完信号处理函数，再次恢复为<code>x</code></strong>(<strong>捕捉函数执行期间, 信号屏蔽字由<code>mask</code>变为<code>sigaction</code>结构体中的<code>sa_mask</code>, 捕捉函数执行结束后, 恢复回<code>mask</code></strong>)。</p>
</li>
<li><p><code>xxx</code>信号捕捉函数执行期间，<code>xxx</code>信号自动被屏蔽(捕捉函数执行期间, 本信号自动被屏蔽(<code>sa_flags=0</code>);)</p>
</li>
<li>阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）(<strong>捕捉函数执行期间, 若被屏蔽信号多次发送, 解除屏蔽后只响应一次</strong>)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">docatch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d signal is catched\n"</span>,signo);</span><br><span class="line">    sleep(<span class="number">10</span>); <span class="comment">//模拟信号捕捉函数执行时间很长</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"finish\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = docatch;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaddset(&amp;act.sa_mask,SIGQUIT);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;<span class="comment">//默认属性，信号捕捉函数执行期间自动屏蔽本信号</span></span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGINT,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内核实现信号捕捉过程："><a href="#内核实现信号捕捉过程：" class="headerlink" title="内核实现信号捕捉过程："></a>内核实现信号捕捉过程：</h4><p><img src="https://api2.mubu.com/v3/document_image/59beec01-cbf6-47bc-b417-05caf5134bab-11197877.jpg" alt="signal_catch"></p>
<p>为什么执行完信号处理函数后要再次进入内核?<strong>因为信号处理函数是内核调用的, 函数执行完毕后要返回给调用者。</strong></p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><h4 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a>pause函数</h4><p>调用该函数可以<strong>造成进程主动挂起，等待信号唤醒</strong>。<strong>调用该系统调用的进程将处于阻塞状态（主动放弃<code>cpu</code>）直到信号递达将其唤醒。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span> </span>;<span class="comment">//返回值：-1并设置errno为EINTR</span></span><br><span class="line"><span class="comment">/*返回值：</span></span><br><span class="line"><span class="comment">如果信号的默认处理动作为终止进程，则进程终止，pause函数没有机会返回</span></span><br><span class="line"><span class="comment">如果信号的默认处理动作是忽略，进程继续处于挂起状态，pause函数不返回</span></span><br><span class="line"><span class="comment">如果信号的处理动作是捕捉，则调用完信号处理函数后，pause返回-1。errno设置为EINTR，表示信号被中断</span></span><br><span class="line"><span class="comment">pause收到的信号不能被屏蔽，如果被屏蔽，那么puase就不能被唤醒</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>使用<code>pause</code>和<code>alarm</code>来实现<code>sleep</code>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_sigalrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"catched\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    act.sa_handler = catch_sigalrm;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGALRM,&amp;act,&amp;oldact);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(seconds);</span><br><span class="line">    ret = pause();<span class="comment">//主动挂起，等待信号</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pause success\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = alarm(<span class="number">0</span>);<span class="comment">//闹钟清0</span></span><br><span class="line">    sigaction(SIGALRM,&amp;oldact,<span class="literal">NULL</span>);<span class="comment">//恢复SIGALRM信号旧有的处理方式</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mysleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----------\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时序竞态"><a href="#时序竞态" class="headerlink" title="时序竞态"></a>时序竞态</h4><p>时序问题分析：</p>
<p>借助<code>pause</code>和<code>alarm</code>实现的<code>mysleep</code>函数，设想如下时序：</p>
<ul>
<li>注册<code>SIGALRM</code>信号处理函数（<code>sigaction...</code>）</li>
<li>调用<code>alarm(1)</code>函数设定闹钟1秒</li>
<li>函数调用刚结束，开始倒计时1秒，当前进程失去cpu，内核调度优先级高的进程（多个）取代当前进程，当前进程无法获得cpu，进入<strong>就绪态等待cpu</strong></li>
<li><strong>1秒后，闹钟超时，内核向当前进程发送<code>SIGALARM</code>信号（自然定时法，与进程状态无关），高优先级进程尚未执行完，当前进程仍处于就绪态，信号无法处理(未决)</strong></li>
<li>优先级高的进程执行完，当前进程获得cpu资源，内核调度回当前进程执行。<code>SIGALRM</code>信号递达，信号设置捕捉，执行处理函数<code>catch_sigalrm</code></li>
<li><strong>信号处理函数执行结束，返回当前进程主控流程，<code>pause()</code>被调用挂起等待。（欲等待<code>alarm</code>函数发送的<code>SIGALRM</code>信号将自己唤醒）</strong></li>
<li><strong><code>SIGALRM</code>信号已经处理完毕，<code>pause</code>不会等到。</strong></li>
</ul>
<h4 id="解决时序问题"><a href="#解决时序问题" class="headerlink" title="解决时序问题"></a>解决时序问题</h4><p>可以通过设置屏蔽<code>SIGALRM</code>的方法来控制程序执行逻辑，<strong>但无论如何设置，程序都有可能在“解除信号屏蔽”与“挂起等待信号”这两个操作间隙失去cpu资源</strong>。除非将这两步骤合并成一个“<strong>原子操作</strong>”，<strong><code>sigsuspend</code>函数具备这个功能。在对时序要求严格的场合下都应该使用<code>sigsuspend</code>替换<code>pause</code>。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *mask)</span></span>; <span class="comment">//挂起等待信号</span></span><br></pre></td></tr></table></figure>
<p><strong><code>sigsuspend</code>函数调用期间，进程信号屏蔽字由其参数<code>mask</code>指定。</strong></p>
<p><strong>程序执行过程的信号屏蔽字由<code>sigaction.sa_mask</code>决定，但在执行<code>sigsuspend</code>期间由传入的<code>mask</code>决定。</strong></p>
<p><strong>可将某个信号（如<code>SIGALRM</code>）从临时屏蔽字<code>mask</code>中删除，这样在调用<code>sigsuspend</code>时将解除对该信号的屏蔽，然后挂起等待，当<code>sigsubpend</code>返回时，进程的信号屏蔽字恢复为原来的值。如果原来对该信号是屏蔽态，<code>sigsuspend</code>函数返回后仍然屏蔽该信号字。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> newmask, oldmask, suspmask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为SIGALRM设置捕捉函数，一个空函数</span></span><br><span class="line">    newact.sa_handler = catch_sigalrm;</span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGALRM,&amp;newact, &amp;oldact);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置阻塞信号集，阻塞SIGALRM信号</span></span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask, SIGALRM);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask); <span class="comment">//信号屏蔽字 mask</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时n秒，到时可以产生SIGALRM信号</span></span><br><span class="line">    alarm(seconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造一个调用sigsuspend临时有效的阻塞信号集，</span></span><br><span class="line">    <span class="comment">//在临时阻塞信号集里解除SIGALRM的阻塞</span></span><br><span class="line">    suspmask = oldmask; <span class="comment">//SIGALRM没有被屏蔽</span></span><br><span class="line">    sigdelset(&amp;suspmask, SIGALRM); <span class="comment">//原来屏蔽字中可能有屏蔽</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//sigsuspend调用期间，采用临时阻塞信号集suspmask替换原有阻塞信号集合</span></span><br><span class="line">    <span class="comment">//这个信号集中不包含SIGALRM喜好，同时挂起等待</span></span><br><span class="line">    <span class="comment">//当sigsuspend被信号唤醒返回时，恢复原来的阻塞信号集</span></span><br><span class="line">    sigsuspend(&amp;suspmask);<span class="comment">//原子操作</span></span><br><span class="line">    unslept = alarm(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复SIGALRM原有的处理动作，呼应前面注释</span></span><br><span class="line">    sigaction(SIGALRM,&amp;oldact,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解除对SIGALRM的阻塞，呼应前面注释</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (unslept);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>竞态条件跟系统负载有很紧密的的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</strong></p>
<p>不可靠由其实现原理导致。<strong>信号是通过软件方式实现的（与内核调度高度依赖，延时性强），每次系统调用结束后，或中断处理结束后，需要扫描PCB中的未决信号集来判断是否应该处理某个信号，当系统负载过重时，会出现时序混乱</strong>。</p>
<p>这种意外情况只能出现在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补，且由于该错误不具规律性，后期捕捉和重现十分困难。</p>
<h4 id="可重入函数，不可重入函数"><a href="#可重入函数，不可重入函数" class="headerlink" title="可重入函数，不可重入函数"></a>可重入函数，不可重入函数</h4><p>一个函数在被调用执行期间(尚未调用结束)，由于某种时序又被重复调用，称为“重入”,根据函数实现的方法可分为”可重入函数”和“不可重入函数”。</p>
<p>注意事项：</p>
<ul>
<li>定义可重入函数，函数内部不能含有全局变量及<code>static</code>变量，不能使用<code>malloc,free</code></li>
<li>信号捕捉函数应设计为可重入函数</li>
<li>信号处理程序可以调用的可重入函数可参阅<code>man 7 signal</code></li>
</ul>
<h3 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a><code>SIGCHLD</code>信号</h3><h4 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h4><ul>
<li><strong>子进程终止</strong>时</li>
<li>子进程<strong>收到<code>SIGSTOP</code>信号停止</strong>时</li>
<li>子进程<strong>处在停止态，接受到<code>SIGCONT</code>后唤醒</strong>时</li>
</ul>
<h4 id="借助SIGCHLD信号回收子进程"><a href="#借助SIGCHLD信号回收子进程" class="headerlink" title="借助SIGCHLD信号回收子进程"></a>借助<code>SIGCHLD</code>信号回收子进程</h4><p>子进程结束运行，其<strong>父进程会收到<code>SIGCHLD</code>信号，该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收。</strong></p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((pid = waitpid(<span class="number">0</span>, &amp;status,WNOHANG))&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) <span class="comment">//WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"--------------child %d exit %d\n"</span>,pid,WEXITSTATUS(status)); <span class="comment">//当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)退出，WEXITSTATUS(status)就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。请注意，如果进程不是正常退出的，也就是说，WIFEXITED返回0，这个值就毫无意义</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status)) <span class="comment">// WIFSIGNALED(status)为非0 表明进程异常终止</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child %d cancle signal %d\n"</span>,pid, WTERMSIG(status)); <span class="comment">//通过WTERMSIG(status)获取使得进程退出的信号编号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//阻塞SIGCHLD</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sys_err(<span class="string">"fork"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">//10个子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child ID %d\n"</span>,getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//SIGCHLD阻塞</span></span><br><span class="line">        struct sigaction act;</span><br><span class="line">        act.sa_handler = do_sig_child;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//NULL解除对SIGCHLD的阻塞</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Parent ID %d\n"</span>,getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h4><p>系统调用可以分为两种：慢速系统调用和其他系统调用。</p>
<ul>
<li>慢速系统调用：<strong>可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就会被中断，</strong>不再继续执行(早期)。也可以设定系统调用是否重启。如<code>read、write、pause、wait...</code></li>
<li>其他系统调用：<code>getpid、getppid、fork</code></li>
</ul>
<p>结合<code>pause</code>,回顾慢速系统调用：</p>
<p>慢速系统调用被中断的相关行为。实际上就是<code>pause</code>的行为，如read:</p>
<ul>
<li>想中断<code>pause</code>，信号不能被屏蔽</li>
<li>信号的处理方式必须是捕捉（默认、忽略都不可以）</li>
<li>中断后返回-1,设置<code>errno</code>为<code>EINTR</code>(表示被信号中断)</li>
</ul>
<p>可以修改<code>sa_flags</code>参数来设置被信号中断后系统调用是否重启。<code>SA_INTERRURT</code>不重启，<code>SA_RESTART</code>重启。</p>
<p><code>sa_flags</code>还有很多可选参数，适用于不同情况。如：捕捉到信号后，在执行捕捉信号期间，不希望自动阻塞该信号，可将<code>sa_flags</code>设置为<code>SA_NODEFER</code>,除非<code>sa_mask</code>中包含该信号。</p>
<h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><p><strong>所有输入输出设备总称。</strong></p>
<p>终端启动流程：<code>init-&gt;fork-&gt;exec-&gt;getty</code>-&gt;用户输入帐号-&gt;<code>login</code>-&gt;输入密码-&gt;<code>exec</code>-&gt;<code>bash</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/27/linux-%E7%B3%BB%E7%BB%9F-07%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/27/linux-%E7%B3%BB%E7%BB%9F-07%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">linux系统-进程间通信</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-27 22:21:59" itemprop="dateCreated datePublished" datetime="2020-03-27T22:21:59+08:00">2020-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 16:54:55" itemprop="dateModified" datetime="2021-03-25T16:54:55+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="进程间通信常见方式"><a href="#进程间通信常见方式" class="headerlink" title="进程间通信常见方式"></a>进程间通信常见方式</h3><p><strong>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷贝到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信(<code>IPC,Inter Process Communication</code>).</strong></p>
<p>在进程间完成数据传递需要<strong>借助操作系统提供特殊的方法</strong>，如：文件、管道、信号、内存共享、消息队列、套接字、命名管道等。常用的进程间通信方式有：</p>
<ul>
<li>管道（使用最简单）<ul>
<li><code>pipe</code></li>
<li>管道的读写行为</li>
<li><code>fifo</code><ul>
<li>用于<strong>非血缘关系进程间通信</strong></li>
</ul>
</li>
</ul>
</li>
<li>信号（开销最小），<strong>只能携带固定的少量信息</strong></li>
<li>共享映射区<ul>
<li><code>mmap</code></li>
<li>函数的参数使用注意事项</li>
<li>用于<strong>非血缘关系的进程通信</strong></li>
</ul>
</li>
<li>本地套接字（最稳定）</li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>管道是一种最基本的<code>IPC</code>机制，<strong>作用于有血缘关系的进程之间，完成数据传递</strong>。调用<code>pipe</code>系统函数即可创建一个管道。有如下特质：</p>
<ul>
<li>其本质是一个<strong>伪文件</strong>（实为<strong>内核缓冲区</strong>）</li>
<li>有<strong>两个文件描述符引用</strong>，一个表示<strong>读端</strong>，一个表示<strong>写端</strong></li>
<li><strong>规定数据从管道的写端流入管道，从读端流出</strong></li>
</ul>
<p>管道的原理：管道实为内核使用<strong>环形队列机</strong>制，借助<strong>内核缓冲区</strong>(4K)实现。</p>
<p>管道的局限性：</p>
<ul>
<li>数据<strong>不能自己读自己写</strong></li>
<li><strong>数据一旦被读走，便不在管道中存在，不可反复读取</strong></li>
<li>由于管道采用<strong>半双工通信</strong>方式。因此数据<strong>只能在一个方向上流动</strong></li>
<li><strong>只能在有公共祖先的进程间使用管道</strong></li>
</ul>
<h4 id="管道使用方法"><a href="#管道使用方法" class="headerlink" title="管道使用方法"></a>管道使用方法</h4><p><code>pipe</code>函数: <strong>创建并打开</strong>管道。</p>
<p>函数调用成功返回<code>r/w</code>两个文件描述符，无需<code>open</code>,但需手动<code>close</code>。规定：<code>fd[0] :r, fd[1]:w</code>,  <strong>类似于0对应标准输入，1对应标准输出</strong>。<strong>向管道文件读写数据其实是在读写内核缓冲区。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*pipefd[0]-读端;</span></span><br><span class="line"><span class="comment">pipefd[1]-写端;</span></span><br><span class="line"><span class="comment">成功返回0, 失败返回-1并设置errno;*/</span></span><br></pre></td></tr></table></figure>
<p>刚<code>fork</code>完成时<strong>父进程关闭读端，子进程关闭写端，此时数据能在<code>pipe</code>中单向流动，父子进程能够完成通信</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span>* str=<span class="string">"loveyou\n"</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="comment">/*创建管道,文件描述符保存在数组里*/</span></span><br><span class="line">	ret=pipe(pipefd);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"pipe error"</span>);</span><br><span class="line"></span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">close</span>(pipefd[<span class="number">0</span>]);						<span class="comment">//父进程关闭读端</span></span><br><span class="line">		<span class="built_in">write</span>(pipefd[<span class="number">1</span>],str,<span class="keyword">sizeof</span>(str));		<span class="comment">//向管道中写入数据</span></span><br><span class="line">		<span class="built_in">close</span>(pipefd[<span class="number">1</span>]);						<span class="comment">//父进程关闭写端</span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">close</span>(pipefd[<span class="number">1</span>]);						<span class="comment">//子进程关闭写端</span></span><br><span class="line">		ret=<span class="built_in">read</span>(pipefd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));	<span class="comment">//从管道中读取数据</span></span><br><span class="line">		<span class="built_in">write</span>(STDOUT_FILENO,buf,ret);			<span class="comment">//写到标准输出打印</span></span><br><span class="line">		<span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="管道读写行为"><a href="#管道读写行为" class="headerlink" title="管道读写行为"></a>管道读写行为</h4><ul>
<li>读管道<ul>
<li><strong>管道中有数据：<code>read</code>返回实际读到的字节数</strong></li>
<li>管道中无数据：<ul>
<li><strong>写端全关闭：read返回0</strong></li>
<li><strong>写端没有被全部关闭</strong>（仍有写端打开）, <strong><code>read</code>阻塞等待(不久的将来可能会有数据抵达, 此时会让出CPU</strong></li>
</ul>
</li>
</ul>
</li>
<li>写管道<ul>
<li><strong>管道读端全部被关闭, 进程异常终止</strong>(也可以捕捉<code>SIGPIPE</code>信号, 使进程不终止)</li>
<li>有读端打开<ul>
<li>管道未满：<strong>写数据，<code>write</code>将数据写入，返回写入字节数</strong></li>
<li>管道已满，<code>write</code>阻塞（少见）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>获取管道缓冲区大小： <code>ulimit -a</code></p>
<p><strong>父子进程</strong>通信练习：实现 <code>ls | wc -l</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要使用exec(), dup2(), pipe()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret=pipe(fd);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"pipe error"</span>);</span><br><span class="line"></span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*父进程先读管道,如果子进程还没起来,他就会阻塞,这样子进程就会先于父进程结束*/</span></span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">		dup2(fd[<span class="number">0</span>],STDIN_FILENO);</span><br><span class="line">		execlp(<span class="string">"wc"</span>,<span class="string">"wc"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line">		perr_exit(<span class="string">"execlp wc error"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*子进程写管道*/</span></span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">		dup2(fd[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line">		execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="literal">NULL</span>);</span><br><span class="line">		perr_exit(<span class="string">"execlp ls error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>兄弟进程间通信：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*创建管道*/</span></span><br><span class="line">	ret=pipe(fd);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"pipe error"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*循环创建2个子进程*/</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)&#123;</span><br><span class="line">		pid=fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">			perr_exit(<span class="string">"fork error"</span>);</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*父进程关闭管道读写两端*/</span></span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*兄进程关闭读端,将STDOUT指向fd[1]*/</span></span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">		dup2(fd[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line">		execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="literal">NULL</span>);</span><br><span class="line">		perr_exit(<span class="string">"execlp ls error"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">/*弟进程关闭写端,将STDIN指向fd[0]*/</span></span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">		dup2(fd[<span class="number">0</span>],STDIN_FILENO);</span><br><span class="line">		execlp(<span class="string">"wc"</span>,<span class="string">"wc"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line">		perr_exit(<span class="string">"execlp wc error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：管道可以一个读端, 多个写端, 但是不建议这样做。默认管道的大小是4k。</p>
<h3 id="命名管道FIFO"><a href="#命名管道FIFO" class="headerlink" title="命名管道FIFO"></a>命名管道FIFO</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>为区分<code>pipe</code>,将<code>FIFO</code>称为命名管道。<code>FIFO</code>可<strong>用于不相关进程间的数据交换</strong>。</p>
<p><code>FIFO</code>是Linux<strong>基础文件类型中的一种</strong>, 但是<strong><code>FIFO</code>文件在磁盘上没有数据块, 仅仅用来标识内核中的一条通道, 各进程可以打开这个文件进行read/write, 实际上是在读写内核通道, 这样就实现了进程间通信</strong></p>
<p>创建方式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname,<span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0, 失败返回-1并设置errno</span></span><br></pre></td></tr></table></figure>
<p>用FIFO进行通信几乎只有文件读写操作, 比较简单。</p>
<h3 id="文件通信"><a href="#文件通信" class="headerlink" title="文件通信"></a>文件通信</h3><p>读普通文件不会造成<code>read</code>阻塞, 如果子进程睡1秒再写, 父进程由于刚开始读不到数据<code>read</code>直接返回0。</p>
<p>没有血缘关系的进程也可以用文件进行进程间通信。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>写进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">	<span class="comment">/*靠已经创建好的FIFO,如果命令行参数没给指定,报错*/</span></span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter like this:./a.out fifoname\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*以只写方式打开FIFO文件,拿到fd*/</span></span><br><span class="line">	fd=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_WRONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"open error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">/*将数据写到buf中*/</span></span><br><span class="line">		<span class="built_in">sprintf</span>(buf,<span class="string">"love you:%d\n"</span>,i++);</span><br><span class="line">		<span class="built_in">write</span>(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">	<span class="comment">/*同样要依靠已经创建好的FIFO,从命令行参数中指定*/</span></span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter like this:./a.out fifoname\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*以只读方式打开FIFO文件,拿到fd*/</span></span><br><span class="line">	fd=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"open error"</span>);</span><br><span class="line">	<span class="comment">/*从fd中读取数据,并写到标准输出上*/</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		len=<span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="built_in">write</span>(STDOUT_FILENO,buf,len);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://api2.mubu.com/v3/document_image/f56e0e79-6128-4a52-beb4-982703780c5e-11197877.jpg" alt="mmap"></p>
<p><strong>存储映射I/O使一个磁盘文件与存储空间中的一个缓冲区相映射, 于是当从缓冲区中取数据, 就相当于读文件中的相应字节。</strong>与此类似, <strong>将数据存入缓冲区, 则相应的字节就自动写入文件, 这样就可以在不使用<code>read</code>和<code>write</code>函数的情况下, 使用指针完成<code>I/O</code>操作</strong>。可以借助共享内存和指针来访问磁盘文件。</p>
<p>使用这种方法, <strong>首先应通知内核, 将一个文件映射到存储区域中</strong>, 这个映射工作可以通过<strong><code>mmap函数</code></strong>来实现。</p>
<h4 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回：成功则返回创建的映射区首地址，失败:MAP_FAILED宏((void*)-1), 设置errno;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">addr:建立映射区的首地址，由linux内核指定，使用的时候直接传递NULL, 表示让系统自动分配;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">length:创建映射区的大小(&lt;=文件的实际大小);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">prot: 共享内存映射区的读写属性：PROT_READ, PROT_WRITE, PROT_READ|PROT_WRITE</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">flags: 标志位参数（常用于设定更新物理区域，设置共享，创建匿名映射区）</span></span><br><span class="line"><span class="comment">	MAP_SHARED: 将映射区所做的操作反映到物理设备上（磁盘）</span></span><br><span class="line"><span class="comment">	MAP_PRIVATE：映射区所做的修改不会映射到物理设备</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">fd：用来建立映射区的文件描述符*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len, ret;</span><br><span class="line">    <span class="keyword">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"mytest.txt"</span>,O_CREAT|O_RDWR,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    len = ftruncate(fd,<span class="number">4</span>); <span class="comment">//将文件截断为4byte</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftruncate"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p = mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmap"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*内存的写操作,会被映射到文件的写操作*/</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">"abc"</span>);<span class="comment">//写数据</span></span><br><span class="line">    <span class="comment">/*与malloc一样,申请的内存要还回去*/</span></span><br><span class="line">    ret = munmap(p,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"munmap"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>od -tcx filename</code>:以16进制查看文件</p>
<h4 id="MMAP使用注意事项"><a href="#MMAP使用注意事项" class="headerlink" title="MMAP使用注意事项"></a>MMAP使用注意事项</h4><p><strong>创建映射区的权限应该小于等于文件打开的权限，创建映射区的过程隐含一次对文件的读操作。</strong></p>
<p><strong>段错误：gdb，直接run就可以抓取到段错误的位置。</strong></p>
<ul>
<li>可以<code>open</code>的时候<code>O_CREAT</code>一个新文件来创建映射区，但是<strong>要拓展文件大小, 否则会出现总线错误</strong>. 当然 <code>mmap</code>时指定<code>size=0</code>,<code>mmap</code>会报错</li>
<li>如果<code>open</code>时指定<code>O_RDONLY</code>，<code>mmap</code>时<code>PROT</code>参数指定<code>PROT_READ|PROT_WRITE</code>会报错，无效参数(注意<code>ftruncte()</code>函数需要<strong>写权限, 否则无法拓展文件大小</strong>). <strong>如果都用只读权限, 不会出错. 要创建映射区, 文件必须有读权限</strong></li>
<li><strong>文件描述符先关闭，对<code>mmap</code>映射没有影响，建立完映射区后<code>fd</code>即可关闭</strong></li>
<li>如果文件偏移量为1000，<code>mmap</code>会报错，<strong>因为偏移量必须是<code>4K</code>的整数倍(<code>MMU</code>映射的最小单位为<code>4K</code>)</strong></li>
<li>对<code>mem</code>进行越界操作：小范围的越界问题不大, 但是最好不要这样(操纵不安全的内存, 操作系统不给保障)</li>
<li>如果<code>mem++</code>,<code>munmap</code>不会成功(与<code>malloc</code>一样, <strong>释放的内存的指针必须是申请得来的初始的指针, 如果要改变指针的值, 拷贝一份用</strong>)</li>
<li>除了第一个参数, 后面的参数都可能导致失败</li>
<li>无论<code>mmap</code>多复杂，一定要检查<code>mmap</code>的返回值</li>
</ul>
<p>总结：</p>
<ul>
<li>创建映射区过程中，隐含一次对映射文件的读操作</li>
<li>当<code>MAP_SHARED</code>时，<strong>要求映射区的权限应该&lt;=文件打开的权限（出于对映射区的保护）</strong>,而<code>MAP_PRIVATE</code>则无所谓因为<strong><code>mmap</code>中的权限是对内存的限制</strong></li>
<li>特别注意，<strong>当映射区文件大小为0时，不能创建映射区，所以：用于映射的文件必须要有实际大小！！<code>mmap</code>使用时候经常会出现总线错误，通常是由于共享文件存储空间大小引起的</strong></li>
<li><code>munmap</code>传入的地址一定是<code>mmap</code>的返回地址，坚决杜绝指针<code>++</code>操作</li>
<li>文件偏移量必须为<code>4K</code>的整数倍</li>
<li><code>mma</code>p创建映射区出错概率很高，一定要检查返回值，确保映射区建立成功后再进行后续操作</li>
</ul>
<h4 id="mmap优点"><a href="#mmap优点" class="headerlink" title="mmap优点"></a>mmap优点</h4><ul>
<li><p>对文件的读取操作<strong>跨过了页缓存，减少了数据的拷贝次数，用内存读写取代<code>I/O</code>读写，提高了文件读取效率。</strong></p>
</li>
<li><p>实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p>
</li>
<li><p><strong>提供进程间共享内存及相互通信的方式</strong>。<strong>不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。</strong>同时，<strong>如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可以直接使用已经保存在内存中的文件数据。</strong></p>
</li>
<li><p>可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过<code>mmap</code>映射很好的解决。换句话说，<strong>但凡是需要用磁盘空间代替内存的时候，<code>mmap</code>都可以发挥其功效。</strong></p>
</li>
</ul>
<h4 id="mmap父子进程通信"><a href="#mmap父子进程通信" class="headerlink" title="mmap父子进程通信"></a>mmap父子进程通信</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"temp"</span>,O_CREAT |O_RDWR|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    unlink(<span class="string">"temp"</span>); <span class="comment">//删除临时文件目录项，使之具备被释放的条件</span></span><br><span class="line">    ftruncate(fd,<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    p = (<span class="keyword">int</span>*)mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>); <span class="comment">//共享</span></span><br><span class="line">    <span class="comment">// p = (int*)mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_PRIVATE,fd,0); //进程各自独占</span></span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED) <span class="comment">//注意：不是p==NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmap error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd); <span class="comment">//映射区建立完毕，即可关闭文件</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">//创建子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">2000</span>; <span class="comment">//给映射区赋值</span></span><br><span class="line">        var = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child, *p = %d, var = %d\n"</span>,*p, var);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent, *p = %d, var = %d\n"</span>,*p, var);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = munmap(p,<span class="number">4</span>); <span class="comment">//释放映射区</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"munmap error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//child, *p = 2000, var = 1000</span></span><br><span class="line"><span class="comment">//parent, *p = 2000, var = 100</span></span><br></pre></td></tr></table></figure>
<p>父子等有血缘关系的进程直接也可以通过<code>mmap</code>建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数<code>flags</code>:</p>
<ul>
<li><code>MAP_PRIVATE</code>(私有映射): 父子进程各自独占映射区</li>
<li><code>MAP_SHARED</code>(共享映射):父子进程共享映射区</li>
</ul>
<p>结论：父子进程共享：</p>
<ul>
<li>打开的文件</li>
<li><code>mmap</code>建立的映射区（但必须使用MAP_SHARED）</li>
</ul>
<h4 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h4><p>使用映射区来完成文件读写操作十分方便，父子进程间通信也比较容易，但缺陷是：每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要<code>open</code>一个<code>temp</code>文件，创建好了再<code>unlink</code>、<code>close</code>,比较麻烦。可以直接使用匿名映射来代替。linux提供了相应的方法，<strong>无需依赖一个文件即可创建映射区，同样需要借助标志位参数<code>flags</code>来指定：</strong></p>
<p>使用<code>MAP_ANONYMOUS(或MAP_ANON)</code>,如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>*p = mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    p = (<span class="keyword">int</span>*)mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANON,<span class="number">-1</span>,<span class="number">0</span>); <span class="comment">//共享</span></span><br><span class="line">    <span class="comment">// p = (int*)mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_PRIVATE,fd,0); //进程各自独占</span></span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED) <span class="comment">//注意：不是p==NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmap error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">//创建子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">2000</span>; <span class="comment">//给映射区赋值</span></span><br><span class="line">        var = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child, *p = %d, var = %d\n"</span>,*p, var);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent, *p = %d, var = %d\n"</span>,*p, var);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = munmap(p,<span class="number">4</span>); <span class="comment">//释放映射区</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"munmap error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<code>MAP_ANONYMOUS</code>和<code>MAP_ANON</code>两个宏是linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="built_in">open</span>(<span class="string">"dev/zero"</span>,O_RDWR);</span><br><span class="line">p = mmap(<span class="literal">NULL</span>, <span class="built_in">size</span>,PROT_READ|PROT_WRITE,MMAP_SHARED,fd,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><code>/dev/zero</code>-<strong>文件白洞</strong>, 里面<strong>有无限量的’\0’, 要多少有多少</strong></p>
<p><code>/dev/null</code>-<strong>文件黑洞</strong>, 可以<strong>写入任意量的数据</strong></p>
<p>所以在创建映射区时可以用zero文件, 就不用自己创建文件然后拓展大小了</p>
<h4 id="mmap无血缘关系进程间通信"><a href="#mmap无血缘关系进程间通信" class="headerlink" title="mmap无血缘关系进程间通信"></a>mmap无血缘关系进程间通信</h4><p>实质上<code>mmap</code>是内核借助文件帮助创建的一个映射区，多个进程之间利用该映射区完成数据传递。<strong>由于内核空间多进程共享，因此无血缘关系的进程间也可以使用<code>mmap</code>来完成通信，只要设置相应的标志位参数<code>flags</code>即可。若想实现共享，应该使用<code>MAP_SHARED</code></strong></p>
<p>要点：<strong>必须是同一个文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mmap_w.c 写进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span> = &#123;</span><span class="number">10</span>,<span class="string">"xiaoming"</span>,<span class="string">'m'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>* mm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./a.out file_shared\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	 <span class="comment">/*打开或创建一个文件*/</span></span><br><span class="line">    fd = <span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">"open error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ftruncate(fd,<span class="keyword">sizeof</span>(student));</span><br><span class="line">	<span class="comment">/*建立内存映射区*/</span></span><br><span class="line">    mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student),PROT_READ|PROT_WRITE, MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mm == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*循环使用memcpy向内存映射区中写入数据,并修改stu的id值*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(mm,&amp;student,<span class="keyword">sizeof</span>(student));</span><br><span class="line">        student.id ++;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*归还内存映射区给内存池*/</span></span><br><span class="line">    munmap(mm,<span class="keyword">sizeof</span>(student));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mmap_r.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span>* <span class="title">mm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./a.out file_shared\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*建立内存映射区*/</span></span><br><span class="line">    fd = <span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">"open error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*循环读出内存映射区中的数据*/</span></span><br><span class="line">    mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student),PROT_READ, MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mm == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"id = %d\tname=%s\t%c\n"</span>,mm-&gt;id,mm-&gt;name,mm-&gt;sex);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>无血缘关系进程间通信, 不能用匿名映射</strong></p>
<p><code>strace</code>: 追踪一个可执行文件在执行过程中所有的系统调用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/linux-%E7%B3%BB%E7%BB%9F-06%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/linux-%E7%B3%BB%E7%BB%9F-06%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">linux系统-进程管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-26 16:51:35" itemprop="dateCreated datePublished" datetime="2020-03-26T16:51:35+08:00">2020-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 10:13:23" itemprop="dateModified" datetime="2021-03-25T10:13:23+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h4><p>创建一个子进程, 原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> fork();		<span class="comment">/*函数原型相当简单:空参,返回一个整数pid*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//    返回值有两个:父进程的fork返回子进程的id，子进程返回0（表示fork成功）</span></span><br><span class="line"><span class="comment">//    返回子进程的pid(一个非负整数&gt;0)</span></span><br><span class="line"><span class="comment">//    返回0</span></span><br><span class="line"><span class="comment">//    失败返回-1并设置errno</span></span><br></pre></td></tr></table></figure>
<p><code>fork</code>确实创建了一个子进程并完全复制父进程，但是<strong>子进程是从<code>fork</code>后面那个指令开始执行的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sdsfdfdsfd\n"</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm child, pid =%u,ppid = %u\n"</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm Parent, pid =%u,ppid = %u\n"</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"yyyyyyy\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建n个线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"xxxxxxx\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span> ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm %d child, pid = %u\n"</span>,i+<span class="number">1</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm parent\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>父进程和子进程谁先执行？谁先抢到cpu就谁先执行。</strong>如果不加<code>sleep</code>，则输出是乱序的(反映了操作系统对进程调度的无序性)。</p>
<h4 id="getuid"><a href="#getuid" class="headerlink" title="getuid"></a>getuid</h4><ul>
<li><p>获取当前进程实际用户ID： <code>uid_t getuid(void)</code></p>
</li>
<li><p>获取当前进程有效用户ID： <code>uid_t geteuid(void)</code></p>
</li>
</ul>
<h4 id="getgid"><a href="#getgid" class="headerlink" title="getgid"></a>getgid</h4><ul>
<li><p>获取当前进程使用用户组ID： <code>gid_t getgid()</code></p>
</li>
<li><p>获取当前进程有效用户组ID： <code>gid_t getegid()</code></p>
</li>
</ul>
<h3 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a>进程共享</h3><p><strong>父子进程之间在fork后，有哪些相同，哪些相异？</strong></p>
<p>刚fork之后：</p>
<p><strong>父子相同之处：全局变量、.data段,.text段，栈，堆，环境变量，用户ID，宿主目录，进程工作目录，信号处理方式…</strong></p>
<p>父子不同之处：<strong>进程ID，fork返回值，父子进程ID，进程运行时间，闹钟（定时器），未决定信号集</strong></p>
<p>注意：子进程并不是把父进程0~3G地址空间完全cpoy一份, 然后映射到物理内存。 父子进程之间遵循<strong>读时共享写时复制</strong>的原则。这样设计，<strong>无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">34</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// var = 55;/*读时共享,写时复制*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm parent pid = %d, parentID = %d, var = %d\n"</span>,getpid(), getppid(),var);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        var = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child pid = %d, parentID = %d, var = %d\n"</span>,getpid(),getppid(),var);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"var = %d\n"</span>,var);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点：</p>
<ul>
<li><p>躲避父子进程共享全局变量的误区(线程之间可以共享全局变量)。</p>
</li>
<li><p>父子进程共享</p>
<ul>
<li>文件描述符（打开文件的结构体）</li>
<li>mmap建立的映射区（进程间通信）</li>
</ul>
</li>
</ul>
<p><strong>特别：fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法。</strong></p>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>使用gdb调试的时候，<strong>gdb只能跟踪一个进程。可以在fork函数调用之前，通过命令设置gdb调试工具跟踪父进程或是子进程。默认跟踪父进程。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set follow-fork-mode child #命令设置gdb在fork之后跟踪子进程</span><br><span class="line">set follow-fork-mode parent #设置跟踪父进程</span><br></pre></td></tr></table></figure>
<p>注意：一定要在fork函数调用之前设置才有效。</p>
<h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><p><strong>fork函数创建子进程后执行的是和父进程相同的程序（但可能执行不同的代码分支）</strong>，<strong>子进程往往要调用一种exec函数以执行另一个程序</strong>。<strong>当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。</strong></p>
<p><strong>将当前进程的.text, .data替换为所要加载的程序的.text, .data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。</strong></p>
<ul>
<li>int execl()</li>
<li>int execlp()</li>
<li>int  execle()</li>
<li>int execv()</li>
<li>int execvp()</li>
<li>int execve()</li>
</ul>
<h4 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h4><p><code>execlp</code>中的p表示环境变量, <strong>所以该函数通常用来调用系统程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="comment">/*参数1：要加载的程序的名字的，该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后但没有参数1则出错返回。*/</span></span><br></pre></td></tr></table></figure>
<p><strong>注意结尾加上NULL指定变参结束, printf函数也是变参, 结尾也要加上NULL作为哨兵</strong>.</p>
<p>该函数通常用来调用系统程序。如<code>ls, cat , date</code>等命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pid_t</span> pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"fork error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">/*参数从argv[0]开始算*/</span></span><br><span class="line">		execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="string">"-R"</span>,<span class="string">"-h"</span>,<span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">/*正常情况下是不会执行到这里的,只有当出错时才会返回到这里执行*/</span></span><br><span class="line">		perror(<span class="string">"execlp error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm parent:%d\n"</span>,getpid());</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先fork, 再exec, 这就是bash的大概原理.</p>
<p>如果要执行自己的可执行文件:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">"./test"</span>,<span class="string">"./test"</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h4 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h4><p>加载一个进程，通过 路径+程序名 来加载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span>\* arg, ...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//对比execlp</span></span></span><br><span class="line"><span class="function"><span class="title">execlp</span><span class="params">(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="string">"-a"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>)</span></span>;</span><br><span class="line">execl(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-a"</span>,<span class="string">"-l"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//exec_ps.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> fd1=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*打开或创建一个文件*/</span></span><br><span class="line">	fd1=<span class="built_in">open</span>(<span class="string">"ps.log"</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd1==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"open error"</span>);</span><br><span class="line">	<span class="comment">/*将STDOUT_FILENO指向fd1*/</span></span><br><span class="line">	ret=dup2(fd1,STDOUT_FILENO);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"dup2 error"</span>);</span><br><span class="line">	<span class="comment">/*执行命令*/</span></span><br><span class="line">	execlp(<span class="string">"ps"</span>,<span class="string">"ps"</span>,<span class="string">"aux"</span>,<span class="literal">NULL</span>);</span><br><span class="line">	perror(<span class="string">"execlp error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a>exec函数族一般规律</h4><p><strong>exec函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1。所以通常直接在exec函数后直接调用perror()和exit()，无需if判断。</strong></p>
<ul>
<li><p>l (list) 命令行参数列表</p>
</li>
<li><p>p (path) 搜索file时使用<strong>path变量</strong></p>
</li>
<li><p>v (vector) 使用<strong>命令行参数数组</strong></p>
</li>
<li><p>e (environment) 使用<strong>环境变量数组，不使用进程原有的环境变量，设置新加载程序运行的环境变量。</strong></p>
</li>
</ul>
<p>事实上，只有<code>execve</code>是真正的系统调用，其他五个函数最终都调用<code>execev</code>,所以<code>execve</code>在man手册第二节，而其他函数在man手册第三节。</p>
<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p><strong>父进程先于子进程结束，则子进程变为孤儿进程，子进程的父进程变为<code>init</code>进程，称为<code>init</code>进程领养孤儿进程。该过程主要是为了后期进行回收。</strong></p>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p><strong>进程终止，父进程尚未回收，子进程残留资源(PCB)存放在内核中，变成僵尸(Zombie)进程。</strong></p>
<p>特别注意：<strong>僵尸进程不能使用kill命令来清除。因为kill命令只是用来终止进程的，而僵尸进程已经终止。</strong></p>
<p>进程的运行状态：R 运行， S 后台运行， Z 僵尸进程</p>
<p>用什么办法可以清除僵尸进程？<strong>避免僵尸进程：回收</strong></p>
<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><p><strong>一个进程在终止的时候会关闭所有的文件描述符，释放在该用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息。如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用<code>wait</code>或者<code>waitpid</code>获取这些信息，然后彻底清除掉这个进程。一个进程的退出状态可以在<code>shell</code>中用特殊变量<code>$?</code>查看，因为shell是它的父进程，当它终止时<code>shell</code>调用<code>wait</code>或<code>waitpid</code>得到它的退出状态同时彻底清除掉这个进程。</strong></p>
<p><strong>父进程调用wait函数可以回收子进程终止信息，</strong>该函数的三个功能：</p>
<ul>
<li><strong>阻塞等待子进程退出</strong></li>
<li><strong>回收子进程残留资源</strong></li>
<li><strong>获取子进程结束状态（退出原因）</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br><span class="line"><span class="comment">//成功：清理掉的子进程ID， 失败：-1(没有子进程)</span></span><br></pre></td></tr></table></figure>
<p>当进程终止时，操作系统的隐式回收机制会：</p>
<ul>
<li>关闭所有文件描述符</li>
<li>释放用户空间分配的内存，<strong>内核的PCB仍存在。其中保存该进程的退出状态。（正常终止：退出值;异常终止：终止信号）</strong></li>
</ul>
<p>可使用<code>wait</code>函数传出参数<code>status</code>来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可以分为三组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WIFEXITED(status) <span class="comment">//为非0 :进程正常结束</span></span><br><span class="line">WEXITSTATUS(status） <span class="comment">//如上宏为真，使用此宏：获取进程退出状态（exit的参数）</span></span><br><span class="line"></span><br><span class="line">WIFSIGNALED(status)  <span class="comment">//为非0： 进程异常终止</span></span><br><span class="line">WTERMSIG(status) <span class="comment">//如上宏函数为真，使用此宏：取得使进程终止的那个信号的编号</span></span><br><span class="line"></span><br><span class="line">WIFSTOPED(status) <span class="comment">//为非0：进程处于暂停状态</span></span><br><span class="line">WSTOPSIG(status) <span class="comment">//加上宏为真，使用此宏：取得使进程暂停的那个信号的编号</span></span><br><span class="line">WIFCONTINUED(status) <span class="comment">//为真，进程暂停后已经继续运行</span></span><br></pre></td></tr></table></figure>
<p><code>kill -l</code> 可以<strong>查看进程结束的所有状态</strong></p>
<p><strong>程序所有异常终止的原因都是因为信号</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid,wpid;</span><br><span class="line">	<span class="keyword">int</span> status=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"fork error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm child:%d,my parent is %d,I'm going to sleep 10s\n"</span>,getpid(),getppid());</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm child,I'm going to die\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">73</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//wpid=wait(NULL);		//不关心子进程退出原因</span></span><br><span class="line">		wpid=wait(&amp;status);</span><br><span class="line">		<span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">			perr_exit(<span class="string">"wait error"</span>);</span><br><span class="line">		<span class="comment">/*如果子进程正常终止,则可获取它的退出值*/</span></span><br><span class="line">		<span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"My child exited with:%d\n"</span>,WEXITSTATUS(status));</span><br><span class="line">        <span class="comment">/*如果子进程被信号终止,可获取结束它的信号*/</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"My child killed by:%d\n"</span>,WTERMSIG(status));</span><br><span class="line">		<span class="comment">/*提示回收完成*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm parent,wait %d finish\n"</span>,wpid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><p><strong>作用同wait,但可指定pid进程清理，可以不阻塞</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options); </span><br><span class="line"><span class="comment">//成功：返回清理的子进程ID, 失败：-1(无子进程)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*特殊参数和返回情况：</span></span><br><span class="line"><span class="comment">参数pid:</span></span><br><span class="line"><span class="comment">&gt;0 回收指定ID的子进程</span></span><br><span class="line"><span class="comment">-1 回收任意子进程（相当与wait）</span></span><br><span class="line"><span class="comment">0 回收和当前调用waitpid一个组的所有子进程</span></span><br><span class="line"><span class="comment">&lt;-1 回收指定进程组内的任意子进程(进程组号取反, 表示回收指定进程组的任意子进程)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参2传进程结束状态, 如果不关心直接传NULL(传出参数)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参3传回收方式:WNOHANG(非阻塞)*/</span></span><br></pre></td></tr></table></figure>
<p>注意：<strong>一次<code>wait</code>或<code>waitpid</code>调用只能清理一个子进程，清理多个子进程应该使用循环。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带有bug的版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> wpid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">				pid=getpid();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">		<span class="comment">//wpid=waitpid(-1,NULL,WNOHANG);		//以非阻塞的方式回收任意子进程</span></span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">		wpid=waitpid(pid,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">		<span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">			perr_exit(<span class="string">"waitpid error"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm parent,wait a child finish:%d\n"</span>,wpid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm %dth child,my pid=%d\n"</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bug的原因:在<code>fork()==0</code>时是在子进程的执行逻辑中保存了<code>pid</code>, 但是子进程执行结束后直接返回, 用户空间的地址空间被回收, 当然也就没有了<code>pid</code>这个变量, 所以后面父进程<code>waitpid</code>时拿到的<code>pid</code>一直是0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改bug后</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> wpid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temppid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">		pid=fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/*在父进程中,如果i==2,将fork的返回值存入temppid*/</span></span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">			temppid=pid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">		<span class="comment">//wpid=waitpid(-1,NULL,WNOHANG);		//以非阻塞的方式回收任意子进程</span></span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">		wpid=waitpid(temppid,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">		<span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">			perr_exit(<span class="string">"waitpid error"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm parent,wait a child finish:%d\n"</span>,wpid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm %dth child,my pid=%d\n"</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回收多个子进程: <strong>用while循环</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> wpid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">		pid=fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="comment">/*以非阻塞忙轮询的方式回收子进程*/</span></span><br><span class="line">		<span class="keyword">while</span>((wpid=waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG))!=<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"wait chile:%d\n"</span>,wpid);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">0</span>)</span><br><span class="line">				sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm %dth child,my pid=%d\n"</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>wait/waitpid</code>只能回收子进程, 爷孙的也不行.</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/25/linux-%E7%B3%BB%E7%BB%9F-05%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/25/linux-%E7%B3%BB%E7%BB%9F-05%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">linux系统编程-进程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-25 16:02:58" itemprop="dateCreated datePublished" datetime="2020-03-25T16:02:58+08:00">2020-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-23 21:47:57" itemprop="dateModified" datetime="2021-03-23T21:47:57+08:00">2021-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="linux进程"><a href="#linux进程" class="headerlink" title="linux进程"></a>linux进程</h3><h4 id="进程、程序、并发"><a href="#进程、程序、并发" class="headerlink" title="进程、程序、并发"></a>进程、程序、并发</h4><p>程序：编译好的二进制文件。在<strong>磁盘上，不占用系统资源</strong>(cpu、 内存、打开的文件、设备、锁…)</p>
<p>进程：一个抽象概念，与操作系统原理联系紧密。进程是<strong>活跃的程序，占用系统资源</strong>。在内存中执行(程序运行起来则产生一个进程)</p>
<p>并发：<strong>操作系统中，一个时间段中有多个进程都处于已启动到运行完毕之间的状态。但一个时刻点上仍只有一个进程在运行（分时复用）。</strong></p>
<h4 id="cpu和MMU-内存管理单元"><a href="#cpu和MMU-内存管理单元" class="headerlink" title="cpu和MMU(内存管理单元)"></a>cpu和MMU(内存管理单元)</h4><p><img src="https://api2.mubu.com/v3/document_image/e44706d6-6069-4a0e-9c85-6c1c43c3c19f-11197877.jpg" alt="cpu和存储"></p>
<ul>
<li><p>存储设备包括寄存器，cache,内存，硬盘，网络等。<strong>与cpu直接打交道的应该是寄存器，多级缓存</strong></p>
</li>
<li><p><strong>MMU(内存管理单元), 位于CPU内部</strong></p>
</li>
<li>MMU完成<strong>虚拟地址到物理地址的映射</strong>，设置<strong>修改内存访问级别（用户空间，内核空间）。一个page是内存分配的最小单位。</strong></li>
</ul>
<ul>
<li><p>虚拟内存空间产生的时间：进程启动的时候，<strong>进程的所有东西都放在虚拟内存中，并不真实存在</strong>。实际的都放在内存中，虚拟空间如何描述？</p>
</li>
<li><p>虚拟地址：可用的地址空间有4G(32位操作系统)</p>
</li>
<li><p>如果一个程序跑了两个进程：<strong>两个进程开了两个虚拟空间，两个进程互相独立。两个不同的进程共用一个内存空间</strong>。</p>
</li>
</ul>
<p>虚拟内存和物理内存映射关系：</p>
<p><img src="https://api2.mubu.com/v3/document_image/06bd754f-dfe9-4081-a742-5f305d537582-11197877.jpg" alt="虚拟内存和物理内存映射关系"></p>
<ul>
<li><p>对于一个32位的机器来说, 每个进程都能看到4GB的虚拟地址空间, 且他们的3G~4G的位置都是kernel(<strong>每个进程都有kernel区</strong>)</p>
</li>
<li><p>从虚拟内存到物理内存的映射由MMU完成, <strong>不同进程的用户空间被映射到物理内存的不同位置, 而不同进程的kernel空间被映射到物理内存的相同位置</strong>, 对于物理内存来说，<strong>用户空间和内核空间有不同的特权级, 从用户空间到内核空间的转换实质上是特权级的切换。</strong></p>
</li>
</ul>
<h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><p><strong>每个进程在内核中都有一个PCB来维护进程相关信息</strong>, Linux内核的进程控制块是task_struct类型的结构体。</p>
<p>在<code>/usr/src/linux-headers-3.16.0-30/include/linux/sched.h</code>文件中可以查看<code>struct task_struct</code>结构体定义。其内部成员有很多，重点需要掌握部分：</p>
<ul>
<li><strong>进程id。系统中每一个进程都有唯一的id,在c语言中用<code>pid_t</code>类型表示，其实就是一个非负整数</strong></li>
<li><strong>进程的状态，有就绪、运行、挂起、停止等状态</strong></li>
<li>进程切换时需要保存和恢复的一些CPU寄存器</li>
<li>描述虚拟地址空间的信息，从虚拟地址映射到物理地址。</li>
<li>描述控制终端的信息</li>
<li>当前工作目录：cd 改变当前进程的工作目录，shell也是一个进程。</li>
<li>umask掩码</li>
<li><strong>文件描述符表，包含很多指向file结构体的指针</strong></li>
<li><strong>和信号相关的信息</strong></li>
<li><strong>用户id和组id</strong></li>
<li>会话和进程组</li>
<li>进程可以使用的资源上限：<code>ulimit -a</code></li>
</ul>
<p>就绪状态：<strong>等待cpu分配时间片</strong></p>
<p>挂起状态：<strong>等待除cpu以外的其他资源，主动放弃cpu</strong></p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>操作系统中用来<strong>指定操作系统运行环境的一些参数</strong>，通常具备以下特征：</p>
<ul>
<li><p>字符串（本质）</p>
</li>
<li><p>有统一的格式：名=值[:值]</p>
</li>
<li><p>值用来描述进程环境信息。</p>
</li>
<li><p>存储形式：与命令行参数类似。char* []，数组名 environ, 内部存储字符串，NULL作为哨兵结尾。</p>
</li>
<li><p>使用形式：与命令行参数类似</p>
</li>
<li><p>加载位置：与命令行参数类似，<strong>位于用户区，高于stack的起始位置</strong></p>
</li>
<li><p>引入环境变量表：须声明环境变量。<code>extern char** environ; （extern 声明）</code></p>
</li>
</ul>
<p>常见环境变量：</p>
<ul>
<li><p>PATH</p>
<ul>
<li>可执行文件的<strong>搜索路径</strong>。<code>ls</code>命令也是一个程序，执行它不需要提供完成的路径名<code>/bin/ls</code>,然而通常执行当前目录下的程序<code>a.out</code>却需要提供完整的路径名<code>./a.out</code>,<strong>这是因为<code>PATH</code>环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在shell中用echo命令可以查看这个环境变量的值。</strong></li>
<li><p><code>echo $PATH</code></p>
</li>
<li><p>使用date 和/bin/date原理是不同的。</p>
</li>
<li>shell按照PATH中的目录从前往后查找。</li>
</ul>
</li>
<li><p>SHELL</p>
<ul>
<li>当前shell(命令解析器)，值一般是/bin/shell</li>
</ul>
</li>
<li><p>TERM</p>
<ul>
<li>当前<strong>终端类型</strong>，在图形界面终端下它的值通常是xterm,终端类型决定了一些程序的输出方式，比如图形界面终端可以显示汉字，而字符终端一般不行。</li>
</ul>
</li>
<li><p>LANG</p>
<ul>
<li>语言和locale，决定了字符编码以及时间、货币等信息的显示格式</li>
</ul>
</li>
<li><p>HOME</p>
<ul>
<li><strong>当前用户主目录的路径，很多程序需要在主目录下保存配置文件，使得每个用户在运行该程序时都有自己的一套配置。</strong></li>
</ul>
</li>
<li>env:<strong>查看所有环境变量</strong></li>
</ul>
<p><code>getenv函数， setenv函数</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/23/linux-%E7%B3%BB%E7%BB%9F-04%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/linux-%E7%B3%BB%E7%BB%9F-04%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">linux系统下文件和目录操作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-23 10:50:49" itemprop="dateCreated datePublished" datetime="2020-03-23T10:50:49+08:00">2020-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-23 16:00:25" itemprop="dateModified" datetime="2021-03-23T16:00:25+08:00">2021-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="系统调用说明"><a href="#系统调用说明" class="headerlink" title="系统调用说明"></a>系统调用说明</h3><p>系统调用: <strong>内核提供的函数</strong>，由操作系统实现并提供给外部应用程序的编程接口, 是应用程序同操作系统之间交互数据的桥梁</p>
<p>为了保证系统的安全性, <strong>manPage中的系统调用都是对系统调用的一次浅封装</strong>, 比如open对应的是sys_open…</p>
<h4 id="系统调用和库函数的比较：预读入和缓输出"><a href="#系统调用和库函数的比较：预读入和缓输出" class="headerlink" title="系统调用和库函数的比较：预读入和缓输出"></a>系统调用和库函数的比较：预读入和缓输出</h4><p>使用<code>strace</code>工具可以跟踪一个程序执行时所需的<strong>系统调用</strong>。</p>
<p>如果规定逐字节的进行拷贝, 用库函数会比用系统调用快很多, 因为<strong>有预读入和缓输出机制:</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/ca853e5c-878b-4feb-80a4-2d4205eb88e3-11197877.jpg" alt="预读入和缓输出机制"></p>
<p>操作系统不会让用户逐字节的向磁盘上写数据, 实际上它<strong>维护了一个系统级缓冲</strong>, <strong>只有当从用户空间过来的数据在该缓冲上写满时, 才会一次性将数据冲刷到Disk上</strong></p>
<p><strong>当使用系统调用的方法时, 要不断的在用户空间和内核空间进行来回切换, 这会消耗大量时间</strong></p>
<p>而使用fputc(库函数)时, <strong>在设计之初自己在用户空间维护了一个缓冲, 这样在用户空间把自己的缓冲写满, 再一次性写入内核缓冲(写入了内核缓冲就认为写到了磁盘上), 可见这样大大减少了在用户空间和内核空间来回切换的次数</strong></p>
<p><strong>read和write函数常被称为UnbufferedIO, 指无用户级缓冲区, 但不保证不使用内核缓冲区</strong></p>
<h3 id="文件及相关操作"><a href="#文件及相关操作" class="headerlink" title="文件及相关操作"></a>文件及相关操作</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p><img src="https://api2.mubu.com/v3/document_image/1148cba1-a13e-4a4f-a00d-e12aafbae072-11197877.jpg" alt="文件描述符"></p>
<ul>
<li>PCB中有一个指针, <strong>指向了该进程的文件描述符表, 每个表项都是一个键值对, 其中的value是指向文件结构体的指针, 其中的索引是fd,</strong> <strong>操作系统暴露给用户的唯一操作文件的依据</strong></li>
<li>新打开的文件描述符一定是所有文件描述符表中<strong>可用的, 最小的</strong>那个文件描述符</li>
<li>文件描述符最大1023, 说明<strong>一个进程最多能打开1024个文件</strong></li>
</ul>
<h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;	<span class="comment">//mode_t是一个8进制整型,指定文件权限,只有当参2指定了CREAT才有用</span></span><br></pre></td></tr></table></figure>
<p>flag的参数:</p>
<ul>
<li>O_RDONLY</li>
<li>O_WRONLY</li>
<li>O_RDWR</li>
<li>O_APPEND</li>
<li>O_CREATE</li>
<li>O_EXCL</li>
<li>O_TRUNC</li>
<li>O_NONBLOCK</li>
</ul>
<p>成功返回<strong>文件描述符</strong>, 失败返回-1并设置errno;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd1=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> fd2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	fd1=<span class="built_in">open</span>(<span class="string">"./dirt.txt"</span>,O_RDONLY|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">    <span class="comment">/*打开的文件不存在*/</span></span><br><span class="line">	fd2=<span class="built_in">open</span>(<span class="string">"./dirt2.txt"</span>,O_RDONLY);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fd1=%d\n"</span>,fd1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd2=%d,errno=%d:%s\n"</span>,fd2,errno,strerror(errno));</span><br><span class="line">	<span class="built_in">close</span>(fd1);</span><br><span class="line">	<span class="built_in">close</span>(fd2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建文件权限时, 指定文件访问权限, 权限同时受umask影响:<code>文件权限=mode&amp;(~umask)</code></strong></p>
<h4 id="read和write"><a href="#read和write" class="headerlink" title="read和write"></a>read和write</h4><ul>
<li>read:从<strong>文件中读数据到缓冲区</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">read</span>(<span class="keyword">int</span> fd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> count);<span class="comment">//count是缓冲区的大小;</span></span><br></pre></td></tr></table></figure>
<p><strong>成功返回实际读到的字节数, 返回0时意味着读到了文件末尾, 失败返回-1并设置errno</strong></p>
<ul>
<li>wirte:从<strong>缓冲区中读数据到文件</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">write</span>(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> count); <span class="comment">//count是数据的大小(字节数);</span></span><br></pre></td></tr></table></figure>
<p><strong>成功返回实际写入的字节数, 失败返回-1, 并设置errno</strong></p>
<h4 id="read和write实现文件拷贝"><a href="#read和write实现文件拷贝" class="headerlink" title="read和write实现文件拷贝"></a>read和write实现文件拷贝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> fd1=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd1==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open argv1 error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> fd2=<span class="built_in">open</span>(argv[<span class="number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd2==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open argv2 error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((n=<span class="built_in">read</span>(fd1,buf,<span class="keyword">sizeof</span>(buf)))!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			perror(<span class="string">"open argv2 error"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">write</span>(fd2,buf,n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(fd1);</span><br><span class="line">	<span class="built_in">close</span>(fd2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><p>阻塞：<strong>当进程调用一个阻塞的系统调用时，该进程被置于睡眠状态，这时内核调度其他进程运行，直到该进程等待的事件发生了（比如网络上接收到数据包或者调用sleep指定的睡眠时间到了）它才可能继续运行</strong>。与睡眠状态相对的是运行状态。</p>
<p>正在被调度执行的进程：cpu处于该进程的上下文环境中，程序计数器中保存着该进程的指令地址，通用寄存器中保存着进程运算过程中的中间结果，正在执行该进程的指令，正在读写该进程的地址空间。</p>
<p>常规读文件是不会阻塞的，不论读多少字节，read一定会在有限时间内返回。<strong>从终端或网络读则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会阻塞</strong>。<strong>如果网络上没有接收到数据包，调用read从网络读就会阻塞，至于阻塞多长时间也是不确定的，如果一直没有数据到达就会一直阻塞。同样，写常规文件也是不会阻塞的，而向终端设备或网络写则不一定。</strong></p>
<h5 id="echo程序"><a href="#echo程序" class="headerlink" title="echo程序"></a>echo程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"read error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(STDOUT_FILENO,buf,n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当不敲入换行符时, read会一直阻塞等待用户输入</p>
<p>阻塞是<strong>设备文件, 网络文件</strong>的属性</p>
<h5 id="非阻塞方式从tty中读数据"><a href="#非阻塞方式从tty中读数据" class="headerlink" title="非阻塞方式从tty中读数据"></a>非阻塞方式从tty中读数据</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*以非阻塞方式打开终端文件*/</span></span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">"/dev/tty"</span>,O_RDONLY|O_NONBLOCK);</span><br><span class="line">	<span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open /dev/tty error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">tryagain: </span><br><span class="line">	n=<span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">/*当read的返回值小于0*/</span></span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*errno不是EWOULDBLOCK,说明出现了其他问题*/</span></span><br><span class="line">		<span class="keyword">if</span>(errno!=EWOULDBLOCK)&#123;</span><br><span class="line">			perror(<span class="string">"read /dev/tty error"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/*errno是EWOULDBLOCK,说明读到为空,则打印提示信息,并再次尝试*/</span></span><br><span class="line">			<span class="built_in">write</span>(STDOUT_FILENO,<span class="string">"try again\n"</span>,<span class="built_in">strlen</span>(<span class="string">"try again\n"</span>));</span><br><span class="line">			sleep(<span class="number">2</span>);</span><br><span class="line">			<span class="keyword">goto</span> tryagain;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*当read的返回值大于0,说明读到了数据,写到标准输出上*/</span></span><br><span class="line">	<span class="built_in">write</span>(STDOUT_FILENO,buf,n);</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>当<code>read</code>函数返回-1, 并且<code>errno=EAGAIN或EWOULDBLOCK</code>, 说明不是<code>read</code>失败, 而是read在以非阻塞方式读一个<strong>设备文件</strong>或<strong>网络文件</strong>, 而文件中无数据。</p>
<p>阻塞方式存在的问题也正是网络IO中<code>select, poll和epoll</code>函数存在的原因。</p>
<h4 id="fcntl修改文件的属性"><a href="#fcntl修改文件的属性" class="headerlink" title="fcntl修改文件的属性"></a>fcntl修改文件的属性</h4><p>改变一个<strong>已经打开的</strong>文件的访问控制属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>用fcntl改写上面的程序, <strong>不用重新打开文件:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flags=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*获取原来的flags*/</span></span><br><span class="line">	flags=fcntl(STDIN_FILENO,F_GETFL);</span><br><span class="line">	<span class="keyword">if</span>(flags==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"fcntl error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*位或上新的属性*/</span></span><br><span class="line">	flags|=O_NONBLOCK;</span><br><span class="line">    <span class="comment">/*将新的flags设置回去*/</span></span><br><span class="line">	ret=fcntl(STDIN_FILENO,F_SETFL,flags);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"fcntl error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*与上面的相同*/</span></span><br><span class="line">tryagain:</span><br><span class="line">	n=<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(errno!=EWOULDBLOCK)&#123;</span><br><span class="line">			perror(<span class="string">"read /dev/tty error"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">write</span>(STDOUT_FILENO,<span class="string">"try again\n"</span>,<span class="built_in">strlen</span>(<span class="string">"try again\n"</span>));</span><br><span class="line">			sleep(<span class="number">2</span>);</span><br><span class="line">			<span class="keyword">goto</span> tryagain;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(STDOUT_FILENO,buf,n);</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>文件的flags是一个位图, 每一位代表不同属性的真假值</strong></p>
<h4 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h4><p><strong>文件偏移：每个打开的文件都记录着当前读写位置，打开文件时候写位置是0,表示文件开头，通常读写多少个字节就会将读写位置往后移动多少个字节。例外：如果以<code>O_APPEND</code>方式打开，每次写操作都会在文件末尾追加数据，然后将读写位置移动到新的文件末尾</strong>。<code>lseek</code>和标准<code>I/O</code>库的<code>fseek</code>函数类似，可以移动当前读写位置(或偏移量)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>; <span class="comment">//成功返回0,失败返回-1.特别：超出文件末尾位置返回0,往回超出文件头位置，返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence); <span class="comment">//失败返回-1,成功：返回的值是较文件起始位置向后的偏移量</span></span><br><span class="line"><span class="comment">//特别：lseek允许超过文件结尾设置偏移量，未见会因此被拓展。</span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> msg[]=<span class="string">"It's a lseek test\n"</span>;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">"./lseek.txt"</span>,O_CREAT|O_RDWR,<span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(fd,msg,<span class="built_in">strlen</span>(msg));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*如果这里不进行lseek,由于读写共用同一个偏移位置,下面的读会从文件末尾开始读,读不到任何数据*/</span></span><br><span class="line">	lseek(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>((n=<span class="built_in">read</span>(fd,&amp;c,<span class="number">1</span>)))&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">"read error"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">write</span>(STDOUT_FILENO,&amp;c,n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用lseek获取文件大小:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*从0开始向后偏移到结尾,返回值表示偏移量,即为文件大小*/</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>=lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The file's size:%d\n"</span>,<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用lseek拓展文件大小: <strong>要想使文件大小真正拓展, 必须引起IO操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*从文件的结束位置开始,向后偏移110，被填入的是文件空洞*/</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>=lseek(fd,<span class="number">110</span>,SEEK_END);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The file's size:%d\n"</span>,<span class="built_in">size</span>);</span><br><span class="line">	<span class="comment">/*然后写入一个空字符*/</span></span><br><span class="line">	<span class="built_in">write</span>(fd,<span class="string">"\0"</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以HEX查看文件:<code>od -tcx filename</code>。</p>
<p>也可以使用truncate拓展文件大小:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret=truncate(<span class="string">"dict.cp"</span>,<span class="number">250</span>);</span><br></pre></td></tr></table></figure>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><h4 id="目录项和inode"><a href="#目录项和inode" class="headerlink" title="目录项和inode"></a>目录项和inode</h4><p>文件存储的关键点：inode, denty,数据存储，文件系统。</p>
<p>inode: <strong>本质为结构体，存储文件的属性信息。如：权限、大小、时间、用户、盘块位置…也叫做文件属性管理结构，大多数的inode都存储在磁盘上。</strong></p>
<p><strong>可以用stat命令，查看某个文件的inode信息：</strong><br><code>stat example.txt</code></p>
<p>inode的大小：<br>inode会消耗硬盘空间，所以<strong>硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</strong><br>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令：</p>
<p><code>df -i</code></p>
<p>denty: 目录项，<strong>本质依然是结构体</strong>，重要成员变量:文件名，inode。文<strong>件内容(data)保存在磁盘块中。</strong></p>
<p><strong>增加文件的硬链接只是增加dentry, 指向相同的inode</strong></p>
<p>同样, <strong>删除硬链接也只是删除dentry, 要注意删除文件并不会让数据在磁盘消失, 只是OS丢失了inode, 磁盘只能覆盖, 不能擦除</strong>。</p>
<h4 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h4><p>stat函数作用:<strong>获取文件属性(从inode中获取)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, struct stat* statbuf)</span></span>;</span><br><span class="line"><span class="comment">//参数:</span></span><br><span class="line"><span class="comment">//path:文件路径;</span></span><br><span class="line"><span class="comment">//buf(传出参数)存放文件属性;</span></span><br><span class="line"><span class="comment">//返回值: 成功返回0, 失败返回-1并设置errno;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结构体信息*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">	<span class="keyword">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">	<span class="keyword">ino_t</span>     st_ino;         <span class="comment">/* Inode number */</span></span><br><span class="line">	<span class="keyword">mode_t</span>    st_mode;        <span class="comment">/* File type and mode */</span></span><br><span class="line">	<span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">	<span class="keyword">uid_t</span>     st_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">	<span class="keyword">gid_t</span>     st_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">	<span class="keyword">dev_t</span>     st_rdev;        <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">	<span class="keyword">off_t</span>     st_size;        <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">	<span class="keyword">blksize_t</span> st_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">	<span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Since Linux 2.6, the kernel supports nanosecond precision for the following timestamp fields.For the details before Linux 2.6, see NOTES. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>利用stat获取文件大小:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	ret=stat(argv[<span class="number">1</span>],&amp;sbuf);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"stat error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"file size:%ld\n"</span>,sbuf.st_size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用宏函数获取文件属性:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	ret=stat(argv[<span class="number">1</span>],&amp;sbuf);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"stat error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*宏函数一般返回布尔值*/</span></span><br><span class="line">	<span class="keyword">if</span>(S_ISREG(sbuf.st_mode))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"It's a regular\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(sbuf.st_mode))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"It's a dir\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(S_ISFIFO(sbuf.st_mode))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"It's a pipe\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(S_ISLNK(sbuf.st_mode))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"It's a symbol"</span>);</span><br><span class="line">	<span class="comment">/*and so on...*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lstat"><a href="#lstat" class="headerlink" title="lstat"></a>lstat</h4><p><code>ln -s makefile makefile.soft</code>:创建软连接</p>
<p><code>mkfifo f1</code>:创建管道文件</p>
<p><strong>stat穿透: 当用stat获取软连接的文件属性时, 会穿透符号连接直接返回软连接指向的本尊的文件属性</strong>(vim,cat命令也有穿透作用)</p>
<p>解决方法: 换lstat函数</p>
<p>S_IFMT是一个文件类型掩码(文件类型那四位全1), st_mode与它位与后就可以提取出文件类型(后面的权限位被归零)</p>
<h4 id="link和unlink"><a href="#link和unlink" class="headerlink" title="link和unlink"></a>link和unlink</h4><p>特殊权限位：包含三个二进制位。依次是：设置组ID位：setGID; 设置用户ID位setID; 黏住位sticky</p>
<p>黏住位： 早期计算机内存紧张<strong>，只有精要的常用的程序可以常驻物理内存，剩下的要暂存在磁盘中。**</strong>当内存不够的时候会将该部分程序存回磁盘，腾出内存空间。若文件设置了黏住位，即使在内存比较吃紧的情况下也不会将该文件回存到磁盘上。**现阶段操作系统的虚拟内存管理分页算法比较完善，该功能已经被废弃。</p>
<p>仍然可以<strong>对目录设置黏住位。</strong>被设置了该位的目录，其内部文件只有：</p>
<ul>
<li>超级管理员</li>
<li>该目录所有者</li>
<li>改文件的所有者</li>
</ul>
<p>这三种用户有权限做删除、修改操作。其他用户可以读、创建，但不能随意删除。</p>
<p>link函数</p>
<p><strong>可以为已经存在的文件创建目录项(硬链接)</strong></p>
<p><code>ln makefile makefile.hard</code>:为makefile创建硬连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用link和unlink函数实现mv命令:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	ret=link(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"link error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret=unlink(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"unlink error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Linux下的文件删除机制: 不断的将文件的st_nlink-1, 直到减到0为止. 无目录项对应的文件, 会被操作系统择机释放</strong>。因此删除文件, 从某种意义上来说只是让文件具备了被删除的条件</p>
<p>unlink函数的特征:<strong>清除文件时, 如果文件的硬连接计数减到了0, 没有dentry与之对应, 但该文件仍不会马上被释放掉. 要等到所有打开该文件的进程关闭该文件, 系统才会择机将文件释放。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span>* p=<span class="string">"test of unlink\n"</span>;</span><br><span class="line">	<span class="keyword">char</span>* p2=<span class="string">"after write something\n"</span>;</span><br><span class="line"></span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">"temp.txt"</span>,O_RDWR|O_TRUNC|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"open file error"</span>);</span><br><span class="line"></span><br><span class="line">	ret=<span class="built_in">write</span>(fd,p,<span class="built_in">strlen</span>(p));</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"write error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello,I'm printf\n"</span>);</span><br><span class="line">	ret=<span class="built_in">write</span>(fd,p2,<span class="built_in">strlen</span>(p2));</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"write error"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Entry key to continue\n"</span>);</span><br><span class="line">    <span class="comment">/*程序在此阻塞等待用户输入*/</span></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="comment">/*删除该文件*/</span></span><br><span class="line">	ret=unlink(<span class="string">"temp.txt"</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"unlink error"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果在unlink之前诱发段错误, 程序崩溃, temp.txt就会存活下来. 所以将unlink这一步放到打开文件之后紧接着就unlink掉</strong></p>
<p><strong>虽然文件被unlink掉了, 用户用cat查看不到磁盘上的对应文件, 但是write函数拿到fd写文件是向内核的buffer中写, 仍可正常写入</strong></p>
<p>隐式回收:</p>
<p>当<strong>进程运行结束时, 所有该进程打开的文件会被关闭, 申请的内存空间会被释放</strong>, 系统的这一特性称为<strong>隐式回收系统资源</strong></p>
<h4 id="文件目录权限"><a href="#文件目录权限" class="headerlink" title="文件目录权限"></a>文件目录权限</h4><p><code>readlink m1.soft</code>:查看软连接的内容</p>
<p>Linux下所见皆文件, 如果用vim打开一个目录，目录也是”文件”。文件内容是该目录下所有子文件的目录项dentry。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>r</th>
<th>w</th>
<th>x</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件</td>
<td>文件内容可以被查看，cat、more、less…</td>
<td>内容可以被修改vi…</td>
<td>运行产生一个进程 ./文件名</td>
</tr>
<tr>
<td>目录</td>
<td>目录可以被浏览</td>
<td>创建、删除、修改文件mv, touch, mkdir…</td>
<td>可以被打开、进入 cd</td>
</tr>
</tbody>
</table>
</div>
<h4 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h4><p>文件名不能超过255个字符, 引文dirent中的d_name长度为256, 再算上\0, 有255个字符可用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR* <span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;	<span class="comment">/*返回的是一个目录结构体指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR* dirp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct dirent* <span class="title">readdir</span><span class="params">(DIR* dirp)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">	<span class="keyword">ino_t</span>          d_ino;       <span class="comment">/* Inode number */</span></span><br><span class="line">	<span class="keyword">off_t</span>          d_off;       <span class="comment">/* Not an offset; see below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;    <span class="comment">/* Length of this record */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>  d_type;      <span class="comment">/* Type of file; not supported by all filesystem types */</span></span><br><span class="line">	<span class="keyword">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用目录操作函数实现ls的功能:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	DIR* dp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">sdp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*根据输入的内容打开一个目录文件,拿到一个类似文件描述符的东西dp*/</span></span><br><span class="line">	dp=opendir(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span>(dp==<span class="literal">NULL</span>)</span><br><span class="line">		perr_exit(<span class="string">"opendir error"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*循环从dirent流中读取数据*/</span></span><br><span class="line">	<span class="keyword">while</span>((sdp=readdir(dp))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">/*跳过当前目录和上一级目录*/</span></span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">"."</span>))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">".."</span>))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/*打印文件名*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,sdp-&gt;d_name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*关闭文件*/</span></span><br><span class="line">	closedir(dp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归遍历目录"><a href="#递归遍历目录" class="headerlink" title="递归遍历目录"></a>递归遍历目录</h4><p>思路：</p>
<ul>
<li><p>判断命令行参数, 获取用户要查询的目录名-argv[1]</p>
<ul>
<li>注意如果argc==1, 说明要查询的是当前目录./</li>
</ul>
</li>
<li><p>判断用户指定的是否是目录: stat S_ISDIR()-&gt;封装函数isFile()</p>
</li>
<li>读目录:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">opendir(dir);	</span><br><span class="line"><span class="keyword">while</span>(readdir())&#123;</span><br><span class="line">	普通文件:直接打印;</span><br><span class="line">	目录文件:拼接目录访问绝对路径:<span class="built_in">sprintf</span>(path,<span class="string">"%s%s"</span>,dir,d_name);</span><br><span class="line">	递归调用自己:opendir(path), readdir, closedir;</span><br><span class="line">&#125;</span><br><span class="line">closedir();</span><br></pre></td></tr></table></figure>
<p>实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*参2是回调函数名*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fetchdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dir,<span class="keyword">void</span>(*fcn)(<span class="keyword">char</span>*))</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[PATH_LEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">sdp</span>;</span></span><br><span class="line">	DIR* dp;</span><br><span class="line">	<span class="comment">/*打开目录失败*/</span></span><br><span class="line">	<span class="keyword">if</span>((dp=opendir(dir))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"fetchdir:can't open %s\n"</span>,dir);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*循环读取内容*/</span></span><br><span class="line">	<span class="keyword">while</span>((sdp=readdir(dp))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">/*遇到当前目录和上一级目录,跳过,否则会陷入死循环*/</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">"."</span>)==<span class="number">0</span>)||(<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">".."</span>)==<span class="number">0</span>))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/*路径名是否越界*/</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strlen</span>(dir)+<span class="built_in">strlen</span>(sdp-&gt;d_name)+<span class="number">2</span>&gt;<span class="keyword">sizeof</span>(name))&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"fetchdir:name %s %s is too long\n"</span>,dir,sdp-&gt;d_name);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/*拼接为一个路径,传给isFile函数*/</span></span><br><span class="line">			<span class="built_in">sprintf</span>(name,<span class="string">"%s/%s"</span>,dir,sdp-&gt;d_name);</span><br><span class="line">			(*fcn)(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	closedir(dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isFile</span><span class="params">(<span class="keyword">char</span>* name)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="comment">/*获取文件属性失败*/</span></span><br><span class="line">	<span class="keyword">if</span>(stat(name,&amp;sbuf)==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"isFile:can't access %s\n"</span>,name);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*这是一个目录文件:调用函数fetchdir*/</span></span><br><span class="line">	<span class="keyword">if</span>((sbuf.st_mode&amp;S_IFMT)==S_IFDIR)&#123;</span><br><span class="line">		fetchdir(name,isFile);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*不是目录文件:是一个普通文件,打印文件信息*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%ld\t\t%s\n"</span>,sbuf.st_size,name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="comment">/*不指定命令行参数*/</span></span><br><span class="line">	<span class="keyword">if</span>(argc==<span class="number">1</span>)</span><br><span class="line">		isFile(<span class="string">"."</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(--argc&gt;<span class="number">0</span>)</span><br><span class="line">			isFile(*++argv);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="dup和dup2"><a href="#dup和dup2" class="headerlink" title="dup和dup2"></a>dup和dup2</h4><p><code>cat makefile &gt; m1</code>:将cat的结果重定向到m1(此时m1与makefile内容相同)</p>
<p><code>cat makefile &gt;&gt; m1</code>:将cat的结果重定向并追加到m1后面(此时m1是双份的makefile)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The dup() system call creates a copy of the file descriptor oldfd, using the lowest-numbered unused file descriptor for the new descriptor.</p>
</blockquote>
<p>传入已有的文件描述符, 返回一个新的文件描述符:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">/*open或创建一个文件,拿到文件描述符fd1*/</span></span><br><span class="line">        <span class="keyword">int</span> fd1=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd1==<span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">"open error"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*fd2作为fd1的副本,拿着fd2也可以向被open的文件写入*/</span></span><br><span class="line">        <span class="keyword">int</span> fd2=dup(fd1);</span><br><span class="line">        <span class="keyword">if</span>(fd2==<span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">"dup error"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fd1=%d  fd2=%d\n"</span>,fd1,fd2);</span><br><span class="line">        <span class="comment">/*向fd2(fd1)中写入一句话*/</span></span><br><span class="line">        <span class="built_in">write</span>(fd2,<span class="string">"love you\n"</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dup的返回值fd2相当于fd1的副本, 拿着它也可以操作fd1</strong></p>
<p>dup2<strong>:后面的指向前面的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd1=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd2=<span class="built_in">open</span>(argv[<span class="number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">        <span class="comment">/*dup2后fd2也指向了fd1的文件*/</span></span><br><span class="line">        <span class="keyword">int</span> fdret=dup2(fd1,fd2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fdret=%d\n"</span>,fdret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret=<span class="built_in">write</span>(fd2,<span class="string">"love you\n"</span>,<span class="number">9</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ret=%d\n"</span>,ret);</span><br><span class="line">        <span class="comment">/*现在标准输出也指向了fd1*/</span></span><br><span class="line">        dup2(fd1,STDOUT_FILENO);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"--------love you--------\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fcntl实现dup描述符"><a href="#fcntl实现dup描述符" class="headerlink" title="fcntl实现dup描述符"></a>fcntl实现dup描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd1=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fd1=%d\n"</span>,fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newfd1=fcntl(fd1,F_DUPFD,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"newfd1=%d\n"</span>,newfd1);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> newfd2=fcntl(fd1,F_DUPFD,<span class="number">8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"newfd2=%d\n"</span>,newfd2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret=<span class="built_in">write</span>(newfd2,<span class="string">"fuckyou\n"</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ret=%d\n"</span>,ret);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fcntl 参3传0, 则从0开始向下寻找可用的文件描述符返回给newfd1</span></span><br><span class="line"><span class="comment">//fcntl 参3传8, 则从8开始向下寻找可用的文件描述符返回给newfd2</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShifuDong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShifuDong</p>
  <div class="site-description" itemprop="description">记录生活， 记录学习， 分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/mailto:sfd_w@foxmail.com" title="E-Mail → mailto:sfd_w@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShifuDong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  



    </div>
</body>
</html>
