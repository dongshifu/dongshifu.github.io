<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ShifuDong" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="记录生活， 记录学习， 分享知识">
<meta name="keywords" content="生活，C++, C, go, java, OS, 网络， 存储， 联邦学习， 机器学习，python">
<meta property="og:type" content="website">
<meta property="og:title" content="ShifuDong">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;4&#x2F;index.html">
<meta property="og:site_name" content="ShifuDong">
<meta property="og:description" content="记录生活， 记录学习， 分享知识">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ShifuDong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShifuDong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Knowledge Sharing</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/28/linux-%E7%B3%BB%E7%BB%9F-08%E4%BF%A1%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/28/linux-%E7%B3%BB%E7%BB%9F-08%E4%BF%A1%E5%8F%B7/" class="post-title-link" itemprop="url">linux系统-信号</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-28 16:54:01" itemprop="dateCreated datePublished" datetime="2020-03-28T16:54:01+08:00">2020-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-26 15:33:59" itemprop="dateModified" datetime="2021-03-26T15:33:59+08:00">2021-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="基本概念及机制"><a href="#基本概念及机制" class="headerlink" title="基本概念及机制"></a>基本概念及机制</h4><p>信号的共性:</p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足特性条件才能发送</li>
</ul>
<p>特质：A给B发送信号，B收到信号之前执行自己的代码，<strong>收到信号后，不管执行到程序的什么位置，都要暂停运行去处理信号，处理完毕之后再继续执行。</strong>与硬件中断类似——异步模式。但信号是软件层面上的实现的中断，早期被称为”软中断”。</p>
<p>信号的特质：由于<strong>信号通过软件方法实现，其实现手段导致信号有很强的延时性</strong>。但对于用户来说，这个延迟时间非常短，不易察觉。</p>
<p><strong>所有信号的产生和处理, 都是由内核完成的</strong>。</p>
<h4 id="与信号相关的事件和状态"><a href="#与信号相关的事件和状态" class="headerlink" title="与信号相关的事件和状态"></a>与信号相关的事件和状态</h4><p>产生信号:</p>
<ul>
<li><p><strong>按键</strong>产生:<code>Ctrl+c, Ctrl+z, Ctrl+\</code></p>
</li>
<li><p><strong>系统调用</strong>产生:<code>kill, raise, abort</code></p>
</li>
<li><p><strong>软件条件产生</strong>:定时器<code>alarm</code></p>
</li>
<li><p><strong>硬件异常</strong>产生:非法访问内存(段错误), 除0(浮点数例外), 内存对齐错误(总线错误);</p>
</li>
<li><p><strong>命令</strong>产生:<code>kill</code>命令</p>
</li>
</ul>
<p>递达: 内核发出的信号<strong>递送并且到达</strong>进程</p>
<p>未决: 产生和递达之间的状态, 主要由于<strong>阻塞(屏蔽)导致该状态</strong></p>
<p>信号的处理方式:</p>
<ul>
<li><p>执行<strong>默认动作</strong></p>
</li>
<li><p><strong>丢弃</strong>(忽略)</p>
</li>
<li><p><strong>捕捉</strong>(调用户处理函数)</p>
</li>
</ul>
<h4 id="信号屏蔽字和未决信号集"><a href="#信号屏蔽字和未决信号集" class="headerlink" title="信号屏蔽字和未决信号集"></a>信号屏蔽字和未决信号集</h4><p>Linux内核的进程控制块PCB是一个结构体，<code>task_struct</code>除了包含进程<code>id</code>，状态，工作目录，用户<code>id</code>，组<code>id</code>，文件描述符，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。</p>
<p>阻塞态：用<strong>阻塞信号集（信号屏蔽字）</strong>来描述</p>
<p><code>PCB</code>中<strong>阻塞信号集影响未决信号集</strong></p>
<p>阻塞信号集（信号屏蔽字）<strong>：将某些信号加入集合，对他们设置屏蔽，当屏蔽<code>x</code>信号后，再收到该信号，该信号的处理将推后（解除屏蔽字后）</strong></p>
<p>未决信号集：</p>
<ul>
<li>信号产生，<strong>未决信号集中描述该信号的位立刻翻转为1,表示信号处于未决状态，当信号被处理后，对应位翻转回为0，</strong>这一时刻往往非常短暂。</li>
<li><strong>信号产生后由于某些原因（主要是阻塞）不能抵达</strong>。这类信号的集合称为未决信号集。在屏蔽解除前，信号一直处于未决状态。</li>
</ul>
<h4 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h4><ul>
<li><p>编号：信号有自己的编号，不存在为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号）。34-64为实时信号，驱动编程与硬件相关，名字上区别不大。而前32个名字各不相同。</p>
</li>
<li><p>名称</p>
</li>
<li><p>事件</p>
</li>
<li><p>默认处理动作</p>
<ul>
<li>Term：终止进程</li>
<li>Ign：<strong>忽略</strong>信号（默认即时对该种信号忽略操作）</li>
<li>Core：<strong>终止</strong>进程，生成Core文件（查验进程死亡原因，用于gdb调试）</li>
<li>Stop：停止（<strong>暂停</strong>）进程</li>
<li>Cont：<strong>继续运行</strong>进程</li>
</ul>
</li>
</ul>
<p><code>man 7 signal</code>可以查看帮助文档</p>
<p><strong>特别强调：9)SIGKILL和19)SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其其设置为阻塞。</strong></p>
<p>只有每个信号所对应的事件发生了, 该信号才会被递送(但不一定递达), 不应该乱发信号</p>
<h4 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h4><p>给指定进程发送指定信号（不一定杀死）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;<span class="comment">//成功：0， 失败：-1（ID非法，普通用户杀init进程等权级问题），设置errno</span></span><br><span class="line"><span class="comment">//sig:不推荐使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致</span></span><br><span class="line"><span class="comment">//pid &gt;0; //发送信号给指定的进程</span></span><br><span class="line"><span class="comment">//pid = 0; //发送信号给与调用kill函数进程属于同一进程组的所有进程</span></span><br><span class="line"><span class="comment">//pid &lt; 0;//取|pid|发给对应进程组:kill -9 -10698 :杀死10698进程组的所有进程;</span></span><br><span class="line"><span class="comment">//pid = -1;//发送给进程有权限发送的系统中所有进程</span></span><br></pre></td></tr></table></figure>
<p>进程组：每个进程都属于一个进程组，<strong>进程组是一个或多个进程集合，它们互相关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组<code>ID</code>与进程组长<code>ID</code>相同。</strong></p>
<p>权限保护：<strong><code>super</code>用户（<code>root</code>）可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。<code>kill -9</code> (<code>root</code>用户的<code>pid</code>)是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。只能向自己创建的进程发送信号，普通用户基本规则是：发送者实际或有效用户<code>ID == 接收者实际或有效用户ID</code>。</strong></p>
<h4 id="raise和abort函数"><a href="#raise和abort函数" class="headerlink" title="raise和abort函数"></a>raise和abort函数</h4><p><code>raise</code>函数：给当前进程发送指定信号（自己给自己发）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">raise(signo) == kill(getpid(), signo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;<span class="comment">//成功：0</span></span><br></pre></td></tr></table></figure>
<p><code>abort</code>函数：给自己发送异常终止信号。<code>SIGABRT</code>信号，终止并产生core文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//该函数无返回</span></span><br></pre></td></tr></table></figure>
<h4 id="软件条件产生信号（定时产生信号）"><a href="#软件条件产生信号（定时产生信号）" class="headerlink" title="软件条件产生信号（定时产生信号）"></a>软件条件产生信号（定时产生信号）</h4><p><code>alarm</code>函数：设置定时器（闹钟），在指定<code>seconds</code>后，内核会给当前进程发送<code>14)SIGALRM</code>信号。<strong>进程收到该信号，默认动作终止</strong>。</p>
<p><strong>每个进程都有且只有唯一个定时器。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;<span class="comment">//返回0或剩余的秒数，无失败</span></span><br></pre></td></tr></table></figure>
<p>常用：取消定时器<code>alarm(0)</code>,返回旧闹钟余下秒数</p>
<p><strong>定时，与进程无关（自然定时法）！无论进程处于何种状态（就绪、运行、挂起、终止、僵尸…)，<code>alarm</code>都计时</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试一秒钟数多少个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用time命令测试程序运行时间</span></span><br><span class="line"><span class="comment">//real    0m1.003s</span></span><br><span class="line"><span class="comment">//user    0m0.074s</span></span><br><span class="line"><span class="comment">//sys     0m0.217s</span></span><br></pre></td></tr></table></figure>
<p><code>time ./alarm</code>可以统计<code>alarm</code>的运算时间。</p>
<p>使用<code>time</code>命令查看程序执行的时间。<strong>程序运行的瓶颈在<code>IO</code>，优化程序，首先优化<code>IO</code></strong></p>
<p><strong>实际执行时间 = 系统时间+用户时间+等待时间</strong></p>
<p><code>setitimer</code>函数：<strong>设置定时器（闹钟），可以替代<code>alarm</code>函数，精度微秒<code>（us）</code>，可以实现周期定时</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getitimer</span><span class="params">(<span class="keyword">int</span> which, struct itimerval *curr_value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">const</span> struct itimerval *new_value, struct itimerval *old_value)</span></span>;</span><br><span class="line"><span class="comment">//参数which:指定定时方式。</span></span><br><span class="line"><span class="comment">//自然定时：ITIMER_REAL:14) SIGLARM 计算自然定时</span></span><br><span class="line"><span class="comment">//虚拟空间计时（用户空间，只计算进程占用CPU的时间）：ITIMER_VIRTUAL 26) SIGVIRTUAL 只计算进程占用cpu时间</span></span><br><span class="line"><span class="comment">//运行时计时（用户+内核）： ITIMER_PROF 27)SIGPROF 计算cpu及执行系统调用的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*精确到us的时间结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="keyword">time_t</span>	tv_sec;        		 <span class="comment">/* seconds */</span></span><br><span class="line">	<span class="keyword">suseconds_t</span>	tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><p><code>it_interva</code>l :用来设定<strong>两次定时任务之间间隔的时间</strong></p>
</li>
<li><p><code>it_value</code>:<strong>定时的时长</strong></p>
</li>
<li><p>两个参数都设置为0,即清0操作</p>
</li>
</ul>
<p>signal捕捉信号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*信号捕捉回调函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello signal\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*it为传入参数,进行初始化*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">    <span class="comment">//信号捕捉函数是一个回调函数</span></span><br><span class="line">    signal(SIGALRM, myfun);<span class="comment">//注册SIGALRM信号的捕捉处理函数，捕捉由内核完成</span></span><br><span class="line"></span><br><span class="line">    it.it_value.tv_sec = <span class="number">5</span>;</span><br><span class="line">    it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    it.it_interval.tv_sec = <span class="number">3</span>;</span><br><span class="line">    it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(setitimer(ITIMER_REAL,&amp;it, &amp;oldit) == <span class="number">-1</span>) <span class="comment">//自然定时</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"settimer error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*手动让程序阻塞*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h3><p>内核通过<strong>读取未决信号集来判断信号是否应该被处理，信号屏蔽字<code>mask</code>可以影响未决信集</strong>。可以在应用程序中<strong>自定义<code>set</code>来改变<code>mask</code>以达到屏蔽指定信号的目的。</strong></p>
<h4 id="操作信号集的若干步骤"><a href="#操作信号集的若干步骤" class="headerlink" title="操作信号集的若干步骤"></a>操作信号集的若干步骤</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建一个自定义信号集*/</span></span><br><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"><span class="comment">/*清空自定义信号集*/</span></span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">/*向自定义信号集添加信号*/</span></span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"><span class="comment">/*用自定义信号集操作内核信号集*/</span></span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">/*查看未决信号集*/</span></span><br><span class="line">sigpending(&amp;myset);</span><br></pre></td></tr></table></figure>
<h4 id="信号集设定"><a href="#信号集设定" class="headerlink" title="信号集设定"></a>信号集设定</h4><p><code>sigset_t</code> 类型的本质是<strong>位图</strong>。但不应该直接使用位操作，而应该使用下列函数，<strong>保证跨系统操作有效</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>; <span class="comment">//typedef unsigned long sigset_t</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//将某个信号集清0,成功0,失败-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//将某个信号集置1, 成功0,失败-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;<span class="comment">//将某个信号加入信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;<span class="comment">//将某个信号清出信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;<span class="comment">//判断某个信号是否在信号集中，返回值：在集合：1,不在集合：0</span></span><br></pre></td></tr></table></figure>
<h4 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h4><p>用来<strong>屏蔽信号、解除屏蔽</strong>也使用该函数。其<strong>本质为读取或修改进程的信号屏蔽字(<code>PCB</code>中).</strong></p>
<p>注意：<strong>屏蔽信号只是将信号处理延后执行（延至解除屏蔽），而忽略表示将信号丢弃处理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> sigset *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;<span class="comment">//成功，0,失败-1,设置errno</span></span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//how参数取值：假设当前的信号屏蔽字为mask</span></span><br><span class="line"><span class="comment">//1.SIG_BLOCK:当how设置为此值，set表示需要屏蔽的信号。相当于mask = mask|set(设置阻塞, set表示需要屏蔽的信号)</span></span><br><span class="line"><span class="comment">//2.SIG_UNBLOCK:当how设置为此值，set表示需要解除屏蔽的信号，相当于mask = mask&amp;~set(设置非阻塞, set表示需要解除屏蔽的信号;)</span></span><br><span class="line"><span class="comment">//3.SIG_SETMASK:set表示用于替代原始屏蔽集的新屏蔽集：相当于mask = set。若调用sigprocmask解除了对当前若干个信号的阻塞。则在sigprocmask返回前，至少将其中一个信号递达。(用set替换原始屏蔽集)</span></span><br><span class="line"><span class="comment">//set：传入参数，是一个位图，set中哪个位置为1,就表示当前进程屏蔽哪个信号</span></span><br><span class="line"><span class="comment">//oldset:传出参数，保留旧的信号屏蔽集</span></span><br></pre></td></tr></table></figure>
<h4 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h4><p><strong>读取当前进程的未决信号集</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(sigset *<span class="built_in">set</span>)</span> </span>;<span class="comment">//set传出参数。</span></span><br><span class="line"><span class="comment">//返回：成功:0，失败-1,设置errno</span></span><br></pre></td></tr></table></figure>
<p>打印未决信号集：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printped</span><span class="params">(<span class="keyword">sigset_t</span> *ped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;<span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sigismember(ped,i) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> myset, ped, oldset; <span class="comment">//自定义集合类型</span></span><br><span class="line">    sigemptyset(&amp;myset);	<span class="comment">/*清空自定义信号集*/</span></span><br><span class="line">    sigaddset(&amp;myset,SIGQUIT);<span class="comment">/*向自定义信号集添加信号*/</span></span><br><span class="line">    sigaddset(&amp;myset,SIGINT); <span class="comment">//程序终止信号，通常Ctrl+c</span></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;myset, &amp;oldset);<span class="comment">/*用自定义信号集操作内核信号集*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sigpending(&amp;ped);</span><br><span class="line">        printped(&amp;ped);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简易信号捕捉"><a href="#简易信号捕捉" class="headerlink" title="简易信号捕捉"></a>简易信号捕捉</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catchsigint</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------catch\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sighandler_t</span> handler;</span><br><span class="line">    handler = signal(SIGINT,catchsigint);</span><br><span class="line">    <span class="keyword">if</span>(handler == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"signal error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sigaction函数注册捕捉"><a href="#sigaction函数注册捕捉" class="headerlink" title="sigaction函数注册捕捉"></a>sigaction函数注册捕捉</h4><p><strong>sigaction函数的功能是检查或修改与指定信号相关联的处理动作（可同时两种操作）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction* act, struct sigaction* oldact)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);	<span class="comment">//不用</span></span><br><span class="line">	<span class="keyword">sigset_t</span>   sa_mask;		<span class="comment">//只工作于信号捕捉函数执行期间,相当于中断屏蔽</span></span><br><span class="line">	<span class="keyword">int</span>        sa_flags;	<span class="comment">//本信号默认屏蔽</span></span><br><span class="line">	<span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);			<span class="comment">//废弃</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">docatch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d signal is catched\n"</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = docatch;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaddset(&amp;act.sa_mask,SIGQUIT);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;<span class="comment">//默认属性，信号捕捉函数执行期间自动屏蔽本信号</span></span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGINT,&amp;act,<span class="literal">NULL</span>); <span class="comment">//程序终止信号</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a>信号捕捉特性</h4><ul>
<li><p>进程正常运行时，默认<strong>PCB中有一个信号屏蔽字</strong>，假定为<code>x</code>，它<strong>决定了进程自动屏蔽哪些信号</strong>。当注册了某个信号捕捉函数，捕捉到该信号之后，要调用该函数。而该函数有可能执行很长时间，<strong>在这期间所屏蔽的信号不能由<code>x</code>来指定。而是用<code>sa_mask</code>来指定。调用完信号处理函数，再次恢复为<code>x</code></strong>(<strong>捕捉函数执行期间, 信号屏蔽字由<code>mask</code>变为<code>sigaction</code>结构体中的<code>sa_mask</code>, 捕捉函数执行结束后, 恢复回<code>mask</code></strong>)。</p>
</li>
<li><p><code>xxx</code>信号捕捉函数执行期间，<code>xxx</code>信号自动被屏蔽(捕捉函数执行期间, 本信号自动被屏蔽(<code>sa_flags=0</code>);)</p>
</li>
<li>阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）(<strong>捕捉函数执行期间, 若被屏蔽信号多次发送, 解除屏蔽后只响应一次</strong>)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">docatch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d signal is catched\n"</span>,signo);</span><br><span class="line">    sleep(<span class="number">10</span>); <span class="comment">//模拟信号捕捉函数执行时间很长</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"finish\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = docatch;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaddset(&amp;act.sa_mask,SIGQUIT);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;<span class="comment">//默认属性，信号捕捉函数执行期间自动屏蔽本信号</span></span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGINT,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内核实现信号捕捉过程："><a href="#内核实现信号捕捉过程：" class="headerlink" title="内核实现信号捕捉过程："></a>内核实现信号捕捉过程：</h4><p><img src="https://api2.mubu.com/v3/document_image/59beec01-cbf6-47bc-b417-05caf5134bab-11197877.jpg" alt="signal_catch"></p>
<p>为什么执行完信号处理函数后要再次进入内核?<strong>因为信号处理函数是内核调用的, 函数执行完毕后要返回给调用者。</strong></p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><h4 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a>pause函数</h4><p>调用该函数可以<strong>造成进程主动挂起，等待信号唤醒</strong>。<strong>调用该系统调用的进程将处于阻塞状态（主动放弃<code>cpu</code>）直到信号递达将其唤醒。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span> </span>;<span class="comment">//返回值：-1并设置errno为EINTR</span></span><br><span class="line"><span class="comment">/*返回值：</span></span><br><span class="line"><span class="comment">如果信号的默认处理动作为终止进程，则进程终止，pause函数没有机会返回</span></span><br><span class="line"><span class="comment">如果信号的默认处理动作是忽略，进程继续处于挂起状态，pause函数不返回</span></span><br><span class="line"><span class="comment">如果信号的处理动作是捕捉，则调用完信号处理函数后，pause返回-1。errno设置为EINTR，表示信号被中断</span></span><br><span class="line"><span class="comment">pause收到的信号不能被屏蔽，如果被屏蔽，那么puase就不能被唤醒</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>使用<code>pause</code>和<code>alarm</code>来实现<code>sleep</code>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_sigalrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"catched\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    act.sa_handler = catch_sigalrm;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGALRM,&amp;act,&amp;oldact);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(seconds);</span><br><span class="line">    ret = pause();<span class="comment">//主动挂起，等待信号</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pause success\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = alarm(<span class="number">0</span>);<span class="comment">//闹钟清0</span></span><br><span class="line">    sigaction(SIGALRM,&amp;oldact,<span class="literal">NULL</span>);<span class="comment">//恢复SIGALRM信号旧有的处理方式</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mysleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----------\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时序竞态"><a href="#时序竞态" class="headerlink" title="时序竞态"></a>时序竞态</h4><p>时序问题分析：</p>
<p>借助<code>pause</code>和<code>alarm</code>实现的<code>mysleep</code>函数，设想如下时序：</p>
<ul>
<li>注册<code>SIGALRM</code>信号处理函数（<code>sigaction...</code>）</li>
<li>调用<code>alarm(1)</code>函数设定闹钟1秒</li>
<li>函数调用刚结束，开始倒计时1秒，当前进程失去cpu，内核调度优先级高的进程（多个）取代当前进程，当前进程无法获得cpu，进入<strong>就绪态等待cpu</strong></li>
<li><strong>1秒后，闹钟超时，内核向当前进程发送<code>SIGALARM</code>信号（自然定时法，与进程状态无关），高优先级进程尚未执行完，当前进程仍处于就绪态，信号无法处理(未决)</strong></li>
<li>优先级高的进程执行完，当前进程获得cpu资源，内核调度回当前进程执行。<code>SIGALRM</code>信号递达，信号设置捕捉，执行处理函数<code>catch_sigalrm</code></li>
<li><strong>信号处理函数执行结束，返回当前进程主控流程，<code>pause()</code>被调用挂起等待。（欲等待<code>alarm</code>函数发送的<code>SIGALRM</code>信号将自己唤醒）</strong></li>
<li><strong><code>SIGALRM</code>信号已经处理完毕，<code>pause</code>不会等到。</strong></li>
</ul>
<h4 id="解决时序问题"><a href="#解决时序问题" class="headerlink" title="解决时序问题"></a>解决时序问题</h4><p>可以通过设置屏蔽<code>SIGALRM</code>的方法来控制程序执行逻辑，<strong>但无论如何设置，程序都有可能在“解除信号屏蔽”与“挂起等待信号”这两个操作间隙失去cpu资源</strong>。除非将这两步骤合并成一个“<strong>原子操作</strong>”，<strong><code>sigsuspend</code>函数具备这个功能。在对时序要求严格的场合下都应该使用<code>sigsuspend</code>替换<code>pause</code>。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *mask)</span></span>; <span class="comment">//挂起等待信号</span></span><br></pre></td></tr></table></figure>
<p><strong><code>sigsuspend</code>函数调用期间，进程信号屏蔽字由其参数<code>mask</code>指定。</strong></p>
<p><strong>程序执行过程的信号屏蔽字由<code>sigaction.sa_mask</code>决定，但在执行<code>sigsuspend</code>期间由传入的<code>mask</code>决定。</strong></p>
<p><strong>可将某个信号（如<code>SIGALRM</code>）从临时屏蔽字<code>mask</code>中删除，这样在调用<code>sigsuspend</code>时将解除对该信号的屏蔽，然后挂起等待，当<code>sigsubpend</code>返回时，进程的信号屏蔽字恢复为原来的值。如果原来对该信号是屏蔽态，<code>sigsuspend</code>函数返回后仍然屏蔽该信号字。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> newmask, oldmask, suspmask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为SIGALRM设置捕捉函数，一个空函数</span></span><br><span class="line">    newact.sa_handler = catch_sigalrm;</span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGALRM,&amp;newact, &amp;oldact);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置阻塞信号集，阻塞SIGALRM信号</span></span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask, SIGALRM);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask); <span class="comment">//信号屏蔽字 mask</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时n秒，到时可以产生SIGALRM信号</span></span><br><span class="line">    alarm(seconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造一个调用sigsuspend临时有效的阻塞信号集，</span></span><br><span class="line">    <span class="comment">//在临时阻塞信号集里解除SIGALRM的阻塞</span></span><br><span class="line">    suspmask = oldmask; <span class="comment">//SIGALRM没有被屏蔽</span></span><br><span class="line">    sigdelset(&amp;suspmask, SIGALRM); <span class="comment">//原来屏蔽字中可能有屏蔽</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//sigsuspend调用期间，采用临时阻塞信号集suspmask替换原有阻塞信号集合</span></span><br><span class="line">    <span class="comment">//这个信号集中不包含SIGALRM喜好，同时挂起等待</span></span><br><span class="line">    <span class="comment">//当sigsuspend被信号唤醒返回时，恢复原来的阻塞信号集</span></span><br><span class="line">    sigsuspend(&amp;suspmask);<span class="comment">//原子操作</span></span><br><span class="line">    unslept = alarm(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复SIGALRM原有的处理动作，呼应前面注释</span></span><br><span class="line">    sigaction(SIGALRM,&amp;oldact,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解除对SIGALRM的阻塞，呼应前面注释</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (unslept);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>竞态条件跟系统负载有很紧密的的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</strong></p>
<p>不可靠由其实现原理导致。<strong>信号是通过软件方式实现的（与内核调度高度依赖，延时性强），每次系统调用结束后，或中断处理结束后，需要扫描PCB中的未决信号集来判断是否应该处理某个信号，当系统负载过重时，会出现时序混乱</strong>。</p>
<p>这种意外情况只能出现在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补，且由于该错误不具规律性，后期捕捉和重现十分困难。</p>
<h4 id="可重入函数，不可重入函数"><a href="#可重入函数，不可重入函数" class="headerlink" title="可重入函数，不可重入函数"></a>可重入函数，不可重入函数</h4><p>一个函数在被调用执行期间(尚未调用结束)，由于某种时序又被重复调用，称为“重入”,根据函数实现的方法可分为”可重入函数”和“不可重入函数”。</p>
<p>注意事项：</p>
<ul>
<li>定义可重入函数，函数内部不能含有全局变量及<code>static</code>变量，不能使用<code>malloc,free</code></li>
<li>信号捕捉函数应设计为可重入函数</li>
<li>信号处理程序可以调用的可重入函数可参阅<code>man 7 signal</code></li>
</ul>
<h3 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a><code>SIGCHLD</code>信号</h3><h4 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h4><ul>
<li><strong>子进程终止</strong>时</li>
<li>子进程<strong>收到<code>SIGSTOP</code>信号停止</strong>时</li>
<li>子进程<strong>处在停止态，接受到<code>SIGCONT</code>后唤醒</strong>时</li>
</ul>
<h4 id="借助SIGCHLD信号回收子进程"><a href="#借助SIGCHLD信号回收子进程" class="headerlink" title="借助SIGCHLD信号回收子进程"></a>借助<code>SIGCHLD</code>信号回收子进程</h4><p>子进程结束运行，其<strong>父进程会收到<code>SIGCHLD</code>信号，该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收。</strong></p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((pid = waitpid(<span class="number">0</span>, &amp;status,WNOHANG))&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) <span class="comment">//WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"--------------child %d exit %d\n"</span>,pid,WEXITSTATUS(status)); <span class="comment">//当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)退出，WEXITSTATUS(status)就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。请注意，如果进程不是正常退出的，也就是说，WIFEXITED返回0，这个值就毫无意义</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status)) <span class="comment">// WIFSIGNALED(status)为非0 表明进程异常终止</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child %d cancle signal %d\n"</span>,pid, WTERMSIG(status)); <span class="comment">//通过WTERMSIG(status)获取使得进程退出的信号编号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//阻塞SIGCHLD</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sys_err(<span class="string">"fork"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">//10个子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child ID %d\n"</span>,getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//SIGCHLD阻塞</span></span><br><span class="line">        struct sigaction act;</span><br><span class="line">        act.sa_handler = do_sig_child;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//NULL解除对SIGCHLD的阻塞</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Parent ID %d\n"</span>,getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h4><p>系统调用可以分为两种：慢速系统调用和其他系统调用。</p>
<ul>
<li>慢速系统调用：<strong>可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就会被中断，</strong>不再继续执行(早期)。也可以设定系统调用是否重启。如<code>read、write、pause、wait...</code></li>
<li>其他系统调用：<code>getpid、getppid、fork</code></li>
</ul>
<p>结合<code>pause</code>,回顾慢速系统调用：</p>
<p>慢速系统调用被中断的相关行为。实际上就是<code>pause</code>的行为，如read:</p>
<ul>
<li>想中断<code>pause</code>，信号不能被屏蔽</li>
<li>信号的处理方式必须是捕捉（默认、忽略都不可以）</li>
<li>中断后返回-1,设置<code>errno</code>为<code>EINTR</code>(表示被信号中断)</li>
</ul>
<p>可以修改<code>sa_flags</code>参数来设置被信号中断后系统调用是否重启。<code>SA_INTERRURT</code>不重启，<code>SA_RESTART</code>重启。</p>
<p><code>sa_flags</code>还有很多可选参数，适用于不同情况。如：捕捉到信号后，在执行捕捉信号期间，不希望自动阻塞该信号，可将<code>sa_flags</code>设置为<code>SA_NODEFER</code>,除非<code>sa_mask</code>中包含该信号。</p>
<h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><p><strong>所有输入输出设备总称。</strong></p>
<p>终端启动流程：<code>init-&gt;fork-&gt;exec-&gt;getty</code>-&gt;用户输入帐号-&gt;<code>login</code>-&gt;输入密码-&gt;<code>exec</code>-&gt;<code>bash</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/27/linux-%E7%B3%BB%E7%BB%9F-07%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/27/linux-%E7%B3%BB%E7%BB%9F-07%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">linux系统-进程间通信</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-27 22:21:59" itemprop="dateCreated datePublished" datetime="2020-03-27T22:21:59+08:00">2020-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 16:54:55" itemprop="dateModified" datetime="2021-03-25T16:54:55+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="进程间通信常见方式"><a href="#进程间通信常见方式" class="headerlink" title="进程间通信常见方式"></a>进程间通信常见方式</h3><p><strong>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷贝到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信(<code>IPC,Inter Process Communication</code>).</strong></p>
<p>在进程间完成数据传递需要<strong>借助操作系统提供特殊的方法</strong>，如：文件、管道、信号、内存共享、消息队列、套接字、命名管道等。常用的进程间通信方式有：</p>
<ul>
<li>管道（使用最简单）<ul>
<li><code>pipe</code></li>
<li>管道的读写行为</li>
<li><code>fifo</code><ul>
<li>用于<strong>非血缘关系进程间通信</strong></li>
</ul>
</li>
</ul>
</li>
<li>信号（开销最小），<strong>只能携带固定的少量信息</strong></li>
<li>共享映射区<ul>
<li><code>mmap</code></li>
<li>函数的参数使用注意事项</li>
<li>用于<strong>非血缘关系的进程通信</strong></li>
</ul>
</li>
<li>本地套接字（最稳定）</li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>管道是一种最基本的<code>IPC</code>机制，<strong>作用于有血缘关系的进程之间，完成数据传递</strong>。调用<code>pipe</code>系统函数即可创建一个管道。有如下特质：</p>
<ul>
<li>其本质是一个<strong>伪文件</strong>（实为<strong>内核缓冲区</strong>）</li>
<li>有<strong>两个文件描述符引用</strong>，一个表示<strong>读端</strong>，一个表示<strong>写端</strong></li>
<li><strong>规定数据从管道的写端流入管道，从读端流出</strong></li>
</ul>
<p>管道的原理：管道实为内核使用<strong>环形队列机</strong>制，借助<strong>内核缓冲区</strong>(4K)实现。</p>
<p>管道的局限性：</p>
<ul>
<li>数据<strong>不能自己读自己写</strong></li>
<li><strong>数据一旦被读走，便不在管道中存在，不可反复读取</strong></li>
<li>由于管道采用<strong>半双工通信</strong>方式。因此数据<strong>只能在一个方向上流动</strong></li>
<li><strong>只能在有公共祖先的进程间使用管道</strong></li>
</ul>
<h4 id="管道使用方法"><a href="#管道使用方法" class="headerlink" title="管道使用方法"></a>管道使用方法</h4><p><code>pipe</code>函数: <strong>创建并打开</strong>管道。</p>
<p>函数调用成功返回<code>r/w</code>两个文件描述符，无需<code>open</code>,但需手动<code>close</code>。规定：<code>fd[0] :r, fd[1]:w</code>,  <strong>类似于0对应标准输入，1对应标准输出</strong>。<strong>向管道文件读写数据其实是在读写内核缓冲区。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*pipefd[0]-读端;</span></span><br><span class="line"><span class="comment">pipefd[1]-写端;</span></span><br><span class="line"><span class="comment">成功返回0, 失败返回-1并设置errno;*/</span></span><br></pre></td></tr></table></figure>
<p>刚<code>fork</code>完成时<strong>父进程关闭读端，子进程关闭写端，此时数据能在<code>pipe</code>中单向流动，父子进程能够完成通信</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span>* str=<span class="string">"loveyou\n"</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="comment">/*创建管道,文件描述符保存在数组里*/</span></span><br><span class="line">	ret=pipe(pipefd);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"pipe error"</span>);</span><br><span class="line"></span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">close</span>(pipefd[<span class="number">0</span>]);						<span class="comment">//父进程关闭读端</span></span><br><span class="line">		<span class="built_in">write</span>(pipefd[<span class="number">1</span>],str,<span class="keyword">sizeof</span>(str));		<span class="comment">//向管道中写入数据</span></span><br><span class="line">		<span class="built_in">close</span>(pipefd[<span class="number">1</span>]);						<span class="comment">//父进程关闭写端</span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">close</span>(pipefd[<span class="number">1</span>]);						<span class="comment">//子进程关闭写端</span></span><br><span class="line">		ret=<span class="built_in">read</span>(pipefd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));	<span class="comment">//从管道中读取数据</span></span><br><span class="line">		<span class="built_in">write</span>(STDOUT_FILENO,buf,ret);			<span class="comment">//写到标准输出打印</span></span><br><span class="line">		<span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="管道读写行为"><a href="#管道读写行为" class="headerlink" title="管道读写行为"></a>管道读写行为</h4><ul>
<li>读管道<ul>
<li><strong>管道中有数据：<code>read</code>返回实际读到的字节数</strong></li>
<li>管道中无数据：<ul>
<li><strong>写端全关闭：read返回0</strong></li>
<li><strong>写端没有被全部关闭</strong>（仍有写端打开）, <strong><code>read</code>阻塞等待(不久的将来可能会有数据抵达, 此时会让出CPU</strong></li>
</ul>
</li>
</ul>
</li>
<li>写管道<ul>
<li><strong>管道读端全部被关闭, 进程异常终止</strong>(也可以捕捉<code>SIGPIPE</code>信号, 使进程不终止)</li>
<li>有读端打开<ul>
<li>管道未满：<strong>写数据，<code>write</code>将数据写入，返回写入字节数</strong></li>
<li>管道已满，<code>write</code>阻塞（少见）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>获取管道缓冲区大小： <code>ulimit -a</code></p>
<p><strong>父子进程</strong>通信练习：实现 <code>ls | wc -l</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要使用exec(), dup2(), pipe()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret=pipe(fd);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"pipe error"</span>);</span><br><span class="line"></span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*父进程先读管道,如果子进程还没起来,他就会阻塞,这样子进程就会先于父进程结束*/</span></span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">		dup2(fd[<span class="number">0</span>],STDIN_FILENO);</span><br><span class="line">		execlp(<span class="string">"wc"</span>,<span class="string">"wc"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line">		perr_exit(<span class="string">"execlp wc error"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*子进程写管道*/</span></span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">		dup2(fd[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line">		execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="literal">NULL</span>);</span><br><span class="line">		perr_exit(<span class="string">"execlp ls error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>兄弟进程间通信：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*创建管道*/</span></span><br><span class="line">	ret=pipe(fd);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"pipe error"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*循环创建2个子进程*/</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)&#123;</span><br><span class="line">		pid=fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">			perr_exit(<span class="string">"fork error"</span>);</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*父进程关闭管道读写两端*/</span></span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*兄进程关闭读端,将STDOUT指向fd[1]*/</span></span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">		dup2(fd[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line">		execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="literal">NULL</span>);</span><br><span class="line">		perr_exit(<span class="string">"execlp ls error"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">/*弟进程关闭写端,将STDIN指向fd[0]*/</span></span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">		dup2(fd[<span class="number">0</span>],STDIN_FILENO);</span><br><span class="line">		execlp(<span class="string">"wc"</span>,<span class="string">"wc"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line">		perr_exit(<span class="string">"execlp wc error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：管道可以一个读端, 多个写端, 但是不建议这样做。默认管道的大小是4k。</p>
<h3 id="命名管道FIFO"><a href="#命名管道FIFO" class="headerlink" title="命名管道FIFO"></a>命名管道FIFO</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>为区分<code>pipe</code>,将<code>FIFO</code>称为命名管道。<code>FIFO</code>可<strong>用于不相关进程间的数据交换</strong>。</p>
<p><code>FIFO</code>是Linux<strong>基础文件类型中的一种</strong>, 但是<strong><code>FIFO</code>文件在磁盘上没有数据块, 仅仅用来标识内核中的一条通道, 各进程可以打开这个文件进行read/write, 实际上是在读写内核通道, 这样就实现了进程间通信</strong></p>
<p>创建方式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname,<span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0, 失败返回-1并设置errno</span></span><br></pre></td></tr></table></figure>
<p>用FIFO进行通信几乎只有文件读写操作, 比较简单。</p>
<h3 id="文件通信"><a href="#文件通信" class="headerlink" title="文件通信"></a>文件通信</h3><p>读普通文件不会造成<code>read</code>阻塞, 如果子进程睡1秒再写, 父进程由于刚开始读不到数据<code>read</code>直接返回0。</p>
<p>没有血缘关系的进程也可以用文件进行进程间通信。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>写进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">	<span class="comment">/*靠已经创建好的FIFO,如果命令行参数没给指定,报错*/</span></span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter like this:./a.out fifoname\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*以只写方式打开FIFO文件,拿到fd*/</span></span><br><span class="line">	fd=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_WRONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"open error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">/*将数据写到buf中*/</span></span><br><span class="line">		<span class="built_in">sprintf</span>(buf,<span class="string">"love you:%d\n"</span>,i++);</span><br><span class="line">		<span class="built_in">write</span>(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">	<span class="comment">/*同样要依靠已经创建好的FIFO,从命令行参数中指定*/</span></span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter like this:./a.out fifoname\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*以只读方式打开FIFO文件,拿到fd*/</span></span><br><span class="line">	fd=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"open error"</span>);</span><br><span class="line">	<span class="comment">/*从fd中读取数据,并写到标准输出上*/</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		len=<span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="built_in">write</span>(STDOUT_FILENO,buf,len);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://api2.mubu.com/v3/document_image/f56e0e79-6128-4a52-beb4-982703780c5e-11197877.jpg" alt="mmap"></p>
<p><strong>存储映射I/O使一个磁盘文件与存储空间中的一个缓冲区相映射, 于是当从缓冲区中取数据, 就相当于读文件中的相应字节。</strong>与此类似, <strong>将数据存入缓冲区, 则相应的字节就自动写入文件, 这样就可以在不使用<code>read</code>和<code>write</code>函数的情况下, 使用指针完成<code>I/O</code>操作</strong>。可以借助共享内存和指针来访问磁盘文件。</p>
<p>使用这种方法, <strong>首先应通知内核, 将一个文件映射到存储区域中</strong>, 这个映射工作可以通过<strong><code>mmap函数</code></strong>来实现。</p>
<h4 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回：成功则返回创建的映射区首地址，失败:MAP_FAILED宏((void*)-1), 设置errno;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">addr:建立映射区的首地址，由linux内核指定，使用的时候直接传递NULL, 表示让系统自动分配;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">length:创建映射区的大小(&lt;=文件的实际大小);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">prot: 共享内存映射区的读写属性：PROT_READ, PROT_WRITE, PROT_READ|PROT_WRITE</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">flags: 标志位参数（常用于设定更新物理区域，设置共享，创建匿名映射区）</span></span><br><span class="line"><span class="comment">	MAP_SHARED: 将映射区所做的操作反映到物理设备上（磁盘）</span></span><br><span class="line"><span class="comment">	MAP_PRIVATE：映射区所做的修改不会映射到物理设备</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">fd：用来建立映射区的文件描述符*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len, ret;</span><br><span class="line">    <span class="keyword">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"mytest.txt"</span>,O_CREAT|O_RDWR,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    len = ftruncate(fd,<span class="number">4</span>); <span class="comment">//将文件截断为4byte</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftruncate"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p = mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmap"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*内存的写操作,会被映射到文件的写操作*/</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">"abc"</span>);<span class="comment">//写数据</span></span><br><span class="line">    <span class="comment">/*与malloc一样,申请的内存要还回去*/</span></span><br><span class="line">    ret = munmap(p,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"munmap"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>od -tcx filename</code>:以16进制查看文件</p>
<h4 id="MMAP使用注意事项"><a href="#MMAP使用注意事项" class="headerlink" title="MMAP使用注意事项"></a>MMAP使用注意事项</h4><p><strong>创建映射区的权限应该小于等于文件打开的权限，创建映射区的过程隐含一次对文件的读操作。</strong></p>
<p><strong>段错误：gdb，直接run就可以抓取到段错误的位置。</strong></p>
<ul>
<li>可以<code>open</code>的时候<code>O_CREAT</code>一个新文件来创建映射区，但是<strong>要拓展文件大小, 否则会出现总线错误</strong>. 当然 <code>mmap</code>时指定<code>size=0</code>,<code>mmap</code>会报错</li>
<li>如果<code>open</code>时指定<code>O_RDONLY</code>，<code>mmap</code>时<code>PROT</code>参数指定<code>PROT_READ|PROT_WRITE</code>会报错，无效参数(注意<code>ftruncte()</code>函数需要<strong>写权限, 否则无法拓展文件大小</strong>). <strong>如果都用只读权限, 不会出错. 要创建映射区, 文件必须有读权限</strong></li>
<li><strong>文件描述符先关闭，对<code>mmap</code>映射没有影响，建立完映射区后<code>fd</code>即可关闭</strong></li>
<li>如果文件偏移量为1000，<code>mmap</code>会报错，<strong>因为偏移量必须是<code>4K</code>的整数倍(<code>MMU</code>映射的最小单位为<code>4K</code>)</strong></li>
<li>对<code>mem</code>进行越界操作：小范围的越界问题不大, 但是最好不要这样(操纵不安全的内存, 操作系统不给保障)</li>
<li>如果<code>mem++</code>,<code>munmap</code>不会成功(与<code>malloc</code>一样, <strong>释放的内存的指针必须是申请得来的初始的指针, 如果要改变指针的值, 拷贝一份用</strong>)</li>
<li>除了第一个参数, 后面的参数都可能导致失败</li>
<li>无论<code>mmap</code>多复杂，一定要检查<code>mmap</code>的返回值</li>
</ul>
<p>总结：</p>
<ul>
<li>创建映射区过程中，隐含一次对映射文件的读操作</li>
<li>当<code>MAP_SHARED</code>时，<strong>要求映射区的权限应该&lt;=文件打开的权限（出于对映射区的保护）</strong>,而<code>MAP_PRIVATE</code>则无所谓因为<strong><code>mmap</code>中的权限是对内存的限制</strong></li>
<li>特别注意，<strong>当映射区文件大小为0时，不能创建映射区，所以：用于映射的文件必须要有实际大小！！<code>mmap</code>使用时候经常会出现总线错误，通常是由于共享文件存储空间大小引起的</strong></li>
<li><code>munmap</code>传入的地址一定是<code>mmap</code>的返回地址，坚决杜绝指针<code>++</code>操作</li>
<li>文件偏移量必须为<code>4K</code>的整数倍</li>
<li><code>mma</code>p创建映射区出错概率很高，一定要检查返回值，确保映射区建立成功后再进行后续操作</li>
</ul>
<h4 id="mmap优点"><a href="#mmap优点" class="headerlink" title="mmap优点"></a>mmap优点</h4><ul>
<li><p>对文件的读取操作<strong>跨过了页缓存，减少了数据的拷贝次数，用内存读写取代<code>I/O</code>读写，提高了文件读取效率。</strong></p>
</li>
<li><p>实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p>
</li>
<li><p><strong>提供进程间共享内存及相互通信的方式</strong>。<strong>不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。</strong>同时，<strong>如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可以直接使用已经保存在内存中的文件数据。</strong></p>
</li>
<li><p>可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过<code>mmap</code>映射很好的解决。换句话说，<strong>但凡是需要用磁盘空间代替内存的时候，<code>mmap</code>都可以发挥其功效。</strong></p>
</li>
</ul>
<h4 id="mmap父子进程通信"><a href="#mmap父子进程通信" class="headerlink" title="mmap父子进程通信"></a>mmap父子进程通信</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"temp"</span>,O_CREAT |O_RDWR|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    unlink(<span class="string">"temp"</span>); <span class="comment">//删除临时文件目录项，使之具备被释放的条件</span></span><br><span class="line">    ftruncate(fd,<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    p = (<span class="keyword">int</span>*)mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>); <span class="comment">//共享</span></span><br><span class="line">    <span class="comment">// p = (int*)mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_PRIVATE,fd,0); //进程各自独占</span></span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED) <span class="comment">//注意：不是p==NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmap error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd); <span class="comment">//映射区建立完毕，即可关闭文件</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">//创建子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">2000</span>; <span class="comment">//给映射区赋值</span></span><br><span class="line">        var = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child, *p = %d, var = %d\n"</span>,*p, var);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent, *p = %d, var = %d\n"</span>,*p, var);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = munmap(p,<span class="number">4</span>); <span class="comment">//释放映射区</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"munmap error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//child, *p = 2000, var = 1000</span></span><br><span class="line"><span class="comment">//parent, *p = 2000, var = 100</span></span><br></pre></td></tr></table></figure>
<p>父子等有血缘关系的进程直接也可以通过<code>mmap</code>建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数<code>flags</code>:</p>
<ul>
<li><code>MAP_PRIVATE</code>(私有映射): 父子进程各自独占映射区</li>
<li><code>MAP_SHARED</code>(共享映射):父子进程共享映射区</li>
</ul>
<p>结论：父子进程共享：</p>
<ul>
<li>打开的文件</li>
<li><code>mmap</code>建立的映射区（但必须使用MAP_SHARED）</li>
</ul>
<h4 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h4><p>使用映射区来完成文件读写操作十分方便，父子进程间通信也比较容易，但缺陷是：每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要<code>open</code>一个<code>temp</code>文件，创建好了再<code>unlink</code>、<code>close</code>,比较麻烦。可以直接使用匿名映射来代替。linux提供了相应的方法，<strong>无需依赖一个文件即可创建映射区，同样需要借助标志位参数<code>flags</code>来指定：</strong></p>
<p>使用<code>MAP_ANONYMOUS(或MAP_ANON)</code>,如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>*p = mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    p = (<span class="keyword">int</span>*)mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANON,<span class="number">-1</span>,<span class="number">0</span>); <span class="comment">//共享</span></span><br><span class="line">    <span class="comment">// p = (int*)mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_PRIVATE,fd,0); //进程各自独占</span></span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED) <span class="comment">//注意：不是p==NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmap error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">//创建子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">2000</span>; <span class="comment">//给映射区赋值</span></span><br><span class="line">        var = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child, *p = %d, var = %d\n"</span>,*p, var);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent, *p = %d, var = %d\n"</span>,*p, var);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = munmap(p,<span class="number">4</span>); <span class="comment">//释放映射区</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"munmap error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<code>MAP_ANONYMOUS</code>和<code>MAP_ANON</code>两个宏是linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="built_in">open</span>(<span class="string">"dev/zero"</span>,O_RDWR);</span><br><span class="line">p = mmap(<span class="literal">NULL</span>, <span class="built_in">size</span>,PROT_READ|PROT_WRITE,MMAP_SHARED,fd,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><code>/dev/zero</code>-<strong>文件白洞</strong>, 里面<strong>有无限量的’\0’, 要多少有多少</strong></p>
<p><code>/dev/null</code>-<strong>文件黑洞</strong>, 可以<strong>写入任意量的数据</strong></p>
<p>所以在创建映射区时可以用zero文件, 就不用自己创建文件然后拓展大小了</p>
<h4 id="mmap无血缘关系进程间通信"><a href="#mmap无血缘关系进程间通信" class="headerlink" title="mmap无血缘关系进程间通信"></a>mmap无血缘关系进程间通信</h4><p>实质上<code>mmap</code>是内核借助文件帮助创建的一个映射区，多个进程之间利用该映射区完成数据传递。<strong>由于内核空间多进程共享，因此无血缘关系的进程间也可以使用<code>mmap</code>来完成通信，只要设置相应的标志位参数<code>flags</code>即可。若想实现共享，应该使用<code>MAP_SHARED</code></strong></p>
<p>要点：<strong>必须是同一个文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mmap_w.c 写进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span> = &#123;</span><span class="number">10</span>,<span class="string">"xiaoming"</span>,<span class="string">'m'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>* mm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./a.out file_shared\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	 <span class="comment">/*打开或创建一个文件*/</span></span><br><span class="line">    fd = <span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">"open error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ftruncate(fd,<span class="keyword">sizeof</span>(student));</span><br><span class="line">	<span class="comment">/*建立内存映射区*/</span></span><br><span class="line">    mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student),PROT_READ|PROT_WRITE, MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mm == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*循环使用memcpy向内存映射区中写入数据,并修改stu的id值*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(mm,&amp;student,<span class="keyword">sizeof</span>(student));</span><br><span class="line">        student.id ++;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*归还内存映射区给内存池*/</span></span><br><span class="line">    munmap(mm,<span class="keyword">sizeof</span>(student));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mmap_r.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span>* <span class="title">mm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./a.out file_shared\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*建立内存映射区*/</span></span><br><span class="line">    fd = <span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">"open error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*循环读出内存映射区中的数据*/</span></span><br><span class="line">    mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student),PROT_READ, MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mm == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"id = %d\tname=%s\t%c\n"</span>,mm-&gt;id,mm-&gt;name,mm-&gt;sex);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>无血缘关系进程间通信, 不能用匿名映射</strong></p>
<p><code>strace</code>: 追踪一个可执行文件在执行过程中所有的系统调用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/linux-%E7%B3%BB%E7%BB%9F-06%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/linux-%E7%B3%BB%E7%BB%9F-06%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">linux系统-进程管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-26 16:51:35" itemprop="dateCreated datePublished" datetime="2020-03-26T16:51:35+08:00">2020-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 10:13:23" itemprop="dateModified" datetime="2021-03-25T10:13:23+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h4><p>创建一个子进程, 原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> fork();		<span class="comment">/*函数原型相当简单:空参,返回一个整数pid*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//    返回值有两个:父进程的fork返回子进程的id，子进程返回0（表示fork成功）</span></span><br><span class="line"><span class="comment">//    返回子进程的pid(一个非负整数&gt;0)</span></span><br><span class="line"><span class="comment">//    返回0</span></span><br><span class="line"><span class="comment">//    失败返回-1并设置errno</span></span><br></pre></td></tr></table></figure>
<p><code>fork</code>确实创建了一个子进程并完全复制父进程，但是<strong>子进程是从<code>fork</code>后面那个指令开始执行的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sdsfdfdsfd\n"</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm child, pid =%u,ppid = %u\n"</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm Parent, pid =%u,ppid = %u\n"</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"yyyyyyy\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建n个线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"xxxxxxx\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span> ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm %d child, pid = %u\n"</span>,i+<span class="number">1</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm parent\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>父进程和子进程谁先执行？谁先抢到cpu就谁先执行。</strong>如果不加<code>sleep</code>，则输出是乱序的(反映了操作系统对进程调度的无序性)。</p>
<h4 id="getuid"><a href="#getuid" class="headerlink" title="getuid"></a>getuid</h4><ul>
<li><p>获取当前进程实际用户ID： <code>uid_t getuid(void)</code></p>
</li>
<li><p>获取当前进程有效用户ID： <code>uid_t geteuid(void)</code></p>
</li>
</ul>
<h4 id="getgid"><a href="#getgid" class="headerlink" title="getgid"></a>getgid</h4><ul>
<li><p>获取当前进程使用用户组ID： <code>gid_t getgid()</code></p>
</li>
<li><p>获取当前进程有效用户组ID： <code>gid_t getegid()</code></p>
</li>
</ul>
<h3 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a>进程共享</h3><p><strong>父子进程之间在fork后，有哪些相同，哪些相异？</strong></p>
<p>刚fork之后：</p>
<p><strong>父子相同之处：全局变量、.data段,.text段，栈，堆，环境变量，用户ID，宿主目录，进程工作目录，信号处理方式…</strong></p>
<p>父子不同之处：<strong>进程ID，fork返回值，父子进程ID，进程运行时间，闹钟（定时器），未决定信号集</strong></p>
<p>注意：子进程并不是把父进程0~3G地址空间完全cpoy一份, 然后映射到物理内存。 父子进程之间遵循<strong>读时共享写时复制</strong>的原则。这样设计，<strong>无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">34</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// var = 55;/*读时共享,写时复制*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm parent pid = %d, parentID = %d, var = %d\n"</span>,getpid(), getppid(),var);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        var = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child pid = %d, parentID = %d, var = %d\n"</span>,getpid(),getppid(),var);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"var = %d\n"</span>,var);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点：</p>
<ul>
<li><p>躲避父子进程共享全局变量的误区(线程之间可以共享全局变量)。</p>
</li>
<li><p>父子进程共享</p>
<ul>
<li>文件描述符（打开文件的结构体）</li>
<li>mmap建立的映射区（进程间通信）</li>
</ul>
</li>
</ul>
<p><strong>特别：fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法。</strong></p>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>使用gdb调试的时候，<strong>gdb只能跟踪一个进程。可以在fork函数调用之前，通过命令设置gdb调试工具跟踪父进程或是子进程。默认跟踪父进程。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set follow-fork-mode child #命令设置gdb在fork之后跟踪子进程</span><br><span class="line">set follow-fork-mode parent #设置跟踪父进程</span><br></pre></td></tr></table></figure>
<p>注意：一定要在fork函数调用之前设置才有效。</p>
<h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><p><strong>fork函数创建子进程后执行的是和父进程相同的程序（但可能执行不同的代码分支）</strong>，<strong>子进程往往要调用一种exec函数以执行另一个程序</strong>。<strong>当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。</strong></p>
<p><strong>将当前进程的.text, .data替换为所要加载的程序的.text, .data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。</strong></p>
<ul>
<li>int execl()</li>
<li>int execlp()</li>
<li>int  execle()</li>
<li>int execv()</li>
<li>int execvp()</li>
<li>int execve()</li>
</ul>
<h4 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h4><p><code>execlp</code>中的p表示环境变量, <strong>所以该函数通常用来调用系统程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="comment">/*参数1：要加载的程序的名字的，该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后但没有参数1则出错返回。*/</span></span><br></pre></td></tr></table></figure>
<p><strong>注意结尾加上NULL指定变参结束, printf函数也是变参, 结尾也要加上NULL作为哨兵</strong>.</p>
<p>该函数通常用来调用系统程序。如<code>ls, cat , date</code>等命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pid_t</span> pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"fork error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">/*参数从argv[0]开始算*/</span></span><br><span class="line">		execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="string">"-R"</span>,<span class="string">"-h"</span>,<span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">/*正常情况下是不会执行到这里的,只有当出错时才会返回到这里执行*/</span></span><br><span class="line">		perror(<span class="string">"execlp error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm parent:%d\n"</span>,getpid());</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先fork, 再exec, 这就是bash的大概原理.</p>
<p>如果要执行自己的可执行文件:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">"./test"</span>,<span class="string">"./test"</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h4 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h4><p>加载一个进程，通过 路径+程序名 来加载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span>\* arg, ...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//对比execlp</span></span></span><br><span class="line"><span class="function"><span class="title">execlp</span><span class="params">(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="string">"-a"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>)</span></span>;</span><br><span class="line">execl(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-a"</span>,<span class="string">"-l"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//exec_ps.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> fd1=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*打开或创建一个文件*/</span></span><br><span class="line">	fd1=<span class="built_in">open</span>(<span class="string">"ps.log"</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd1==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"open error"</span>);</span><br><span class="line">	<span class="comment">/*将STDOUT_FILENO指向fd1*/</span></span><br><span class="line">	ret=dup2(fd1,STDOUT_FILENO);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"dup2 error"</span>);</span><br><span class="line">	<span class="comment">/*执行命令*/</span></span><br><span class="line">	execlp(<span class="string">"ps"</span>,<span class="string">"ps"</span>,<span class="string">"aux"</span>,<span class="literal">NULL</span>);</span><br><span class="line">	perror(<span class="string">"execlp error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a>exec函数族一般规律</h4><p><strong>exec函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1。所以通常直接在exec函数后直接调用perror()和exit()，无需if判断。</strong></p>
<ul>
<li><p>l (list) 命令行参数列表</p>
</li>
<li><p>p (path) 搜索file时使用<strong>path变量</strong></p>
</li>
<li><p>v (vector) 使用<strong>命令行参数数组</strong></p>
</li>
<li><p>e (environment) 使用<strong>环境变量数组，不使用进程原有的环境变量，设置新加载程序运行的环境变量。</strong></p>
</li>
</ul>
<p>事实上，只有<code>execve</code>是真正的系统调用，其他五个函数最终都调用<code>execev</code>,所以<code>execve</code>在man手册第二节，而其他函数在man手册第三节。</p>
<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p><strong>父进程先于子进程结束，则子进程变为孤儿进程，子进程的父进程变为<code>init</code>进程，称为<code>init</code>进程领养孤儿进程。该过程主要是为了后期进行回收。</strong></p>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p><strong>进程终止，父进程尚未回收，子进程残留资源(PCB)存放在内核中，变成僵尸(Zombie)进程。</strong></p>
<p>特别注意：<strong>僵尸进程不能使用kill命令来清除。因为kill命令只是用来终止进程的，而僵尸进程已经终止。</strong></p>
<p>进程的运行状态：R 运行， S 后台运行， Z 僵尸进程</p>
<p>用什么办法可以清除僵尸进程？<strong>避免僵尸进程：回收</strong></p>
<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><p><strong>一个进程在终止的时候会关闭所有的文件描述符，释放在该用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息。如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用<code>wait</code>或者<code>waitpid</code>获取这些信息，然后彻底清除掉这个进程。一个进程的退出状态可以在<code>shell</code>中用特殊变量<code>$?</code>查看，因为shell是它的父进程，当它终止时<code>shell</code>调用<code>wait</code>或<code>waitpid</code>得到它的退出状态同时彻底清除掉这个进程。</strong></p>
<p><strong>父进程调用wait函数可以回收子进程终止信息，</strong>该函数的三个功能：</p>
<ul>
<li><strong>阻塞等待子进程退出</strong></li>
<li><strong>回收子进程残留资源</strong></li>
<li><strong>获取子进程结束状态（退出原因）</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br><span class="line"><span class="comment">//成功：清理掉的子进程ID， 失败：-1(没有子进程)</span></span><br></pre></td></tr></table></figure>
<p>当进程终止时，操作系统的隐式回收机制会：</p>
<ul>
<li>关闭所有文件描述符</li>
<li>释放用户空间分配的内存，<strong>内核的PCB仍存在。其中保存该进程的退出状态。（正常终止：退出值;异常终止：终止信号）</strong></li>
</ul>
<p>可使用<code>wait</code>函数传出参数<code>status</code>来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可以分为三组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WIFEXITED(status) <span class="comment">//为非0 :进程正常结束</span></span><br><span class="line">WEXITSTATUS(status） <span class="comment">//如上宏为真，使用此宏：获取进程退出状态（exit的参数）</span></span><br><span class="line"></span><br><span class="line">WIFSIGNALED(status)  <span class="comment">//为非0： 进程异常终止</span></span><br><span class="line">WTERMSIG(status) <span class="comment">//如上宏函数为真，使用此宏：取得使进程终止的那个信号的编号</span></span><br><span class="line"></span><br><span class="line">WIFSTOPED(status) <span class="comment">//为非0：进程处于暂停状态</span></span><br><span class="line">WSTOPSIG(status) <span class="comment">//加上宏为真，使用此宏：取得使进程暂停的那个信号的编号</span></span><br><span class="line">WIFCONTINUED(status) <span class="comment">//为真，进程暂停后已经继续运行</span></span><br></pre></td></tr></table></figure>
<p><code>kill -l</code> 可以<strong>查看进程结束的所有状态</strong></p>
<p><strong>程序所有异常终止的原因都是因为信号</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid,wpid;</span><br><span class="line">	<span class="keyword">int</span> status=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"fork error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm child:%d,my parent is %d,I'm going to sleep 10s\n"</span>,getpid(),getppid());</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm child,I'm going to die\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">73</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//wpid=wait(NULL);		//不关心子进程退出原因</span></span><br><span class="line">		wpid=wait(&amp;status);</span><br><span class="line">		<span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">			perr_exit(<span class="string">"wait error"</span>);</span><br><span class="line">		<span class="comment">/*如果子进程正常终止,则可获取它的退出值*/</span></span><br><span class="line">		<span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"My child exited with:%d\n"</span>,WEXITSTATUS(status));</span><br><span class="line">        <span class="comment">/*如果子进程被信号终止,可获取结束它的信号*/</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"My child killed by:%d\n"</span>,WTERMSIG(status));</span><br><span class="line">		<span class="comment">/*提示回收完成*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm parent,wait %d finish\n"</span>,wpid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><p><strong>作用同wait,但可指定pid进程清理，可以不阻塞</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options); </span><br><span class="line"><span class="comment">//成功：返回清理的子进程ID, 失败：-1(无子进程)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*特殊参数和返回情况：</span></span><br><span class="line"><span class="comment">参数pid:</span></span><br><span class="line"><span class="comment">&gt;0 回收指定ID的子进程</span></span><br><span class="line"><span class="comment">-1 回收任意子进程（相当与wait）</span></span><br><span class="line"><span class="comment">0 回收和当前调用waitpid一个组的所有子进程</span></span><br><span class="line"><span class="comment">&lt;-1 回收指定进程组内的任意子进程(进程组号取反, 表示回收指定进程组的任意子进程)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参2传进程结束状态, 如果不关心直接传NULL(传出参数)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参3传回收方式:WNOHANG(非阻塞)*/</span></span><br></pre></td></tr></table></figure>
<p>注意：<strong>一次<code>wait</code>或<code>waitpid</code>调用只能清理一个子进程，清理多个子进程应该使用循环。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带有bug的版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> wpid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">				pid=getpid();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">		<span class="comment">//wpid=waitpid(-1,NULL,WNOHANG);		//以非阻塞的方式回收任意子进程</span></span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">		wpid=waitpid(pid,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">		<span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">			perr_exit(<span class="string">"waitpid error"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm parent,wait a child finish:%d\n"</span>,wpid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm %dth child,my pid=%d\n"</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bug的原因:在<code>fork()==0</code>时是在子进程的执行逻辑中保存了<code>pid</code>, 但是子进程执行结束后直接返回, 用户空间的地址空间被回收, 当然也就没有了<code>pid</code>这个变量, 所以后面父进程<code>waitpid</code>时拿到的<code>pid</code>一直是0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改bug后</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> wpid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temppid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">		pid=fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/*在父进程中,如果i==2,将fork的返回值存入temppid*/</span></span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">			temppid=pid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">		<span class="comment">//wpid=waitpid(-1,NULL,WNOHANG);		//以非阻塞的方式回收任意子进程</span></span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">		wpid=waitpid(temppid,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">		<span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">			perr_exit(<span class="string">"waitpid error"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm parent,wait a child finish:%d\n"</span>,wpid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm %dth child,my pid=%d\n"</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回收多个子进程: <strong>用while循环</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> wpid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">		pid=fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="comment">/*以非阻塞忙轮询的方式回收子进程*/</span></span><br><span class="line">		<span class="keyword">while</span>((wpid=waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG))!=<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"wait chile:%d\n"</span>,wpid);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">0</span>)</span><br><span class="line">				sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I'm %dth child,my pid=%d\n"</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>wait/waitpid</code>只能回收子进程, 爷孙的也不行.</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/25/linux-%E7%B3%BB%E7%BB%9F-05%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/25/linux-%E7%B3%BB%E7%BB%9F-05%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">linux系统编程-进程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-25 16:02:58" itemprop="dateCreated datePublished" datetime="2020-03-25T16:02:58+08:00">2020-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-23 21:47:57" itemprop="dateModified" datetime="2021-03-23T21:47:57+08:00">2021-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="linux进程"><a href="#linux进程" class="headerlink" title="linux进程"></a>linux进程</h3><h4 id="进程、程序、并发"><a href="#进程、程序、并发" class="headerlink" title="进程、程序、并发"></a>进程、程序、并发</h4><p>程序：编译好的二进制文件。在<strong>磁盘上，不占用系统资源</strong>(cpu、 内存、打开的文件、设备、锁…)</p>
<p>进程：一个抽象概念，与操作系统原理联系紧密。进程是<strong>活跃的程序，占用系统资源</strong>。在内存中执行(程序运行起来则产生一个进程)</p>
<p>并发：<strong>操作系统中，一个时间段中有多个进程都处于已启动到运行完毕之间的状态。但一个时刻点上仍只有一个进程在运行（分时复用）。</strong></p>
<h4 id="cpu和MMU-内存管理单元"><a href="#cpu和MMU-内存管理单元" class="headerlink" title="cpu和MMU(内存管理单元)"></a>cpu和MMU(内存管理单元)</h4><p><img src="https://api2.mubu.com/v3/document_image/e44706d6-6069-4a0e-9c85-6c1c43c3c19f-11197877.jpg" alt="cpu和存储"></p>
<ul>
<li><p>存储设备包括寄存器，cache,内存，硬盘，网络等。<strong>与cpu直接打交道的应该是寄存器，多级缓存</strong></p>
</li>
<li><p><strong>MMU(内存管理单元), 位于CPU内部</strong></p>
</li>
<li>MMU完成<strong>虚拟地址到物理地址的映射</strong>，设置<strong>修改内存访问级别（用户空间，内核空间）。一个page是内存分配的最小单位。</strong></li>
</ul>
<ul>
<li><p>虚拟内存空间产生的时间：进程启动的时候，<strong>进程的所有东西都放在虚拟内存中，并不真实存在</strong>。实际的都放在内存中，虚拟空间如何描述？</p>
</li>
<li><p>虚拟地址：可用的地址空间有4G(32位操作系统)</p>
</li>
<li><p>如果一个程序跑了两个进程：<strong>两个进程开了两个虚拟空间，两个进程互相独立。两个不同的进程共用一个内存空间</strong>。</p>
</li>
</ul>
<p>虚拟内存和物理内存映射关系：</p>
<p><img src="https://api2.mubu.com/v3/document_image/06bd754f-dfe9-4081-a742-5f305d537582-11197877.jpg" alt="虚拟内存和物理内存映射关系"></p>
<ul>
<li><p>对于一个32位的机器来说, 每个进程都能看到4GB的虚拟地址空间, 且他们的3G~4G的位置都是kernel(<strong>每个进程都有kernel区</strong>)</p>
</li>
<li><p>从虚拟内存到物理内存的映射由MMU完成, <strong>不同进程的用户空间被映射到物理内存的不同位置, 而不同进程的kernel空间被映射到物理内存的相同位置</strong>, 对于物理内存来说，<strong>用户空间和内核空间有不同的特权级, 从用户空间到内核空间的转换实质上是特权级的切换。</strong></p>
</li>
</ul>
<h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><p><strong>每个进程在内核中都有一个PCB来维护进程相关信息</strong>, Linux内核的进程控制块是task_struct类型的结构体。</p>
<p>在<code>/usr/src/linux-headers-3.16.0-30/include/linux/sched.h</code>文件中可以查看<code>struct task_struct</code>结构体定义。其内部成员有很多，重点需要掌握部分：</p>
<ul>
<li><strong>进程id。系统中每一个进程都有唯一的id,在c语言中用<code>pid_t</code>类型表示，其实就是一个非负整数</strong></li>
<li><strong>进程的状态，有就绪、运行、挂起、停止等状态</strong></li>
<li>进程切换时需要保存和恢复的一些CPU寄存器</li>
<li>描述虚拟地址空间的信息，从虚拟地址映射到物理地址。</li>
<li>描述控制终端的信息</li>
<li>当前工作目录：cd 改变当前进程的工作目录，shell也是一个进程。</li>
<li>umask掩码</li>
<li><strong>文件描述符表，包含很多指向file结构体的指针</strong></li>
<li><strong>和信号相关的信息</strong></li>
<li><strong>用户id和组id</strong></li>
<li>会话和进程组</li>
<li>进程可以使用的资源上限：<code>ulimit -a</code></li>
</ul>
<p>就绪状态：<strong>等待cpu分配时间片</strong></p>
<p>挂起状态：<strong>等待除cpu以外的其他资源，主动放弃cpu</strong></p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>操作系统中用来<strong>指定操作系统运行环境的一些参数</strong>，通常具备以下特征：</p>
<ul>
<li><p>字符串（本质）</p>
</li>
<li><p>有统一的格式：名=值[:值]</p>
</li>
<li><p>值用来描述进程环境信息。</p>
</li>
<li><p>存储形式：与命令行参数类似。char* []，数组名 environ, 内部存储字符串，NULL作为哨兵结尾。</p>
</li>
<li><p>使用形式：与命令行参数类似</p>
</li>
<li><p>加载位置：与命令行参数类似，<strong>位于用户区，高于stack的起始位置</strong></p>
</li>
<li><p>引入环境变量表：须声明环境变量。<code>extern char** environ; （extern 声明）</code></p>
</li>
</ul>
<p>常见环境变量：</p>
<ul>
<li><p>PATH</p>
<ul>
<li>可执行文件的<strong>搜索路径</strong>。<code>ls</code>命令也是一个程序，执行它不需要提供完成的路径名<code>/bin/ls</code>,然而通常执行当前目录下的程序<code>a.out</code>却需要提供完整的路径名<code>./a.out</code>,<strong>这是因为<code>PATH</code>环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在shell中用echo命令可以查看这个环境变量的值。</strong></li>
<li><p><code>echo $PATH</code></p>
</li>
<li><p>使用date 和/bin/date原理是不同的。</p>
</li>
<li>shell按照PATH中的目录从前往后查找。</li>
</ul>
</li>
<li><p>SHELL</p>
<ul>
<li>当前shell(命令解析器)，值一般是/bin/shell</li>
</ul>
</li>
<li><p>TERM</p>
<ul>
<li>当前<strong>终端类型</strong>，在图形界面终端下它的值通常是xterm,终端类型决定了一些程序的输出方式，比如图形界面终端可以显示汉字，而字符终端一般不行。</li>
</ul>
</li>
<li><p>LANG</p>
<ul>
<li>语言和locale，决定了字符编码以及时间、货币等信息的显示格式</li>
</ul>
</li>
<li><p>HOME</p>
<ul>
<li><strong>当前用户主目录的路径，很多程序需要在主目录下保存配置文件，使得每个用户在运行该程序时都有自己的一套配置。</strong></li>
</ul>
</li>
<li>env:<strong>查看所有环境变量</strong></li>
</ul>
<p><code>getenv函数， setenv函数</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/23/linux-%E7%B3%BB%E7%BB%9F-04%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/23/linux-%E7%B3%BB%E7%BB%9F-04%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">linux系统下文件和目录操作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-23 10:50:49" itemprop="dateCreated datePublished" datetime="2020-03-23T10:50:49+08:00">2020-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-23 16:00:25" itemprop="dateModified" datetime="2021-03-23T16:00:25+08:00">2021-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="系统调用说明"><a href="#系统调用说明" class="headerlink" title="系统调用说明"></a>系统调用说明</h3><p>系统调用: <strong>内核提供的函数</strong>，由操作系统实现并提供给外部应用程序的编程接口, 是应用程序同操作系统之间交互数据的桥梁</p>
<p>为了保证系统的安全性, <strong>manPage中的系统调用都是对系统调用的一次浅封装</strong>, 比如open对应的是sys_open…</p>
<h4 id="系统调用和库函数的比较：预读入和缓输出"><a href="#系统调用和库函数的比较：预读入和缓输出" class="headerlink" title="系统调用和库函数的比较：预读入和缓输出"></a>系统调用和库函数的比较：预读入和缓输出</h4><p>使用<code>strace</code>工具可以跟踪一个程序执行时所需的<strong>系统调用</strong>。</p>
<p>如果规定逐字节的进行拷贝, 用库函数会比用系统调用快很多, 因为<strong>有预读入和缓输出机制:</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/ca853e5c-878b-4feb-80a4-2d4205eb88e3-11197877.jpg" alt="预读入和缓输出机制"></p>
<p>操作系统不会让用户逐字节的向磁盘上写数据, 实际上它<strong>维护了一个系统级缓冲</strong>, <strong>只有当从用户空间过来的数据在该缓冲上写满时, 才会一次性将数据冲刷到Disk上</strong></p>
<p><strong>当使用系统调用的方法时, 要不断的在用户空间和内核空间进行来回切换, 这会消耗大量时间</strong></p>
<p>而使用fputc(库函数)时, <strong>在设计之初自己在用户空间维护了一个缓冲, 这样在用户空间把自己的缓冲写满, 再一次性写入内核缓冲(写入了内核缓冲就认为写到了磁盘上), 可见这样大大减少了在用户空间和内核空间来回切换的次数</strong></p>
<p><strong>read和write函数常被称为UnbufferedIO, 指无用户级缓冲区, 但不保证不使用内核缓冲区</strong></p>
<h3 id="文件及相关操作"><a href="#文件及相关操作" class="headerlink" title="文件及相关操作"></a>文件及相关操作</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p><img src="https://api2.mubu.com/v3/document_image/1148cba1-a13e-4a4f-a00d-e12aafbae072-11197877.jpg" alt="文件描述符"></p>
<ul>
<li>PCB中有一个指针, <strong>指向了该进程的文件描述符表, 每个表项都是一个键值对, 其中的value是指向文件结构体的指针, 其中的索引是fd,</strong> <strong>操作系统暴露给用户的唯一操作文件的依据</strong></li>
<li>新打开的文件描述符一定是所有文件描述符表中<strong>可用的, 最小的</strong>那个文件描述符</li>
<li>文件描述符最大1023, 说明<strong>一个进程最多能打开1024个文件</strong></li>
</ul>
<h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;	<span class="comment">//mode_t是一个8进制整型,指定文件权限,只有当参2指定了CREAT才有用</span></span><br></pre></td></tr></table></figure>
<p>flag的参数:</p>
<ul>
<li>O_RDONLY</li>
<li>O_WRONLY</li>
<li>O_RDWR</li>
<li>O_APPEND</li>
<li>O_CREATE</li>
<li>O_EXCL</li>
<li>O_TRUNC</li>
<li>O_NONBLOCK</li>
</ul>
<p>成功返回<strong>文件描述符</strong>, 失败返回-1并设置errno;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd1=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> fd2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	fd1=<span class="built_in">open</span>(<span class="string">"./dirt.txt"</span>,O_RDONLY|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">    <span class="comment">/*打开的文件不存在*/</span></span><br><span class="line">	fd2=<span class="built_in">open</span>(<span class="string">"./dirt2.txt"</span>,O_RDONLY);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fd1=%d\n"</span>,fd1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd2=%d,errno=%d:%s\n"</span>,fd2,errno,strerror(errno));</span><br><span class="line">	<span class="built_in">close</span>(fd1);</span><br><span class="line">	<span class="built_in">close</span>(fd2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建文件权限时, 指定文件访问权限, 权限同时受umask影响:<code>文件权限=mode&amp;(~umask)</code></strong></p>
<h4 id="read和write"><a href="#read和write" class="headerlink" title="read和write"></a>read和write</h4><ul>
<li>read:从<strong>文件中读数据到缓冲区</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">read</span>(<span class="keyword">int</span> fd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> count);<span class="comment">//count是缓冲区的大小;</span></span><br></pre></td></tr></table></figure>
<p><strong>成功返回实际读到的字节数, 返回0时意味着读到了文件末尾, 失败返回-1并设置errno</strong></p>
<ul>
<li>wirte:从<strong>缓冲区中读数据到文件</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">write</span>(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> count); <span class="comment">//count是数据的大小(字节数);</span></span><br></pre></td></tr></table></figure>
<p><strong>成功返回实际写入的字节数, 失败返回-1, 并设置errno</strong></p>
<h4 id="read和write实现文件拷贝"><a href="#read和write实现文件拷贝" class="headerlink" title="read和write实现文件拷贝"></a>read和write实现文件拷贝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> fd1=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd1==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open argv1 error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> fd2=<span class="built_in">open</span>(argv[<span class="number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd2==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open argv2 error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((n=<span class="built_in">read</span>(fd1,buf,<span class="keyword">sizeof</span>(buf)))!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			perror(<span class="string">"open argv2 error"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">write</span>(fd2,buf,n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(fd1);</span><br><span class="line">	<span class="built_in">close</span>(fd2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><p>阻塞：<strong>当进程调用一个阻塞的系统调用时，该进程被置于睡眠状态，这时内核调度其他进程运行，直到该进程等待的事件发生了（比如网络上接收到数据包或者调用sleep指定的睡眠时间到了）它才可能继续运行</strong>。与睡眠状态相对的是运行状态。</p>
<p>正在被调度执行的进程：cpu处于该进程的上下文环境中，程序计数器中保存着该进程的指令地址，通用寄存器中保存着进程运算过程中的中间结果，正在执行该进程的指令，正在读写该进程的地址空间。</p>
<p>常规读文件是不会阻塞的，不论读多少字节，read一定会在有限时间内返回。<strong>从终端或网络读则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会阻塞</strong>。<strong>如果网络上没有接收到数据包，调用read从网络读就会阻塞，至于阻塞多长时间也是不确定的，如果一直没有数据到达就会一直阻塞。同样，写常规文件也是不会阻塞的，而向终端设备或网络写则不一定。</strong></p>
<h5 id="echo程序"><a href="#echo程序" class="headerlink" title="echo程序"></a>echo程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"read error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(STDOUT_FILENO,buf,n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当不敲入换行符时, read会一直阻塞等待用户输入</p>
<p>阻塞是<strong>设备文件, 网络文件</strong>的属性</p>
<h5 id="非阻塞方式从tty中读数据"><a href="#非阻塞方式从tty中读数据" class="headerlink" title="非阻塞方式从tty中读数据"></a>非阻塞方式从tty中读数据</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*以非阻塞方式打开终端文件*/</span></span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">"/dev/tty"</span>,O_RDONLY|O_NONBLOCK);</span><br><span class="line">	<span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open /dev/tty error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">tryagain: </span><br><span class="line">	n=<span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">/*当read的返回值小于0*/</span></span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*errno不是EWOULDBLOCK,说明出现了其他问题*/</span></span><br><span class="line">		<span class="keyword">if</span>(errno!=EWOULDBLOCK)&#123;</span><br><span class="line">			perror(<span class="string">"read /dev/tty error"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/*errno是EWOULDBLOCK,说明读到为空,则打印提示信息,并再次尝试*/</span></span><br><span class="line">			<span class="built_in">write</span>(STDOUT_FILENO,<span class="string">"try again\n"</span>,<span class="built_in">strlen</span>(<span class="string">"try again\n"</span>));</span><br><span class="line">			sleep(<span class="number">2</span>);</span><br><span class="line">			<span class="keyword">goto</span> tryagain;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*当read的返回值大于0,说明读到了数据,写到标准输出上*/</span></span><br><span class="line">	<span class="built_in">write</span>(STDOUT_FILENO,buf,n);</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>当<code>read</code>函数返回-1, 并且<code>errno=EAGAIN或EWOULDBLOCK</code>, 说明不是<code>read</code>失败, 而是read在以非阻塞方式读一个<strong>设备文件</strong>或<strong>网络文件</strong>, 而文件中无数据。</p>
<p>阻塞方式存在的问题也正是网络IO中<code>select, poll和epoll</code>函数存在的原因。</p>
<h4 id="fcntl修改文件的属性"><a href="#fcntl修改文件的属性" class="headerlink" title="fcntl修改文件的属性"></a>fcntl修改文件的属性</h4><p>改变一个<strong>已经打开的</strong>文件的访问控制属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>用fcntl改写上面的程序, <strong>不用重新打开文件:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flags=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*获取原来的flags*/</span></span><br><span class="line">	flags=fcntl(STDIN_FILENO,F_GETFL);</span><br><span class="line">	<span class="keyword">if</span>(flags==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"fcntl error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*位或上新的属性*/</span></span><br><span class="line">	flags|=O_NONBLOCK;</span><br><span class="line">    <span class="comment">/*将新的flags设置回去*/</span></span><br><span class="line">	ret=fcntl(STDIN_FILENO,F_SETFL,flags);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"fcntl error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*与上面的相同*/</span></span><br><span class="line">tryagain:</span><br><span class="line">	n=<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(errno!=EWOULDBLOCK)&#123;</span><br><span class="line">			perror(<span class="string">"read /dev/tty error"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">write</span>(STDOUT_FILENO,<span class="string">"try again\n"</span>,<span class="built_in">strlen</span>(<span class="string">"try again\n"</span>));</span><br><span class="line">			sleep(<span class="number">2</span>);</span><br><span class="line">			<span class="keyword">goto</span> tryagain;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(STDOUT_FILENO,buf,n);</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>文件的flags是一个位图, 每一位代表不同属性的真假值</strong></p>
<h4 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h4><p><strong>文件偏移：每个打开的文件都记录着当前读写位置，打开文件时候写位置是0,表示文件开头，通常读写多少个字节就会将读写位置往后移动多少个字节。例外：如果以<code>O_APPEND</code>方式打开，每次写操作都会在文件末尾追加数据，然后将读写位置移动到新的文件末尾</strong>。<code>lseek</code>和标准<code>I/O</code>库的<code>fseek</code>函数类似，可以移动当前读写位置(或偏移量)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>; <span class="comment">//成功返回0,失败返回-1.特别：超出文件末尾位置返回0,往回超出文件头位置，返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence); <span class="comment">//失败返回-1,成功：返回的值是较文件起始位置向后的偏移量</span></span><br><span class="line"><span class="comment">//特别：lseek允许超过文件结尾设置偏移量，未见会因此被拓展。</span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> msg[]=<span class="string">"It's a lseek test\n"</span>;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">"./lseek.txt"</span>,O_CREAT|O_RDWR,<span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(fd,msg,<span class="built_in">strlen</span>(msg));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*如果这里不进行lseek,由于读写共用同一个偏移位置,下面的读会从文件末尾开始读,读不到任何数据*/</span></span><br><span class="line">	lseek(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>((n=<span class="built_in">read</span>(fd,&amp;c,<span class="number">1</span>)))&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">"read error"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">write</span>(STDOUT_FILENO,&amp;c,n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用lseek获取文件大小:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*从0开始向后偏移到结尾,返回值表示偏移量,即为文件大小*/</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>=lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The file's size:%d\n"</span>,<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用lseek拓展文件大小: <strong>要想使文件大小真正拓展, 必须引起IO操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*从文件的结束位置开始,向后偏移110，被填入的是文件空洞*/</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>=lseek(fd,<span class="number">110</span>,SEEK_END);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The file's size:%d\n"</span>,<span class="built_in">size</span>);</span><br><span class="line">	<span class="comment">/*然后写入一个空字符*/</span></span><br><span class="line">	<span class="built_in">write</span>(fd,<span class="string">"\0"</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以HEX查看文件:<code>od -tcx filename</code>。</p>
<p>也可以使用truncate拓展文件大小:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret=truncate(<span class="string">"dict.cp"</span>,<span class="number">250</span>);</span><br></pre></td></tr></table></figure>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><h4 id="目录项和inode"><a href="#目录项和inode" class="headerlink" title="目录项和inode"></a>目录项和inode</h4><p>文件存储的关键点：inode, denty,数据存储，文件系统。</p>
<p>inode: <strong>本质为结构体，存储文件的属性信息。如：权限、大小、时间、用户、盘块位置…也叫做文件属性管理结构，大多数的inode都存储在磁盘上。</strong></p>
<p><strong>可以用stat命令，查看某个文件的inode信息：</strong><br><code>stat example.txt</code></p>
<p>inode的大小：<br>inode会消耗硬盘空间，所以<strong>硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</strong><br>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令：</p>
<p><code>df -i</code></p>
<p>denty: 目录项，<strong>本质依然是结构体</strong>，重要成员变量:文件名，inode。文<strong>件内容(data)保存在磁盘块中。</strong></p>
<p><strong>增加文件的硬链接只是增加dentry, 指向相同的inode</strong></p>
<p>同样, <strong>删除硬链接也只是删除dentry, 要注意删除文件并不会让数据在磁盘消失, 只是OS丢失了inode, 磁盘只能覆盖, 不能擦除</strong>。</p>
<h4 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h4><p>stat函数作用:<strong>获取文件属性(从inode中获取)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, struct stat* statbuf)</span></span>;</span><br><span class="line"><span class="comment">//参数:</span></span><br><span class="line"><span class="comment">//path:文件路径;</span></span><br><span class="line"><span class="comment">//buf(传出参数)存放文件属性;</span></span><br><span class="line"><span class="comment">//返回值: 成功返回0, 失败返回-1并设置errno;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结构体信息*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">	<span class="keyword">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">	<span class="keyword">ino_t</span>     st_ino;         <span class="comment">/* Inode number */</span></span><br><span class="line">	<span class="keyword">mode_t</span>    st_mode;        <span class="comment">/* File type and mode */</span></span><br><span class="line">	<span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">	<span class="keyword">uid_t</span>     st_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">	<span class="keyword">gid_t</span>     st_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">	<span class="keyword">dev_t</span>     st_rdev;        <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">	<span class="keyword">off_t</span>     st_size;        <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">	<span class="keyword">blksize_t</span> st_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">	<span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Since Linux 2.6, the kernel supports nanosecond precision for the following timestamp fields.For the details before Linux 2.6, see NOTES. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>利用stat获取文件大小:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	ret=stat(argv[<span class="number">1</span>],&amp;sbuf);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"stat error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"file size:%ld\n"</span>,sbuf.st_size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用宏函数获取文件属性:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	ret=stat(argv[<span class="number">1</span>],&amp;sbuf);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"stat error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*宏函数一般返回布尔值*/</span></span><br><span class="line">	<span class="keyword">if</span>(S_ISREG(sbuf.st_mode))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"It's a regular\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(sbuf.st_mode))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"It's a dir\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(S_ISFIFO(sbuf.st_mode))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"It's a pipe\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(S_ISLNK(sbuf.st_mode))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"It's a symbol"</span>);</span><br><span class="line">	<span class="comment">/*and so on...*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lstat"><a href="#lstat" class="headerlink" title="lstat"></a>lstat</h4><p><code>ln -s makefile makefile.soft</code>:创建软连接</p>
<p><code>mkfifo f1</code>:创建管道文件</p>
<p><strong>stat穿透: 当用stat获取软连接的文件属性时, 会穿透符号连接直接返回软连接指向的本尊的文件属性</strong>(vim,cat命令也有穿透作用)</p>
<p>解决方法: 换lstat函数</p>
<p>S_IFMT是一个文件类型掩码(文件类型那四位全1), st_mode与它位与后就可以提取出文件类型(后面的权限位被归零)</p>
<h4 id="link和unlink"><a href="#link和unlink" class="headerlink" title="link和unlink"></a>link和unlink</h4><p>特殊权限位：包含三个二进制位。依次是：设置组ID位：setGID; 设置用户ID位setID; 黏住位sticky</p>
<p>黏住位： 早期计算机内存紧张<strong>，只有精要的常用的程序可以常驻物理内存，剩下的要暂存在磁盘中。**</strong>当内存不够的时候会将该部分程序存回磁盘，腾出内存空间。若文件设置了黏住位，即使在内存比较吃紧的情况下也不会将该文件回存到磁盘上。**现阶段操作系统的虚拟内存管理分页算法比较完善，该功能已经被废弃。</p>
<p>仍然可以<strong>对目录设置黏住位。</strong>被设置了该位的目录，其内部文件只有：</p>
<ul>
<li>超级管理员</li>
<li>该目录所有者</li>
<li>改文件的所有者</li>
</ul>
<p>这三种用户有权限做删除、修改操作。其他用户可以读、创建，但不能随意删除。</p>
<p>link函数</p>
<p><strong>可以为已经存在的文件创建目录项(硬链接)</strong></p>
<p><code>ln makefile makefile.hard</code>:为makefile创建硬连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用link和unlink函数实现mv命令:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	ret=link(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"link error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret=unlink(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"unlink error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Linux下的文件删除机制: 不断的将文件的st_nlink-1, 直到减到0为止. 无目录项对应的文件, 会被操作系统择机释放</strong>。因此删除文件, 从某种意义上来说只是让文件具备了被删除的条件</p>
<p>unlink函数的特征:<strong>清除文件时, 如果文件的硬连接计数减到了0, 没有dentry与之对应, 但该文件仍不会马上被释放掉. 要等到所有打开该文件的进程关闭该文件, 系统才会择机将文件释放。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span>* p=<span class="string">"test of unlink\n"</span>;</span><br><span class="line">	<span class="keyword">char</span>* p2=<span class="string">"after write something\n"</span>;</span><br><span class="line"></span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">"temp.txt"</span>,O_RDWR|O_TRUNC|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"open file error"</span>);</span><br><span class="line"></span><br><span class="line">	ret=<span class="built_in">write</span>(fd,p,<span class="built_in">strlen</span>(p));</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"write error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello,I'm printf\n"</span>);</span><br><span class="line">	ret=<span class="built_in">write</span>(fd,p2,<span class="built_in">strlen</span>(p2));</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"write error"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Entry key to continue\n"</span>);</span><br><span class="line">    <span class="comment">/*程序在此阻塞等待用户输入*/</span></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="comment">/*删除该文件*/</span></span><br><span class="line">	ret=unlink(<span class="string">"temp.txt"</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"unlink error"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果在unlink之前诱发段错误, 程序崩溃, temp.txt就会存活下来. 所以将unlink这一步放到打开文件之后紧接着就unlink掉</strong></p>
<p><strong>虽然文件被unlink掉了, 用户用cat查看不到磁盘上的对应文件, 但是write函数拿到fd写文件是向内核的buffer中写, 仍可正常写入</strong></p>
<p>隐式回收:</p>
<p>当<strong>进程运行结束时, 所有该进程打开的文件会被关闭, 申请的内存空间会被释放</strong>, 系统的这一特性称为<strong>隐式回收系统资源</strong></p>
<h4 id="文件目录权限"><a href="#文件目录权限" class="headerlink" title="文件目录权限"></a>文件目录权限</h4><p><code>readlink m1.soft</code>:查看软连接的内容</p>
<p>Linux下所见皆文件, 如果用vim打开一个目录，目录也是”文件”。文件内容是该目录下所有子文件的目录项dentry。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>r</th>
<th>w</th>
<th>x</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件</td>
<td>文件内容可以被查看，cat、more、less…</td>
<td>内容可以被修改vi…</td>
<td>运行产生一个进程 ./文件名</td>
</tr>
<tr>
<td>目录</td>
<td>目录可以被浏览</td>
<td>创建、删除、修改文件mv, touch, mkdir…</td>
<td>可以被打开、进入 cd</td>
</tr>
</tbody>
</table>
</div>
<h4 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h4><p>文件名不能超过255个字符, 引文dirent中的d_name长度为256, 再算上\0, 有255个字符可用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR* <span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;	<span class="comment">/*返回的是一个目录结构体指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR* dirp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct dirent* <span class="title">readdir</span><span class="params">(DIR* dirp)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">	<span class="keyword">ino_t</span>          d_ino;       <span class="comment">/* Inode number */</span></span><br><span class="line">	<span class="keyword">off_t</span>          d_off;       <span class="comment">/* Not an offset; see below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;    <span class="comment">/* Length of this record */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>  d_type;      <span class="comment">/* Type of file; not supported by all filesystem types */</span></span><br><span class="line">	<span class="keyword">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用目录操作函数实现ls的功能:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	DIR* dp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">sdp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*根据输入的内容打开一个目录文件,拿到一个类似文件描述符的东西dp*/</span></span><br><span class="line">	dp=opendir(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span>(dp==<span class="literal">NULL</span>)</span><br><span class="line">		perr_exit(<span class="string">"opendir error"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*循环从dirent流中读取数据*/</span></span><br><span class="line">	<span class="keyword">while</span>((sdp=readdir(dp))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">/*跳过当前目录和上一级目录*/</span></span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">"."</span>))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">".."</span>))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/*打印文件名*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,sdp-&gt;d_name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*关闭文件*/</span></span><br><span class="line">	closedir(dp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归遍历目录"><a href="#递归遍历目录" class="headerlink" title="递归遍历目录"></a>递归遍历目录</h4><p>思路：</p>
<ul>
<li><p>判断命令行参数, 获取用户要查询的目录名-argv[1]</p>
<ul>
<li>注意如果argc==1, 说明要查询的是当前目录./</li>
</ul>
</li>
<li><p>判断用户指定的是否是目录: stat S_ISDIR()-&gt;封装函数isFile()</p>
</li>
<li>读目录:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">opendir(dir);	</span><br><span class="line"><span class="keyword">while</span>(readdir())&#123;</span><br><span class="line">	普通文件:直接打印;</span><br><span class="line">	目录文件:拼接目录访问绝对路径:<span class="built_in">sprintf</span>(path,<span class="string">"%s%s"</span>,dir,d_name);</span><br><span class="line">	递归调用自己:opendir(path), readdir, closedir;</span><br><span class="line">&#125;</span><br><span class="line">closedir();</span><br></pre></td></tr></table></figure>
<p>实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*参2是回调函数名*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fetchdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dir,<span class="keyword">void</span>(*fcn)(<span class="keyword">char</span>*))</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[PATH_LEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">sdp</span>;</span></span><br><span class="line">	DIR* dp;</span><br><span class="line">	<span class="comment">/*打开目录失败*/</span></span><br><span class="line">	<span class="keyword">if</span>((dp=opendir(dir))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"fetchdir:can't open %s\n"</span>,dir);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*循环读取内容*/</span></span><br><span class="line">	<span class="keyword">while</span>((sdp=readdir(dp))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">/*遇到当前目录和上一级目录,跳过,否则会陷入死循环*/</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">"."</span>)==<span class="number">0</span>)||(<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">".."</span>)==<span class="number">0</span>))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/*路径名是否越界*/</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strlen</span>(dir)+<span class="built_in">strlen</span>(sdp-&gt;d_name)+<span class="number">2</span>&gt;<span class="keyword">sizeof</span>(name))&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"fetchdir:name %s %s is too long\n"</span>,dir,sdp-&gt;d_name);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/*拼接为一个路径,传给isFile函数*/</span></span><br><span class="line">			<span class="built_in">sprintf</span>(name,<span class="string">"%s/%s"</span>,dir,sdp-&gt;d_name);</span><br><span class="line">			(*fcn)(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	closedir(dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isFile</span><span class="params">(<span class="keyword">char</span>* name)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="comment">/*获取文件属性失败*/</span></span><br><span class="line">	<span class="keyword">if</span>(stat(name,&amp;sbuf)==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"isFile:can't access %s\n"</span>,name);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*这是一个目录文件:调用函数fetchdir*/</span></span><br><span class="line">	<span class="keyword">if</span>((sbuf.st_mode&amp;S_IFMT)==S_IFDIR)&#123;</span><br><span class="line">		fetchdir(name,isFile);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*不是目录文件:是一个普通文件,打印文件信息*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%ld\t\t%s\n"</span>,sbuf.st_size,name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="comment">/*不指定命令行参数*/</span></span><br><span class="line">	<span class="keyword">if</span>(argc==<span class="number">1</span>)</span><br><span class="line">		isFile(<span class="string">"."</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(--argc&gt;<span class="number">0</span>)</span><br><span class="line">			isFile(*++argv);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="dup和dup2"><a href="#dup和dup2" class="headerlink" title="dup和dup2"></a>dup和dup2</h4><p><code>cat makefile &gt; m1</code>:将cat的结果重定向到m1(此时m1与makefile内容相同)</p>
<p><code>cat makefile &gt;&gt; m1</code>:将cat的结果重定向并追加到m1后面(此时m1是双份的makefile)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The dup() system call creates a copy of the file descriptor oldfd, using the lowest-numbered unused file descriptor for the new descriptor.</p>
</blockquote>
<p>传入已有的文件描述符, 返回一个新的文件描述符:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">/*open或创建一个文件,拿到文件描述符fd1*/</span></span><br><span class="line">        <span class="keyword">int</span> fd1=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd1==<span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">"open error"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*fd2作为fd1的副本,拿着fd2也可以向被open的文件写入*/</span></span><br><span class="line">        <span class="keyword">int</span> fd2=dup(fd1);</span><br><span class="line">        <span class="keyword">if</span>(fd2==<span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">"dup error"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fd1=%d  fd2=%d\n"</span>,fd1,fd2);</span><br><span class="line">        <span class="comment">/*向fd2(fd1)中写入一句话*/</span></span><br><span class="line">        <span class="built_in">write</span>(fd2,<span class="string">"love you\n"</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dup的返回值fd2相当于fd1的副本, 拿着它也可以操作fd1</strong></p>
<p>dup2<strong>:后面的指向前面的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd1=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd2=<span class="built_in">open</span>(argv[<span class="number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">        <span class="comment">/*dup2后fd2也指向了fd1的文件*/</span></span><br><span class="line">        <span class="keyword">int</span> fdret=dup2(fd1,fd2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fdret=%d\n"</span>,fdret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret=<span class="built_in">write</span>(fd2,<span class="string">"love you\n"</span>,<span class="number">9</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ret=%d\n"</span>,ret);</span><br><span class="line">        <span class="comment">/*现在标准输出也指向了fd1*/</span></span><br><span class="line">        dup2(fd1,STDOUT_FILENO);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"--------love you--------\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fcntl实现dup描述符"><a href="#fcntl实现dup描述符" class="headerlink" title="fcntl实现dup描述符"></a>fcntl实现dup描述符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd1=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fd1=%d\n"</span>,fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newfd1=fcntl(fd1,F_DUPFD,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"newfd1=%d\n"</span>,newfd1);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> newfd2=fcntl(fd1,F_DUPFD,<span class="number">8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"newfd2=%d\n"</span>,newfd2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret=<span class="built_in">write</span>(newfd2,<span class="string">"fuckyou\n"</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ret=%d\n"</span>,ret);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fcntl 参3传0, 则从0开始向下寻找可用的文件描述符返回给newfd1</span></span><br><span class="line"><span class="comment">//fcntl 参3传8, 则从8开始向下寻找可用的文件描述符返回给newfd2</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/21/linux-%E7%B3%BB%E7%BB%9F-03makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/21/linux-%E7%B3%BB%E7%BB%9F-03makefile/" class="post-title-link" itemprop="url">makefile</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-21 10:08:23" itemprop="dateCreated datePublished" datetime="2020-03-21T10:08:23+08:00">2020-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-21 11:00:39" itemprop="dateModified" datetime="2021-03-21T11:00:39+08:00">2021-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="makefile-作用"><a href="#makefile-作用" class="headerlink" title="makefile 作用"></a>makefile 作用</h3><ul>
<li>项目代码编译管理</li>
<li>节省编译项目时间</li>
<li>一次编写终身受益</li>
</ul>
<h4 id="运行规则"><a href="#运行规则" class="headerlink" title="运行规则"></a>运行规则</h4><ul>
<li>若想生成目标，<strong>检查规则中的依赖条件是否存在</strong>。如果不存在，则寻找是否有规则用来生成该依赖文件。</li>
<li>检查规则中的目标是否需要被更新，必须先检查它的所有依赖，依赖中有任何一个被更新，则目标必须被更新。<ul>
<li>分析各个目标和依赖之间的关系</li>
<li>根据依赖关系自底向上执行命令</li>
<li>根据修改时间比目标新旧与否确定更新</li>
<li>如果目标不依赖任何条件，则执行对应命令，以示更新</li>
</ul>
</li>
</ul>
<p>一个最简单的makefile:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:hello.c</span></span><br><span class="line">	gcc hello.c -o hello</span><br></pre></td></tr></table></figure>
<p>考虑中间步骤：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:hello.o</span></span><br><span class="line">	gcc hello.c -o hello</span><br><span class="line"><span class="section">hello.o:hello.c</span></span><br><span class="line">	gcc hello.c-o hello.o</span><br></pre></td></tr></table></figure>
<h3 id="makefile使用"><a href="#makefile使用" class="headerlink" title="makefile使用"></a>makefile使用</h3><h4 id="一个规则"><a href="#一个规则" class="headerlink" title="一个规则"></a>一个规则</h4><p>多文件联编：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:hello.o</span></span><br><span class="line">	gcc hello.c add.c sub.c div1.c -o hello</span><br></pre></td></tr></table></figure>
<p>考虑到多文件编译的时间成本，应该先将个各个模块编译成<code>.o</code>目标文件，<strong>由目标文件链接成可执行文件。</strong>这样只有改动过的模块会被再次编译，其他的保持不变。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:hello.o</span></span><br><span class="line">	gcc hello.o add.o sub.o div1.o -o hello</span><br><span class="line"><span class="section">hello.o:hello.c</span></span><br><span class="line">	gcc -c hello.c -o hello.o</span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">	gcc -c add.c -o add.o</span><br><span class="line"><span class="section">div1.o:div1.c</span></span><br><span class="line">	gcc -c div1.c -o div1.o</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当依赖条件的时间比目标的时间还晚, 说明目标该更新了。</p>
</li>
<li><p>依赖条件如果不存在, 找寻新的规则去产生依赖</p>
</li>
</ul>
<p>make只会认为第一行是自己的最终目标, 如果最终目标没有写在第一行, 通过<strong>ALL</strong>来指定;</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ALL:hello</span></span><br><span class="line"></span><br><span class="line"><span class="section">hello.o:hello.c</span></span><br><span class="line">	gcc -c hello.c -o hello.o</span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">	gcc -c add.c -o add.o</span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">	gcc -c sub.c -o sub.o	</span><br><span class="line"><span class="section">div1.o:div1.c</span></span><br><span class="line">	gcc -c div1.c -o div1.o</span><br><span class="line"></span><br><span class="line"><span class="section">hello:hello.o add.o sub.o div1.o</span></span><br><span class="line">	gcc hello.o add.o sub.o div1.o -o hello</span><br></pre></td></tr></table></figure>
<h4 id="两个函数和clean"><a href="#两个函数和clean" class="headerlink" title="两个函数和clean"></a>两个函数和clean</h4><ul>
<li><p><code>src=$(wildcard ./*.c)</code>:<strong>匹配当前目录下的所有.c源文件, 赋值给变量src(与shell类似, 变量只有字符串类型)</strong></p>
</li>
<li><p><code>obj=$(patsubst %.c,%.o,$(src))</code>:将参数3中包含参数1的部分<strong>替换</strong>为参数2</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">ALL:hello</span></span><br><span class="line"><span class="section">hello:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$(obj)</span> -o hello</span><br><span class="line"></span><br><span class="line"><span class="section">hello.o:hello.c</span></span><br><span class="line">	gcc -c hello.c -o hello.o</span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">	gcc -c add.c -o add.o</span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">	gcc -c sub.c -o sub.o	</span><br><span class="line"><span class="section">div1.o:div1.c</span></span><br><span class="line">	gcc -c div1.c -o div1.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> hello</span><br></pre></td></tr></table></figure>
<ul>
<li>执行<code>make clean</code>时务必加上-n参数检查, 避免把源码删掉</li>
<li>clean相当于一个没有依赖条件的规则</li>
<li>rm前面的<strong>横杠表示出错(文件不存在)仍然执行</strong></li>
</ul>
<h4 id="三个自动变量和模式规则"><a href="#三个自动变量和模式规则" class="headerlink" title="三个自动变量和模式规则"></a>三个自动变量和模式规则</h4><h5 id="三个自动变量"><a href="#三个自动变量" class="headerlink" title="三个自动变量:"></a>三个自动变量:</h5><ul>
<li><code>$@</code>:在规则的命令中, 表示规则中的<strong>目标</strong></li>
<li><code>$^</code>:在规则的命令中, 表示<strong>所有依赖条件</strong></li>
<li><code>$&lt;</code>:在规则的命令中, 表示<strong>第一个依赖条件</strong></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">ALL:hello</span></span><br><span class="line"><span class="section">hello:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span>			<span class="comment">#目标依赖于所有依赖条件</span></span><br><span class="line"></span><br><span class="line"><span class="section">hello.o:hello.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span>			<span class="comment">#目标依赖于第一个(唯一一个)依赖条件</span></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span>			<span class="comment">#目标依赖于第一个(唯一一个)依赖条件</span></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span>			<span class="comment">#目标依赖于第一个(唯一一个)依赖条件</span></span><br><span class="line"><span class="section">div1.o:div1.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span>			<span class="comment">#目标依赖于第一个(唯一一个)依赖条件</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> hello</span><br></pre></td></tr></table></figure>
<h5 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则:"></a>模式规则:</h5><p>鉴于上面的<strong>都是某个.o文件依赖于某个.c文件的形式,</strong> 可以将其总结为一个模式规则:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>关于$&lt;:如果将该变量应用在模式规则中<strong>, 它可将依赖条件列表中的依赖项依次取出, 套用模式规则:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">ALL:hello</span></span><br><span class="line"><span class="section">hello:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> hello</span><br></pre></td></tr></table></figure>
<p>加入了模式规则后, <strong>当再加入新的模块, 比如mul模块, 不需要改动makefile就可以实现自动编译链接, 非</strong>常的方便.</p>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><ul>
<li>静态模式规则(制定了模式规则给谁用):</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(obj)</span>%.o:%.c</span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<ul>
<li>加入<strong>伪目标(为了防止目录下的与clean和ALL的同名文件的干扰):</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:clean ALL</span><br></pre></td></tr></table></figure>
<ul>
<li>加入常用参数(-Wall, -I, -l, -L, -g), 形成<strong>最终版本:</strong></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">myArgs=-Wall -g</span><br><span class="line"></span><br><span class="line"><span class="section">ALL:hello</span></span><br><span class="line"><span class="section">hello:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> hello</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean ALL</span></span><br></pre></td></tr></table></figure>
<h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p><img src="https://api2.mubu.com/v3/document_image/d1182118-df4b-4b46-8829-eff04eb8168a-11197877.jpg" alt="文件存放形式"></p>
<p>makefile文件:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> ./src/*.c)</span></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> ./src/%.c,./obj/%.o,<span class="variable">$(src)</span>)</span>		<span class="comment">#注意百分号的匹配和锁定作用</span></span><br><span class="line"></span><br><span class="line">myArgs=-Wall -g</span><br><span class="line">inc_path=./inc					<span class="comment">#头文件所在目录</span></span><br><span class="line"></span><br><span class="line"><span class="section">ALL:hello</span></span><br><span class="line"><span class="section">hello:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc  <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(obj)</span>:./obj/%.o:./src/%.c			<span class="comment">#目标和依赖都需要改变</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span> -I <span class="variable">$(inc_path)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: ALL clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf ./obj/*.o hello</span><br></pre></td></tr></table></figure>
<p>当文件名不叫makefile:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -f m1</span><br><span class="line">make -f m1 clean</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/21/linux-%E7%B3%BB%E7%BB%9F-02gbd%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/21/linux-%E7%B3%BB%E7%BB%9F-02gbd%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">gbd调试</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-21 09:05:29" itemprop="dateCreated datePublished" datetime="2020-03-21T09:05:29+08:00">2020-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-21 10:44:37" itemprop="dateModified" datetime="2021-03-21T10:44:37+08:00">2021-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>基本调试思想：分析现象-&gt;假设错误原因-&gt;产生新的现象去验证假设。</p>
<p>gdb可以完全操控程序的运行，可以控制程序的运行过程，并且可以随时查看程序中所有的内部状态(各变量的值、传递给函数的参数、当前执行的语句位置等)。</p>
<p>生成gdb可调试代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g main.c -o main</span><br></pre></td></tr></table></figure>
<p>基本命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb main 	<span class="comment"># 开始调试</span></span><br><span class="line">list 1 		<span class="comment">#从第一行开始显示源码, 后面再展开用l（小写的L）;</span></span><br><span class="line"><span class="built_in">break</span> 52 	<span class="comment">#在第52行设置断点;</span></span><br><span class="line">run			<span class="comment">#开始执行, 到断点暂停;</span></span><br><span class="line">next		<span class="comment">#下一个, 转到下一条语句或函数;</span></span><br><span class="line">step		<span class="comment">#单步, 进入函数, 单步执行, 注意系统函数只能用n, 不要用s进入;</span></span><br><span class="line"><span class="built_in">print</span> i		<span class="comment">#打印变量i的值;</span></span><br><span class="line"><span class="built_in">continue</span> 	<span class="comment">#继续执行断点后续指令;</span></span><br><span class="line">quit		<span class="comment">#退出gdb调试工具;</span></span><br></pre></td></tr></table></figure>
<p>用gdb调试<strong>段错误</strong>: <strong>直接run, 程序停止的位置就是出段错误的位置</strong></p>
<p>栈帧:随着函数调用而在stack上开辟的一块内存空间, 用于存放函数调用时产生的局部变量和临时值</p>
<p>其他命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start		<span class="comment">#单步执行;</span></span><br><span class="line">finish		<span class="comment">#结束当前函数调用, 返回调用点;</span></span><br><span class="line"><span class="built_in">set</span> args aa bb cc	<span class="comment">#给函数添加参数, 或者`run aa bb cc`;</span></span><br><span class="line">info b		<span class="comment">#查看断点信息;</span></span><br><span class="line">b 20 <span class="keyword">if</span> i=5	<span class="comment">#设置条件断点;</span></span><br><span class="line">ptype arr	<span class="comment">#查看变量类型;</span></span><br><span class="line">backtrace	<span class="comment">#简称bt查看函数调用的栈帧和层级关系;</span></span><br><span class="line">frame 1		<span class="comment">#切换函数栈帧;</span></span><br><span class="line">display j	<span class="comment">#一直显示j变量;</span></span><br><span class="line">undisplay num	<span class="comment">#取消监视;</span></span><br><span class="line">delete		<span class="comment">#删除断点;</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/02/linux-02linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/linux-02linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Linux常用命令使用-1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-02 21:29:16" itemprop="dateCreated datePublished" datetime="2020-03-02T21:29:16+08:00">2020-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:48:45" itemprop="dateModified" datetime="2021-03-20T20:48:45+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Linux终端命令格式"><a href="#Linux终端命令格式" class="headerlink" title="Linux终端命令格式"></a>Linux终端命令格式</h3><h4 id="终端命令格式"><a href="#终端命令格式" class="headerlink" title="终端命令格式"></a>终端命令格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] [parameter]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><code>command</code>：命令名，相应功能的英文单词或单词的缩写</li>
<li><code>[-options]</code>：选项，可用来对命令进行控制，也可以省略</li>
<li><code>parameter</code>：传给命令的参数，可以是 <strong>零个</strong>、<strong>一个</strong> 或者 <strong>多个</strong></li>
<li><code>[]</code> 代表可选 </li>
</ul>
<h4 id="查阅命令帮助信息"><a href="#查阅命令帮助信息" class="headerlink" title="查阅命令帮助信息"></a>查阅命令帮助信息</h4><h5 id="help"><a href="#help" class="headerlink" title="help"></a>help</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>显示 <code>command</code> 命令的帮助信息</li>
</ul>
<h5 id="man"><a href="#man" class="headerlink" title="man"></a>man</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>查阅 <code>command</code> 命令的使用手册</li>
</ul>
<p>man 手册：</p>
<ul>
<li>1 可执行程序或shell命令</li>
<li>2 系统调用（内核提供的函数）</li>
<li>3 库调用(程序库中的函数)</li>
</ul>
<p><code>man</code> 是 <strong>manual</strong> 的缩写，是 Linux 提供的一个 <strong>手册</strong>，包含了绝大部分的命令、函数的详细使用说明</p>
<p>使用 <code>man</code> 时的操作键：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>空格键</td>
<td>显示手册页的下一屏</td>
</tr>
<tr>
<td>Enter 键</td>
<td>一次滚动手册页的一行</td>
</tr>
<tr>
<td>b</td>
<td>回滚一屏</td>
</tr>
<tr>
<td>f</td>
<td>前滚一屏</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>/word</td>
<td>搜索 <strong>word</strong> 字符串</td>
</tr>
</tbody>
</table>
</div>
<h3 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h3><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ls</td>
<td>list</td>
<td>查看当前文件夹下的内容</td>
</tr>
<tr>
<td>02</td>
<td>pwd</td>
<td>print wrok directory</td>
<td>查看当前所在文件夹</td>
</tr>
<tr>
<td>03</td>
<td>cd [目录名]</td>
<td>change directory</td>
<td>切换文件夹</td>
</tr>
<tr>
<td>04</td>
<td>touch [文件名]</td>
<td>touch</td>
<td>如果文件不存在，新建文件</td>
</tr>
<tr>
<td>05</td>
<td>mkdir [目录名]</td>
<td>make directory</td>
<td>创建目录</td>
</tr>
<tr>
<td>06</td>
<td>rm [文件名]</td>
<td>remove</td>
<td>删除指定的文件名</td>
</tr>
<tr>
<td>07</td>
<td>clear</td>
<td>clear</td>
<td>清屏</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>小技巧</p>
<ul>
<li><code>ctrl + shift + =</code> <strong>放大</strong>终端窗口的字体显示</li>
<li><code>ctrl + -</code> <strong>缩小</strong>终端窗口的字体显示</li>
<li>在敲出 文件 目录 命令 <code>tab</code><ul>
<li>如果输入的没有歧义，系统会自动补全</li>
<li>如果还存在其他 <code>文件</code>／<code>目录</code>／<code>命令</code>，再按一下 <code>tab</code> 键，系统会提示可能存在的命令</li>
</ul>
</li>
<li>按 <code>上</code>／<code>下</code> 光标键可以在曾经使用过的命令之间来回切换</li>
<li>如果想要退出选择，并且不想执行当前选中的命令，可以按 <code>ctrl + c</code></li>
</ul>
</blockquote>
<h3 id="远程管理常用命令"><a href="#远程管理常用命令" class="headerlink" title="远程管理常用命令"></a>远程管理常用命令</h3><h4 id="关机-重启"><a href="#关机-重启" class="headerlink" title="关机/重启"></a>关机/重启</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>shutdown 选项 时间</td>
<td>shutdown</td>
<td>关机／重新启动</td>
</tr>
</tbody>
</table>
</div>
<h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a><code>shutdown</code></h4><ul>
<li><code>shutdown</code> 命令可以 <strong>安全</strong> <strong>关闭</strong> 或者 <strong>重新启动系统</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>重新启动</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>提示：</p>
<ul>
<li><strong>不指定选项和参数</strong>，默认表示 <strong>1 分钟</strong>之后 <strong>关闭电脑</strong></li>
<li>远程维护服务器时，最好不要关闭系统，而应该重新启动系统</li>
</ul>
</blockquote>
<ul>
<li>常用命令示例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新启动操作系统，其中 now 表示现在</span></span><br><span class="line">$ shutdown -r now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立刻关机，其中 now 表示现在</span></span><br><span class="line">$ shutdown now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统在今天的 20:25 会关机</span></span><br><span class="line">$ shutdown 20:25</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统再过十分钟后自动关机</span></span><br><span class="line">$ shutdown +10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消之前指定的关机计划</span></span><br><span class="line">$ shutdown -c</span><br></pre></td></tr></table></figure>
<h4 id="查看或配置网卡信息"><a href="#查看或配置网卡信息" class="headerlink" title="查看或配置网卡信息"></a>查看或配置网卡信息</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ifconfig</td>
<td>configure a network interface</td>
<td>查看/配置计算机当前的网卡配置信息</td>
</tr>
<tr>
<td>02</td>
<td>ping ip地址</td>
<td>ping</td>
<td>检测到目标 ip地址 的连接是否正常</td>
</tr>
</tbody>
</table>
</div>
<h4 id="网卡-和-IP-地址"><a href="#网卡-和-IP-地址" class="headerlink" title="网卡 和 IP 地址"></a>网卡 和 IP 地址</h4><h5 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h5><ul>
<li>网卡是一个专门负责网络通讯的硬件设备</li>
<li><strong>IP 地址</strong>是设置在网卡上的地址信息</li>
</ul>
<blockquote>
<p>我们可以把 <strong>电脑</strong> 比作 <strong>电话</strong>，<strong>网卡</strong> 相当于 <strong>SIM 卡</strong>，<strong>IP 地址</strong> 相当于 <strong>电话号码</strong></p>
</blockquote>
<h5 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h5><ul>
<li><strong>每台联网的电脑上</strong>都有 <strong>IP 地址</strong>，<strong>是保证电脑之间正常通讯的重要设置</strong></li>
</ul>
<blockquote>
<p>注意：每台电脑的 IP 地址不能相同，否则会出现 IP 地址冲突，并且没有办法正常通讯</p>
</blockquote>
<h5 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a><code>ifconfig</code></h5><ul>
<li><code>ifconfig</code> 可以查看／配置计算机当前的网卡配置信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网卡配置信息</span></span><br><span class="line">$ ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网卡对应的 IP 地址</span></span><br><span class="line">$ ifconfig | grep inet</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：一台计算机中有可能会有一个 <strong>物理网卡</strong> 和 <strong>多个虚拟网卡</strong>，在 Linux 中物理网卡的名字通常以 <code>ensXX</code> 表示</p>
</blockquote>
<ul>
<li><code>127.0.0.1</code> 被称为 <strong>本地回环/环回地址</strong>，一般用来测试本机网卡是否正常</li>
</ul>
<h5 id="ping"><a href="#ping" class="headerlink" title="ping"></a><code>ping</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测到目标主机是否连接正常</span></span><br><span class="line">$ ping IP地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测本地网卡工作正常</span></span><br><span class="line">$ ping 127.0.0.1</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ping</code> 一般用于检测当前计算机到目标计算机之间的网络 <strong>是否通畅</strong>，<strong>数值越大，速度越慢</strong></li>
</ul>
<blockquote>
<ul>
<li><code>ping</code> 的工作原理与潜水艇的声纳相似，<code>ping</code> 这个命令就是取自 <strong>声纳的声音</strong> </li>
<li>网络管理员之间也常将 <code>ping</code> 用作动词 —— <strong>ping 一下计算机X，看他是否开着</strong></li>
</ul>
</blockquote>
<p>原理：网络上的机器都有 <strong>唯一确定的 IP 地址</strong>，我们给<strong>目标 IP 地址</strong>发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在</p>
<blockquote>
<p>提示：在 Linux 中，想要终止一个终端程序的执行，绝大多数都可以使用 <code>CTRL + C</code></p>
</blockquote>
<h4 id="远程登录和复制文件"><a href="#远程登录和复制文件" class="headerlink" title="远程登录和复制文件"></a>远程登录和复制文件</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ssh 用户名@ip</td>
<td>secure shell</td>
<td>关机／重新启动</td>
</tr>
<tr>
<td>02</td>
<td>scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径</td>
<td>secure copy</td>
<td>远程复制文件</td>
</tr>
</tbody>
</table>
</div>
<h4 id="ssh-基础"><a href="#ssh-基础" class="headerlink" title="ssh 基础"></a><code>ssh</code> 基础</h4><p>在 Linux 中 SSH 是 <strong>非常常用</strong> 的工具，通过 <strong>SSH 客户端</strong> 可以连接到运行了 <strong>SSH 服务器</strong> 的远程机器上</p>
<p><img src="https://api2.mubu.com/v3/document_image/42fbfc2f-408c-4442-80da-087ddbd5b687-11197877.jpg" alt="SSH示意图">￼</p>
<ul>
<li><strong>SSH 客户端</strong>是一种使用 <code>Secure Shell（SSH）</code> 协议连接到远程计算机的软件程序</li>
<li><code>SSH</code> 是目前较可靠，<strong>专为远程登录会话和其他网络服务</strong> 提供安全性的协议<ul>
<li>利用 <code>SSH 协议</code> 可以有效<strong>防止远程管理过程中的信息泄露</strong></li>
<li>通过 <code>SSH 协议</code> 可以对所有传输的数据进行<strong>加密</strong>，也能够防止 DNS 欺骗和 IP 欺骗</li>
</ul>
</li>
<li><code>SSH</code> 的另一项优点是传输的数据可以是经过<strong>压缩</strong>的，所以可以加快传输的速度</li>
</ul>
<h4 id="域名-和-端口号"><a href="#域名-和-端口号" class="headerlink" title="域名 和 端口号"></a>域名 和 端口号</h4><h5 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h5><ul>
<li>由一串 <strong>用点分隔</strong> 的名字组成，例如：<code>www.baidu.com</code></li>
<li>是 <strong>IP 地址</strong> 的别名，方便用户记忆</li>
</ul>
<h5 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h5><ul>
<li><strong>IP 地址</strong>：通过 <strong>IP 地址</strong> 找到网络上的 <strong>计算机</strong></li>
<li><strong>端口号</strong>：通过 <strong>端口号</strong> 可以找到 <strong>计算机上运行的应用程序</strong><ul>
<li><strong>SSH 服务器</strong> 的默认端口号是 <code>22</code>，如果是默认端口号，在连接的时候，可以省略</li>
</ul>
</li>
<li>常见服务端口号列表：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>服务</th>
<th>端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>SSH 服务器</td>
<td>22</td>
</tr>
<tr>
<td>02</td>
<td>Web 服务器</td>
<td>80</td>
</tr>
<tr>
<td>03</td>
<td>HTTPS</td>
<td>443</td>
</tr>
<tr>
<td>04</td>
<td>FTP 服务器</td>
<td>21</td>
</tr>
</tbody>
</table>
</div>
<h4 id="SSH-客户端的简单使用"><a href="#SSH-客户端的简单使用" class="headerlink" title="SSH 客户端的简单使用"></a>SSH 客户端的简单使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-p port] user@remote</span><br></pre></td></tr></table></figure>
<ul>
<li><code>user</code> 是在远程机器上的用户名，如果不指定的话默认为当前用户</li>
<li><code>remote</code> 是远程机器的地址，可以是 <strong>IP</strong>／<strong>域名</strong>，或者是 <strong>后面会提到的别名</strong></li>
<li><code>port</code> 是 <strong>SSH Server 监听的端口</strong>，如果不指定，就为默认值 <code>22</code></li>
</ul>
<blockquote>
<p>提示：</p>
<ul>
<li>使用 <code>exit</code> 退出当前用户的登录</li>
</ul>
<p>注意：</p>
<ul>
<li><code>ssh</code> 这个终端命令只能在 <code>Linux</code> 或者 <code>UNIX</code> 系统下使用</li>
<li>如果在 <code>Windows</code> 系统中，可以安装 <code>PuTTY</code> 或者 <code>XShell</code> 客户端软件即可</li>
</ul>
<p>提示：</p>
<ul>
<li>在工作中，SSH 服务器的端口号很有可能<strong>不是 22</strong>，如果遇到这种情况就需要使用 <code>-p</code> 选项，指定正确的端口号，否则无法正常连接到服务器</li>
</ul>
</blockquote>
<h4 id="Windows-下-SSH-客户端的安装"><a href="#Windows-下-SSH-客户端的安装" class="headerlink" title="Windows 下 SSH 客户端的安装"></a>Windows 下 SSH 客户端的安装</h4><ul>
<li><code>Putty</code> <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="noopener">http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></li>
<li><code>XShell</code> <a href="http://xshellcn.com" target="_blank" rel="noopener">http://xshellcn.com</a></li>
</ul>
<h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a><code>scp</code></h4><ul>
<li>scp 就是 <code>secure copy</code>，是一个在 Linux 下用来进行 <strong>远程拷贝文件</strong> 的命令</li>
<li>它的<strong>地址格式与 ssh 基本相同</strong>，<strong>需要注意的是</strong>，在指定<strong>端口时用的是大写的 <code>-P</code> 而不是小写的</strong></li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/be4dc3b6-1fd2-44b3-8d3a-90afee22e1c8-11197877.jpg" alt="SCP示意图">￼</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py</span></span><br><span class="line"><span class="comment"># 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径</span></span><br><span class="line">scp -P port 01.py user@remote:Desktop/01.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py</span></span><br><span class="line">scp -P port user@remote:Desktop/01.py 01.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上 -r 选项可以传送文件夹</span></span><br><span class="line"><span class="comment"># 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop</span></span><br><span class="line">scp -r demo user@remote:Desktop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹</span></span><br><span class="line">scp -r user@remote:Desktop demo</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</td>
</tr>
<tr>
<td>-P</td>
<td>若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意：</p>
<ul>
<li><code>scp</code> 这个终端命令只能在 <code>Linux</code> 或者 <code>UNIX</code> 系统下使用</li>
<li>如果在 <code>Windows</code> 系统中，可以安装 <code>PuTTY</code>，使用 <code>pscp</code> 命令行工具或者安装 <code>FileZilla</code> 使用 <code>FTP</code> 进行文件传输</li>
</ul>
</blockquote>
<h4 id="FileZilla"><a href="#FileZilla" class="headerlink" title="FileZilla"></a><code>FileZilla</code></h4><ul>
<li>官方网站：<a href="https://www.filezilla.cn/download/client" target="_blank" rel="noopener">https://www.filezilla.cn/download/client</a></li>
<li><code>FileZilla</code> 在传输文件时，使用的是 <code>FTP 服务</code> 而不是 <code>SSH 服务</code>，因此端口号应该设置为 <code>21</code></li>
</ul>
<h4 id="SSH-高级"><a href="#SSH-高级" class="headerlink" title="SSH 高级"></a>SSH 高级</h4><ul>
<li>免密码登录</li>
<li>配置别名</li>
</ul>
<blockquote>
<p>提示：有关 SSH 配置信息都保存在用户家目录下的 <code>.ssh</code> 目录下</p>
</blockquote>
<h5 id="免密码登录"><a href="#免密码登录" class="headerlink" title="免密码登录"></a>免密码登录</h5><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>配置公钥 <ul>
<li>执行 <code>ssh-keygen</code> 即可生成 SSH 钥匙，一路回车即可</li>
</ul>
</li>
<li>上传公钥到服务器 <ul>
<li>执行 <code>ssh-copy-id -p port user@remote</code>，可以让远程服务器记住我们的公钥</li>
</ul>
</li>
</ul>
<h5 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h5><p><img src="https://api2.mubu.com/v3/document_image/d2e4130c-8c39-4c4c-99bf-9efde29eb97b-11197877.jpg" alt="SSH 免密码示意图">￼</p>
<blockquote>
<p>非对称加密算法</p>
<ul>
<li>使用 <strong>公钥</strong> 加密的数据，需要使用 <strong>私钥</strong> 解密</li>
<li>使用 <strong>私钥</strong> 加密的数据，需要使用 <strong>公钥</strong> 解密</li>
</ul>
</blockquote>
<h5 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h5><p>每次都输入 <code>ssh -p port user@remote</code>，时间久了会觉得很麻烦，特别是当 <code>user</code>, <code>remote</code> 和 <code>port</code> 都得输入，而且还不好记忆</p>
<p>而 <strong>配置别名</strong> 可以让进一步偷懒，譬如用：<code>ssh mac</code> 来替代上面这么一长串，那么就在 <code>~/.ssh/config</code> 里面追加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host mac</span><br><span class="line">    HostName ip地址</span><br><span class="line">    User itheima</span><br><span class="line">    Port 22</span><br></pre></td></tr></table></figure>
<p><strong>保存之后，即可用 <code>ssh mac</code> 实现远程登录了，<code>scp</code> 同样可以使用</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/02/linux-02linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%20-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/linux-02linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%20-1/" class="post-title-link" itemprop="url">Linux常用命令使用-2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-02 21:29:16" itemprop="dateCreated datePublished" datetime="2020-03-02T21:29:16+08:00">2020-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:47:13" itemprop="dateModified" datetime="2021-03-20T20:47:13+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="系统相关命令"><a href="#系统相关命令" class="headerlink" title="系统相关命令"></a>系统相关命令</h3><h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>date</td>
<td>查看系统时间</td>
</tr>
<tr>
<td>02</td>
<td>cal</td>
<td><code>calendar</code> 查看日历，<code>-y</code> 选项可以查看一年的日历</td>
</tr>
</tbody>
</table>
</div>
<h4 id="磁盘信息"><a href="#磁盘信息" class="headerlink" title="磁盘信息"></a>磁盘信息</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>df -h</td>
<td><code>disk free</code> 显示磁盘剩余空间</td>
</tr>
<tr>
<td>02</td>
<td>du -h [目录名]</td>
<td><code>disk usage</code> 显示目录下的文件大小</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>选项说明</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-h</td>
<td>以人性化的方式显示文件大小</td>
</tr>
</tbody>
</table>
</div>
<h4 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h4><ul>
<li>所谓 <strong>进程</strong>，通俗地说就是 <strong>当前正在执行的一个程序</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ps aux</td>
<td><code>process status</code> 查看<strong>进程的详细状况</strong></td>
</tr>
<tr>
<td>02</td>
<td>top</td>
<td><strong>动态显示运行中的进程并且排序</strong></td>
</tr>
<tr>
<td>03</td>
<td>htop</td>
<td>更方便的动态显示运行中的进程并且排序</td>
</tr>
<tr>
<td>04</td>
<td>kill [-9] 进程代号</td>
<td>终止指定代号的进程，<code>-9</code> 表示强行终止</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><code>ps</code> 默认只会显示当前用户通过终端启动的应用程序</p>
</blockquote>
<ul>
<li><code>ps</code> 选项说明功能</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>显示终端上的所有进程，包括其他用户的进程</td>
</tr>
<tr>
<td>u</td>
<td>显示进程的详细状态</td>
</tr>
<tr>
<td>x</td>
<td>显示没有控制终端的进程</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>提示：使用 <code>kill</code> 命令时，最好只终止由当前用户开启的进程，而不要终止 <code>root</code> 身份开启的进程，否则可能导致系统崩溃</p>
<ul>
<li>要退出 <code>top</code> 可以直接输入 <code>q</code></li>
</ul>
</blockquote>
<h3 id="用户权限相关命令"><a href="#用户权限相关命令" class="headerlink" title="用户权限相关命令"></a>用户权限相关命令</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><strong>用户</strong> 是 Linux 系统工作中重要的一环，用户管理包括 <strong>用户</strong> 与 <strong>组</strong> 管理</li>
<li>在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都<strong>必须拥有一个账号</strong>，并且<strong>对于不同的系统资源拥有不同的使用权限</strong></li>
<li>在 Linux 中，可以指定 <strong>每一个用户</strong> 针对 <strong>不同的文件或者目录</strong> 的 <strong>不同权限</strong></li>
<li>对 <strong>文件／目录</strong> 的权限包括：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">权限</th>
<th style="text-align:center">英文</th>
<th style="text-align:center">缩写</th>
<th style="text-align:center">数字代号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">读</td>
<td style="text-align:center">read</td>
<td style="text-align:center">r</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">02</td>
<td style="text-align:center">写</td>
<td style="text-align:center">write</td>
<td style="text-align:center">w</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">03</td>
<td style="text-align:center">执行</td>
<td style="text-align:center">excute</td>
<td style="text-align:center">x</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<h4 id="组"><a href="#组" class="headerlink" title="组"></a>组</h4><ul>
<li><p>为了方便用户管理，提出了 <strong>组</strong> 的概念</p>
</li>
<li><p>在实际应用中，可以预先针对 <strong>组</strong> 设置好权限，然后 <strong>将不同的用户添加到对应的组中</strong>，从而<strong>不用依次为每一个用户设置权限</strong></p>
</li>
</ul>
<h4 id="ls-l-扩展"><a href="#ls-l-扩展" class="headerlink" title="ls -l 扩展"></a>ls -l 扩展</h4><ul>
<li><code>ls -l</code> 可以查看文件夹下文件的详细信息，从左到右依次是：<ul>
<li><strong>权限</strong>，第 1 个字符如果是 <code>d</code> 表示目录</li>
<li><strong>硬链接数</strong>，通俗地讲，就是<strong>有多少种方式，可以访问到当前目录／文件</strong></li>
<li><strong>拥有者</strong>，家目录下 文件／目录 的拥有者通常都是当前用户</li>
<li><strong>组</strong>，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲</li>
<li><strong>大小</strong></li>
<li><strong>时间</strong></li>
<li><strong>名称</strong></li>
</ul>
</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/bb7185f1-43e5-48fc-a2be-52411cc3e61d-11197877.jpg" alt="权限示意图">￼</p>
<h4 id="chmod-简单使用"><a href="#chmod-简单使用" class="headerlink" title="chmod 简单使用"></a><code>chmod</code> 简单使用</h4><ul>
<li><code>chmod</code> 可以修改 <strong>用户／组</strong> 对 <strong>文件／目录</strong> 的权限</li>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：以上方式会一次性修改 <code>拥有者</code> / <code>组</code> 权限</p>
</blockquote>
<h4 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h4><ul>
<li>Linux 系统中的 <code>root</code> 账号通常 <strong>用于系统的维护和管理</strong>，对操作系统的所有资源 <strong>具有所有访问权限</strong></li>
<li>在大多数版本的 Linux 中，都不推荐 <strong>直接使用 root 账号登录系统</strong></li>
<li>在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户”</li>
</ul>
<h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><ul>
<li><code>su</code> 是 <code>substitute user</code> 的缩写，表示 <strong>使用另一个用户的身份</strong></li>
<li><strong><code>sudo</code> 命令用来以其他身份来执行命令，预设的身份为 <code>root</code></strong></li>
<li>用户使用 <code>sudo</code> 时，必须先输入密码，之后有 <strong>5 分钟的有效期限</strong>，超过期限则必须重新输入密码</li>
</ul>
<blockquote>
<p>若其未经授权的用户企图使用 <code>sudo</code>，则会发出警告邮件给管理员</p>
</blockquote>
<h4 id="组管理-终端命令"><a href="#组管理-终端命令" class="headerlink" title="组管理 终端命令"></a><strong>组管理</strong> 终端命令</h4><blockquote>
<p>提示：<strong>创建组</strong> / <strong>删除组</strong> 的终端命令都需要通过 <code>sudo</code> 执行</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>groupadd 组名</td>
<td>添加组</td>
</tr>
<tr>
<td>02</td>
<td>groupdel 组名</td>
<td>删除组</td>
</tr>
<tr>
<td>03</td>
<td>cat /etc/group</td>
<td>确认组信息</td>
</tr>
<tr>
<td>04</td>
<td>chgrp -R 组名 文件/目录名</td>
<td>递归修改文件/目录的所属组</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>提示：</p>
<ul>
<li>组信息保存在 <code>/etc/group</code> 文件中</li>
<li><code>/etc</code> 目录是专门用来保存 <strong>系统配置信息</strong> 的目录￼</li>
</ul>
</blockquote>
<ul>
<li>在实际应用中，可以预先针对 <strong>组</strong> 设置好权限，然后 <strong>将不同的用户添加到对应的组中</strong>，从而<strong>不用依次为每一个用户设置权限</strong></li>
</ul>
<h4 id="用户管理-终端命令"><a href="#用户管理-终端命令" class="headerlink" title="用户管理 终端命令"></a><strong>用户管理</strong> 终端命令</h4><blockquote>
<p>提示：<strong>创建用户</strong> / <strong>删除用户</strong> / <strong>修改其他用户密码</strong> 的终端命令都需要通过 <code>sudo</code> 执行</p>
</blockquote>
<h5 id="创建用户／设置密码／删除用户"><a href="#创建用户／设置密码／删除用户" class="headerlink" title="创建用户／设置密码／删除用户"></a>创建用户／设置密码／删除用户</h5><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>useradd -m -g 组 新建用户名</td>
<td>添加新用户</td>
<td>-m 自动建立用户家目录-g 指定用户所在的组，否则会建立一个和同名的组</td>
</tr>
<tr>
<td>02</td>
<td>passwd 用户名</td>
<td>设置用户密码</td>
<td><strong>如果是普通用户，直接用 passwd 可以修改自己的账户密码</strong></td>
</tr>
<tr>
<td>03</td>
<td>userdel -r 用户名</td>
<td>删除用户</td>
<td><strong>-r 选项会自动删除用户家目录</strong></td>
</tr>
<tr>
<td>04</td>
<td>cat /etc/passwd `</td>
<td>` grep 用户名</td>
<td>确认用户信息</td>
<td>新建用户后，用户信息会保存在 /etc/passwd 文件中</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>提示：</p>
<ul>
<li>创建用户时，如果忘记添加 <code>-m</code> 选项指定新用户的家目录 —— 最简单的方法就是<strong>删除用户，重新创建</strong></li>
<li>创建用户时，默认会创建一个和<strong>用户名</strong>同名的<strong>组名</strong></li>
<li>用户信息保存在 <code>/etc/passwd</code> 文件中</li>
</ul>
</blockquote>
<h5 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h5><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>id [用户名]</td>
<td>查看用户 UID 和 GID 信息</td>
</tr>
<tr>
<td>02</td>
<td>who</td>
<td>查看当前所有登录的用户列表</td>
</tr>
<tr>
<td>03</td>
<td>whoami</td>
<td>查看当前登录用户的账户名</td>
</tr>
</tbody>
</table>
</div>
<h5 id="passwd-文件"><a href="#passwd-文件" class="headerlink" title="passwd 文件"></a>passwd 文件</h5><p><code>/etc/passwd</code> 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是</p>
<ol>
<li>用户名</li>
<li>密码（x，表示加密的密码）</li>
<li>UID（用户标识）</li>
<li>GID（组标识）</li>
<li>用户全名或本地帐号</li>
<li>家目录</li>
<li>登录使用的 Shell，就是登录之后，使用的终端命令，<code>ubuntu</code> 默认用 <code>dash</code></li>
</ol>
<h5 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h5><ul>
<li><code>usermod</code> 可以用来设置 <strong>用户</strong> 的 <strong>主组</strong> ／ <strong>附加组</strong> 和 <strong>登录 Shell</strong>，命令格式如下：<ul>
<li><strong>主组</strong>：通常在新建用户时指定，在 <code>etc/passwd</code> 的第 4 列 <strong>GID 对应的组</strong></li>
<li><strong>附加组</strong>：在 <code>etc/group</code> 中最后一列表示该组的用户列表，用于指定 <strong>用户的附加权限</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>提示：设置了用户的附加组之后，需要重新登录才能生效！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改用户的主组（passwd 中的 GID）</span></span><br><span class="line">usermod -g 组 用户名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户的附加组</span></span><br><span class="line">usermod -G 组 用户名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户登录 Shell</span></span><br><span class="line">usermod -s /bin/bash 用户名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：默认使用 <code>useradd</code> 添加的用户是没有权限使用 <code>sudo</code> 以 <code>root</code> 身份执行命令的，可以使用以下命令，将用户添加到 <code>sudo</code> 附加组中</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -G sudo 用户名</span><br></pre></td></tr></table></figure>
<h5 id="which"><a href="#which" class="headerlink" title="which"></a>which</h5><blockquote>
<p>提示</p>
<ul>
<li><code>/etc/passwd</code> 是用于保存用户信息的文件</li>
<li><code>/usr/bin/passwd</code> 是用于修改用户密码的程序</li>
</ul>
</blockquote>
<ul>
<li><code>which</code> 命令可以<strong>查看执行命令所在位置</strong>，例如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># /bin/ls</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">which</span> useradd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># /usr/sbin/useradd</span></span><br></pre></td></tr></table></figure>
<h5 id="bin-和-sbin"><a href="#bin-和-sbin" class="headerlink" title="bin 和 sbin"></a><code>bin</code> 和 <code>sbin</code></h5><ul>
<li>在 <code>Linux</code> 中，绝大多数可执行文件都是保存在 <code>/bin</code>、<code>/sbin</code>、<code>/usr/bin</code>、<code>/usr/sbin</code></li>
<li><code>/bin</code>（<code>binary</code>）是二进制执行文件目录，<strong>主要用于具体应用</strong></li>
<li><code>/sbin</code>（<code>system binary</code>）是<strong>系统管理员专用</strong>的二进制代码存放目录，主要用于<strong>系统管理</strong></li>
<li><code>/usr/bin</code>（<code>user commands for applications</code>）后期安装的一些软件</li>
<li><code>/usr/sbin</code>（<code>super user commands for applications</code>）超级用户的一些管理程序</li>
</ul>
<blockquote>
<p>提示：</p>
<ul>
<li><code>cd</code> 终端命令是内置在系统内核中的，没有独立的文件，因此用 <code>which</code> 无法找到 <code>cd</code> 命令的位置</li>
</ul>
</blockquote>
<h5 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h5><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>su - 用户名</td>
<td>切换用户，并且切换目录</td>
<td>- 可以切换到用户家目录，否则保持位置不变</td>
</tr>
<tr>
<td>02</td>
<td>exit</td>
<td>退出当前登录账户</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>su</code> 不接用户名，可以切换到 <code>root</code>，但是不推荐使用，因为不安全</li>
<li><code>exit</code> 示意图如下：</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/6a787f05-e037-4fbb-95a0-7cbb8aab2f48-11197877.jpg" alt="su和exit示意图">￼</p>
<h5 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h5><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>chown</td>
<td>修改拥有者</td>
</tr>
<tr>
<td>02</td>
<td>chgrp</td>
<td>修改组</td>
</tr>
<tr>
<td>03</td>
<td>chmod</td>
<td>修改权限</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改文件|目录的拥有者</span></span><br><span class="line">chown 用户名 文件名|目录名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件|目录的组</span></span><br><span class="line">chgrp -R 组名 文件名|目录名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件权限</span></span><br><span class="line">chmod -R 755 文件名|目录名</span><br></pre></td></tr></table></figure>
<ul>
<li><code>chmod</code> 在设置权限时，可以简单地使用三个数字分别对应 <strong>拥有者</strong> ／ <strong>组</strong> 和 <strong>其他</strong> 用户的权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他</span></span><br><span class="line">chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/d5fd3e0b-d68b-4218-a3e6-186de7512dcb-11197877.jpg" alt="文件权限示意图"></p>
<ul>
<li>常见数字组合有（<code>u</code>表示用户／<code>g</code>表示组／<code>o</code>表示其他）： <ul>
<li><code>777</code> ===&gt; <code>u=rwx,g=rwx,o=rwx</code> </li>
<li><code>755</code> ===&gt; <code>u=rwx,g=rx,o=rx</code></li>
<li><code>644</code> ===&gt; <code>u=rw,g=r,o=r</code></li>
</ul>
</li>
</ul>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h4><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><ul>
<li><p>目录紧跟在find之后</p>
<ul>
<li><code>find ./ -type &#39;l&#39;</code>找当前目录下的软连接, 子目录会递龟进入;</li>
<li><code>find ./ -name &#39;*.jpg&#39;</code>-找当前目录下的jpg文件, 子目录会递龟进入;</li>
<li><p><code>find ./ -maxdepth 3 -name &#39;*.jpg&#39;</code>-指定目录层级深度为3层;</p>
</li>
<li><p><code>find ./ -size +20M -size -50M</code>-指定大小范围;</p>
</li>
<li><p>按时间查找:</p>
<ul>
<li>-atime(access访问时间)</li>
<li>-ctime(change更改时间)</li>
<li>-mtime(modify改动时间)</li>
<li><code>find ./ -ctime 3</code>查找三天内被改动的文件;</li>
</ul>
</li>
<li><p><code>ls -h</code>-以人类可读的方式显示结果;</p>
</li>
<li>man手册中反斜杠<strong>/</strong>可以用于查找关键字;</li>
</ul>
</li>
</ul>
<h5 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h5><p>grep:按文件内容搜索”return”关键字:</p>
<p><code>grep -r &quot;return&quot; ./ -n</code></p>
<p>ps:监控后台进程的工作情况;</p>
<p><code>ps aux</code></p>
<p>加个管道过滤内容</p>
<p><code>ps aux | grep &quot;kernel&quot;</code>(搜索本身会占一个进程)</p>
<p>如果将管道的手法用在find上(用xargs):</p>
<p><code>find /usr/ -maxdepth 3 -type -f | xargs ls -l</code></p>
<p><strong><code>-exec</code>与<code>xargs</code>的区别:前者会将结果不论多少一股脑的交给-exec, 而xargs会做分片处理(效率更高);</strong></p>
<p>创建名字中有空格的文件:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch abc\ def</span><br><span class="line">$ touch <span class="string">"abc def"</span></span><br></pre></td></tr></table></figure>
<p>由于xargs会将文件名中的空格误认为是分隔符, 解决方式: 控制分隔符:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /usr/ -maxdepth 3 -<span class="built_in">type</span> f -print0 | xargs -0 ls -l</span><br></pre></td></tr></table></figure>
<h4 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h4><ul>
<li><strong>打包压缩</strong> 是日常工作中备份文件的一种方式</li>
<li>在不同操作系统中，常用的打包压缩方式是不同的 <ul>
<li><code>Windows</code> 常用 <code>rar</code></li>
<li><code>Mac</code> 常用 <code>zip</code></li>
<li><code>Linux</code> 常用 <code>tar.gz</code></li>
</ul>
</li>
</ul>
<h4 id="打包-／-解包"><a href="#打包-／-解包" class="headerlink" title="打包 ／ 解包"></a>打包 ／ 解包</h4><ul>
<li><code>tar</code> 是 Linux 中最常用的 <strong>备份</strong>工具，此命令可以 <strong>把一系列文件</strong> 打包到 <strong>一个大文件中</strong>，也可以把一个 <strong>打包的大文件恢复成一系列文件</strong></li>
<li><code>tar</code> 的命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包文件</span></span><br><span class="line">tar -cvf 打包文件.tar 被打包的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包文件</span></span><br><span class="line">tar -xvf 打包文件.tar</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tar</code> 选项说明</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>生成档案文件，创建打包文件</td>
</tr>
<tr>
<td>x</td>
<td>解开档案文件</td>
</tr>
<tr>
<td>v</td>
<td>列出归档解档的详细过程，显示进度</td>
</tr>
<tr>
<td>f</td>
<td>指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意：<code>f</code> 选项必须放在最后，其他选项顺序可以随意</p>
</blockquote>
<h4 id="压缩／解压缩"><a href="#压缩／解压缩" class="headerlink" title="压缩／解压缩"></a>压缩／解压缩</h4><h5 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h5><p>zip压缩:</p>
<p><code>zip -r ziptest.zip hello.c hello.cpp</code></p>
<p>zip解压缩:</p>
<p><code>unzip ziptest.zip</code></p>
<h5 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h5><p><code>tar</code> 与 <code>gzip</code> 命令结合可以使用实现文件 <strong>打包和压缩</strong></p>
<ul>
<li>打包和压缩<ul>
<li><code>tar</code> 只负责打包文件，但不压缩</li>
<li>用 <code>gzip</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.gz</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>在 <code>Linux</code> 中，最常见的压缩文件格式就是 <code>xxx.tar.gz</code></p>
</blockquote>
<ul>
<li><strong>在 <code>tar</code> 命令中有一个选项 -z 可以调用 <code>gzip</code>，从而可以方便的实现压缩和解压缩的功能</strong></li>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩文件</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩到指定路径</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz -C 目标路径</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-C</td>
<td><strong>解压缩到指定目录，注意：要解压缩的目录必须存在</strong></td>
</tr>
</tbody>
</table>
</div>
<h5 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a><code>bzip2</code></h5><ul>
<li><code>tar</code> 与 <code>bzip2</code> 命令结合可以使用实现文件 <strong>打包和压缩</strong>（用法和 <code>gzip</code> 一样）<ul>
<li><code>tar</code> 只负责打包文件，但不压缩，</li>
<li>用 <code>bzip2</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.bz2</code></li>
</ul>
</li>
<li>在 <code>tar</code> 命令中有一个选项 <strong>-j</strong> 可以调用 <code>bzip2</code>，从而可以方便的实现压缩和解压缩的功能</li>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩文件</span></span><br><span class="line">tar -jxvf 打包文件.tar.bz2</span><br></pre></td></tr></table></figure>
<h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><h5 id="通过-apt-安装／卸载软件"><a href="#通过-apt-安装／卸载软件" class="headerlink" title="通过 apt 安装／卸载软件"></a>通过 apt 安装／卸载软件</h5><ul>
<li>apt 是 <code>Advanced Packaging Tool</code>，是 Linux 下的一款安装包管理工具</li>
<li>可以在终端中方便的 <strong>安装</strong>／<strong>卸载</strong>／<strong>更新软件包</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装软件</span></span><br><span class="line">$ sudo apt install 软件包</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 卸载软件</span></span><br><span class="line">$ sudo apt remove 软件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 更新已安装的包</span></span><br><span class="line">$ sudo apt upgrade </span><br><span class="line"><span class="comment"># 4. 更新源服务器列表:</span></span><br><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<h5 id="配置软件源"><a href="#配置软件源" class="headerlink" title="配置软件源"></a>配置软件源</h5><ul>
<li>如果希望在 <code>ubuntu</code> 中安装软件，<strong>更加快速</strong>，可以通过设置<strong>镜像源</strong>，选择一个访问网速更快的服务器，来提供软件下载／安装服务</li>
<li>提示：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了</li>
</ul>
<blockquote>
<p>所谓镜像源，就是<strong>所有服务器的内容是相同的（镜像）</strong>，但是根据所在位置不同，国内服务器通常速度会更快一些！</p>
</blockquote>
<h5 id="通过deb包安装"><a href="#通过deb包安装" class="headerlink" title="通过deb包安装"></a>通过deb包安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安装deb软件包命令： sudo dpkg -i xxx.deb</span><br><span class="line">删除软件包命令： sudo dpkg -r xxx.deb</span><br><span class="line">连同配置文件一起删除：sudo dpkg -r --purge xxx.deb</span><br><span class="line">查看软件包信息命令：sudo dpkg -info xxx.deb</span><br><span class="line">查看文件拷贝详细命令：sudo dpkg -L xxx.deb</span><br><span class="line">查看系统中已安装软件包信息：sudo dpkg -l</span><br><span class="line">重新配置软件包命令：sudo dpkg -reconfigure xxx</span><br></pre></td></tr></table></figure>
<h5 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.解压缩源代码包</span><br><span class="line">2.cd dir</span><br><span class="line">3. ./configure <span class="comment"># 检测文件是否缺失，创建Makefile, 检查编译环境</span></span><br><span class="line">4. make <span class="comment"># 编译源码，生成库和可执行程序</span></span><br><span class="line">5. sudo make install <span class="comment">#将库和可执行程序，安装到系统路径下</span></span><br><span class="line">6. sudo make distclean <span class="comment"># 删除和卸载软件</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/01/linux_01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/01/linux_01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/" class="post-title-link" itemprop="url">Linux 文件和目录及相关操作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-01 21:29:16" itemprop="dateCreated datePublished" datetime="2020-03-01T21:29:16+08:00">2020-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:52:54" itemprop="dateModified" datetime="2021-03-20T20:52:54+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="单用户操作系统和多用户操作系统"><a href="#单用户操作系统和多用户操作系统" class="headerlink" title="单用户操作系统和多用户操作系统"></a>单用户操作系统和多用户操作系统</h3><ul>
<li><strong>单用户操作系统</strong>：指一台计算机在同一时间 <strong>只能由一个用户</strong> 使用，<strong>一个用户独自享用系统的全部硬件和软件资源</strong><ul>
<li><strong>Windows XP</strong> 之前的版本都是单用户操作系统</li>
</ul>
</li>
<li><strong>多用户操作系统</strong>：指一台计算机在同一时间可以由 <strong>多个用户</strong> 使用，多个用户共<strong>同享用系统的全部硬件和软件资源</strong><ul>
<li><strong>Unix</strong> 和 <strong>Linux</strong> 的设计初衷就是多用户操作系统</li>
</ul>
</li>
</ul>
<h3 id="linux下的文件系统"><a href="#linux下的文件系统" class="headerlink" title="linux下的文件系统"></a>linux下的文件系统</h3><h4 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h4><ul>
<li>普通-</li>
<li>目录d</li>
<li>字符设备c</li>
<li>块设备b</li>
<li>软连接l</li>
<li>管道p</li>
<li>套接字s</li>
<li>Unknown</li>
</ul>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><ul>
<li><p>在 <code>Windows</code> 下，打开 “计算机”，看到的是一个个的驱动器盘符：eg: C盘，D盘…。</p>
<ul>
<li>每个驱动器都有自己的根目录结构，形成多个树并列的情形。</li>
</ul>
</li>
<li><p>在 <code>Linux</code> 下，看不到驱动器盘符，看到的是<strong>文件夹（目录）</strong></p>
<ul>
<li>linux没有盘符概念，只有一个根目录 <code>/</code>，所有文件都在它下面</li>
</ul>
</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/fe5a0a8b-ade0-401a-b879-f7264d3f0a80-11197877.jpg" alt="linux文件系统"></p>
<ul>
<li><p>用户目录</p>
<ul>
<li><p>位于 <code>/home/xxx</code>，称之为用户工作目录或家目录，表示方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/xx</span><br><span class="line">~</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>/：根目录，<strong>一般根目录下只存放目录</strong>，在 linux 下有且只有一个根目录，所有的东西都是从这里开始 </p>
<ul>
<li>当在终端里输入 <code>cd /home</code>，其实是在告诉电脑，先从 <code>/</code>（根目录）开始，再进入到 <code>home</code> 目录</li>
</ul>
</li>
<li><p>/bin、/usr/bin：可执行二进制文件的目录，如<strong>常用的命令 ls、tar、mv、cat</strong> 等</p>
</li>
<li><p>/boot：放置 linux <strong>系统启动</strong>时用到的一些文件，如 linux 的<strong>内核</strong>文件：<code>/boot/vmlinuz</code>，<strong>系统引导</strong>管理器：<code>/boot/grub</code></p>
</li>
<li><p>/dev：存放linux系统下的<strong>设备文件</strong>，<strong>访问该目录下某个文件，相当于访问某个设备</strong>，常用的是挂载光驱<code>mount /dev/cdrom /mnt</code></p>
</li>
<li><p>/etc：<strong>系统配置文件</strong>存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有  </p>
<ul>
<li>/etc/inittab</li>
<li>/etc/fstab</li>
<li>/etc/init.d</li>
<li>/etc/X11</li>
<li>/etc/sysconfig</li>
<li><p>/etc/xinetd.d</p>
</li>
<li><p>/etc/profile</p>
</li>
</ul>
</li>
<li><p>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下 </p>
<ul>
<li><strong><code>~</code> 表示当前用户的家目录</strong></li>
<li><code>~xxx</code> 表示用户 <code>xxx</code> 的家目录</li>
</ul>
</li>
<li><p>/lib、/usr/lib、/usr/local/lib：<strong>系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助</strong></p>
</li>
<li><p>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下</p>
</li>
<li><p>/mnt: /media：光盘默认<strong>挂载点</strong>，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载</p>
</li>
<li><p>/opt：给主机<strong>额外安装软件所摆放的目录</strong></p>
</li>
<li><p>/proc：<strong>此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间</strong>，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等</p>
</li>
<li><p>/root：<strong>系统管理员root的家目录</strong></p>
</li>
<li><p>/sbin、/usr/sbin、/usr/local/sbin：放置<strong>系统管理员使用的可执行命令</strong>，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令<strong>，一般用户只能”查看”而不能设置和使用</strong></p>
</li>
<li><p>/tmp：一般用户或正在执行的程序<strong>临时存放文件的目录</strong>，任何人都可以访问，<strong>重要数据不可放置在此目录下</strong></p>
</li>
<li><p>/srv：<strong>服务启动之后需要访问的数据目录</strong>，如 www 服务需要访问的网页数据存放在 /srv/www 内</p>
</li>
<li><p>/usr：<strong>应用程序存</strong>放目录 </p>
<ul>
<li>/usr/bin：存放应用程序</li>
<li>/usr/share：存放共享数据</li>
<li>/usr/lib：存放不能直接运行的，<strong>却是许多程序运行所必需的一些函数库文件</strong></li>
<li>/usr/local：存放<strong>软件升级包</strong></li>
<li>/usr/share/doc：系统说明文件存放目录</li>
<li>/usr/share/man：程序说明文件存放目录</li>
</ul>
</li>
<li><p>/var：放置系统执行过程中<strong>经常变化的文件</strong> </p>
<ul>
<li>/var/log：随时更改的<strong>日志</strong>文件 </li>
<li>/var/spool/mail：邮件存放的目录</li>
<li>/var/run：程序或服务启动后，其 PID 存放在该目录下</li>
</ul>
</li>
</ul>
<h4 id="文件和目录常用命令"><a href="#文件和目录常用命令" class="headerlink" title="文件和目录常用命令"></a>文件和目录常用命令</h4><ul>
<li>查看目录内容 <ul>
<li><code>ls</code></li>
</ul>
</li>
<li>切换目录 <ul>
<li><code>cd</code></li>
</ul>
</li>
<li>创建和删除操作 <ul>
<li><code>touch</code></li>
<li><code>rm</code></li>
<li><code>mkdir</code></li>
</ul>
</li>
<li>拷贝和移动文件 <ul>
<li><code>cp</code></li>
<li><code>mv</code></li>
</ul>
</li>
<li>查看文件内容 <ul>
<li><code>cat</code></li>
<li><code>more</code></li>
<li><code>grep</code></li>
</ul>
</li>
<li>其他 <ul>
<li><code>echo</code></li>
<li>重定向 <code>&gt;</code> 和 <code>&gt;&gt;</code></li>
<li>管道 <code>|</code></li>
</ul>
</li>
</ul>
<h5 id="查看目录ls-命令说明"><a href="#查看目录ls-命令说明" class="headerlink" title="查看目录ls 命令说明"></a>查看目录<code>ls</code> 命令说明</h5><ul>
<li><code>ls</code> 是英文单词 <strong>list</strong> 的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于 <strong>DOS</strong> 下的 <code>dir</code> 命令</li>
</ul>
<h5 id="Linux-下文件和目录的特点"><a href="#Linux-下文件和目录的特点" class="headerlink" title="Linux 下文件和目录的特点"></a>Linux 下文件和目录的特点</h5><ul>
<li>Linux <strong>文件</strong> 或者 <strong>目录</strong> 名称最长可以有 <code>256</code> 个字符</li>
<li>以 <code>.</code> 开头的文件为隐藏文件，需要用 -a 参数才能显示</li>
<li><strong>.</strong> 代表当前目录</li>
<li><strong>..</strong> 代表上一级目录</li>
</ul>
<h5 id="ls-常用选项"><a href="#ls-常用选项" class="headerlink" title="ls 常用选项"></a>ls 常用选项</h5><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>显示指定目录下所有子目录与文件，包括隐藏文件</td>
</tr>
<tr>
<td>-l</td>
<td>以列表方式显示文件的详细信息</td>
</tr>
<tr>
<td>-h</td>
<td>配合 -l 以人性化的方式显示文件大小</td>
</tr>
</tbody>
</table>
</div>
<h5 id="计算机中文件大小的表示方式"><a href="#计算机中文件大小的表示方式" class="headerlink" title="计算机中文件大小的表示方式"></a>计算机中文件大小的表示方式</h5><div class="table-container">
<table>
<thead>
<tr>
<th>单位</th>
<th>英文</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节</td>
<td>B（Byte）</td>
<td>在计算机中作为一个数字单元，一般为 8 位二进制数</td>
</tr>
<tr>
<td>千</td>
<td>K（Kibibyte）</td>
<td>1 KB = 1024 B，千字节 （1024 = 2 ** 10）</td>
</tr>
<tr>
<td>兆</td>
<td>M（Mebibyte）</td>
<td>1 MB = 1024 KB，百万字节</td>
</tr>
<tr>
<td>千兆</td>
<td>G（Gigabyte）</td>
<td>1 GB = 1024 MB，十亿字节，千兆字节</td>
</tr>
<tr>
<td>太</td>
<td>T（Terabyte）</td>
<td>1 TB = 1024 GB，万亿字节，太字节</td>
</tr>
<tr>
<td>拍</td>
<td>P（Petabyte）</td>
<td>1 PB = 1024 TB，千万亿字节，拍字节</td>
</tr>
<tr>
<td>艾</td>
<td>E（Exabyte）</td>
<td>1 EB = 1024 PB，百亿亿字节，艾字节</td>
</tr>
<tr>
<td>泽</td>
<td>Z（Zettabyte）</td>
<td>1 ZB = 1024 EB，十万亿亿字节，泽字节</td>
</tr>
<tr>
<td>尧</td>
<td>Y（Yottabyte）</td>
<td>1 YB = 1024 ZB，一亿亿亿字节，尧字节</td>
</tr>
</tbody>
</table>
</div>
<h5 id="ls-通配符的使用"><a href="#ls-通配符的使用" class="headerlink" title="ls 通配符的使用"></a>ls 通配符的使用</h5><div class="table-container">
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>代表任意个数个字符</td>
</tr>
<tr>
<td>?</td>
<td>代表任意一个字符，至少 1 个</td>
</tr>
<tr>
<td>[]</td>
<td>表示可以匹配字符组中的任一一个</td>
</tr>
<tr>
<td>[abc]</td>
<td>匹配 a、b、c 中的任意一个</td>
</tr>
<tr>
<td>[a-f]</td>
<td>匹配从 a 到 f 范围内的的任意一个字符</td>
</tr>
</tbody>
</table>
</div>
<h5 id="文件操作基本命令"><a href="#文件操作基本命令" class="headerlink" title="文件操作基本命令"></a>文件操作基本命令</h5><p><code>more</code>-分屏显示文件内容, 空格翻页;</p>
<p><code>less</code>同理;</p>
<p><code>head -n file</code>-查看file的前n行;</p>
<p><code>tail -n file</code>-查看file的后n行;</p>
<h5 id="目录及操作基本命令"><a href="#目录及操作基本命令" class="headerlink" title="目录及操作基本命令"></a>目录及操作基本命令</h5><p><strong>一个目录所占的磁盘大小为4K;</strong></p>
<p><code>cd -</code>-在两个目录之间来回切换;</p>
<p><code>rmdir</code>-删除空目录;</p>
<p><code>cp -a/-r srcdir dstdir</code>-拷贝目录;</p>
<h5 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h5><ul>
<li><code>find</code> 命令功能非常强大，通常用来在 <strong>特定的目录下</strong> <strong>搜索</strong> 符合条件的文件</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>find [路径] -name “*.py”</td>
<td>查找指定路径下扩展名是 <code>.py</code> 的文件，包括子目录</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>如果省略路径，表示在当前文件夹下查找</strong></li>
<li>之前学习的通配符，在使用 <code>find</code> 命令时同时可用</li>
</ul>
<h5 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h5><ul>
<li><p>软连接是<strong>一个文件</strong>，其中存的就是<strong>文件的路径</strong>, 路径有几个字符就占几个字节, 所以建议用绝对路径创建软连接;</p>
<ul>
<li>注意文件的权限, <strong>软连接的权限代表其本身的权限, 与指向的目的文件无关</strong>;</li>
</ul>
</li>
<li><p>创建硬链接会增加硬链接计数;</p>
<ul>
<li>这些硬链接只想同一个文件, 修改一个其余的会同步变化;</li>
<li>所有的硬链接有相同的<strong>Inode</strong>(文件统一id);</li>
<li>删除只是把硬链接计数-1;</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ln -s 被链接的源文件 链接文件</td>
<td>建立文件的软链接，用通俗的方式讲<strong>类似于</strong> Windows 下的<strong>快捷方式</strong></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>没有 <code>-s</code> 选项建立的是一个 <strong>硬链接文件</strong><ul>
<li>两个文件占用相同大小的硬盘空间，<strong>工作中几乎不会建立文件的硬链接</strong></li>
</ul>
</li>
<li><strong>源文件要使用绝对路径</strong>，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s hello.c hello.c.s #创建软连接;</span><br><span class="line">ln hello.c hello.c.h #创建硬链接;</span><br></pre></td></tr></table></figure>
<h5 id="文件软硬链接的示意图"><a href="#文件软硬链接的示意图" class="headerlink" title="文件软硬链接的示意图"></a>文件软硬链接的示意图</h5><p><img src="https://api2.mubu.com/v3/document_image/1f4e640f-dc3e-4678-bb88-9fa7c1321aeb-11197877.jpg" alt="文件软硬链接示意图"></p>
<blockquote>
<p>在 Linux 中，<strong>文件名</strong> 和 <strong>文件的数据</strong> 是分开存储的</p>
</blockquote>
<ul>
<li>提示： <ul>
<li>在 Linux 中，只有文件的 <code>硬链接数 == 0</code> 才会被删除</li>
<li>使用 <code>ls -l</code> 可以查看一个文件的硬链接的数量</li>
</ul>
</li>
</ul>
<h4 id="磁盘分区类型"><a href="#磁盘分区类型" class="headerlink" title="磁盘分区类型"></a>磁盘分区类型</h4><ul>
<li>主分区：最多只能有四个</li>
<li>扩展分区：最多一个，算作主分区的一种，主分区加扩展分区最多有四个。扩展分区不能存储数据和格式化，必须再划分为逻辑分区才可以使用。</li>
<li>逻辑分区：在扩展分区中划分</li>
</ul>
<p>逻辑分区的编号从5开始</p>
<h4 id="支持的文件系统"><a href="#支持的文件系统" class="headerlink" title="支持的文件系统"></a>支持的文件系统</h4><ul>
<li>ext2:ext文件系统的升级版。最大支持16TB的分区和最大2TB的文件。</li>
<li>ext3:ext2的升级，增加日志功能。</li>
<li>ext4:ext3升级版本，主流使用，功能强大</li>
</ul>
<h4 id="文件系统常用命令"><a href="#文件系统常用命令" class="headerlink" title="文件系统常用命令"></a>文件系统常用命令</h4><h4 id="df-du-fsck-dump2fs"><a href="#df-du-fsck-dump2fs" class="headerlink" title="df, du, fsck, dump2fs"></a>df, du, fsck, dump2fs</h4><h5 id="文件系统查看命令df"><a href="#文件系统查看命令df" class="headerlink" title="文件系统查看命令df"></a>文件系统查看命令df</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df \[选项][挂载点]</span><br><span class="line"></span><br><span class="line">-a 所有文件系统信息</span><br><span class="line"></span><br><span class="line">-h 使用习惯单位显示容量，如kB,MB,GB</span><br><span class="line"></span><br><span class="line">ls 只统计目录下的大小，而不会统计子目录下的数据大小。</span><br></pre></td></tr></table></figure>
<h5 id="统计目录或文件大小du"><a href="#统计目录或文件大小du" class="headerlink" title="统计目录或文件大小du"></a>统计目录或文件大小du</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a , -h , -s</span><br></pre></td></tr></table></figure>
<p>df命令从文件系统考虑，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（eg. 文件已经被删除，但程序并没有释放空间）</p>
<p><strong>du命令面向文件，只会计算文件或目录占用的空间。</strong></p>
<h5 id="文件系统修复命令fsck"><a href="#文件系统修复命令fsck" class="headerlink" title="文件系统修复命令fsck"></a>文件系统修复命令fsck</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck[选项]分区设备文件名</span><br></pre></td></tr></table></figure>
<h5 id="显示磁盘状态命令dumpe2fs"><a href="#显示磁盘状态命令dumpe2fs" class="headerlink" title="显示磁盘状态命令dumpe2fs"></a>显示磁盘状态命令dumpe2fs</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpe2fs 分区设备文件名</span><br></pre></td></tr></table></figure>
<h4 id="文件系统常用命令-挂载命令"><a href="#文件系统常用命令-挂载命令" class="headerlink" title="文件系统常用命令-挂载命令"></a>文件系统常用命令-挂载命令</h4><h5 id="查询与自动挂载"><a href="#查询与自动挂载" class="headerlink" title="查询与自动挂载"></a>查询与自动挂载</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount [-l]：查询系统中已经挂载的设备，-l会显示卷标名称</span><br><span class="line"></span><br><span class="line">mount -a 依据配置文件/etc/fastb的内容，自动挂载</span><br></pre></td></tr></table></figure>
<h5 id="挂载命令格式"><a href="#挂载命令格式" class="headerlink" title="挂载命令格式"></a>挂载命令格式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">-t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3，ext4,iso9660等文件系统</span><br><span class="line"></span><br><span class="line">-L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载</span><br><span class="line"></span><br><span class="line">-o 特殊指令（remount ...）</span><br><span class="line"></span><br><span class="line">mount -o remount ,noexec /home</span><br></pre></td></tr></table></figure>
<h5 id="挂载光盘与U盘"><a href="#挂载光盘与U盘" class="headerlink" title="挂载光盘与U盘"></a>挂载光盘与U盘</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">挂载光盘</span></span><br><span class="line"></span><br><span class="line">mkdir /mnt/cdrom/ #建立挂载点</span><br><span class="line"></span><br><span class="line">mount -t iso9660 /dev/cdrom /mnt/cdrom #挂载光盘</span><br><span class="line"></span><br><span class="line">mount /dev/sr0 /mnt/cdrom</span><br></pre></td></tr></table></figure>
<h5 id="卸载命令"><a href="#卸载命令" class="headerlink" title="卸载命令"></a>卸载命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">umount 设备文件名或挂载点</span><br><span class="line"></span><br><span class="line">umount /mnt/cdrom</span><br></pre></td></tr></table></figure>
<h5 id="挂载U盘"><a href="#挂载U盘" class="headerlink" title="挂载U盘"></a>挂载U盘</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l 查看U盘设备文件名</span><br><span class="line"></span><br><span class="line">mount -t vfat /dev/sdb1 /mnt/usb/</span><br><span class="line"></span><br><span class="line">linux默认不支持NTFS文件系统</span><br></pre></td></tr></table></figure>
<h4 id="fdisk分区"><a href="#fdisk分区" class="headerlink" title="fdisk分区"></a>fdisk分区</h4><h5 id="fdisk命令分区过程"><a href="#fdisk命令分区过程" class="headerlink" title="fdisk命令分区过程"></a>fdisk命令分区过程</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.添加硬盘，虚拟机必须在关机的情况下添加</span><br><span class="line"></span><br><span class="line">2.查看新硬盘 fdisk -l</span><br><span class="line"></span><br><span class="line">3.使用fdisk命令分区</span><br><span class="line"></span><br><span class="line">fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">4.重新读取分区表信息</span><br><span class="line"></span><br><span class="line">partprobe</span><br><span class="line"></span><br><span class="line">5.格式化分区</span><br><span class="line"></span><br><span class="line">扩展分区不可以格式化</span><br><span class="line"></span><br><span class="line">mkfs -t ext4 /dev/sdb1</span><br><span class="line"></span><br><span class="line">6.建立挂载分区</span><br></pre></td></tr></table></figure>
<h5 id="分区自动挂载与fstab文件修复"><a href="#分区自动挂载与fstab文件修复" class="headerlink" title="分区自动挂载与fstab文件修复"></a>分区自动挂载与fstab文件修复</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将挂载写入/etc/fstab文件，一定要写对</span><br><span class="line"></span><br><span class="line">mount -a 依据配置文件 /etc/fstab的内容，自动挂载</span><br><span class="line"></span><br><span class="line">/etc/fstab文件修复</span><br><span class="line"></span><br><span class="line">mount -o remount,rm /</span><br></pre></td></tr></table></figure>
<h4 id="分配swap分区"><a href="#分配swap分区" class="headerlink" title="分配swap分区"></a>分配swap分区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.free命令</span><br><span class="line">查看内存与swap分区使用情况</span><br><span class="line">cached(缓存):加速数据的读取过程</span><br><span class="line">buffer(缓冲)：写入数据过程中，将分散的写入操作保存到内存中，当达到一定的程度再集中写入硬盘，加速数据的写入过程。</span><br><span class="line"></span><br><span class="line">2.新建swap分区</span><br><span class="line">fdisk /dev/sdb</span><br><span class="line">还需将分区ID改为82</span><br><span class="line"></span><br><span class="line">3.格式化</span><br><span class="line">mkswap /dev/sdb6</span><br><span class="line"></span><br><span class="line">4.加入swap分区</span><br><span class="line">swapon /dev/sdb6 加入swap分区</span><br><span class="line">swapoff /dev/sdb6 取消swap分区</span><br><span class="line"></span><br><span class="line">5.swap分区开机自动挂载</span><br><span class="line">vi /etc/fstab</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShifuDong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShifuDong</p>
  <div class="site-description" itemprop="description">记录生活， 记录学习， 分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/mailto:shifudong.cug.edu@gmail.com" title="E-Mail → mailto:shifudong.cug.edu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShifuDong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  



    </div>
</body>
</html>
