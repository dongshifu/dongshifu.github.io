<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ShifuDong" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="记录生活， 记录学习， 分享知识">
<meta name="keywords" content="生活，C++, C, go, java, OS, 网络， 存储， 联邦学习， 机器学习，python">
<meta property="og:type" content="website">
<meta property="og:title" content="ShifuDong">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;5&#x2F;index.html">
<meta property="og:site_name" content="ShifuDong">
<meta property="og:description" content="记录生活， 记录学习， 分享知识">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ShifuDong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShifuDong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Knowledge Sharing</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-9/" class="post-title-link" itemprop="url">linux网络编程-多路I/O转接服务器:event</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 15:45:00" itemprop="dateCreated datePublished" datetime="2020-05-31T15:45:00+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:19:34" itemprop="dateModified" datetime="2021-04-29T14:19:34+08:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux网络编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/Go%20%E6%8E%A5%E5%8F%A3_0Go%E7%94%A8%20interface%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/Go%20%E6%8E%A5%E5%8F%A3_0Go%E7%94%A8%20interface%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/" class="post-title-link" itemprop="url">Go 用interface实现多态</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 21:29:16" itemprop="dateCreated datePublished" datetime="2020-05-30T21:29:16+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 10:58:15" itemprop="dateModified" datetime="2021-04-08T10:58:15+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Go-用interface实现多态"><a href="#Go-用interface实现多态" class="headerlink" title="Go 用interface实现多态"></a>Go 用interface实现多态</h3><p>Go 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。</p>
<p>多态是一种运行期的行为，它有以下几个特点：</p>
<blockquote>
<ol>
<li>一种类型具有多种类型的能力</li>
<li>允许不同的对象对同一消息做出灵活的反应</li>
<li>以一种通用的方式对待个使用的对象</li>
<li>非动态语言必须通过继承和接口的方式来实现</li>
</ol>
</blockquote>
<p>看一个实现了多态的代码例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	qcrao := Student&#123;age: <span class="number">18</span>&#125;</span><br><span class="line">	whatJob(&amp;qcrao)</span><br><span class="line"></span><br><span class="line">	growUp(&amp;qcrao)</span><br><span class="line">	fmt.Println(qcrao)</span><br><span class="line"></span><br><span class="line">	stefno := Programmer&#123;age: <span class="number">100</span>&#125;</span><br><span class="line">	whatJob(stefno)</span><br><span class="line"></span><br><span class="line">	growUp(stefno)</span><br><span class="line">	fmt.Println(stefno)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">whatJob</span><span class="params">(p Person)</span></span> &#123;</span><br><span class="line">	p.job()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growUp</span><span class="params">(p Person)</span></span> &#123;</span><br><span class="line">	p.growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">	job()</span><br><span class="line">	growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Student)</span> <span class="title">job</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"I am a student."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Student)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.age += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Programmer)</span> <span class="title">job</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"I am a programmer."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Programmer)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 程序员老得太快 ^_^</span></span><br><span class="line">	p.age += <span class="number">10</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里先定义了 1 个 <code>Person</code> 接口，包含两个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job()</span><br><span class="line">growUp()</span><br></pre></td></tr></table></figure>
<p>然后，又定义了 2 个结构体，<code>Student</code> 和 <code>Programmer</code>，同时，类型 <code>*Student</code>、<code>Programmer</code> 实现了 <code>Person</code> 接口定义的两个函数。注意，<code>*Student</code> 类型实现了接口， <code>Student</code> 类型却没有。</p>
<p>之后，我又定义了函数参数是 <code>Person</code> 接口的两个函数：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">whatJob</span><span class="params">(p Person)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growUp</span><span class="params">(p Person)</span></span></span><br></pre></td></tr></table></figure>
<p><code>main</code> 函数里先生成 <code>Student</code> 和 <code>Programmer</code> 的对象，再将它们分别传入到函数 <code>whatJob</code> 和 <code>growUp</code>。函数中，直接调用接口函数，实际执行的时候是看最终传入的实体类型是什么，调用的是实体类型实现的函数。于是，不同对象针对同一消息就有多种表现，<code>多态</code>就实现了。</p>
<p>更深入一点来说的话，在函数 <code>whatJob()</code> 或者 <code>growUp()</code> 内部，接口 <code>person</code> 绑定了实体类型 <code>*Student</code> 或者 <code>Programmer</code>。根据前面分析的 <code>iface</code> 源码，这里会直接调用 <code>fun</code> 里保存的函数，类似于： <code>s.tab-&gt;fun[0]</code>，而因为 <code>fun</code> 数组里保存的是实体类型实现的函数，所以当函数传入不同的实体类型时，调用的实际上是不同的函数实现，从而实现多态。</p>
<p>运行一下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am a student.</span><br><span class="line">&#123;<span class="number">19</span>&#125;</span><br><span class="line">I am a programmer.</span><br><span class="line">&#123;<span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【各种面向对象的名词】<a href="https://cyent.github.io/golang/other/oo/" target="_blank" rel="noopener">https://cyent.github.io/golang/other/oo/</a></p>
<p>【多态与鸭子类型】<a href="https://www.jb51.net/article/116025.htm" target="_blank" rel="noopener">https://www.jb51.net/article/116025.htm</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/29/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-7/" class="post-title-link" itemprop="url">linux网络编程-多路I/O转接服务器:epoll基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-29 13:45:00" itemprop="dateCreated datePublished" datetime="2020-05-29T13:45:00+08:00">2020-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 16:24:32" itemprop="dateModified" datetime="2021-04-29T16:24:32+08:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux网络编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会<strong>复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行</strong>。</p>
<p>epoll除了提供select/polld 的IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少<code>epoll_wait/epoll_pwait</code>的调用，提高应用程序效率。</p>
<p><code>ulimit -a</code>:当前用户进程所能打开的最大文件描述符个数(缺省为1024)</p>
<p>可以使用cat命令查看一个进程可以打开的socket描述符上限<code>cat /proc/fs/file-max</code>。</p>
<p>如有需要，可以通过修改配置文件的方式修改该上限值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line">在文件尾部写入以下配置,soft软限制，hard硬限制：</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 100000</span><br></pre></td></tr></table></figure>
<h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><p>会创建一个监听红黑树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line">int epoll_create(int size)		size：监听数目</span><br><span class="line"><span class="comment">//返回值: 成功返回指向新创建的红黑树的根节点的fd, 失败返回-1并设置errno;</span></span><br></pre></td></tr></table></figure>
<h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><p>操作监听红黑树：<strong>控制某个epoll监控的文件描述符上的事件：注册、修改、删除</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">epfd：为epoll_creat的句柄</span></span></span><br><span class="line"><span class="function"><span class="comment">op：	表示动作，用3个宏来表示：</span></span></span><br><span class="line"><span class="function"><span class="comment">    EPOLL_CTL_ADD (注册新的fd到epfd)，</span></span></span><br><span class="line"><span class="function"><span class="comment">    EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，</span></span></span><br><span class="line"><span class="function"><span class="comment">    EPOLL_CTL_DEL (从epfd删除一个fd,取消监听)；</span></span></span><br><span class="line"><span class="function"><span class="comment">fd:待监听的fd</span></span></span><br><span class="line"><span class="function"><span class="comment">event：	告诉内核需要监听的事件</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function">struct epoll_event </span>&#123;</span><br><span class="line">     <span class="keyword">__uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">     <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line">EPOLLIN ：	表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</span><br><span class="line">EPOLLOUT：	表示对应的文件描述符可以写</span><br><span class="line">EPOLLPRI：	表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</span><br><span class="line">EPOLLERR：	表示对应的文件描述符发生错误</span><br><span class="line">EPOLLHUP：	表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 	将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure>
<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p><strong>等待所监控文件描述符上有事件的产生，类似于select()调用。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">epfd: 		epoll_create的返回值</span></span></span><br><span class="line"><span class="function"><span class="comment">events：		传出参数, 是一个数组, 满足监听条件的那些fd结构体，用来存内核得到事件的集合。</span></span></span><br><span class="line"><span class="function"><span class="comment">maxevents：	数组中元素的总个数,告知内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</span></span></span><br><span class="line"><span class="function"><span class="comment">timeout：	超时时间</span></span></span><br><span class="line"><span class="function"><span class="comment">    -1：	阻塞</span></span></span><br><span class="line"><span class="function"><span class="comment">    0：	立即返回，非阻塞</span></span></span><br><span class="line"><span class="function"><span class="comment">    &gt;0：	指定毫秒</span></span></span><br><span class="line"><span class="function"><span class="comment">返回值：	成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure>
<h4 id="epoll实现多路IO转接"><a href="#epoll实现多路IO转接" class="headerlink" title="epoll实现多路IO转接"></a>epoll实现多路IO转接</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, maxi, listenfd, connfd, sockfd;</span><br><span class="line">	<span class="keyword">int</span> nready, efd, res;</span><br><span class="line">	<span class="keyword">ssize_t</span> n;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="keyword">socklen_t</span> clilen;</span><br><span class="line">	<span class="keyword">int</span> client[OPEN_MAX];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="comment">/*创建一个临时节点temp和一个数组ep*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">tep</span>, <span class="title">ep</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建监听套接字*/</span></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置地址可复用*/</span></span><br><span class="line">    <span class="keyword">int</span> opt=<span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,(<span class="keyword">void</span>*)&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化服务器地址结构*/</span></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*绑定服务器地址结构*/</span></span><br><span class="line">	Bind(listenfd, (struct sockaddr *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    <span class="comment">/*设置监听上限*/</span></span><br><span class="line">	Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">		client[i] = <span class="number">-1</span>;</span><br><span class="line">	maxi = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*创建监听红黑树*/</span></span><br><span class="line">	efd = epoll_create(OPEN_MAX);</span><br><span class="line">	<span class="keyword">if</span> (efd == <span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"epoll_create"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*将listenFd加入监听红黑树中*/</span></span><br><span class="line">	tep.events = EPOLLIN; tep.data.fd = listenfd;</span><br><span class="line">	res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep);</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"epoll_ctl"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*阻塞监听写事件*/</span></span><br><span class="line">		nready = epoll_wait(efd, ep, OPEN_MAX, <span class="number">-1</span>); <span class="comment">/* 阻塞监听 */</span></span><br><span class="line">		<span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">			perr_exit(<span class="string">"epoll_wait"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*轮询整个数组(红黑树)*/</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nready; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(ep[i].events &amp; EPOLLIN))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">/*如果是建立连接请求*/</span></span><br><span class="line">			<span class="keyword">if</span> (ep[i].data.fd == listenfd) &#123;</span><br><span class="line">				clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">				connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>, </span><br><span class="line">						inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)), </span><br><span class="line">						ntohs(cliaddr.sin_port));</span><br><span class="line">				<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; OPEN_MAX; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (client[j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">						client[j] = connfd; <span class="comment">/* save descriptor */</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (j == OPEN_MAX)</span><br><span class="line">					perr_exit(<span class="string">"too many clients"</span>);</span><br><span class="line">				<span class="keyword">if</span> (j &gt; maxi)</span><br><span class="line">					maxi = j; 		<span class="comment">/* max index in client[] array */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/*将新创建的连接套接字加入红黑树*/</span></span><br><span class="line">				tep.events = EPOLLIN; </span><br><span class="line">				tep.data.fd = connfd;</span><br><span class="line">				res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep);</span><br><span class="line">				<span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">					perr_exit(<span class="string">"epoll_ctl"</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*不是建立连接请求,是数据处理请求*/</span></span><br><span class="line">				sockfd = ep[i].data.fd;</span><br><span class="line">                <span class="comment">/*读到0说明客户端关闭*/</span></span><br><span class="line">				n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">				<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= maxi; j++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (client[j] == sockfd) &#123;</span><br><span class="line">							client[j] = <span class="number">-1</span>;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);</span><br><span class="line">					<span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">						perr_exit(<span class="string">"epoll_ctl"</span>);</span><br><span class="line"></span><br><span class="line">					Close(sockfd);</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, j);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 数据处理</span></span><br><span class="line">					<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">						buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">					Writen(sockfd, buf, n);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(listenfd);</span><br><span class="line">	<span class="built_in">close</span>(efd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/28/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/28/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-6/" class="post-title-link" itemprop="url">linux网络编程-多路I/O转接服务器:poll</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-28 15:45:00" itemprop="dateCreated datePublished" datetime="2020-05-28T15:45:00+08:00">2020-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 15:09:54" itemprop="dateModified" datetime="2021-04-29T15:09:54+08:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux网络编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>为拓展监听的上限，可以使用poll</p>
<h4 id="poll函数原型"><a href="#poll函数原型" class="headerlink" title="poll函数原型"></a>poll函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fds				监听的文件描述符数组</span></span><br><span class="line"><span class="comment">nfds 			监控数组中有多少文件描述符需要被监控    </span></span><br><span class="line"><span class="comment">timeout 		毫秒级等待</span></span><br><span class="line"><span class="comment">    -1：阻塞等，#define INFTIM -1 		Linux中没有定义此宏</span></span><br><span class="line"><span class="comment">    0：立即返回，不阻塞进程</span></span><br><span class="line"><span class="comment">    &gt;0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值</span></span><br><span class="line"><span class="comment">返回值:返回满足对应监听事件的文件描述符总个数;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* 待监听的文件描述符 */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/*待监听的文件描述符对应的监听事件-&gt;POLLIN,POLLOUT,POLLERR*/</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/*returned events:传入时给0,如果满足对应事件的话被置为非零-&gt;POLLIN,POLLOUT,POLLERR*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">POLLIN			普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND</span><br><span class="line">POLLRDNORM		数据可读</span><br><span class="line">POLLRDBAND		优先级带数据可读</span><br><span class="line">POLLPRI 		高优先级可读数据</span><br><span class="line">POLLOUT			普通或带外数据可写</span><br><span class="line">POLLWRNORM		数据可写</span><br><span class="line">POLLWRBAND		优先级带数据可写</span><br><span class="line">POLLERR 		发生错误</span><br><span class="line">POLLHUP 		发生挂起</span><br><span class="line">POLLNVAL 		描述字不是一个打开的文件</span><br></pre></td></tr></table></figure>
<p>如果<strong>不再监控某个文件描述符时，可以把pollfd中，fd设置为-1，poll不再监控此pollfd，下次返回时，把revents设置为0。</strong></p>
<h4 id="poll实现服务器"><a href="#poll实现服务器" class="headerlink" title="poll实现服务器"></a>poll实现服务器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"><span class="comment">//可以突破select监听的1024限制</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, maxi, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="comment">/*poll函数返回值*/</span></span><br><span class="line">	<span class="keyword">int</span> nready;</span><br><span class="line">	<span class="keyword">ssize_t</span> n;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="keyword">socklen_t</span> clilen;</span><br><span class="line">    <span class="comment">/*创建结构体数组*/</span>	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span> </span><br><span class="line">    <span class="comment">/*创建客户端地址结构和服务器地址结构*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*得到监听套接字listenFd*/</span></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*向服务器地址结构填入内容*/</span></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*绑定服务器地址结构到监听套接字,并设置监听上限*/</span></span><br><span class="line">	Bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化第一个pollfd为监听套接字*/</span></span><br><span class="line">	client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">	client[<span class="number">0</span>].events = POLLRDNORM; 					<span class="comment">/* listenfd监听普通读事件 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">		client[i].fd = <span class="number">-1</span>; 							<span class="comment">/* 用-1初始化client[]里剩下元素 */</span></span><br><span class="line">	maxi = <span class="number">0</span>; 										<span class="comment">/* client[]数组有效元素中最大元素下标 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        <span class="comment">/*nready是有多少套接字有POLLIN请求*/</span></span><br><span class="line">		nready = poll(client, maxi+<span class="number">1</span>, <span class="number">-1</span>); 			<span class="comment">/* 阻塞 */</span></span><br><span class="line">        <span class="comment">/*如果listenFd的revents有POLLIN请求,则调用Accept函数得到connectFd*/</span></span><br><span class="line">		<span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLRDNORM) &#123; 		<span class="comment">/* 有客户端连接请求 */</span></span><br><span class="line">			clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">			connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">					inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">					ntohs(cliaddr.sin_port));</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					client[i].fd = connfd; 	<span class="comment">/* 找到client[]中空闲的位置，存放accept返回的connfd */</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i == OPEN_MAX)</span><br><span class="line">				perr_exit(<span class="string">"too many clients"</span>);</span><br><span class="line"></span><br><span class="line">			client[i].events = POLLRDNORM; 		<span class="comment">/* 设置刚刚返回的connfd，监控读事件 */</span></span><br><span class="line">			<span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">				maxi = i; 						<span class="comment">/* 更新client[]中最大元素下标 */</span></span><br><span class="line">			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>; 						<span class="comment">/* 没有更多就绪事件时,继续回到poll阻塞 */</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/*开始从1遍历pollfd数组*/</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= maxi; i++) &#123; 			<span class="comment">/* 检测client[] */</span></span><br><span class="line">            <span class="comment">/*到结尾了或者有异常*/</span></span><br><span class="line">			<span class="keyword">if</span> ((sockfd = client[i].fd) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">/*第i个客户端有连接请求,进行处理*/</span></span><br><span class="line">			<span class="keyword">if</span> (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((n = Read(sockfd, buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/*出错时进一步判断errno*/</span></span><br><span class="line">					<span class="keyword">if</span> (errno == ECONNRESET) &#123; <span class="comment">/* 当收到 RST标志时 */</span></span><br><span class="line">						<span class="comment">/* connection reset by client */</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">"client[%d] aborted connection\n"</span>, i);</span><br><span class="line">						Close(sockfd);</span><br><span class="line">						client[i].fd = <span class="number">-1</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						perr_exit(<span class="string">"read error"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/*read返回0,说明读到了结尾,关闭连接*/</span></span><br><span class="line">					<span class="comment">/* connection closed by client */</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, i);</span><br><span class="line">					Close(sockfd);</span><br><span class="line">					client[i].fd = <span class="number">-1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/*数据处理*/</span></span><br><span class="line">					<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">						buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">						Writen(sockfd, buf, n);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>; 				<span class="comment">/* no more readable descriptors */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="poll总结"><a href="#poll总结" class="headerlink" title="poll总结"></a>poll总结</h4><p>优点:</p>
<ul>
<li>自带数组结构, 可以<strong>将监听事件集合和返回事件集合分开</strong></li>
<li>可以<strong>拓展监听上限, 超出1024的限制</strong></li>
</ul>
<p>缺点:</p>
<ul>
<li>不能跨平台, 只适合于Linux系统</li>
<li>无法直接定位到满足监听事件的文件描述符, 编码难度较大</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/27/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/27/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-5/" class="post-title-link" itemprop="url">linux网络编程-多路I/O转接服务器：select</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-27 13:45:00" itemprop="dateCreated datePublished" datetime="2020-05-27T13:45:00+08:00">2020-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 15:10:51" itemprop="dateModified" datetime="2021-04-29T15:10:51+08:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux网络编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>多路IO转接服务器也叫做多任务IO服务器。该类服务器实现的主旨思想是，<strong>不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件。</strong>实现方法主要有<code>select, poll, epoll</code>。</p>
<p>这种思想类似CPU对IO的处理的发展历程, select的地位就像中断管理器, IO设备有中断请求时才通知CPU, 对应的, <strong>只有当客户端有连接请求时才会通知server进行处理. 也就是说只要server收到通知, 就一定有数据待处理或连接待响应, 不会再被阻塞而浪费资源</strong>。</p>
<h4 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h4><ul>
<li><p>select能监听的文件描述符个数受限于<code>`FD_SETSIZE</code>,一般为1024，<strong>单纯改变进程打开的文件描述符个数并不能改变select监听文件个数</strong></p>
</li>
<li><p>解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，<strong>select采用的是轮询模型</strong>，会大大降低服务器响应效率，不应在select上投入更多精力</p>
</li>
</ul>
<p>函数原型分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds,fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	nfds: 		监控的文件描述符集里最大文件描述符加1，此参数会告诉内核检测前多少个文件描述符的状态</span></span><br><span class="line"><span class="comment">	readfds：	监控有读数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">	writefds：	监控写数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">	exceptfds：	监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数</span></span><br><span class="line"><span class="comment">	timeout：	定时阻塞监控时间，3种情况</span></span><br><span class="line"><span class="comment">				1.NULL，永远等下去</span></span><br><span class="line"><span class="comment">				2.设置timeval，等待固定时间</span></span><br><span class="line"><span class="comment">				3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span></span><br><span class="line"><span class="comment">	struct timeval &#123;</span></span><br><span class="line"><span class="comment">		long tv_sec; /* seconds */</span></span><br><span class="line">		<span class="keyword">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">	&#125;;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<ul>
<li>重点在于readfds:<strong>当客户端有数据发到服务器上时, 触发服务器的读事件</strong>. 后面两个一般传NULL</li>
<li><strong>三个传入传出参数都是位图, 每个二进制位代表了一个文件描述符的状态</strong></li>
<li>传入的是<strong>想监听的文件描述符集合(对应位置一), 传出来的是实际有事件发生的文件描述符集合(将没有事件发生的位置零)</strong></li>
<li>返回值: <ul>
<li>所有监听的文件描述符当中<strong>有事件发生的总个数(读写异常三个参数综合考虑)</strong></li>
<li>-1说明发生异常, 设置errno</li>
</ul>
</li>
</ul>
<p>操作文件描述符的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; 	<span class="comment">//把文件描述符集合里fd清0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; 	<span class="comment">//测试文件描述符集合里fd是否置1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; 	<span class="comment">//把文件描述符集合里fd位置1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>; 			<span class="comment">//把文件描述符集合里所有位清0</span></span><br></pre></td></tr></table></figure>
<h4 id="select实现多路IO转接设计思路"><a href="#select实现多路IO转接设计思路" class="headerlink" title="select实现多路IO转接设计思路"></a>select实现多路IO转接设计思路</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">listenFd=Socket();								<span class="comment">//创建套接字</span></span><br><span class="line">Bind();											<span class="comment">//绑定地址结构</span></span><br><span class="line">Listen();										<span class="comment">//设置监听上限</span></span><br><span class="line">fd_set rset;									<span class="comment">//创建读监听集合</span></span><br><span class="line">fd_set allset;</span><br><span class="line">FD_ZERO(&amp;allset);								<span class="comment">//将读监听集合清空</span></span><br><span class="line">FD_SET(listenFd,&amp;allset);						<span class="comment">//将listenFd添加到所有读集合当中</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    rset=allset;								<span class="comment">//保存监听集合</span></span><br><span class="line">	ret=select(listenFd,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);		<span class="comment">//监听文件描述符集合对应事件</span></span><br><span class="line">	<span class="keyword">if</span>(ret&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(FD_ISSET(listenFd,&amp;rset))&#123;</span><br><span class="line">        	cfd=accept();</span><br><span class="line">        	FD_SET(cfd,&amp;allset);					<span class="comment">//添加到监听通信描述符集合中</span></span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">for</span>(i=listenFd+<span class="number">1</span>;i&lt;=cfd;++i)&#123;</span><br><span class="line">            FD_ISSET(i,&amp;rset);						<span class="comment">//有read,write事件</span></span><br><span class="line">            <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">toupper</span>();</span><br><span class="line">            <span class="built_in">write</span>();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* select.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> listenFd,connectFd;</span><br><span class="line">	<span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>,<span class="title">clientAddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> clientAddrLen;</span><br><span class="line">	<span class="comment">/*创建一个监听套接字*/</span></span><br><span class="line">	listenFd=Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/*设置端口复用*/</span></span><br><span class="line">	<span class="keyword">int</span> opt=<span class="number">1</span>;</span><br><span class="line">	setsockopt(listenFd,SOL_SOCKET,SO_REUSEADDR,(<span class="keyword">void</span>*)&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br><span class="line">	<span class="comment">/*设置地址结构*/</span></span><br><span class="line">	bzero(&amp;serverAddr,<span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">	serverAddr.sin_family=AF_INET;</span><br><span class="line">	serverAddr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">	serverAddr.sin_port=htons(SERVER_PORT);</span><br><span class="line">	<span class="comment">/*绑定地址结构*/</span></span><br><span class="line">	Bind(listenFd,(struct sockaddr*)&amp;serverAddr,<span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">	Listen(listenFd,<span class="number">128</span>);</span><br><span class="line">	<span class="comment">/*定义读集合和备份集合并清空*/</span></span><br><span class="line">	fd_set rset,allset;</span><br><span class="line">	FD_ZERO(&amp;allset);</span><br><span class="line">	FD_SET(listenFd,&amp;allset);</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> maxfd=listenFd;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">/*备份*/</span></span><br><span class="line">		rset=allset;</span><br><span class="line">        <span class="comment">/*使用select监听*/</span></span><br><span class="line">		ret=select(maxfd+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">/*出错返回*/</span></span><br><span class="line">		<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">			perr_exit(<span class="string">"select error"</span>);</span><br><span class="line">		<span class="comment">/*listen满足监听的事件*/</span></span><br><span class="line">		<span class="keyword">if</span>(FD_ISSET(listenFd,&amp;rset))&#123;</span><br><span class="line">			clientAddrLen=<span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">            <span class="comment">/*建立链接,不会阻塞*/</span></span><br><span class="line">			connectFd=Accept(listenFd,(struct sockaddr*)&amp;clientAddr,&amp;clientAddrLen);</span><br><span class="line">			<span class="comment">/*将connectFd加入集合*/</span></span><br><span class="line">			FD_SET(connectFd,&amp;allset);</span><br><span class="line">			<span class="comment">/*更新最大值*/</span></span><br><span class="line">			<span class="keyword">if</span>(maxfd&lt;connectFd)</span><br><span class="line">				maxfd=connectFd;</span><br><span class="line">			<span class="comment">/*如果只有listen事件,只需建立连接即可,无需数据传输,跳出循环剩余部分*/</span></span><br><span class="line">			<span class="keyword">if</span>(ret==<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*否则,说明有数据传输需求*/</span></span><br><span class="line">		<span class="keyword">for</span>(i=listenFd+<span class="number">1</span>;i&lt;=maxfd;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(FD_ISSET(i,&amp;rset))&#123;</span><br><span class="line">				n=<span class="built_in">read</span>(i,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">				<span class="keyword">if</span>(n==<span class="number">-1</span>)</span><br><span class="line">					perr_exit(<span class="string">"read error"</span>);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="built_in">close</span>(i);</span><br><span class="line">					FD_CLR(i,&amp;allset);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">					buf[j]=<span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">				<span class="built_in">write</span>(i,buf,n);</span><br><span class="line">				<span class="built_in">write</span>(STDOUT_FILENO,buf,n);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(listenFd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">int</span> sockfd, n;</span><br><span class="line"></span><br><span class="line">	sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Write(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			Write(STDOUT_FILENO, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义数组提高效率"><a href="#自定义数组提高效率" class="headerlink" title="自定义数组提高效率"></a>自定义数组提高效率</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 9527</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, n, maxi;</span><br><span class="line">    <span class="comment">/*将需要轮询的客户端套接字放入数组client[FD_SETSIZE]*/</span></span><br><span class="line">	<span class="keyword">int</span> nready, client[FD_SETSIZE];</span><br><span class="line">	<span class="keyword">int</span> listenFd, connectFd, maxFd, socketFd;</span><br><span class="line">	<span class="keyword">char</span> buf[BUFSIZ], str[INET_ADDRSTRLEN];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>, <span class="title">clientAddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> clientAddrLen;</span><br><span class="line">	<span class="comment">/*得到监听套接字*/</span></span><br><span class="line">	listenFd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/*定义两个集合,将listenFd放入allset集合当中*/</span></span><br><span class="line">	fd_set rset, allset;</span><br><span class="line">	FD_ZERO(&amp;allset);</span><br><span class="line">	FD_SET(listenFd, &amp;allset);</span><br><span class="line">	<span class="comment">/*设置地址复用*/</span></span><br><span class="line">	<span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">	setsockopt(listenFd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">void</span> *)&amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">	<span class="comment">/*填写服务器地址结构*/</span></span><br><span class="line">	bzero(&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">	serverAddr.sin_family = AF_INET;</span><br><span class="line">	serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">	<span class="comment">/*绑定服务器地址结构*/</span></span><br><span class="line">	Bind(listenFd, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">	Listen(listenFd, <span class="number">128</span>);</span><br><span class="line">	<span class="comment">/*将listenFd设置为数组中最大的Fd*/</span></span><br><span class="line">	maxFd = listenFd;</span><br><span class="line">	maxi = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">/*初始化自己的数组为-1*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; ++i)</span><br><span class="line">		client[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">/*把allset给rest*/</span></span><br><span class="line">		rset = allset;</span><br><span class="line">		nready = select(maxFd + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">			perr_exit(<span class="string">"select error"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*如果有了新的连接请求,得到connectFd,并将其放入自定义数组中*/</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(listenFd, &amp;rset))&#123;</span><br><span class="line">			clientAddrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">			connectFd = Accept(listenFd, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrLen);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Recived from %s at PORT %d\n"</span>, inet_ntop(AF_INET, &amp;(clientAddr.sin_addr.s_addr), str, <span class="keyword">sizeof</span>(str)), ntohs(clientAddr.sin_port));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; ++i)</span><br><span class="line">				<span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">					client[i] = connectFd;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="comment">/*自定义数组满了*/</span></span><br><span class="line">			<span class="keyword">if</span>(i==FD_SETSIZE)&#123;</span><br><span class="line">				<span class="built_in">fputs</span>(<span class="string">"Too many clients\n"</span>,<span class="built_in">stderr</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*connectFd加入监听集合*/</span></span><br><span class="line">			FD_SET(connectFd, &amp;allset);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*更新最大的Fd*/</span></span><br><span class="line">			<span class="keyword">if</span> (maxFd &lt; connectFd)</span><br><span class="line">				maxFd = connectFd;</span><br><span class="line">			<span class="comment">/*更新循环上限*/</span></span><br><span class="line">			<span class="keyword">if</span>(i&gt;maxi)</span><br><span class="line">				maxi=i;</span><br><span class="line">			<span class="comment">/*select返回1,说明只有建立连接请求,没有数据传送请求,跳出while循环剩余部分(下面的for循环轮询过程)*/</span></span><br><span class="line">			<span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*select返回不是1,说明有connectFd有数据传输请求,遍历自定义数组*/</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; ++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>((socketFd=client[i])&lt;<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">/*遍历检查*/</span></span><br><span class="line">			<span class="keyword">if</span> (FD_ISSET(socketFd, &amp;rset))&#123;</span><br><span class="line">                <span class="comment">/*read返回0说明传输结束,关闭连接*/</span></span><br><span class="line">				<span class="keyword">if</span> ((n=<span class="built_in">read</span>(socketFd,buf,<span class="keyword">sizeof</span>(buf)))==<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="built_in">close</span>(socketFd);</span><br><span class="line">					FD_CLR(socketFd, &amp;allset);</span><br><span class="line">					client[i]=<span class="number">-1</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">						buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">					<span class="built_in">write</span>(socketFd, buf, n);</span><br><span class="line">					<span class="built_in">write</span>(STDOUT_FILENO, buf, n);</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">/*不懂:需要处理的个数减1?*/</span></span><br><span class="line">				<span class="keyword">if</span>(--nready==<span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(listenFd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="select优缺点"><a href="#select优缺点" class="headerlink" title="select优缺点"></a>select优缺点</h4><p>缺点:</p>
<ul>
<li><p>监听上限受文件描述符显示, 最大1024个</p>
</li>
<li><p>要检测满足条件的fd, 要自己添加业务逻辑, 提高了编码难度</p>
</li>
</ul>
<p>优点:</p>
<ul>
<li>跨平台, 各种系统都能支持</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/25/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-4/" class="post-title-link" itemprop="url">linux网络编程-并发服务器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-25 14:45:00" itemprop="dateCreated datePublished" datetime="2020-05-25T14:45:00+08:00">2020-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-23 16:07:03" itemprop="dateModified" datetime="2021-03-23T16:07:03+08:00">2021-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux网络编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h3><p><img src="https://api2.mubu.com/v3/document_image/967e86cf-02e9-4b64-8bf0-daca9bd9ac6f-11197877.jpg" alt="并发服务器"></p>
<h3 id="多进程并发服务器"><a href="#多进程并发服务器" class="headerlink" title="多进程并发服务器"></a>多进程并发服务器</h3><p>使用多进程并发服务器时要考虑以下几点：</p>
<ul>
<li><p>父进程最<strong>大文件描述个数(父进程中需要close关闭accept返回的新文件描述符)</strong></p>
</li>
<li><p>系统内创建<strong>进程个数(与内存大小相关)</strong></p>
</li>
<li><p>进程创建过多是否降低整体服务性能(进程调度)</p>
</li>
</ul>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//框架</span></span><br><span class="line">Socket();		<span class="comment">//创建监听套接字lfd</span></span><br><span class="line">Bind();			<span class="comment">//绑定服务器地址结构</span></span><br><span class="line">Listen();		<span class="comment">//设置监听上限</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	cfd=Accept();</span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">close</span>(lfd);		<span class="comment">//子进程用不到lfd</span></span><br><span class="line">		<span class="built_in">read</span>(cfd);</span><br><span class="line">		数据处理;</span><br><span class="line">		<span class="built_in">write</span>(cfd);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">close</span>(cfd);		<span class="comment">//父进程用不到cfd</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">子进程</span></span><br><span class="line"><span class="comment">close(lfd)</span></span><br><span class="line"><span class="comment">read()</span></span><br><span class="line"><span class="comment">数据处理</span></span><br><span class="line"><span class="comment">wirte()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">父进程</span></span><br><span class="line"><span class="comment">注册信号捕捉函数:SIGNAL</span></span><br><span class="line"><span class="comment">在回调函数中完成子进程回收:while(waitpid())</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 800</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*信号捕捉函数:回收子进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sigchild</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">		;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>;</span></span><br><span class="line">	newact.sa_handler = do_sigchild;</span><br><span class="line">	sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">	newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigaction(SIGCHLD, &amp;newact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/*服务器地址结构*/</span></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	<span class="comment">/*绑定服务器地址结构*/</span></span><br><span class="line">	Bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	<span class="comment">/*设置监听上限*/</span></span><br><span class="line">	Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">		connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line"></span><br><span class="line">		pid = fork();</span><br><span class="line">		<span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">			Close(listenfd);</span><br><span class="line">			<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">				n = Read(connfd, buf, MAXLINE);</span><br><span class="line">				<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">						inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">						ntohs(cliaddr.sin_port));</span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">					buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">				Write(connfd, buf, n);</span><br><span class="line">			&#125;</span><br><span class="line">			Close(connfd);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			Close(connfd);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			perr_exit(<span class="string">"fork"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(listenfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">int</span> sockfd, n;</span><br><span class="line"></span><br><span class="line">	sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Write(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			Write(STDOUT_FILENO, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程并发服务器"><a href="#多线程并发服务器" class="headerlink" title="多线程并发服务器"></a>多线程并发服务器</h3><p>在使用线程模型开发服务器时需考虑以下问题：</p>
<ul>
<li><p>调整进程内最大文件描述符上限</p>
</li>
<li><p>线程如有共享数据，考虑<strong>线程同步</strong></p>
</li>
<li><p>服务于客户端线程退出时，退出处理。（退出值，分离态）</p>
</li>
<li><p><strong>系统负载</strong>，随着链接客户端增加，导致其它线程不能及时得到CPU</p>
</li>
</ul>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Socket();		<span class="comment">//创建监听套接字lfd</span></span><br><span class="line">Bind();			<span class="comment">//绑定服务器地址结构</span></span><br><span class="line">Listen();		<span class="comment">//设置监听上限</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    cfd=Accept(lfd,);</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,&amp;tfn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	*detach设置线程分离,但是这样不能获取线程退出状态</span></span><br><span class="line"><span class="comment">    	*如果想获取子线程退出状态,用pthread_join()函数,但是这样会造成主线程阻塞</span></span><br><span class="line"><span class="comment">    	*解决方案:create出一个新的子线程调用pthread_join()专门用于回收</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="built_in">read</span>(cfd,);</span><br><span class="line">    数据处理;</span><br><span class="line">    <span class="built_in">write</span>(cfd,);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)out);		<span class="comment">//线程退出状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将客户端的地址结构和对应的套接字封装到一个结构体中用于向子线程传参*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> connfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子线程的回调函数,注意参数类型*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_work</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,i;</span><br><span class="line">    <span class="comment">/*将参数接收下来*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> *<span class="title">ts</span> = (<span class="title">struct</span> <span class="title">s_info</span>*)<span class="title">arg</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="comment">/* 可以在创建线程前设置线程创建属性,设为分离态,*/</span></span><br><span class="line">	pthread_detach(pthread_self());</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		n = Read(ts-&gt;connfd, buf, MAXLINE);</span><br><span class="line">        <span class="comment">/*读到0,说明客户端已经断开连接*/</span></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/*打印客户端的信息*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">				inet_ntop(AF_INET, &amp;(*ts).cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">				ntohs((*ts).cliaddr.sin_port));</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">		Write(ts-&gt;connfd, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="comment">/*从循环跳出时,关闭套接字,退出线程*/</span></span><br><span class="line">	Close(ts-&gt;connfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> <span class="title">ts</span>[256];</span></span><br><span class="line">	<span class="comment">/*创建监听套接字*/</span></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/*初始化服务器地址结构*/</span></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*绑定服务器地址结构并设置监听上限*/</span></span><br><span class="line">	Bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">		connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">        <span class="comment">/*拿到客户端信息后,填写到结构体中*/</span></span><br><span class="line">		ts[i].cliaddr = cliaddr;</span><br><span class="line">		ts[i].connfd = connfd;</span><br><span class="line">		<span class="comment">/* 达到线程最大数时，pthread_create出错处理, 增加服务器稳定性 */</span></span><br><span class="line">		pthread_create(&amp;tid, <span class="literal">NULL</span>, do_work, (<span class="keyword">void</span>*)&amp;ts[i]);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/24/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-3/" class="post-title-link" itemprop="url">linux-网络编程-使用TCP的C/S模型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-24 10:57:39" itemprop="dateCreated datePublished" datetime="2020-05-24T10:57:39+08:00">2020-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 10:16:59" itemprop="dateModified" datetime="2021-04-29T10:16:59+08:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux网络编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="基于TCP协议的客户端-服务器程序的一般流程"><a href="#基于TCP协议的客户端-服务器程序的一般流程" class="headerlink" title="基于TCP协议的客户端/服务器程序的一般流程"></a>基于TCP协议的客户端/服务器程序的一般流程</h3><p><img src="https://api2.mubu.com/v3/document_image/f6c51f91-0005-44c9-8010-64d523fe5e12-11197877.jpg" alt="TCP协议下的C/S流程"></p>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于<strong>监听端口的状态。</strong></p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>调用<code>socket()</code>初始化后，调用<code>connect()</code>发出<code>SYN</code>段并阻塞等待服务器应答，服务器应答一个<code>SYN-ACK</code>段，客户端收到后从<code>connect()</code>返回，同时应答一个<code>ACK</code>段，服务器收到后从<code>accept()</code>返回。</p>
<h4 id="数据传输的过程"><a href="#数据传输的过程" class="headerlink" title="数据传输的过程"></a>数据传输的过程</h4><p>建立连接后，TCP协议提供<strong>全双工</strong>的通信服务，但是一般的客户端/服务器程序的流程是由客户端主动发起请求，服务器被动处理请求，一问一答的方式。因此，服务器从<code>accept()</code>返回后立刻调用<code>read()</code>，<strong>读socket就像读管道一样，如果没有数据到达就阻塞等待，这时客户端调用write()发送请求给服务器，服务器收到后从read()返回，对客户端的请求进行处理，在此期间客户端调用read()阻塞等待服务器的应答，服务器调用write()将处理结果发回给客户端，再次调用read()阻塞等待下一条请求，客户端收到后从read()返回，发送下一条请求，如此循环下去。</strong></p>
<p>如果客户端没有更多的请求了，就调用<code>close()</code>关闭连接，<strong>就像写端关闭的管道一样，服务器的<code>read()</code>返回0，这样服务器就知道客户端关闭了连接，</strong>也调用<code>close()</code>关闭连接。注意，<strong>任何一方调用close()后，连接的两个传输方向都关闭，不能再发送数据了。如果一方调用shutdown()则连接处于半关闭状态，仍可接收对方发来的数据。</strong></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server 端，作用是从客户端读字符，然后将每个字符转换为大写并回送给客户端。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9726</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*错误处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> link_fd=<span class="number">0</span>;						<span class="comment">//建立连接的socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> connect_fd=<span class="number">0</span>					<span class="comment">//用于通信的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;							<span class="comment">//用于检查是否出错</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];					<span class="comment">//缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> client_IP[<span class="number">1024</span>]				<span class="comment">//存入客户端IP字符串</span></span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;							<span class="comment">//读出的字节数</span></span><br><span class="line">    <span class="comment">/*服务器端地址结构*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_port=htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*成功与服务器建立连接的客户端地址结构*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clint_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clint_addr_len=<span class="keyword">sizeof</span>(clint_addr);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*socket函数:创建用于建立连接的socket,返回的文件描述符存入link_fd*/</span></span><br><span class="line">    link_fd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(link_fd==<span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"socket error"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*bind函数:绑定服务器端的地址结构*/</span></span><br><span class="line">    ret=bind(link_fd,(<span class="keyword">const</span> struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"bind error"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*listen函数:设定监听(连接)上线*/</span></span><br><span class="line">    ret=<span class="built_in">listen</span>(link_fd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"listen error"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*accept函数:阻塞等待客户端建立连接*/</span></span><br><span class="line">    connect_fd=accept(link_fd,(struct sockaddr*)&amp;clint_addr,&amp;clint_addr_len);</span><br><span class="line">    <span class="keyword">if</span>(connect_fd==<span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"accept error"</span>);</span><br><span class="line">    <span class="comment">/*建立连接后打印客户端的IP和端口号*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client IP:%s,client port:%d"</span>,</span><br><span class="line">           inet_ntop(AF_INET,&amp;clint_addr.sin_addr.s_addr,client_IP,<span class="keyword">sizeof</span>(client_IP)),</span><br><span class="line">          ntohs(clint_addr.sin_port));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*业务逻辑*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        num=<span class="built_in">read</span>(connect_fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO,buf,num);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">            buf[i]=<span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        <span class="built_in">write</span>(connect_fd,buf,num);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(connect_fd);</span><br><span class="line">    <span class="built_in">close</span>(link_fd);</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取客户端的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"client IP:%s,client port:%d"</span>,</span><br><span class="line">         inet_ntop(AF_INET,&amp;clint_addr.sin_addr.s_addr,client_IP,<span class="keyword">sizeof</span>(client_IP));</span><br><span class="line">ntohs(clint_addr.sin_port);</span><br></pre></td></tr></table></figure>
<p>client端实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client的作用是从命令行参数中获得一个字符串发给服务器，然后接收服务器返回的字符串并打印</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9726</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*错误处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> client_fd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//connect的参数2填入服务器的文件描述符!</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">	serv_addr.sin_family=AF_INET;</span><br><span class="line">	serv_addr.sin_port=htons(SERV_PORT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*点分十进制-&gt;网络二进制*/</span></span><br><span class="line">    <span class="comment">/*协议族,源数据,目的数据(int32足够,因为IP地址就是32位)*/</span></span><br><span class="line">	inet_pton(AF_INET,<span class="string">"127.0.0.1"</span>,(<span class="keyword">void</span>*)&amp;serv_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*客户端直接创建用于连接的套接字即可*/</span></span><br><span class="line">	client_fd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(client_fd==<span class="number">-1</span>)</span><br><span class="line">		sys_err(<span class="string">"socket error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*将客户端套接字与服务器地址结构连接起来*/</span></span><br><span class="line">	ret=<span class="built_in">connect</span>(client_fd,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">		sys_err(<span class="string">"connect error"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//业务逻辑</span></span><br><span class="line">	<span class="keyword">while</span>(--cnt)&#123;</span><br><span class="line">		<span class="built_in">write</span>(client_fd,<span class="string">"fuckyou\n"</span>,<span class="number">8</span>);</span><br><span class="line">		num=<span class="built_in">read</span>(client_fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="built_in">write</span>(STDOUT_FILENO,buf,num);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(client_fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：套接字: <strong>一个fd可以索引读写两个缓冲区</strong></p>
<p>由于<strong>客户端不需要固定的端口号，因此不必调用bind()，客户端的端口号由内核自动分配。</strong>注意，<strong>客户端不是不允许调用bind()，只是没有必要调用bind()固定一个端口号，服务器也不是必须调用bind()，但如果服务器不调用bind()，内核会自动给服务器分配监听端口，每次启动服务器时端口号都不一样，客户端要连接服务器就会遇到麻烦。</strong></p>
<p>客户端和服务器启动后可以使用netstat命令查看链接情况：</p>
<p><code>netstat -apn | grep 9726</code></p>
<h4 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h4><p>为使错误处理的代码不影响主程序的可读性，把与socket相关的一些系统函数加上错误处理代码封装成新的函数，做成一个模块wrap.c。</p>
<p>封装的目的：在server.c编译过程中突出逻辑，将出错处理与逻辑分开。<strong>将原函数首字母大写进行错误处理，这样还可以跳转到原函数的manPage.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wrap.h</span></span><br><span class="line"><span class="comment">//存放网络通信相关常用自定义函数(声明)</span></span><br><span class="line"><span class="comment">//在server.c 和client.c中调用自定义函数</span></span><br><span class="line"><span class="comment">//联合编译server.c和wrap.c生成server</span></span><br><span class="line"><span class="comment">//联合编译client.c和wrap.c生成client</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WRAP_H_</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *salenptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> Read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> Write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> Readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="keyword">ssize_t</span> Writen(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n);</span><br><span class="line"><span class="keyword">ssize_t</span> my_read(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr);</span><br><span class="line"><span class="keyword">ssize_t</span> Readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrap.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(s);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *salenptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	again:</span><br><span class="line">	<span class="keyword">if</span> ( (n = accept(fd, sa, salenptr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			perr_exit(<span class="string">"accept error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">if</span> ((n = bind(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"bind error"</span>);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">if</span> ((n = <span class="built_in">connect</span>(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"connect error"</span>);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">if</span> ((n = <span class="built_in">listen</span>(fd, backlog)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"listen error"</span>);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">if</span> ( (n = socket(family, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"socket error"</span>);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> Read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ( (n = <span class="built_in">read</span>(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> Write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ( (n = <span class="built_in">write</span>(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">if</span> ((n = <span class="built_in">close</span>(fd)) == <span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"close error"</span>);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> Readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span> nleft;</span><br><span class="line">	<span class="keyword">ssize_t</span> nread;</span><br><span class="line">	<span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( (nread = <span class="built_in">read</span>(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">				nread = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		nleft -= nread;</span><br><span class="line">		ptr += nread;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Writen(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span> nleft;</span><br><span class="line">	<span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( (nwritten = <span class="built_in">write</span>(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">				nwritten = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nleft -= nwritten;</span><br><span class="line">		ptr += nwritten;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">my_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> read_cnt;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *read_ptr;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> read_buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">again:</span><br><span class="line">		<span class="keyword">if</span> ((read_cnt = <span class="built_in">read</span>(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">				<span class="keyword">goto</span> again;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;	</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		read_ptr = read_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	read_cnt--;</span><br><span class="line">	*ptr = *read_ptr++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">ssize_t</span> n, rc;</span><br><span class="line">	<span class="keyword">char</span> c, *ptr;</span><br><span class="line">	ptr = vptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( (rc = my_read(fd, &amp;c)) == <span class="number">1</span>) &#123;</span><br><span class="line">			*ptr++ = c;</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">			*ptr = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*ptr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h4><p><strong>由原来的双工通信变为了单工通信, 客户端只能接受数据(缓冲区中的数据)</strong></p>
<p>实现原理: </p>
<p><strong>关闭了客户端套接字的写缓冲区</strong></p>
<ul>
<li><p>之所以半关闭后Client仍能向Server发送ACK数据包, 是因为Client关闭的只是写缓冲, 连接还在</p>
</li>
<li><p>连接在内核层面, 写缓冲在用户层面</p>
</li>
<li><p>如果Server没有收到Client最后发来的ACK数据包, 它会一直发送FIN数据包, 直到Client回执为止</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/23/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/23/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-2/" class="post-title-link" itemprop="url">linux网络编程-socket模型创建</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-23 10:04:33" itemprop="dateCreated datePublished" datetime="2020-05-23T10:04:33+08:00">2020-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-09 09:29:14" itemprop="dateModified" datetime="2021-04-09T09:29:14+08:00">2021-04-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux网络编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="socket模型创建"><a href="#socket模型创建" class="headerlink" title="socket模型创建"></a>socket模型创建</h3><p><img src="https://api2.mubu.com/v3/document_image/adf756a3-757c-4204-a5d5-4484f2bd1600-11197877.jpg" alt="socket模型创建"></p>
<ul>
<li><p>socket()—创建一个套接字, 用fd或文件句柄索引</p>
</li>
<li><p>bind()—绑定IP和port</p>
</li>
<li><p>listen()—设置<strong>监听上限</strong>(同时与Server建立连接数)</p>
</li>
<li><p>accpet()—<strong>阻塞监听</strong>客户端连接(传入一个上面创建的套接字, 传出一个连接的套接字)</p>
</li>
<li><p>在客户端中的connect()中绑定IP和port, 并建立连接</p>
</li>
</ul>
<h4 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">参数详解：</span><br><span class="line">domain:</span><br><span class="line">	AF_INET 大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址</span><br><span class="line">	AF_INET6 与上面类似，不过是来用IPv6的地址</span><br><span class="line">	AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</span><br><span class="line">        </span><br><span class="line">type:</span><br><span class="line">	SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</span><br><span class="line">	SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</span><br><span class="line">    SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</span><br><span class="line">	SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</span><br><span class="line">	SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</span><br><span class="line">        </span><br><span class="line">protocol:</span><br><span class="line">	传<span class="number">0</span> 表示使用默认协议。</span><br><span class="line">        </span><br><span class="line">返回值：</span><br><span class="line">	成功：返回指向新创建的socket的文件描述符，失败：返回<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure>
<p><code>socket()</code>打开一个网络通讯端口，如果成功的话，就像<code>open()</code>一样返回一个文件描述符，<strong>应用程序可以像读写文件一样用<code>read/write</code>在网络上收发数据，如果<code>socket()</code>调用出错则返回-1 </strong> <strong>对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议</strong>。protocol指定为0即可。</p>
<h4 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">sockfd：</span><br><span class="line">	socket文件描述符</span><br><span class="line">    </span><br><span class="line">addr: </span><br><span class="line">	构造出IP地址加端口号</span><br><span class="line">        </span><br><span class="line">addrlen:</span><br><span class="line">	<span class="keyword">sizeof</span>(addr)长度</span><br><span class="line">        </span><br><span class="line">返回值：</span><br><span class="line">	成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>, 设置errno</span><br></pre></td></tr></table></figure>
<p><strong>服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。</strong></p>
<p><code>bind()</code>的作用是将参数sockfd和addr绑定在一起，<strong>使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号</strong>。<code>struct sockaddr *</code>是一个通用指针类型，<strong><code>addr</code>参数实际上可以接受多种协议的<code>sockaddr</code>结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度</strong>。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET; <span class="comment">//addr.family应该与sofkfd的domain保持一致;</span></span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(<span class="number">6666</span>); <span class="comment">//端口号为short类型(16bit)</span></span><br></pre></td></tr></table></figure>
<p>首先将整个结构体清零，然后设置地址类型为AF_INET，<strong>网络地址为INADDR_ANY，这个宏表示本地的任意IP地址</strong>，因为服务器可能有多个网卡，<strong>每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址</strong>，端口号为6666。</p>
<h4 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line">sockfd:</span><br><span class="line">	socket文件描述符</span><br><span class="line">backlog:</span><br><span class="line">	排队建立<span class="number">3</span>次握手队列和刚刚建立<span class="number">3</span>次握手队列的链接数和</span><br></pre></td></tr></table></figure>
<p>查看系统默认backlog：<code>cat /proc/sys/net/ipv4/tcp_max_syn_backlog</code></p>
<p>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的<code>accept()</code>返回并接受这个连接，<strong>如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。</strong></p>
<h4 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; 					</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">sockdf:</span><br><span class="line">	socket文件描述符</span><br><span class="line">        </span><br><span class="line">addr:</span><br><span class="line">	传入参数，指定服务器端地址信息，含IP地址和端口号</span><br><span class="line">        </span><br><span class="line">addrlen:</span><br><span class="line">	传入参数,传入<span class="keyword">sizeof</span>(addr)大小</span><br><span class="line">        </span><br><span class="line">返回值：</span><br><span class="line">	成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure>
<p>客户端需要调用<code>connect()</code>连接服务器，<strong>connect和bind的参数形式一致，区别在于bind的参数是自己的地址，而connect的参数是对方的地址。connect()成功返回0，出错返回-1。</strong></p>
<h4 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; 		</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">sockdf:</span><br><span class="line">	socket文件描述符</span><br><span class="line">        </span><br><span class="line">addr:</span><br><span class="line">	传出参数，返回链接客户端地址信息，含IP地址和端口号</span><br><span class="line">        </span><br><span class="line">addrlen:</span><br><span class="line">	传入传出参数（值-结果）,传入<span class="keyword">sizeof</span>(addr)大小，函数返回时返回真正接收到地址结构体的大小</span><br><span class="line">        </span><br><span class="line">返回值：</span><br><span class="line">	成功返回一个新的socket文件描述符，用于和客户端通信，失败返回<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure>
<p><strong>三次握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。</strong> <strong>addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。</strong></p>
<p>服务器的结构一般如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">	connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">	n = <span class="built_in">read</span>(connfd, buf, MAXLINE);</span><br><span class="line">	......</span><br><span class="line">	<span class="built_in">close</span>(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个是一个<code>while</code>死循环，每次循环处理一个客户端连接。由于<code>cliaddr_len</code>是传入传出参数，每次调用accept()之前应该重新赋初值。<strong><code>accept()</code>的参数<code>listenfd</code>是先前的监听文件描述符，而<code>accept()</code>的返回值是另外一个文件描述符<code>connfd</code>，之后与客户端之间就通过这个<code>connfd</code>通讯，最后关闭<code>connfd</code>断开连接，而不关闭<code>listenfd</code>，再次回到循环开头<code>listenfd</code>仍然用作<code>accept</code>的参数。<code>accept()</code>成功返回一个文件描述符，出错返回-1。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/22/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/22/linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-1/" class="post-title-link" itemprop="url">linux网络编程-套接字</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-22 14:58:18" itemprop="dateCreated datePublished" datetime="2020-05-22T14:58:18+08:00">2020-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-31 20:00:04" itemprop="dateModified" datetime="2021-03-31T20:00:04+08:00">2021-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux网络编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>在Linux环境下，socket用于表示<strong>进程间网络通信的特殊文件类型</strong>。<strong>本质为内核借助缓冲区形成的伪文件。</strong></p>
<p>既然是文件，那么理所当然的可以<strong>使用文件描述符引用套接字</strong>。与管道类似，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。<strong>区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</strong></p>
<p>在TCP/IP协议中，<strong><code>IP地址+TCP或UDP端口号</code>唯一标识网络通讯中的一个进程。<code>IP地址+端口号</code>就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</strong></p>
<p>套接字通信原理如下图所示：</p>
<p><img src="https://api2.mubu.com/v3/document_image/8ba13ca0-290a-4d32-a14d-0f7dcb64b166-11197877.jpg" alt="套接字通信原理"><strong>在网络通信中，套接字一定是成对出现的。</strong> <strong>一端的发送缓冲区对应对端的接收缓冲区</strong>。使用同一个文件描述符绑定发送缓冲区和接收缓冲区。</p>
<p>一个文件描述符指向一个套接字(该套接字内部由内核借助<strong>两个缓冲区</strong>实现)。</p>
<h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><p>内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，定义网络数据流的地址过程：<strong>发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址规定为：先发出的数据是低地址，后发出的数据是高地址。</strong></p>
<ul>
<li><p>小端法: 高位存在高地址, 低位存在低地址(计算机本地采用)</p>
</li>
<li><p>大端法: 高位存在低地址, 低位存在高地址(网络通信采用)</p>
</li>
</ul>
<p>TCP/IP协议规定，<strong>网络数据流应采用大端字节序，即低地址高字节</strong>。例如，在UDP段格式，地址0-1是16位的源端口号，如果这个端口号是1000（0x3e8），则地址0是0x03，地址1是0xe8，也就是先发0x03，再发0xe8，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址存0xe8。但是，如果发送主机是小端字节序的，这16位被解释成0xe803，而不是1000。因此，发送主机把1000填到发送缓冲区之前需要做字节序的转换。</p>
<p>为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做<strong>网络字节序和主机字节序的转换</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//h表示host，n表示network，l表示32位长整数，s表示16位短整数。</span></span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);	<span class="comment">//主要针对IP(host to network)</span></span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);	<span class="comment">//主要针对port</span></span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);</span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);</span><br></pre></td></tr></table></figure>
<p>如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。</p>
<h3 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h3><p>由于如<code>192.168.45.2</code>的IP地址为<strong>点分十进制表示</strong>, 需要转化为<code>uint32_t</code>型, 有现成的函数(IPv4和IPv6都可以转换，函数接口是void *addrptr):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span>* src,<span class="keyword">void</span>* dst)</span></span>;<span class="comment">//p表示点分十进制的ip,n为网络上的二进制ip</span></span><br><span class="line"><span class="comment">//参数 af: AF_INET/AF_INET6</span></span><br><span class="line"><span class="comment">//src:传入参数, 待转换的点分十进制的IP地址</span></span><br><span class="line"><span class="comment">//dst:传出参数, 转换后符合网络字节序的IP地址</span></span><br><span class="line"><span class="comment">//返回值：成功返回1，若参2无效返回0(异常)，失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span>* src,<span class="keyword">char</span>* dst,<span class="keyword">socklen_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">//src:传入参数, 待转换的网络字节序的IP地址</span></span><br><span class="line"><span class="comment">//dst:传出参数, 转换后的点分十进制IP地址, 是一块缓冲区</span></span><br><span class="line"><span class="comment">//size指定了缓冲区的大小</span></span><br><span class="line"><span class="comment">//返回值：成功返回dst指针，失败返回NULL指针, 设置errorno</span></span><br></pre></td></tr></table></figure>
<h3 id="sockaddr地址结构"><a href="#sockaddr地址结构" class="headerlink" title="sockaddr地址结构"></a>sockaddr地址结构</h3><p>Pv4和IPv6的地址格式定义在<code>netinet/in.h</code>中，IPv4地址用<code>sockaddr_in</code>结构体表示，包括16位端口号和32位IP地址，IPv6地址用<code>sockaddr_in6</code>结构体表示，包括16位端口号、128位IP地址和一些控制字段。UNIX Domain Socket的地址格式定义在<code>sys/un.h</code>中，用<code>sock-addr_un</code>结构体表示。</p>
<p><img src="https://api2.mubu.com/v3/document_image/83a529a8-cf4f-4c1d-9d00-d0d8862c2964-11197877.jpg" alt="sockaddr地址结构"></p>
<p>bind函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr* addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*struct sockaddr是早已废弃的数据结构,已不再使用,用新的需要强转*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,(struct sockaddr*)&amp;addr,<span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>sockaddr_in</code>相关定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*相关结构体定义,在man 7 ip*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">	<span class="keyword">sa_family_t</span>		sin_family;</span><br><span class="line">	<span class="keyword">in_port_t</span>		sin_port;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>	<span class="title">sin_addr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">addr.sin_family=AF_INET/AF_INET6;</span><br><span class="line">addr.sin_port=htons(<span class="number">9527</span>);					<span class="comment">//端口号为short类型(16bit)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dst;</span><br><span class="line">inet_pton(AF_INET,<span class="string">"192.168.10.2"</span>,(<span class="keyword">void</span>*)&amp;dst);</span><br><span class="line">addr.sin_addr.s_addr=dst;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*或者采取下面的方法*/</span></span><br><span class="line">addr.sin_addr.s_addr=htonl(INADDR_ANY)		<span class="comment">//取出系统中任意有效的IP地址</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/linux-%E7%BD%91%E7%BB%9C03%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/linux-%E7%BD%91%E7%BB%9C03%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-2/" class="post-title-link" itemprop="url">网络基础-网络名词术语</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 18:36:05" itemprop="dateCreated datePublished" datetime="2020-05-20T18:36:05+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-31 19:57:01" itemprop="dateModified" datetime="2021-03-31T19:57:01+08:00">2021-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="网络名词术语解析"><a href="#网络名词术语解析" class="headerlink" title="网络名词术语解析"></a>网络名词术语解析</h3><h4 id="路由-route"><a href="#路由-route" class="headerlink" title="路由(route)"></a>路由(route)</h4><ul>
<li><p>路由（名词）</p>
<ul>
<li>数据包从源地址到目的地址所经过的<strong>路径</strong>，由一系列路由节点组成。</li>
</ul>
</li>
<li><p>路由（动词）</p>
<ul>
<li>某个路由节点为数据包选择投递方向的<strong>选路过程</strong>。</li>
</ul>
</li>
</ul>
<h4 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h4><p>路由器（Router）是连接因特网中各局域网、广域网的设备，它会<strong>根据信道的情况自动选择和设定路由</strong>，以<strong>最佳路径</strong>，按<strong>前后顺序</strong>发送信号的设备。</p>
<p>传统地，路由器工作于OSI七层协议中的第三层，其<strong>主要任务是接收来自一个网络接口的数据包，根据其中所含的目的地址，决定转发到下一个目的地址</strong>。因此，路由器<strong>首先得在转发路由表中查找它的目的地址，若找到了目的地址，就在数据包的帧格前添加下一个MAC地址，同时IP数据包头的TTL（Time To Live）域也开始减数， 并重新计算校验和。当数据包被送到输出端口时，它需要按顺序等待，以便被传送到输出链路上。</strong></p>
<p>路由器在工作时能够按照某种路由通信<strong>协议</strong>查找设备中的路由表。如果到某一特定节点有一条以上的路径，则基本预先确定的路由准则是选择最优（或最经济）的传输路径。由于各种网络段和其相互连接情况可能会因环境变化而变化，因此<strong>路由情况的信息一般也按所使用的路由信息协议的规定而定时更新</strong>。</p>
<p>网络中，每个路由器的基本功能都是按照一定的<strong>规则</strong>来动态地更新它所保持的路由表，以便保持路由信息的有效性。为了便于在网络间传送报文<strong>，路由器总是先按照预定的规则把较大的数据分解成适当大小的数据包，再将这些数据包分别通过相同或不同路径发送出去</strong>。当这些数据包按先后秩序到达目的地后，再把分解的数据包按照一定顺序包装成原有的报文形式。路由器的<strong>分层寻址功能</strong>是路由器的重要功能之一，该功能可以帮助具有很多节点站的网络来存储寻址信息，同时还能在网络间截获发送到远地网段的报文，起<strong>转发</strong>作用；选择最合理的路由，引导通信也是路由器基本功能；多协议路由器还可以连接使用不同通信协议的网络段，成为不同通信协议网络段之间的通信平台。</p>
<p>路由和交换之间的主要区别就是<strong>交换发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换在移动信息的过程 中需使用不同的控制信息</strong>，所以两者实现各自功能的方式是不同的。</p>
<h4 id="路由表-Routing-Table"><a href="#路由表-Routing-Table" class="headerlink" title="路由表(Routing Table)"></a>路由表(Routing Table)</h4><p>在计算机网络中，路由表或称路由择域信息库（RIB）是一个存储在路由器或者联网计算机中的<strong>电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径。</strong></p>
<h4 id="路由条目"><a href="#路由条目" class="headerlink" title="路由条目"></a>路由条目</h4><p>路由表中的<strong>一行，每个条目主要由目的网络地址、子网掩码、下一跳地址、发送接口四部分组成</strong>，如果要发送的数据包的目的网络地址<strong>匹配</strong>路由表中的某一行，<strong>就按规定的接口发送到下一跳地址。</strong></p>
<h4 id="缺省路由条目"><a href="#缺省路由条目" class="headerlink" title="缺省路由条目"></a>缺省路由条目</h4><p>路由表中的<strong>最后一行，主要由下一跳地址和发送接口两部分组成，当目的地址与路由表中其它行都不匹配时，就按缺省路由条目规定的接口发送到下一跳地址</strong>。</p>
<h4 id="路由节点"><a href="#路由节点" class="headerlink" title="路由节点"></a>路由节点</h4><p>一个具有路由能力的主机或路由器，它维护一张路由表，通过查询路由表来决定向哪个接口发送数据包。</p>
<h4 id="以太网交换机工作原理"><a href="#以太网交换机工作原理" class="headerlink" title="以太网交换机工作原理"></a>以太网交换机工作原理</h4><p>以太网交换机是基于以太网传输数据的交换机，<strong>以太网采用共享总线型传输媒体方式的局域网</strong>。以太网交换机的结构是<strong>每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据</strong>。</p>
<p>以太网交换机工作于OSI网络参考模型的第二层（即数据链路层），是一种基于MAC（Media Access Control，介质访问控制）地址识别、完成以太网数据帧转发的网络设备。</p>
<h4 id="hub工作原理"><a href="#hub工作原理" class="headerlink" title="hub工作原理"></a>hub工作原理</h4><p>集线器实际上就是中继器的一种，其区别仅在于集线器能够提供更多的端口服务，所以集线器又叫多口中继器。</p>
<p>集线器功能是随机选出某一端口的设备，并让它独占全部带宽，与集线器的上联设备（交换机、路由器或服务器等）进行通信。从Hub的工作方式可以看出，它<strong>在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力，是—个标准的共享式设备。</strong>其次是<strong>Hub只与它的上联设备(如上层Hub、交换机或服务器)进行通信，同层的各端口之间不会直接进行通信，而是通过上联设备再将信息广播到所有端口上。</strong> 由此可见，即使是在同一Hub的不同两个端口之间进行通信，都必须要经过两步操作：</p>
<ul>
<li><p>第一步是将信息上传到上联设备；</p>
</li>
<li><p>第二步是上联设备再将该信息广播到所有端口上。</p>
</li>
</ul>
<h4 id="半双工-全双工"><a href="#半双工-全双工" class="headerlink" title="半双工/全双工"></a>半双工/全双工</h4><p>Full-duplex（全双工）全双工是在通道中同时<strong>双向数据传输</strong>的能力。</p>
<p>Half-duplex（半双工）在通道中同时<strong>只能沿着一个方向传输数据</strong>。</p>
<h4 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h4><p>DNS 是域名系统 (Domain Name System) 的缩写，是因特网的一项核心服务，它作为可以<strong>将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址串。</strong></p>
<p>它是由<strong>解析器以及域名服务器组成</strong>的。<strong>域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。</strong></p>
<h4 id="局域网-LAN"><a href="#局域网-LAN" class="headerlink" title="局域网(LAN)"></a>局域网(LAN)</h4><p>local area network，一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的<strong>小范围的计算机网。</strong></p>
<ul>
<li><p>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</p>
</li>
<li><p>使用专门铺设的传输介质进行联网，数据传输速率高（10Mb/s～10Gb/s）</p>
</li>
<li><p>通信延迟时间短，可靠性较高</p>
</li>
<li><p>局域网可以支持多种传输介质</p>
</li>
</ul>
<h4 id="广域网-WAN"><a href="#广域网-WAN" class="headerlink" title="广域网(WAN)"></a>广域网(WAN)</h4><p>wide area network，一种用来实现<strong>不同地区的局域网或城域网的互连</strong>，可提供不同地区、城市和国家之间的计算机通信的远程计算机网。</p>
<p>覆盖的范围比局域网（LAN）和城域网（MAN）都广。<strong>广域网的通信子网主要使用分组交换技术。</strong></p>
<p>广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如互联网是世界范围内最大的广域网。</p>
<ul>
<li><p>适应大容量与突发性通信的要求；</p>
</li>
<li><p>适应综合业务服务的要求；</p>
</li>
<li><p>开放的设备接口与规范化的协议；</p>
</li>
<li><p>完善的通信服务与网络管理。</p>
</li>
</ul>
<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>逻辑意义上的端口，<strong>一般是指TCP/IP协议中的端口，端口号的范围从0到65535</strong>，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。</p>
<ul>
<li><p>端口号小于256的定义为<strong>常用端口</strong>，服务器一般都是通过常用端口号来识别的。</p>
</li>
<li><p><strong>客户端只需保证该端口号在本机上是惟一的就可以了。客户端口号因存在时间很短暂又称临时端口号；</strong></p>
</li>
<li><p><strong>大多数TCP/IP实现给临时端口号分配1024—5000之间的端口号。大于5000的端口号是为其他服务器预留的。</strong></p>
</li>
<li><p>在自定义端口时，避免使用well-known的端口。如：80、21等等。</p>
</li>
</ul>
<h4 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h4><p>MTU:通信术语 最大传输单元（Maximum Transmission Unit，MTU）</p>
<p>是指<strong>一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）</strong>。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。</p>
<p>eg: 以太网（Ethernet）协议的MTU为1500字节</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShifuDong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShifuDong</p>
  <div class="site-description" itemprop="description">记录生活， 记录学习， 分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/mailto:sfd_w@foxmail.com" title="E-Mail → mailto:sfd_w@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShifuDong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  



    </div>
</body>
</html>
