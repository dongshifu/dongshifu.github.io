<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ShifuDong" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="记录生活， 记录学习， 分享知识">
<meta name="keywords" content="生活，C++, C, go, java, OS, 网络， 存储， 联邦学习， 机器学习，python">
<meta property="og:type" content="website">
<meta property="og:title" content="ShifuDong">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;6&#x2F;index.html">
<meta property="og:site_name" content="ShifuDong">
<meta property="og:description" content="记录生活， 记录学习， 分享知识">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ShifuDong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShifuDong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Knowledge Sharing</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/03/os-8%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/03/os-8%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/" class="post-title-link" itemprop="url">进程和线程的切换开销</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-03 19:29:16" itemprop="dateCreated datePublished" datetime="2020-05-03T19:29:16+08:00">2020-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-13 09:47:16" itemprop="dateModified" datetime="2021-05-13T09:47:16+08:00">2021-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="进程以及进程切换"><a href="#进程以及进程切换" class="headerlink" title="进程以及进程切换"></a>进程以及进程切换</h3><p>进程是操作系统的伟大发明之一，对应用程序屏蔽了CPU调度、内存管理等硬件细节，而抽象出一个进程的概念，让应用程序专心于实现自己的业务逻辑既可，而且在有限的CPU上可以“同时”进行许多个任务。但是它为用户带来方便的同时，也引入了一些额外的开销。如下图，在进程运行中间的时间里，虽然CPU也在忙于干活，但是却没有完成任何的用户工作，这就是进程机制带来的额外开销。</p>
<p><img src="https://api2.mubu.com/v3/document_image/6dd32cf5-8718-46ca-b305-dadb66e6a565-11197877.jpg" alt="进程切换"></p>
<p>在进程A切换到进程B的过程中，先保存A进程的上下文，以便于等A恢复运行的时候，能够知道A进程的下一条指令是啥。然后将要运行的B进程的上下文恢复到寄存器中。这个过程被称为<strong>上下文切换</strong>。上下文切换开销在进程不多、切换不频繁的应用场景下问题不大。但是现在Linux操作系统被用到了高并发的网络程序后端服务器。在单机支持成千上万个用户请求的时候，这个开销影响较大。因为用户进程在请求Redis、Mysql数据等<strong>网络IO阻塞掉的时候，或者在进程时间片到了，都会引发上下文切换。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/16f45d66-9a80-407d-ad17-e6a3e3fb7b79-11197877.jpg" alt="进程状态变化"></p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>实验方法为创建两个进程并在它们之间传送一个<strong>令牌</strong>。其中一个进程在读取令牌时就会引起阻塞。另一个进程发送令牌后等待其返回时也处于阻塞状态。如此往返传送一定的次数，然后统计他们的平均单次切换时间开销。编译、运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;      //pipe()  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> x, i, fd[<span class="number">2</span>], p[<span class="number">2</span>];  </span><br><span class="line">    <span class="keyword">char</span> send    = <span class="string">'s'</span>;  </span><br><span class="line">    <span class="keyword">char</span> receive;  </span><br><span class="line">    pipe(fd);  </span><br><span class="line">    pipe(p);  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span>  </span><br><span class="line">    param.sched_priority = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> ((x = fork()) == <span class="number">-1</span>); </span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>) &#123;  </span><br><span class="line">        sched_setscheduler(getpid(), SCHED_FIFO, &amp;param);  </span><br><span class="line">        gettimeofday(&amp;tv, <span class="literal">NULL</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Before Context Switch Time%u s, %u us\n"</span>, tv.tv_sec, tv.tv_usec);  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;  </span><br><span class="line">            <span class="built_in">read</span>(fd[<span class="number">0</span>], &amp;receive, <span class="number">1</span>);  </span><br><span class="line">            <span class="built_in">write</span>(p[<span class="number">1</span>], &amp;send, <span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        sched_setscheduler(getpid(), SCHED_FIFO, &amp;param);  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;  </span><br><span class="line">            <span class="built_in">write</span>(fd[<span class="number">1</span>], &amp;send, <span class="number">1</span>);  </span><br><span class="line">            <span class="built_in">read</span>(p[<span class="number">0</span>], &amp;receive, <span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        gettimeofday(&amp;tv, <span class="literal">NULL</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"After Context SWitch Time%u s, %u us\n"</span>, tv.tv_sec, tv.tv_usec);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//gcc 编译运行</span></span><br><span class="line"><span class="comment">//Before Context Switch Time1617894469 s, 453169 us</span></span><br><span class="line"><span class="comment">//After Context SWitch Time1617894469 s, 506257 us</span></span><br></pre></td></tr></table></figure>
<p>每次执行的时间会有差异，多次运行后<strong>平均每次上下文切换耗时3.5us左右</strong>。当然这个数字因机器而异。</p>
<p>测试系统调用的时候，最低值是200ns。可见，<strong>上下文切换开销要比系统调用的开销要大。系统调用只是在进程内将用户态切换到内核态，然后再切回来，而上下文切换可是直接从进程A切换到了进程B。显然这个上下文切换需要完成的工作量更大。</strong></p>
<h4 id="进程切换开销"><a href="#进程切换开销" class="headerlink" title="进程切换开销"></a>进程切换开销</h4><p>上下文切换的时候，CPU的开销都具体有哪些呢？开销分成两种，一种是直接开销、一种是间接开销。</p>
<p><strong>直接开销就是在切换时，cpu必须做的事情</strong>，包括：</p>
<p>1、切换<strong>页表</strong>全局目录</p>
<p>2、切换<strong>内核态堆栈</strong></p>
<p>3、切换<strong>硬件上下文</strong>（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</p>
<ul>
<li>ip(instruction pointer)：指向当前执行指令的下一条指令</li>
<li>bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址</li>
<li>sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址</li>
<li>cr3:页目录基址寄存器，保存页目录表的物理地址</li>
<li>……</li>
</ul>
<p>4、刷新TLB</p>
<p>5、系统调度器的代码执行</p>
<p>间接开销主要指的是虽然切换到一个新进程后，由于各种<strong>缓存并不热，速度运行会慢一些</strong>。<strong>如果进程始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多</strong>。上面的实验并没有很好地测量到这种情况，所以实际的上下文切换开销可能比3.5us要大。</p>
<h4 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h4><p>lmbench是用于评价系统综合性能的多平台开源benchmark，能够测试包括文档读写、内存操作、进程创建销毁开销、网络等性能。这个工具的优势是是进行了多组实验，每组2个进程、8个、16个。每个进程使用的数据大小也在变，充分模拟cache miss造成的影响。lmbench显示的进程上下文切换耗时从2.7us到5.48之间。</p>
<h4 id="线程上下文切换耗时"><a href="#线程上下文切换耗时" class="headerlink" title="线程上下文切换耗时"></a>线程上下文切换耗时</h4><p>在Linux下其实本并没有线程，只是为了迎合开发者口味，搞了个<strong>轻量级进程出来就叫做了线程。</strong>轻量级进程和进程一样，<strong>都有自己独立的<code>task_struct</code>进程描述符，也都有自己独立的<code>pid</code>。</strong>从操作系统视角看，<strong>调度上和进程没有什么区别，都是在等待队列的双向链表里选择一个<code>task_struct</code>切到运行态</strong>。只不过<strong>轻量级进程和普通进程的区别是可以共享同一内存地址空间、代码段、全局变量、同一打开文件集合</strong>。</p>
<p>同一进程下的线程<code>getpid()</code>看到的<code>pid</code>是一样的，其实<code>task_struct</code>里还有一个<code>tgid</code>字段。<strong>对于多线程程序来说，<code>getpid()</code>系统调用获取的实际上是这个<code>tgid</code>，因此隶属同一进程的多线程看起来PID相同。</strong></p>
<p>实际测试:</p>
<p>线程和进程测试差不多，创建20个线程，在线程之间通过管道来传递信号。<strong>接到信号就唤醒，然后再传递信号给下一个线程，自己睡眠。这个实验里单独考虑了给管道传递信号的额外开销，</strong>并在第一步就统计了出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipes[<span class="number">20</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">running</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inti</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pipe(pipes[i])&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        pipes[i][<span class="number">2</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">distroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(pipes[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(pipes[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">self_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">20000</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">write</span>(pipes[<span class="number">0</span>][<span class="number">1</span>],<span class="built_in">buffer</span>,<span class="number">10</span>)==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">read</span>(pipes[<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">buffer</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    gettimeofday(&amp;<span class="built_in">end</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)(<span class="number">1000000</span>*(<span class="built_in">end</span>.tv_sec-start.tv_sec)+ <span class="built_in">end</span>.tv_usec-start.tv_usec)/<span class="number">20000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *_test(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = ((<span class="keyword">int</span> *)arg)[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> in = pipes[pos][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> to = pipes[(pos + <span class="number">1</span>)%<span class="number">20</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">running</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(in,<span class="built_in">buffer</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">write</span>(to,<span class="built_in">buffer</span>,<span class="number">10</span>)==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">threading_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">while</span>(--i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;tid,<span class="literal">NULL</span>,_test,(<span class="keyword">void</span> *)pipes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">10000</span>;</span><br><span class="line">    gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">write</span>(pipes[<span class="number">1</span>][<span class="number">1</span>],<span class="built_in">buffer</span>,<span class="number">10</span>)==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">read</span>(pipes[<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">buffer</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    gettimeofday(&amp;<span class="built_in">end</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">running</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">write</span>(pipes[<span class="number">1</span>][<span class="number">1</span>],<span class="built_in">buffer</span>,<span class="number">10</span>)==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)(<span class="number">1000000</span>*(<span class="built_in">end</span>.tv_sec-start.tv_sec)+ <span class="built_in">end</span>.tv_usec-start.tv_usec)/<span class="number">10000</span>/<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inti();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%6.6f\n"</span>,self_test());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%6.6f\n"</span>,threading_test());</span><br><span class="line">    distroy();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc xiancheng.c -o xiancheng -pthread</span><br><span class="line">dongshifu@dong:~/<span class="built_in">test</span>$ ./xiancheng </span><br><span class="line">1.332800</span><br><span class="line">3.168695</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/uq5s5vwk5vtPOZ30sfNsOg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uq5s5vwk5vtPOZ30sfNsOg</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/01/os-7cpu%E5%86%85%E9%83%A8%E7%BC%93%E5%AD%98%E5%8F%8AMMU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/01/os-7cpu%E5%86%85%E9%83%A8%E7%BC%93%E5%AD%98%E5%8F%8AMMU/" class="post-title-link" itemprop="url">CPU多核心及缓存</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-01 19:29:16" itemprop="dateCreated datePublished" datetime="2020-05-01T19:29:16+08:00">2020-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-13 09:46:29" itemprop="dateModified" datetime="2021-05-13T09:46:29+08:00">2021-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="cpu多核真相"><a href="#cpu多核真相" class="headerlink" title="cpu多核真相"></a>cpu多核真相</h3><p><strong>物理CPU</strong>：主板上真正安装的<strong>CPU的个数</strong></p>
<p><strong>物理核</strong>：一个CPU会集成多个<strong>物理核心</strong></p>
<p><strong>逻辑核</strong>：超线程技术可以<strong>把一个物理核虚拟出来多个逻辑核</strong></p>
<p>超线程里的2个逻辑核实际上是在一个物理核上运行的，模拟双核心运作，<strong>共享该物理核的L1和L2缓存</strong>。物理计算能力并没有增加，超线程技术只有在多任务的时候才能提升机器核整体的吞吐量。而且据Intel官方介绍，<strong>相比实核，平均性能提升只有20-30%30%左右。</strong></p>
<p>通过top命令看到的CPU核是逻辑核，linux下可以通过<code>/proc/cupinfo</code>来查看更加详细的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat /proc/cpuinfo | grep "physical id" | sort | uniq #查看物理cpu个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cat /proc/cpuinfo| grep "cpu cores"| uniq #查看每个cpu的物理核数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cat /proc/cpuinfo  | grep -E "core id|process|physical id" #查看逻辑核数量</span></span><br></pre></td></tr></table></figure>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>286之前的时代的CPU本是没有缓存的，因为当时的<strong>CPU和内存速度差异</strong>没有现在这么大,CPU直接访问内存。但是到386时代，CPU和内存的速度不匹配了，第一次出现了缓存。而且最早的缓存并没有放在CPU模块里，而是放在主板上的。再往后<strong>CPU越来越快，现在CPU的速度比内存要快百倍以上，所以就逐步演化出了L1、L2、L3三级缓存结构，而且都集成到的CPU芯片里，以进一步提高访问速度。</strong></p>
<p>现代Intel的CPU架构的基本结构：</p>
<p><img src="https://api2.mubu.com/v3/document_image/da647419-f0ef-4f51-8cab-a50c408074f3-11197877.jpg" alt="cpu核心架构"></p>
<p>L1最接近于CPU，速度也最快，但是容量最小。一般现代CPU的L1会分成两个，一个用来<strong>cache data，一个用来cache code</strong>，这是因为code和data的更新策略并不相同，而且因为CISC的变长指令，code cache要做特殊优化。<strong>一般每个核都有自己独立的data L1和code L1。</strong><br>越往下，速度越慢，容量越大。L2一般也可以做到每个核一个独立的。但是<strong>L3一般就是整颗CPU共享的</strong>了。</p>
<h4 id="linux下实际查看"><a href="#linux下实际查看" class="headerlink" title="linux下实际查看"></a>linux下实际查看</h4><p>Linux的内核的开发者定义了一套框架模型来完成这一目的，它就是CPUFreq系统。CPUFreq提供的sysfs接口，可以看到比/proc/cpuinfo更为详细的CPU详细信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd /sys/devices/system/cpu/;ll</span></span><br><span class="line">drwxr-xr-x  9 root root    0 4月   8 14:15 cpu0/</span><br><span class="line">drwxr-xr-x  9 root root    0 4月   8 14:15 cpu1/</span><br><span class="line">drwxr-xr-x  9 root root    0 4月   8 14:15 cpu2/</span><br><span class="line">drwxr-xr-x  9 root root    0 4月   8 14:15 cpu3/</span><br><span class="line">drwxr-xr-x  9 root root    0 4月   8 14:15 cpu4/</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><strong>L1一级缓存查看：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat cpu0/cache/index0/level</span></span><br><span class="line">1</span><br><span class="line"><span class="comment"># cat cpu0/cache/index0/size</span></span><br><span class="line">32K</span><br><span class="line"><span class="comment"># cat cpu0/cache/index0/type</span></span><br><span class="line">Data</span><br><span class="line"><span class="comment"># cat cpu0/cache/index0/shared_cpu_list</span></span><br><span class="line">0,4</span><br><span class="line"><span class="comment"># cat cpu0/cache/index1/level</span></span><br><span class="line">1</span><br><span class="line"><span class="comment"># cat cpu0/cache/index1/size</span></span><br><span class="line">32K</span><br><span class="line"><span class="comment"># cat cpu0/cache/index1/type</span></span><br><span class="line">Instruction</span><br><span class="line"><span class="comment"># cat cpu0/cache/index1/shared_cpu_list</span></span><br><span class="line">0,4</span><br></pre></td></tr></table></figure>
<p>从上面的level接口可以看出index0和index1都是一级缓存，只不过<strong>一个是Data数据缓存，一个是Instruction也就是代码缓存</strong>。<br>上面提到的是每个Core是独立的L1缓存，为什么shared_cpu_list显示有共享?这里看到的cpu0并不是物理Core，而是逻辑核，都是超线程技术虚拟出来的。实<strong>际上cpu0和cpu4是属于一个物理Core，所以每个Data L1和Instruction是这两个逻辑核共享的</strong>。本台电脑总共是有4个Data L1,4个Instrunction L1，大小都是32K。</p>
<p><strong>L2二级缓存查看：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat cpu0/cache/index2/size</span></span><br><span class="line">256K</span><br><span class="line"><span class="comment"># cat cpu0/cache/index2/type</span></span><br><span class="line">Unified</span><br><span class="line"><span class="comment"># cat cpu0/cache/index2/shared_cpu_list</span></span><br><span class="line">0,4</span><br></pre></td></tr></table></figure>
<p>二级缓存要比一级缓存大不少，有256K，但是<strong>不分Data和Instruction。</strong>另外L2和L1一样，也是总共有4个，<strong>每两个逻辑核共享一个L2。</strong></p>
<p><strong>L3三级缓存查看：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat cpu0/cache/index3/size</span></span><br><span class="line">8192K</span><br><span class="line"><span class="comment"># cat cpu0/cache/index3/type</span></span><br><span class="line">Unified</span><br><span class="line"><span class="comment"># cat cpu0/cache/index3/shared_cpu_list</span></span><br><span class="line">0-7</span><br></pre></td></tr></table></figure>
<p>L3达到了8M，买CPU的时候商品里能看到的缓存属性一般告诉的就是L3属性。因为L3要比L2和L1看起来要大的多。但实际上我的这台电脑里L3只有以个，每个CPU各一个，不像是L2、L1有很多。</p>
<p>另外，Linux上还有个<code>dmidecode</code>命令，也能查看到一些关于CPU缓存的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dmidecode -t cache</span><br></pre></td></tr></table></figure>
<h4 id="Cache-Line"><a href="#Cache-Line" class="headerlink" title="Cache Line"></a>Cache Line</h4><p>Cache Line是<strong>本级缓存向下一层取数据时的基本单位</strong>。可以通过如下方式查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd /sys/devices/system/cpu/;ll</span></span><br><span class="line"><span class="comment"># cat cpu0/cache/index0/coherency_line_size</span></span><br><span class="line">64</span><br><span class="line"><span class="comment"># cat cpu0/cache/index1/coherency_line_size</span></span><br><span class="line">64</span><br><span class="line"><span class="comment"># cat cpu0/cache/index2/coherency_line_size</span></span><br><span class="line">64</span><br><span class="line"><span class="comment"># cat cpu0/cache/index3/coherency_line_size</span></span><br><span class="line">64</span><br></pre></td></tr></table></figure>
<p>可以看到<strong>L1、L2、L3的Cache Line大小都是64字节（注意是字节。内存中的实际情况是：一次IO其实吐出来的只有64比特，注意是比特。 一个cache line请求需要内存吐8次数据。 这个是64bit是由总线位宽决定的，没办法改）。就是说每次cpu从内存获取数据的时候，都是以该单位来进行的，哪怕只取一个bit，CPU也是给取一个Cache Line然后放到各级缓存里存起来。</strong></p>
<h3 id="TLB缓存"><a href="#TLB缓存" class="headerlink" title="TLB缓存"></a>TLB缓存</h3><p>TLB(Translation Lookaside Buffer)是一个小的，虚拟寻址的缓存，其中每一行都保存着一个由单个PTE(Page Table Entry 页表项)组成的块。如果<strong>没有TLB，则每次取数据都需要两次访问内存，即查页表获得物理地址和取数据。</strong>该<strong>缓存位于MMU内</strong>。</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>在<strong>用户的视角里</strong>，<strong>每个进程都有自己独立的地址空间</strong>，A进程的4GB和B进程4GB是完全独立不相关的，他们看到的都是操作系统虚拟出来的地址空间。但是呢，虚拟地址最终还是要落在实际内存的物理地址上进行操作的。<strong>操作系统就会通过页表的机制来实现进程的虚拟地址到物理地址的翻译工作。其中每一页的大小都是固定的</strong>。</p>
<p>页表管理的两个关键点，分别是页面大小和页表级数</p>
<p><strong>1.页面大小</strong><br>在Linux下，通过如下命令可以查看到当前操作系统的页大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># getconf PAGE_SIZE</span></span><br><span class="line">4096</span><br></pre></td></tr></table></figure>
<p>可以看到当前的Linux机器的页表是4KB的大小。</p>
<p><strong>2.页表级数</strong></p>
<p>1）如果页表<strong>级数越少，虚拟地址到物理地址的映射会很快，但是需要管理的页表项会很多，能支持的地址空间也有限。</strong></p>
<p>2）<strong>相反页表级数越多，需要的存储的页表数据就会越少，而且能支持到比较大的地址空间，但是虚拟地址到物理地址的映射就会越慢</strong>。</p>
<h4 id="linux虚拟内存实现"><a href="#linux虚拟内存实现" class="headerlink" title="linux虚拟内存实现"></a>linux虚拟内存实现</h4><h5 id="32位系统的虚拟内存实现：二级页表"><a href="#32位系统的虚拟内存实现：二级页表" class="headerlink" title="32位系统的虚拟内存实现：二级页表"></a>32位系统的虚拟内存实现：<strong>二级页表</strong></h5><p>如果想支持32位的操作系统下的4GB进程虚拟地址空间，假设页表大小为4K，则共有2的20次方页面。如果采用速度最快的1级页表，对应则需要2的20次方个页表项。一个页表项假如4字节，那么一个进程就需要<code>（1048576*4=）4M</code>的内存来存页表项。<br>如果是采用2级页表，如图，则创建进程时只需要有一个页目录就可以了，占用<code>(1024*4)=4KB</code>的内存。剩下的二级页表项只有用到的时候才会再去申请。</p>
<p><img src="https://api2.mubu.com/v3/document_image/b6e8d43f-0635-487e-a49e-bfae31655cff-11197877.jpg" alt="二级页表"></p>
<p>这样则只需要页目录1024个，页表项1024个，<strong>总共2028个页表管理条目，（2048*4=）8k就可以支持起4GB的地址空间转换。</strong></p>
<h5 id="64位系统的虚拟内存实现：四级页表"><a href="#64位系统的虚拟内存实现：四级页表" class="headerlink" title="64位系统的虚拟内存实现：四级页表"></a>64位系统的虚拟内存实现：四级页表</h5><p>现在的操作系统需要支持的可是48位地址空间（理论上可以支持64位，但其实现在只支持到了48位，也足够用了），而且要支持成百上千的进程，如果不采用分级页表的方式，则创建进程时就需要为其维护一个2的36次方个页表项（64位Linux目前只使用了地址中的48位的，在这里面，最后12位都是页内地址，只有前36位才是用来寻找页表的）， 2^36 *4Byte=32GB，这个更不能忍。也必须和32位系统一样，进一步提高页表的级数。</p>
<p>Linux在v2.6.11以后，最终采用的方案是4级页表，分别是：</p>
<ul>
<li>PGD：page Global directory(47-39), 页全局目录</li>
<li>PUD：Page Upper Directory(38-30)，页上级目录</li>
<li>PMD：page middle directory(29-21)，页中间目录</li>
<li>PTE：page table entry(20-12)，页表项</li>
</ul>
<p>这样，一个64位的虚拟空间，初始创建的时候只需要维护一个29 大小的一个页全局目录就够了，现在的页表数据结构被扩展到了8byte。这个页全局目录仅仅需要(29 *8=)4K，剩下的中间页目录、页表项只需要在使用的时候再分配就好了。Linux就是通过这种方式支持起(2^48 =)256T的进程地址空间的。</p>
<h4 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h4><p>使用多级页表虽然只需要4k的初始页目录就可以支持起一个256T的进程地址空间。但是，这也带来了额外的问题，<strong>页表是存在内存里的。那就是一次内存IO光是虚拟地址到物理地址的转换就要去内存查4次页表，再算上真正的内存访问，竟然需要5次内存IO才能获取一个内存数据!</strong></p>
<p>和<strong>CPU的L1、L2、L3的缓存思想一致，既然进行地址转换需要的内存IO次数多，且耗时。那么干脆就在CPU里把页表尽可能地cache起来不就行了么</strong>，所以就有了<strong>TLB(Translation Lookaside Buffer，位于MMU中，MMU位于CPU内)，专门用于改进虚拟地址到物理地址转换速度的缓存。其访问速度非常快，和寄存器相当，比L1访问还快。</strong></p>
<h5 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h5><p>MMU（内存管理单元）：包括从逻辑地址到虚拟地址（线性地址）再到内存地址的变换过程、页式存储管理、段式存储管理、段页式存储管理、虚拟存储管理（请求分页、请求分段、请求段页）。 <strong>MMU位于CPU内部，可以假想为一个进程的所需要的资源都放在虚拟地址空间里面，而CPU在取指令时，机器指令中的地址码部分为虚拟地址（线性地址），需要经过MMU转换成为内存地址，才能进行取指令。</strong>MMU完成两大功能：</p>
<ul>
<li><p>虚拟地址到内存地址的地址变换</p>
</li>
<li><p>设置修改CPU对内存的访问级别。比如在Linux的虚拟地址空间中，3-4G为内核空间，访问级别最高，可以访问整个内存；而0-3G的用户空间只能访问用户空间的内容。其实这也是由MMU的地址变换机制所决定的。对于Inter（英特尔）CPU架构，CPU对内存的访问设置了4个访问级别：0、1、2、3，0最高，4最低。而Linux下，只是使用了CPU的两种级别：0、3。</p>
</li>
</ul>
<p>CPU的状态属于程序状态字PSW的一位，系统模式(0)，用户模式(1)，CPU交替执行操作系统程序和用户程序。0级对应CPU的内核态（特权态、管态、系统态），而3级对应用户态（普通态或目态），这其实是对内核的一种保护机制。例如，在执行printf函数的时候，其本身是在用户空间执行，然后发生系统调用，调用系统函数write将用户空间的数据写入到内核空间，最后把内核的数据刷到（fsync）磁盘上，在这个过程中，CPU的状态发生了变化，从0级（用户态）到3级（内核态）。</p>
<p>有了TLB之后，CPU访问某个虚拟内存地址的过程如下：</p>
<ul>
<li>CPU产生一个虚拟地址</li>
<li><strong>MMU从TLB中获取页表，翻译成物理地址</strong></li>
<li>MMU<strong>把物理地址发送给L1/L2/L3/缓存</strong></li>
<li>L1/L2/L3/内存将地址对应数据返回给CPU</li>
</ul>
<p>第2步是类似于寄存器的访问速度，所以如果TLB能命中，则虚拟地址到物理地址的时间开销几乎可以忽略。</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>因为TLB并不是很大，只有4k，而且现在逻辑核又造成会有两个进程来共享。所以可能会有cache miss的情况出现。<strong>而且一旦TLB miss造成的后果可比物理地址cache miss后果要严重一些，最多可能需要进行5次内存IO才行。</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/PQTuFZO51an6OAe3WX4BVw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PQTuFZO51an6OAe3WX4BVw</a></p>
<p><a href="https://mp.weixin.qq.com/s/mssTS3NN7-w2df1vhYSuYw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mssTS3NN7-w2df1vhYSuYw</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/25/os-6%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/25/os-6%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">内存底层原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-25 19:29:16" itemprop="dateCreated datePublished" datetime="2020-04-25T19:29:16+08:00">2020-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-13 09:45:34" itemprop="dateModified" datetime="2021-05-13T09:45:34+08:00">2021-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="内存底层原理"><a href="#内存底层原理" class="headerlink" title="内存底层原理"></a>内存底层原理</h3><h4 id="内存底层结构"><a href="#内存底层结构" class="headerlink" title="内存底层结构"></a>内存底层结构</h4><p>由于高速缓存的工作机制，内存对齐后性能高。且底层实现中<strong>内存的IO是以8个字节64bit为单位进行的。</strong></p>
<p>内存物理结构：一个内存是由若干个黑色的<strong>内存颗粒</strong>构成的。每一个内存颗粒叫做一个<strong>chip</strong>。<strong>每个chip内部，由8个bank组成</strong>。每一个bank是一个<strong>二维平面上的矩阵</strong>。矩阵中<strong>每一个元素中都是保存了1个字节，也就是8个bit</strong></p>
<h4 id="内存编址"><a href="#内存编址" class="headerlink" title="内存编址"></a>内存编址</h4><p>对于在应用程序中内存中地址连续的8个字节,例如0x0000-0x0007，是从位于bank上的呢？直观感觉，应该是在第一个bank上吗？其实不是的，程序员视角看起来连续的地址0x0000-0x0007，<strong>实际上是位于8个bank中的，每一个bank只保存了一个字节。在物理上，他们并不连续</strong>。下图很好地阐述了实际情况。</p>
<p><img src="https://api2.mubu.com/v3/document_image/6be26faa-2427-4112-bd72-15e2cab64e46-11197877.jpg" alt="连续8字节在内存中的实际分布"></p>
<p>编址原因：是电路工作效率。<strong>内存中的8个bank是可以并行工作的。如果想读取地址0x0000-0x0007，每个bank工作一次，拼起来就是需要的数据，IO效率会比较高。</strong>但要存在一个bank里，那这个bank只能自己干活。只能串行进行读取，需要读8次，这样速度会慢很多。</p>
<p><strong>内存对齐最最底层的原因是内存的IO是以8个字节64bit为单位进行的。</strong> 对于64位数据宽度的内存，假如cpu也是64位的cpu（现在的计算机基本都是这样的），<strong>每次内存IO获取数据都是从同行同列的8个bank中各自读取一个字节拼起来的。从内存的0地址开始，0-7字节的数据可以一次IO读取出来，8-15字节的数据也可以一次读取出来。</strong></p>
<p>假如指定要获取的是0x0001-0x0008，也是8字节，但是不是0开头的，内存需要怎么工作呢？没有好办法，内存只好先工作一次把0x0000-0x0007取出来，然后再把0x0008-0x0015取出来，<strong>把两次的结果都返回</strong>。CPU和内存IO的硬件限制导致没办法一次跨在两个数据宽度中间进行IO。</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul>
<li><p>事实上，<strong>编译和链接器会自动替开发者对齐内存的，尽量保证一个变量不跨列寻址。</strong></p>
</li>
<li><p>其实在内存硬件层上，还有操作系统层。操作系统还管理了CPU的一级、二级、三级缓存。高速缓存里的<strong>Cache Line是64字节，它是内存IO单位的8倍，不会让内存IO浪费。</strong></p>
</li>
</ul>
<h3 id="内存访问延迟"><a href="#内存访问延迟" class="headerlink" title="内存访问延迟"></a>内存访问延迟</h3><p>内存延迟一般是通过CL-tRCD-tRP-tRAS四个参数来标识的。详细理解一下这四个参数的含义：</p>
<ul>
<li>CL(Column Address Latency）：发送一个列地址到内存与数据开始响应之间的周期数</li>
<li>tRCD（Row Address to Column Address Delay）：打开一行内存并访问其中的列所需的最小时钟周期数</li>
<li><p>tRP(Row Precharge Time)：发出预充电命令与打开下一行之间所需的最小时钟周期数。</p>
</li>
<li><p>tRAS(Row Active Time)：行活动命令与发出预充电命令之间所需的最小时钟周期数。也就是对下一次预充电时间进行限制。</p>
</li>
</ul>
<p>除了CL是固定周期数以外，其它的三个都是最小周期。另外上面的参数都是以<strong>时钟周期为单位</strong>的。因为<strong>现代的内存都是一个时钟周期上下沿分别各传输一次数据，所以用Speed/2就可以得出</strong>，如果机器的Speed是1066MHz，则时钟周期为533MHz。自己的机器可以通过dmidecode命令查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode | grep -P -A16 <span class="string">"Memory Device"</span></span><br></pre></td></tr></table></figure>
<h4 id="四个工作场景"><a href="#四个工作场景" class="headerlink" title="四个工作场景"></a>四个工作场景</h4><ul>
<li>场景1：</li>
</ul>
<p>进程需要内存地址0x0000为的一个字节的数据，CPU这时候向内存控制器发出请求，内存控制器进行<strong>行地址的预充电，需要等待tRP个时钟周期。再发出打开一行内存的命令，又需要等待tRCD个时钟周期。接着发送列地址，再等待CL个周期。</strong>最终将0x0000-0x0007的数据全部返回给了CPU。CPU把这些数据放入到了自己的cache里，并帮你开始对0x0000的数据进行运算。</p>
<ul>
<li>场景2：</li>
</ul>
<p>进程需要内存地址0x0003的一个字节数据，<strong>CPU发现发现它在自己的cache里存在，直接使用就好了。这个场景里其实根本就没有内存IO发生</strong>。</p>
<ul>
<li>场景3：</li>
</ul>
<p>进程需要内存地址0x0008的一个字节数据，<strong>CPU的cache并没有命中，于是向内存控制器请求。内存控制器发现行地址和上一次工作的行地址一致，这次只需要发送列地址后等待CL个周期，</strong>就可以拿到0x0008-0x0015的数据并返回给CPU了。</p>
<ul>
<li>场景4：</li>
</ul>
<p>进程需要内存地址0xf000的一个字节数据，同样<strong>CPU的cache并不命中，向内存控制器请求。内存控制器一看（内心有些许的郁闷），这次行w地址又变了，得，和场景1一样。继续等待tRP+tRCD+CL个周期后，才能够取到数据并返回。</strong></p>
<blockquote>
<p>实际的计算机的内存IO过程中还需要进行逻辑地址和物理地址的转换，这里忽略。</p>
</blockquote>
<h4 id="实际计算"><a href="#实际计算" class="headerlink" title="实际计算"></a>实际计算</h4><p>内存也存在和磁盘一样，随机IO比顺序IO要慢的问题。<strong>如果行地址同上一次访问的不一致，则需要重新拷贝row buffer，延迟周期需要tRP+tRCD+CL。而如果是顺序IO的话（行地址不变），只需要CL个周期既可完成。</strong></p>
<p>估算内存的延时,若测试机器上的内存参数Speed为1066MHz（通过dmidecode查得），该值除以2就是时钟周期的频率=1066/2=533Mhz。其延迟周期为7-7-7-24。</p>
<ul>
<li>随机IO：这种状况下需要tRP+tRCD+CL个时钟周期，7+7+7=21个周期。但是还有个tRAS的限制，两次行地址预充电不得小于24。所以得按24来计算，24*(1s/533Mhz) = 45ns</li>
<li>顺序IO：这种状况下只需要CL个时钟周期 7*(1s/533Mhz)=13ns</li>
</ul>
<h4 id="扩展：CPU的cache-line虚拟内存概念"><a href="#扩展：CPU的cache-line虚拟内存概念" class="headerlink" title="扩展：CPU的cache line虚拟内存概念"></a>扩展：CPU的cache line虚拟内存概念</h4><p>因为对于内存来说，<strong>随机IO一次开销比顺序IO高好几倍。所以操作系统在工作的时候，会尽量让内存通过顺序IO的方式来进行。</strong>做法关键就是Cache Line。<strong>当CPU发现缓存不命中的时候，实际上从来不会向内存去请求1个字节，8个字节这种。而是一次性就要64字节，然后放到自己的Cache中存起来。</strong></p>
<p>用上面的例子来看，</p>
<ul>
<li>如果随机请求8字节：耗时是45ns</li>
<li>如果随机请求64字节：耗时是45+7*13 = 136ns</li>
</ul>
<p>开销也没贵多少，<strong>因为只有第一个字节是随机IO，后面的7个字节都是顺序IO。数据是8倍，但是IO耗时只有3倍，而且取出来的数据后面大概率要用</strong>，所以计算机内部就这么搞了，通过这种方式<strong>避免一些随机IO</strong>！</p>
<p>另外，<strong>内存也支持burst(突发传输)模式，在这种模式下可以只传入一次行列地址，就命令内存返回该内存开头的连续字节数据，比如64字节。这种模式下，只有第一次的8字节需要真正的行列访问延迟，后面的7个字节可以直接按内存的数据频率给吐出来。</strong></p>
<h3 id="内存核心频率"><a href="#内存核心频率" class="headerlink" title="内存核心频率"></a>内存核心频率</h3><p><strong>内存真正的工作频率是核心频率，时钟频率和数据频率都是在核心频率的基础上，通过技术手段放大出来的。内存越新，放大的倍数越多</strong>。 <strong>核心频率已经多年没有实质性进步了，这是受物理材料的极限限制，内存的核心频率一直在133MHz~200MHz之间徘徊</strong>。</p>
<p>实际的内存提速使用的是<strong>电路时钟周期预取</strong>以及<strong>Bank Group</strong>等技术。</p>
<h4 id="扩展：内存延迟"><a href="#扩展：内存延迟" class="headerlink" title="扩展：内存延迟"></a>扩展：内存延迟</h4><p>内存还有个概念叫<strong>IO频率、也叫时钟频率。简单理解为将DDR内存的Speed频率除以2，就是内存的IO频率</strong>。这个<strong>必须和CPU的外频相匹配才能工作</strong>。例如对于DDR3来说，假如核心频率133Mhz的内存工作频率下，匹配533MHz的CPU外频,其IO频率就是533Mhz。数据传输因为上下沿都可以传，所以是核心频率的8倍，也就是1066MHz左右。</p>
<p>所有的内存条都有CL-tRCD-tRP-tRAS四个参数。其中最重要的是CL-tRCD-tRP这三个参数，只要费点劲，所有的在售内存你都能找到这3个值。例如经典的DDR3-1066、DDR3-1333及DDR3-1600的CL值分别为7-7-7、8-8-8及9-9-9。现在京东上一条比较流行的台式机内存金士顿(Kingston)DDR4 2400 8G，其时序是17-17-17。</p>
<p>第四个参数有时候会被省略。原因有二，第一：现在的开发者不需要直接和内存打交道，而操作系统呢又做的比较内存友好，很少会有这个开销真正发生。第二，这个开销的值要比其它的值大很多，实在不太好看。商家为了内存能多卖一些，干脆就避而不谈了。</p>
<p><strong>好了，问题来了。为什么内存越进步，延迟周期反而会变大了呢？</strong></p>
<p>这就是因为<strong>延迟周期使用延迟时间除以内存Speed算出来的</strong>。这其实根本就不科学，最科学的办法应该是用延迟时间来评估。<strong>延迟时间很大程度上是受内存的核心频率的制约的</strong>。而这些年核心频率又基本上没有进步，所以延迟时间也不会有实质的降低。内存的制造商们又为了频率数据好看，能多卖些内存，非得采用Speed作为主周期来用。导致在用这个周期一衡量，貌似延迟周期就越来越大了。</p>
<h3 id="测试参考"><a href="#测试参考" class="headerlink" title="测试参考"></a>测试参考</h3><p>在各种情况下进行内存访问延迟实验。<strong>最快的情况下其实不是内存在IO，而是CPU的高速缓存在工作。穿</strong>透到内存的话，顺序IO延时大约在10ns左右，随机访问确实比顺序访问慢的多，大概是4倍的关系。</p>
<p>现代的服务器里，<strong>CPU和内存条都有多个，它们之间目前主要采用的是复杂的NUMA架构进行互联，NUMA把服务器里的CPU和内存分组划分成了不同的node。属于同一个node里的CPU和内存之间访问速度会比较快。而如果跨node的话，则需要经过QPI总线，总体来说，速度会略慢一些</strong>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/F0NTfz-3x3UxQeF-GSavRg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/F0NTfz-3x3UxQeF-GSavRg</a></p>
<p><a href="https://mp.weixin.qq.com/s/ps8VfGpbL4-xKggM2ywjHw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ps8VfGpbL4-xKggM2ywjHw</a></p>
<p><a href="https://mp.weixin.qq.com/s/3KOXcvmtc5jiwzGSTSF_yQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3KOXcvmtc5jiwzGSTSF_yQ</a></p>
<p><a href="https://mp.weixin.qq.com/s/OR2XB4J76haGc1THeq7WQg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OR2XB4J76haGc1THeq7WQg</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/os-4%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/21/os-4%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">文件在磁盘中的开销</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-21 19:29:16" itemprop="dateCreated datePublished" datetime="2020-04-21T19:29:16+08:00">2020-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-13 09:44:18" itemprop="dateModified" datetime="2021-05-13T09:44:18+08:00">2021-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="新建一个空文件占用多少磁盘空间"><a href="#新建一个空文件占用多少磁盘空间" class="headerlink" title="新建一个空文件占用多少磁盘空间"></a>新建一个空文件占用多少磁盘空间</h3><p>linux下<code>touch</code>一个空文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch empyt_file</span><br></pre></td></tr></table></figure>
<p>进行该操作，是否要消耗磁盘空间？需要的话，大概能消耗多少？</p>
<p><code>ls</code>这个命令可以查看文件大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch empty_file</span><br><span class="line">$ ls -l  </span><br><span class="line">total 0  </span><br><span class="line">-rw-r--r-- 1 dongshifu dongshifu 0 Aug 17 17:49 empty_file</span><br></pre></td></tr></table></figure>
<p><code>ls</code>命令表示这个空文件占用的是0。<strong>文件的大小确实是0，因为还没有为该文件写入任何内容</strong>。但是现在要思考的是，<strong>一个空文件是否占用磁盘空间</strong>。所以直觉告诉这绝对不可能，磁盘上多出来一个文件，怎么可能一点空间开销都没有！</p>
<p>为了解开这个谜底，还需要借助<code>df</code>命令。输入<code>df –i</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># df -i</span></span><br><span class="line">Filesystem            Inodes   IUsed   IFree IUse% Mounted on</span><br><span class="line">......</span><br><span class="line">/dev/sdb1            2147361984 12785019 2134576965    1% /search</span><br></pre></td></tr></table></figure>
<p>该命令输出展示了<strong>文件系统中inode的使用情况</strong>。注意IUsed是12785019。继续新建一个空文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># touch empty_file2</span></span><br><span class="line">df -i</span><br><span class="line">Filesystem            Inodes   IUsed   IFree IUse% Mounted on</span><br><span class="line">......</span><br><span class="line">/dev/sdb1            2147361984 12785020 2134576964    1% /search</span><br></pre></td></tr></table></figure>
<p>这下注意IUsed变成了12785020。</p>
<p>得出结论：<strong>新建一个空文件会占用一个Inode。</strong></p>
<h4 id="Inode"><a href="#Inode" class="headerlink" title="Inode"></a>Inode</h4><p>那么inode里都存了哪些和文件相关的信息呢？稍微看一下内核的源代码。以ext2文件系统为例，在linux-2.6里的文件<code>fs/ext2/ext2.h</code>中，可以找到内核对于inode结构体的定义。该结构体较为复杂，<strong>主要存储除了文件内容以外的一些其他数据</strong>，选一些比较关键的截取出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_inode</span> &#123;</span></span><br><span class="line">        __le16  i_mode;         <span class="comment">// 文件权限</span></span><br><span class="line">        __le16  i_uid;          <span class="comment">// 文件所有者ID</span></span><br><span class="line">        __le32  i_size;         <span class="comment">// 文件字节数大小</span></span><br><span class="line">        __le32  i_atime;        <span class="comment">// 文件上次被访问的时间</span></span><br><span class="line">        __le32  i_ctime;        <span class="comment">// 文件创建时间</span></span><br><span class="line">        __le32  i_mtime;        <span class="comment">// 文件被修改的时间</span></span><br><span class="line">        __le32  i_dtime;        <span class="comment">// 文件被删除的时间</span></span><br><span class="line">        __le16  i_gid;          <span class="comment">// 文件所属组ID</span></span><br><span class="line">        __le16  i_links_count;  <span class="comment">// 此文件的inode被连接的次数</span></span><br><span class="line">        __le32  i_blocks;       <span class="comment">// 文件的block数量</span></span><br><span class="line">        ...</span><br><span class="line">        __le32  i_block[EXT2_N_BLOCKS]; <span class="comment">// 指向存储文件数据的块的数组</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>可以看到<strong>和文件相关的所属用户、访问时间等都是存在inode中的</strong>。使用<code>stat</code>命令就可以直接看到文件inode中数据。</p>
<p>每个inode到底是多大呢？<code>dumpe2fs</code>可以查看（XFS的话使用xfs_info)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dumpe2fs -h /dev/mapper/vgroot-lvroot</span></span><br><span class="line">dumpe2fs 1.41.12 (17-May-2010)</span><br><span class="line">......</span><br><span class="line">Inode size:               256</span><br></pre></td></tr></table></figure>
<p><strong>Inode size表示每个Inode的大小。</strong>一般，每个inode都是256字节。<strong>两个inode的大小正好对齐到磁盘扇区的512字节。</strong></p>
<h4 id="文件名保存地址"><a href="#文件名保存地址" class="headerlink" title="文件名保存地址"></a>文件名保存地址</h4><p>Inode结构体都看完了，搞了半天不知道有没有发现一个问题，<strong>inode里并没有存储文件名！！那么，文件名到底跑哪儿去了？</strong></p>
<p>在<code>fs/ext2/ext2.h</code>中，可以找到如下文件夹相关的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_dir_entry</span> &#123;</span></span><br><span class="line">         __le32  inode;                  <span class="comment">/* Inode number */</span></span><br><span class="line">         __le16  rec_len;                <span class="comment">/* Directory entry length */</span></span><br><span class="line">         __le16  name_len;               <span class="comment">/* Name length */</span></span><br><span class="line">         <span class="keyword">char</span>    name[];                 <span class="comment">/* File name, up to EXT2_NAME_LEN */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体就是<strong>文件夹所使用的数据结构</strong>。没错<strong>，文件名是存在其所属的文件夹中的，就是其中的<code>char name[]</code>字段。和文件名一起，文件夹里还记录了该文件的inode号等信息。</strong></p>
<h3 id="一个字节的文件实际占用多少磁盘空间"><a href="#一个字节的文件实际占用多少磁盘空间" class="headerlink" title="一个字节的文件实际占用多少磁盘空间"></a>一个字节的文件实际占用多少磁盘空间</h3><p>假如给文件里只写入1个字节，那么这个文件实际的磁盘占用多大，难道真的是1个字节吗？</p>
<p>实际操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir tempDir</span></span><br><span class="line"><span class="comment"># cd tempDir</span></span><br><span class="line"><span class="comment"># du -h</span></span><br><span class="line">0    .</span><br><span class="line"><span class="comment"># touch test</span></span><br><span class="line"><span class="comment"># du -h</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>在一个目录中创建了一个空的文件以后，通过<code>du</code>命令看到的该文件夹的占用空间并没有发生变化。这符合之前的认识，因为空文件只占用inode。接着修改文件，添加一个字母：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> &gt; <span class="built_in">test</span></span><br><span class="line"><span class="comment"># du -h</span></span><br><span class="line">4.0K</span><br></pre></td></tr></table></figure>
<p>保存后再次查看该目录的空间占用。<strong>发现由原来的0增加到了4K</strong>。 所以说，<strong>文件里的内容不论多小，哪怕是一个字节，其实操作系统也会分配4K的</strong>。哦，当然了<strong>还得再算前文中说到的inode和文件夹数据结构中存储的文件名等所用的空间。</strong> 所以，不要在系统里维护一大堆的碎文件<strong>。文件再小，占用磁盘其实一点都不少！</strong></p>
<h4 id="4K占用的底层原理"><a href="#4K占用的底层原理" class="headerlink" title="4K占用的底层原理"></a>4K占用的底层原理</h4><p>再把linux源代码文件fs/ext2/ext2.h里关于inode的定义翻出来，<strong>找到结构体中定义的指向数据节点用的block数组：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_inode</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">    __le32  i_block[EXT2_N_BLOCKS]; <span class="comment">// 指向存储文件数据的块的数组</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p><strong>当文件没有数据需要存储的时候，这个数组都是空值。而当写入了1个字节以后，文件系统就需要申请block去存储了，申请完后，指针放在这个数组里。哪怕文件内容只有一个字节，仍然会分配一个整的Block，因为这是文件系统的最小工作单位。那么这个block大小是多大呢，ext下可以通过<code>dumpe2fs</code>查看。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dumpe2fs -h /dev/mapper/vgroot-lvroot</span></span><br><span class="line">......</span><br><span class="line">Block size:               4096</span><br></pre></td></tr></table></figure>
<p>一般情况，一个Block是4KB。</p>
<h4 id="大文件如何存储"><a href="#大文件如何存储" class="headerlink" title="大文件如何存储"></a>大文件如何存储</h4><p>inode中定义的block数组大小呢，只有<code>EXT2_N_BLOCKS</code>个。再查看一下这个常量的定义，发现它是15，相关内核中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT2_NDIR_BLOCKS        12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT2_IND_BLOCK         EXT2_NDIR_BLOCKS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT2_DIND_BLOCK        (EXT2_IND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT2_TIND_BLOCK        (EXT2_DIND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT2_N_BLOCKS              (EXT2_TIND_BLOCK + 1)</span></span><br></pre></td></tr></table></figure>
<p>就按4K的block size来看，15个block只够存的下15<em>4=60K的文件。 这个文件大小肯定不是那么简单，存一个mp4大片都得上G了。那<em>*Linux是怎么实现大文件存储的呢？其实上面宏的定义过程已经告知了一切，就是只有12个数组直接存block指针，其余的用来做间接索引（EXT2_IND_BLOCK），二级间接索引（EXT2_DIND_BLOCK）和三级索引（EXT2_TIND_BLOCK）。</em></em></p>
<p><img src="https://api2.mubu.com/v3/document_image/c3c116ba-3f8f-4006-8cf4-a24d3d2a5d5c-11197877.jpg" alt="inode中的直接与间接索引"></p>
<p>这样，一个文件可以使用的空间就指数倍的扩展了。 <strong>文件小的时候，都用直接索引，磁盘IO少，性能好。文件大的时候，访问一个block可能得先进行三次的IO，性能略慢，不过有OS层面的页缓存、目录项缓存的加持，也还好</strong>。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>文件系统是按照inode+block来组织的，所以不管文件多小，哪怕只有一个字节，在数据上都会消耗掉整整一个块(当然还得算上inode等开销)。</strong>这个块大小可以通过<code>dumpe2fs</code>等命令来查看。如果想改变这个块大小怎么办?对不起，只能重新格式化。</p>
<p>再扯的远一点<strong>，所有的文件系统理念都是按照块来分配的，包括分布式文件系统</strong>，例如HDFS。<strong>由于HDFS应用场景是各种GB、TB甚至是PB级别的数据处理。所以为了降低block的管理成本，它的block size设置的非常大。在比较新的版本里，一个block直接就是128M，</strong>没看错，单位是M。 </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/WE6BodR_q0GSKks_TgYL1w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WE6BodR_q0GSKks_TgYL1w</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/12/os-3%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/12/os-3%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/" class="post-title-link" itemprop="url">操作系统固态硬盘基本介绍</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-12 19:29:16" itemprop="dateCreated datePublished" datetime="2020-04-12T19:29:16+08:00">2020-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-13 09:44:02" itemprop="dateModified" datetime="2021-05-13T09:44:02+08:00">2021-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h3><p>SSD硬盘不像机械硬盘IO时依赖两个耗时的机械轴行为：磁盘旋转，以及磁道寻道，SSD硬盘的访问延迟要比机械硬盘要低的多，在随机IO下的表现尤其明显。</p>
<h4 id="SSD的组成结构"><a href="#SSD的组成结构" class="headerlink" title="SSD的组成结构"></a>SSD的组成结构</h4><p>机械硬盘和ssd虽然都同为硬盘，但底层实现技术却完全不一样，机械硬盘使用的是磁性材料记忆，而SSD用的是类似u盘的闪存技术。实现技术的不同，必然在硬盘内部结构上他们就有天壤之别。不像机械硬盘里的圆形碟片，<strong>SSD是由一些电路和黑色的存储颗粒构成。SSD硬盘是基于NAND Flash存储技术的，属于非易失性存储设备</strong>，也即掉电了数据不会丢。</p>
<p>SSD中包含Die,Plane,Block以及Page几个概念，其中：每个Die有若干个Plane，每个Plane有若干个Block，每个Block有若干个Page。Page是磁盘进行读写的最小单位，一般为2KB/4KB/8KB/16KB等。</p>
<h4 id="SSD中的扇区"><a href="#SSD中的扇区" class="headerlink" title="SSD中的扇区"></a>SSD中的扇区</h4><p>与机械硬盘一样，在SSD中虽然每一个物理Page的大小为2K到16K不等，但是为了兼容性，也必须使用逻辑扇区。SSD控制器在逻辑上会把整个磁盘再重新划分成一个个的“扇区”，采用和新机械硬盘一样的LBA方式来进行编址（整个磁盘的扇区从0到某个最大值方式排列，并连成一条线）。当需要读取某几个”扇区”上数据的时候，SSD控制器通过访问这个LBA MapTable,再来找到要实际访问的物理Page。SSD最小的读写单位就是Page，没办法对扇区来进行读写的。</p>
<h4 id="SSD的闪存单元"><a href="#SSD的闪存单元" class="headerlink" title="SSD的闪存单元"></a>SSD的闪存单元</h4><p>SSD是由一个个的Page组成。而在每一个Page里，又包含了许许多多的闪存单元。现代的闪存单元有多种类型，目前主流的主要分为SLC、MLC和TLC。在SLC里，一个单元的电压只分成高低两种状态，所以只能表示1bit数据。到了MLC，硬是把一个单元里的电压按照高低分成了四种状态，所以可以表示2bit。到了TLC，直接一个单元应拆分成8个电压高低不同的状态，为了表示3bit。由于TLC在数据读写需要八种不同电压状态，而施加不同的电压状态、 就需要更精确，也就需要更长的时间才能得以实现。另外由于电压状态多，出错的可能性也会更大。</p>
<p>以上三种闪存单元对比：<strong>从性能和稳定性角度来看，SLC最好。从容量角度看，TLC最大</strong>。这就是为什么日常看到的工业级的SSD要比笔记本SSD要贵很多，其中一个很重要的原因就是工业级的盘往往采用的闪存单元是SLC或MLC，而我们家用的笔记本一般都是TCL，因为便宜。</p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p>假设某SSD的Page大小是4KB，一个文件是16KB。那么该文件是存在一个黑色的存储颗粒里,还是多个颗粒里？</p>
<p>假设只写在一个颗粒里，那么对该文件进行读取的时候，就只能用到一条Flash通道，这样速度就会比较慢。<strong>如果存在相邻的4个颗粒里，每个写入4KB。这样多个Flash通道的带宽会充分发挥出来，传输速度也更快</strong>。所以，实际中是分散在多个。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/10/os-2%E7%A1%AC%E7%9B%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/os-2%E7%A1%AC%E7%9B%98/" class="post-title-link" itemprop="url">操作系统硬盘基本介绍</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-10 19:29:16" itemprop="dateCreated datePublished" datetime="2020-04-10T19:29:16+08:00">2020-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-13 09:42:09" itemprop="dateModified" datetime="2021-05-13T09:42:09+08:00">2021-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h3><p>好像本科时候学的操作系统课程在讲解磁盘的时候非常简略。现在复习一下。</p>
<h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p>对于常见的机械磁盘，分磁盘面、磁道、柱面和扇区。</p>
<p><img src="https://api2.mubu.com/v3/document_image/97cfa71c-113a-43bd-abdb-d78b1bc43a28-11197877.jpg" alt="磁盘逻辑结构"></p>
<p><img src="https://api2.mubu.com/v3/document_image/3b042450-4931-4f66-a012-3c6132ca439c-11197877.jpg" alt="磁道和扇区"></p>
<p>有以下概念 ：</p>
<ul>
<li><p>磁盘面：磁盘是由一叠磁盘面叠加组合构成，<strong>每个磁盘面上都会有一个磁头</strong>负责读写。</p>
</li>
<li><p>磁道(Sector/Track)：每个盘面会围绕圆心划分出多个<strong>同心圆圈，每个圆圈叫做一个磁道</strong>。</p>
</li>
<li><p>柱面(Cylinders)：所有盘片上的同一位置的磁道组成的<strong>立体</strong>叫做一个柱面。</p>
</li>
<li><p>扇区(Sector)：以磁道为单位管理磁盘仍然太大，所以又把每个磁道划分出了多个扇区。而<strong>磁盘存储的最小组成单位就是扇区</strong>。 </p>
</li>
</ul>
<p>单柱面的存储容量 = 每个扇区的字节数 <em> 每柱面扇区数 </em> 磁盘面数 。</p>
<p>整体磁盘的容量 = 单柱面容量 * 总的柱面数字。</p>
<p>扇区与扇区之间其实不是紧挨着的，而是<strong>在每个扇区结尾还有一个存储纠错码的位置</strong>。假设<strong>某一个扇区读取时发生了错误，这样在扇区结尾的纠错码就能发现。磁头就会在磁盘下一圈转过来的时候再读取一遍。</strong></p>
<h4 id="linux下查询"><a href="#linux下查询" class="headerlink" title="linux下查询"></a>linux下查询</h4><p>查看操作系统挂载的硬盘数量及大小，借助<code>lsblk</code>命令</p>
<p>然后通过<code>fdisk</code>可以查看硬盘的详细信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> fdisk -l /dev/sda</span></span><br><span class="line"><span class="meta">#</span><span class="bash">可以查看到heads(磁头)数量，从而确定盘面数</span></span><br><span class="line"><span class="meta">#</span><span class="bash">cylinders 数量：每个盘面的磁道数</span></span><br><span class="line"><span class="meta">#</span><span class="bash">sectors/track 每个磁道上的扇区</span></span><br><span class="line"><span class="meta">#</span><span class="bash">每个逻辑扇区以及物理扇区的大小： 512bytes/4096bytes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">每个units的大小=盘面数*每个磁道上的扇区数*逻辑扇区大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash">磁盘总大小 = cylinders数 * units大小</span></span><br></pre></td></tr></table></figure>
<h4 id="每个磁道可以存储的数据都是一样的吗？"><a href="#每个磁道可以存储的数据都是一样的吗？" class="headerlink" title="每个磁道可以存储的数据都是一样的吗？"></a>每个磁道可以存储的数据都是一样的吗？</h4><p>在<strong>老式的磁盘里，确实是每个磁道数据都是一样的</strong>。这样越是内圈磁道的存储密度越大。目的就是为了访问方便，通过一个CHS地址：柱面地址（Cylinders）、磁头地址（Heads）、扇区地址（Sectors）直接定位到存储数据所在的扇区。但是这产生的问题就是<strong>外圈磁道的数据密度没有充分发挥出来，造成磁盘存储容量很难提升</strong>。</p>
<p>现代的磁盘人们改用等密度结构生产硬盘，也就是说，<strong>外圈磁道的扇区比内圈磁道多。这种磁盘里扇区是线性编号的，即从0到某个最大值方式排列，并连成一条线。这种寻址模式叫做LBA，全称为Logic Block Address（即扇区的逻辑块地址）。磁盘内部是自己会通过磁盘控制器来完成CHS到LBA的转换，进而定位到具体的物理扇区</strong></p>
<h4 id="物理扇区大小"><a href="#物理扇区大小" class="headerlink" title="物理扇区大小"></a>物理扇区大小</h4><p>现代科技进步了，磁盘底层的最小组成单位并不是扇区512字节，physical Sector size 4KB。但这时存在一个问题是扇区大小为512字节的假设已经贯穿于整个软件链，比如BIOS，启动加载器，操作系统内核，文件系统代码，以及磁盘工具，等等。直接切换到4096 byte<strong>兼容性问题太大</strong>了，所以每个新的磁盘控制器将4096字节的物理扇区对应成了8个512字节的逻辑扇区，兼容各种老软件。</p>
<p>除了<code>fdisk -l</code>命令外,如下方式也可以查看物理/逻辑扇区大小。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">cat /sys/block/sda/queue/physical_block_size</span></span><br><span class="line"><span class="meta">#</span><span class="bash">cat /sys/block/sda/queue/logical_block_size</span></span><br></pre></td></tr></table></figure>
<h4 id="磁头的数量"><a href="#磁头的数量" class="headerlink" title="磁头的数量"></a>磁头的数量</h4><p>磁盘不可能真的装很多磁头，通过<code>fdisk -l</code>看到的磁头数量和扇区以及磁道一样，是被虚拟出来的。</p>
<h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><p>分区是操作系统对磁盘进行管理的第一步，这也是任何一个计算机使用者都非常熟悉的概念。例如Windows下的C、D、E、F盘。那么操作系统的设计者是如何把整块磁盘分成C、D等分区的？</p>
<p>为了方便讨论，这里假设要分的硬盘是有50个盘面，3000个柱面。给出两种方案</p>
<ul>
<li>方案一：50个盘面，C盘是0-10盘面， D盘是10-20个盘面,……</li>
<li>方案二：3263个柱面，C盘0-1000个柱面，D盘1001-2001个柱面,……</li>
</ul>
<p>接下来讨论下那种方案更优秀，这得从<strong>磁盘的读写延时</strong>角度说起。读写原理说起来也简单，就是<strong>磁头要找到指定的磁道，指定的扇区，进而把数据读取出来或者写入进去的过程</strong>。这个过程分成如下三步：</p>
<ul>
<li>第一步，首先是磁头径向移动来寻找数据所在的磁道。这部分时间叫<strong>寻道时间</strong>。寻道时间，现代磁盘大概在3-15ms，其中寻道时间大小主要受磁头当前所在位置和目标磁道所在位置相对距离的影响</li>
<li>第二步，找到目标磁道后通过盘面旋转，将目标扇区移动到磁头的正下方，这部分时间叫<strong>旋转延迟</strong>。现在主流服务器上经常使用的是1W转/分钟的磁盘，每旋转一周所需的时间为60*1000/10000=6ms，故其旋转延迟为（0-6ms）</li>
<li>第三步，向目标扇区读取或者写入数据，这部分时间叫<strong>存取时间</strong>。这个是电磁操作，所以一般耗时较短，为零点几ms。</li>
</ul>
<p>到此为止，<strong>单次磁盘IO时间 = 寻道时间 + 旋转延迟 + 存取时间</strong></p>
<p>分区上采用哪一种方案，最主要看的是那种方式性能更快。在磁盘分区的使用中，存在一个基本事实，那就是<strong>同一分区下的数据经常会一起读取。两种方案的对于旋转延迟、和存取时间上表现的性能是一样的，主要区别是在寻道时间的表现上</strong>：</p>
<p>假如采用第一种，那么这样磁头就需要在3000多个磁道间不停地跳来跳去，这样磁盘的寻道时间就降不下来。而对于方案二，假如对于磁盘C，只需要在磁头在1-1000个磁道间移动就可以了，大大降低了寻道时间。所以<strong>所有的操作系统采用的都是方案二</strong>，没有用方案一的。</p>
<p>分区的过程就是<strong>输入起始柱面号和截至柱面号的过程</strong>。不过在实际中，分区并不能从0号柱面开始的，因为磁<strong>盘的第一个磁道对应的柱面会被用来安装引导加载程序以及磁盘分区表。</strong>所以，操作系统通过按磁道对应的柱面划分分区，来降低磁盘IO所花费的的寻道时间 ，最终提高磁盘的读写性能。</p>
<h3 id="机械硬盘的缺点及解决办法"><a href="#机械硬盘的缺点及解决办法" class="headerlink" title="机械硬盘的缺点及解决办法"></a>机械硬盘的缺点及解决办法</h3><h4 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h4><p>机械硬盘更多是用机械技术做出来的产品。当把带有机械技术基因的磁盘搭到计算机，尤其是应用到服务器领域的时候，暴露出了机械技术的两个严重问题：</p>
<ul>
<li><p>第一，速度慢。如果把内存和CPU的速度比作汽车和飞机的话，机械硬盘毫秒级别的延迟几乎就是牛车级别的。 </p>
</li>
<li><p>第二，容易坏。经常听说谁谁的磁盘坏了，很少有听说过谁的内存条，CPU坏了。</p>
</li>
</ul>
<p>要想保证服务器运转的稳定和高速，就必须解决硬盘的这两个缺陷。</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="多硬盘连接"><a href="#多硬盘连接" class="headerlink" title="多硬盘连接"></a>多硬盘连接</h5><p>单块硬盘不行，尝试同时使用多块硬盘。但假如给了N块硬盘，如何设计一个使用的方案？</p>
<ul>
<li>RAID 0：把<strong>一个文件分成N片，每一片都散列在不同的硬盘上</strong>。这样当文件进行读取的时候，就可以N块硬盘一起来工作，从而达到读取速度提高到N倍的效果。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/204662d6-e7e5-41f5-8d33-41927478da19-11197877.jpg" alt="RAID0"></p>
<p>缺点：没有解决容易坏的问题，<strong>任何一块硬盘坏了都会导致存储系统故障</strong>。</p>
<ul>
<li>RAID 1:仍然把文件分片，但是所有的分片都存在一块硬盘上，<strong>其它的硬盘只存拷贝。</strong>这既提高了硬盘的访问速度，也解决了坏的问题。任意一块硬盘坏了，存储系统都可以正常使用，只不过速度会打一点折扣。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/88ea6682-01e8-4fbe-8f04-b8eea8cf3aaa-11197877.jpg" alt="RAID1"></p>
<p>缺点：<strong>实现成本高。</strong></p>
<ul>
<li>RAID 5：样要对文件进行分片，但是不对存储的数据进行备份，而是会再单独存一个校验数据片。假如文件分为A1 A2 A3，然后需要再存一个<strong>校验片</strong>到别的磁盘上。这样<strong>不管A1，A2还是A3那一片丢失了，都可以根据另外两片和校验片合成出来。既保证了数据的安全性，又只用了一块磁盘做冗余存储</strong>。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/7e22af98-48ad-4f07-960b-f1db61ec5e21-11197877.jpg" alt="RAID5"></p>
<p>假如有8块256GB的硬盘，那么RAID5方案下的磁盘阵列从用户角度来看可用的存储空间是7*256GB，只“浪费”了一块盘的空间，所以目前RAID5应用比较广泛。</p>
<h4 id="RAID卡缓存"><a href="#RAID卡缓存" class="headerlink" title="RAID卡缓存"></a>RAID卡缓存</h4><p>硬盘延迟是毫秒级别的，即使是多快硬盘并行，也只能提升数倍而已，不能够达到量级的提升。<strong>和CPU内存的纳秒级别工作频率比起来，还是太慢</strong>。在计算机界，没有<strong>缓存</strong>解决不了的速度问题，如果有，那就再加一层。现代磁盘本身也基本都带了缓存，另外在一些比较新的raid卡里，硬件开发者们又搞出来了一层“内存”，并且还自己附带一块电池，这就是RAID卡缓存。几款主流RAID卡的配置：</p>
<ul>
<li><p>PERC S120 入门软件阵列卡，主板集成无缓存 支持RAID 0 1</p>
</li>
<li><p>PERC H330 入门硬件RAID卡，无板载缓存, 支持RAID 0 1 5 10 50</p>
</li>
<li>PERC H730 主流硬件RAID卡带有1G缓存和电池 支持RAID 0 1 5 6 10 50 60</li>
<li>PERC H730P 高性能硬件RAID卡带有2G缓存和电池 支持RAID 0 1 5 6 10 50 60</li>
<li>PERC H830 同H730P,没有内置接口，使用外置接口连接附加存储磁盘柜用</li>
</ul>
<p>拿目前服务器端出镜率比较高的H730和H730P来看，他们分别带了1G和2G的缓存卡，并且自带电池。<strong>电池的作用就是当发现主机意外断电的时候，能够快速把缓存中的数据写回到磁盘中去。对于写入，一般操作系统写到这个RAID卡里就完事了，所以速度快。对于读取也是，只要缓存里有，就不会透传到磁盘的机械轴上。</strong></p>
<p>文件相关函数里设置DIRECT I/O仅仅只能绕开操作系统本身的Page Cache,而<strong>RAID卡里的缓存，对于Linux来说，可以说算是一个黑盒。换句话说，就是操作系统并不清楚RAID卡是从缓存里吐的数据，还是真正从硬盘里读的。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/05/os-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/05/os-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">操作系统内存管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-05 19:29:16" itemprop="dateCreated datePublished" datetime="2020-04-05T19:29:16+08:00">2020-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-31 19:48:24" itemprop="dateModified" datetime="2021-03-31T19:48:24+08:00">2021-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="使用虚拟地址的原因"><a href="#使用虚拟地址的原因" class="headerlink" title="使用虚拟地址的原因"></a>使用虚拟地址的原因</h4><p><strong>单片机的 CPU 是直接操作内存的物理地址</strong>。在这种情况下，<strong>要想在内存中同时运行两个程序是不可能的</strong>。如果<strong>第一个程序在 1000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容</strong>，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。</p>
<p>无法同时运行两个程序的原因在于：<strong>两个程序都引用了绝对物理地址</strong>。</p>
<p>可以把进程所使用的地址隔」开来，即让操作系统为每个进程分配独立的一套<strong>虚拟地址</strong>，每个进程再自己的地址操作即可，互不干涉。但是有个前提<strong>每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。</strong></p>
<h4 id="虚拟地址和物理地址的映射"><a href="#虚拟地址和物理地址的映射" class="headerlink" title="虚拟地址和物理地址的映射"></a>虚拟地址和物理地址的映射</h4><p>引出了两种地址的概念：</p>
<ul>
<li>程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</li>
<li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</li>
</ul>
<p>操作系统引入了虚拟内存，<strong>进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存</strong></p>
<h3 id="内存分段与内存分页"><a href="#内存分段与内存分页" class="headerlink" title="内存分段与内存分页"></a>内存分段与内存分页</h3><p>操作系统管理虚拟地址和物理地址时主要使用内存分段和内存分页。</p>
<h4 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h4><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。</strong></p>
<p>分段机制下的虚拟地址由两部分组成，<strong>段选择因子（重要部分：段号 ） </strong>和<strong>段内偏移量</strong>。</p>
<p><img src="https://api2.mubu.com/v3/document_image/7ac53b48-2633-4b21-91c7-52a885bf759a-11197877.jpg" alt="内存分段"></p>
<ul>
<li><strong>段选择子</strong>保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作<strong>段表的索引</strong>。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li>
<li>虚拟地址中的<strong>段内偏移量</strong>应该位于 <strong>0 和段界限之间</strong>，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li>
</ul>
<p>分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：</p>
<p><img src="https://api2.mubu.com/v3/document_image/78c1831a-ad8b-42e2-b227-5eded146e5b0-11197877.jpg" alt="内存分段-虚拟地址和物理地址"></p>
<p>如果要访问段 3 中偏移量 500 的虚拟地址，可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。</p>
<p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：</p>
<ul>
<li>第一个就是<strong>内存碎片</strong>的问题。</li>
<li>第二个就是<strong>内存交换的效率低</strong>的问题。</li>
</ul>
<h5 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h5><p>看一个具体的例子。假设有 1G 的物理内存，用户执行了多个程序，其中：</p>
<ul>
<li>游戏占用了 512MB 内存</li>
<li>浏览器占用了 128MB 内存</li>
<li>音乐占用了 256 MB 内存。</li>
</ul>
<p>这个时候，如果关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。</p>
<p>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p>
<p><img src="https://api2.mubu.com/v3/document_image/1f03017b-bace-432c-99a7-e4c3988b5021-11197877.jpg" alt="内存碎片问题"></p>
<p>内存碎片的问题共有两处地方：</p>
<ul>
<li>外部内存碎片，也就是<strong>产生了多个不连续的小物理内存，导致新的程序无法被装载；</strong></li>
<li>内部内存碎片，程序<strong>所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用</strong>，这也会导致内存的浪费；</li>
</ul>
<p>解决外部内存碎片的问题就是<strong>内存交换</strong>。</p>
<p>可以把音乐程序（暂不使用）占用的那 256MB <strong>内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。</strong>这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p>
<p>这个内存交换空间，<strong>在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</strong></p>
<h5 id="内存交换效率低问题"><a href="#内存交换效率低问题" class="headerlink" title="内存交换效率低问题"></a>内存交换效率低问题</h5><p>对于<strong>多进程的系统</strong>来说，用分段的方式，内存碎片是很容易产生的，<strong>产生了内存碎片，那不得不重新 <code>Swap</code> 内存区域，这个过程会产生性能瓶颈。</strong>因为<strong>硬盘的访问速度要比内存慢太多了，每一次内存交换，都需要把一大段连续的内存数据写到硬盘上。</strong>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p>
<h4 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h4><p>分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。</p>
<p>要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，<strong>当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题</strong>了。这个办法，也就是<strong>内存分页</strong>（<em>Paging</em>）。</p>
<p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样<strong>一个连续并且尺寸固定的内存空间，我们叫页（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</strong></p>
<p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，如下图：</p>
<p><img src="https://api2.mubu.com/v3/document_image/f9578597-00c6-4942-b2c9-f277646c4b97-11197877.jpg" alt="内存映射"></p>
<p>页表实际上存储在 CPU 的<strong>内存管理单元</strong> （<em>MMU</em>） 中，于是 <strong>CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。</strong>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，<strong>进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</strong></p>
<h5 id="分页解决分段的内存碎片及内存交换效率低问题"><a href="#分页解决分段的内存碎片及内存交换效率低问题" class="headerlink" title="分页解决分段的内存碎片及内存交换效率低问题"></a>分页解决分段的内存碎片及内存交换效率低问题</h5><p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而<strong>采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</strong></p>
<p><strong>如果内存空间不够，操作系统会把其他正在运行的进程中的最近没被使用的内存页面给释放掉，也就是暂时写在硬盘上</strong>，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/8d9acd7d-a322-4467-adc9-2f642be20a9f-11197877.jpg" alt="分页-换入换出"></p>
<p>分页的方式使得<strong>在加载程序的时候，不再需要一次性都把程序加载到物理内存中</strong>。完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p>
<h4 id="分页机制下，虚拟地址和物理地址的映射"><a href="#分页机制下，虚拟地址和物理地址的映射" class="headerlink" title="分页机制下，虚拟地址和物理地址的映射"></a>分页机制下，虚拟地址和物理地址的映射</h4><p>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。<strong>页号作为页表的索引</strong>，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址，见下图：</p>
<p><img src="https://api2.mubu.com/v3/document_image/87e6c72d-6190-429a-af93-794684259841-11197877.jpg" alt="内存分页寻址"></p>
<p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p>
<ul>
<li><strong>把虚拟内存地址，切分成页号和偏移量</strong>；</li>
<li>根据<strong>页号，从页表里面，查询对应的物理页号</strong>；</li>
<li>直接<strong>拿物理页号，加上前面的偏移量，就得到了物理内存地址</strong>。</li>
</ul>
<h4 id="简单分页的缺陷"><a href="#简单分页的缺陷" class="headerlink" title="简单分页的缺陷"></a>简单分页的缺陷</h4><p>有空间上的缺陷。因为操作系统是可以同时运行非常多的进程的，那这就意味着<strong>页表会非常的庞大。在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个页表项需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有<code>4MB</code> 的内存来存储页表。</strong>这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。那么，<code>100</code> 个进程的话，就需要 <code>400MB</code> 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>对于单页表的实现方式，在 32 位和页大小 <code>4KB</code>的环境下，一个进程的页表需要装下 100 多万个页表项，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。把这个 100 多万个页表项的单级页表再分页，将<strong>页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含<code>1024</code> 个页表项</strong>，形成<strong>二级分页</strong>。如下图所示：</p>
<p><img src="https://api2.mubu.com/v3/document_image/b6e8d43f-0635-487e-a49e-bfae31655cff-11197877.jpg" alt="多级页表"></p>
<p>分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？如果 4GB 的虚拟地址全部都映射到了物理内上的，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。程序中会用到<strong>局部性原理</strong>。</p>
<p>每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为<strong>会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</strong></p>
<p>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但<strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表</strong>。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= <code>0.804MB</code><br>，这对比单级页表的 <code>4MB</code> 是一个巨大的节约。</p>
<p>那么为什么不分级的页表就做不到这样节约内存呢？从页表的性质来看，<strong>保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址</strong>。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以<strong>页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项</strong>（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。</p>
<p>把二级分页再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对局部性原理的充分应用。对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：</p>
<ul>
<li>全局页目录项 PGD（<em>Page Global Directory</em>）</li>
<li>上层页目录项 PUD（<em>Page Upper Directory</em>）</li>
<li>中间页目录项 PMD（<em>Page Middle Directory</em>）</li>
<li>页表项 PTE（<em>Page Table Entry</em>）。</li>
</ul>
<h4 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h4><p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就<strong>降低了这俩地址转换的速度，也就是带来了时间上的开销</strong>。<strong>程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。</strong>可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的<strong>页表项的 Cache，这个 Cache 就是 TLB（<em>Translation Lookaside Buffer</em>） ，通常称为页表缓存、转址旁路缓存、快表等。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/5cee2e43-bed8-4f41-90de-20dd24ea6a58-11197877.jpg" alt="TLB"></p>
<p>在 CPU 芯片里面，封装了内存管理单元（<em>Memory Management Unit</em>）芯片，它用来完成地址转换和 TLB 的访问与交互。有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。</p>
<h4 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h4><p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为<strong>段页式内存管理</strong>。</p>
<p>段页式内存管理实现的方式：</p>
<ul>
<li>先将程序划<strong>分为多个有逻辑意义的段</strong>，也就是前面提到的分段机制；</li>
<li>接着再<strong>把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</strong></li>
</ul>
<p>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。</p>
<p>用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：</p>
<p><img src="https://api2.mubu.com/v3/document_image/9fa91ffc-d687-4daf-9dc5-6fc82603de70-11197877.jpg" alt="段页式地址变换"></p>
<p>段页式地址变换中要得到物理地址须经过三次内存访问：</p>
<ul>
<li><strong>第一次访问段表，得到页表起始地址；</strong></li>
<li><strong>第二次访问页表，得到物理页号；</strong></li>
<li><strong>第三次将物理页号与页内位移组合，得到物理地址。</strong></li>
</ul>
<p>可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。</p>
<h3 id="linux内存管理"><a href="#linux内存管理" class="headerlink" title="linux内存管理"></a>linux内存管理</h3><p>早期 Intel 的处理器从 80286 开始使用的是段式内存管理。但是很快发现，光有段式内存管理而没有页式内存管理是不够的，这会使它的 X86 系列会失去市场的竞争力。因此，在不久以后的 80386 中就实现了对页式内存管理。也就是说，80386 除了完成并完善从 80286 开始的段式内存管理的同时还实现了页式内存管理。</p>
<p>但是这个 80386 的页式内存管理设计时，没有绕开段式内存管理，而是建立在段式内存管理的基础上，这就意味着，<strong>页式内存管理的作用是在由段式内存管理所映射而成的的地址上再加上一层地址映射。</strong></p>
<p>由于此时段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为“线性地址”（也称虚拟地址）。于是，段式内存管理先将逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址。</p>
<p>逻辑地址和线性地址：</p>
<ul>
<li><strong>程序所使用的地址，通常是没被段式内存管理映射的地址，称为逻辑地址</strong>；</li>
<li>通过段式内存管理映射的地址，称为线性地址，也叫<strong>虚拟地址</strong>；</li>
</ul>
<p>逻辑地址是段式内存管理转换前的地址，线性地址则是页式内存管理转换前的地址。</p>
<p><strong>Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制</strong>。</p>
<p>这主要是上面 Intel 处理器发展历史导致的，因为 <strong>Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射。既然 CPU 的硬件结构是这样，Linux 内核也只好服从 Intel 的选择。</strong></p>
<p>但是事实上，Linux 内核所采取的办法是使段式映射的过程实际上不起什么作用。也就是说，“上有政策，下有对策”，若惹不起就躲着走。</p>
<p><strong>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。</strong></p>
<p>Linux 的虚拟地址空间是如何分布的？</p>
<p>在 Linux 操作系统中，虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统：</p>
<p><img src="https://api2.mubu.com/v3/document_image/9fa7b8fb-653c-4d3c-b37f-f9f933815fd8-11197877.jpg" alt="用户空间和内存空间"></p>
<p>通过这里可以看出：</p>
<ul>
<li><code>32</code> 位系统的内核空间占用 <code>1G</code>，位于最高处，剩下的 <code>3G</code> 是用户空间；</li>
<li><code>64</code> 位系统的内核空间和用户空间都是 <code>128T</code>，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。</li>
</ul>
<p>再来说说，内核空间与用户空间的区别：</p>
<ul>
<li>进程在用户态时，只能访问用户空间内存；</li>
<li>只有进入内核态后，才可以访问内核空间的内存；</li>
</ul>
<p>虽然每个进程都各自有独立的虚拟内存，但是<strong>每个虚拟内存中的内核地址，其实关联的都是相同的物理内存</strong>。这样，<strong>进程切换到内核态后，就可以很方便地访问内核空间内存。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/939f7f05-a117-4078-ac4c-4763f8e7fd27-11197877.jpg" alt="进程内核空间一致"></p>
<p>每个进程的内核空间都是一致的，这样其实方便了进程间的通信以及父子进程的创建。具体可参考<a href="https://dongshifu.github.io/2020/03/27/linux-%E7%B3%BB%E7%BB%9F-07%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" target="_blank" rel="noopener">linux系统-进程间通信</a>和<a href="https://dongshifu.github.io/2020/03/26/linux-%E7%B3%BB%E7%BB%9F-06%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/" target="_blank" rel="noopener">linux系统-进程管理</a>。</p>
<h3 id="调用malloc进行内存申请的过程"><a href="#调用malloc进行内存申请的过程" class="headerlink" title="调用malloc进行内存申请的过程"></a>调用malloc进行内存申请的过程</h3><ol>
<li>malloc开始<strong>搜索空闲内存块</strong>，如果能找到一块大小合适的就分配出去</li>
<li>如果malloc找不到一块合适的空闲内存，<strong>那么调用brk等系统调用扩大堆区从而获得更多的空闲内存</strong></li>
<li>malloc<strong>调用brk后开始转入内核态，此时操作系统中的虚拟内存系统开始工作，扩大进程的堆区，注意额外扩大的这一部分内存仅仅是虚拟内存，操作系统并没有为此分配真正的物理内存</strong></li>
<li>brk执行结束后返回到malloc，<strong>从内核态切换到用户态</strong>，malloc找到一块合适的空闲内存后返回</li>
<li>程序员拿到新申请的内存，程序继续</li>
<li>当<strong>有代码读写新申请的内存时系统内部出现缺页中断，此时再次由用户态切换到内核态，操作系统此时真正的分配物理内存，之后再次由内核态切换回用户态，程序继续。</strong></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/03/linux-%E7%B3%BB%E7%BB%9F-11%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/03/linux-%E7%B3%BB%E7%BB%9F-11%E9%94%81/" class="post-title-link" itemprop="url">linux系统-锁</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-03 19:13:29" itemprop="dateCreated datePublished" datetime="2020-04-03T19:13:29+08:00">2020-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-31 19:57:17" itemprop="dateModified" datetime="2021-03-31T19:57:17+08:00">2021-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>linux中提供了互斥锁(<code>mutex</code>,互斥量)。<strong>每个线程在对资源进行操作前都会尝试先加锁，成功加锁才能操作，操作结束解锁。资源还是共享的，线程间也还存在竞争。但通过”锁”可以将资源的访问变成互斥操作，而后与时间有关的错误也将不会再产生。</strong></p>
<p>应该注意：<strong>同一时刻，只能有一个线程持有该锁</strong>。</p>
<p>当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B会阻塞。C线程不加锁而直接访问该全局变量，此时依然能够访问，但会出现数据混乱。</p>
<p>互斥锁实质上是操作系统提供的一把<strong>建议锁（又称”协同锁”）</strong>，当程序中有多线程访问共享资源的时候需要使用该机制。但是<strong>没有强制的限定</strong>。</p>
<h4 id="借助互斥锁管理共享数据实现同步"><a href="#借助互斥锁管理共享数据实现同步" class="headerlink" title="借助互斥锁管理共享数据实现同步"></a>借助互斥锁管理共享数据实现同步</h4><p><code>C</code>关键词<strong><code>restrict</code>用来限定指针变量，被该关键字限定的指针变量所指向的内存操作必须由本指针完成</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> lock; <span class="comment">//创建锁</span></span><br><span class="line">pthread_mutex_init; <span class="comment">//初始化</span></span><br><span class="line">pthread_mutex_lock; <span class="comment">//加锁</span></span><br><span class="line">访问共享数据(<span class="built_in">stdout</span>)</span><br><span class="line">pthread_mutex_unlock(); <span class="comment">//解锁</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/01/linux-%E7%B3%BB%E7%BB%9F-10%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/linux-%E7%B3%BB%E7%BB%9F-10%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">linux系统-线程及其管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 15:12:58" itemprop="dateCreated datePublished" datetime="2020-04-01T15:12:58+08:00">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-26 19:16:28" itemprop="dateModified" datetime="2021-03-26T19:16:28+08:00">2021-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><ul>
<li><p>LWP： light weight process, 轻量级进程，<strong>本质仍是进程（在linux下)</strong></p>
</li>
<li><p>进程：<strong>独立地址空间，拥有PCB</strong></p>
</li>
<li><p>线程：<strong>也有PCB，但没有独立的地址空间（共享）</strong></p>
</li>
<li><p>区别：在于是否共享地址空间。进程独居，线程合租。</p>
</li>
</ul>
<p>Linux下：</p>
<ul>
<li>线程为最小<strong>执行单位（cpu获得效率）</strong></li>
<li>进程为最小<strong>资源分配单位</strong>，<strong>可看作只有一个线程的进程。</strong></li>
</ul>
<p>查看LWP号: <code>ps -Lf pid</code>查看指定线程的lwp号</p>
<h4 id="linux内核线程实现"><a href="#linux内核线程实现" class="headerlink" title="linux内核线程实现"></a>linux内核线程实现</h4><p>linux中进程和线程关系密切</p>
<ul>
<li><p>线程是轻量级进程（light weight process)，<strong>也有PCB,创建线程使用的底层函数和进程一样，都是<code>clone</code></strong></p>
</li>
<li><p><strong>从内核里看进程和线程是一样的，都有各自不同的PCB，但PCB中指向的内存资源的三级页表是相同的</strong></p>
</li>
<li><p>进程可以蜕变为线程</p>
</li>
<li><p><strong>线程可以看作寄存器和栈（主要体现在函数调用,每个线程的stack空间不一样）的集合</strong></p>
</li>
<li><p>在linux下，<strong>线程是最小执行单位，进程是最小资源分配单位</strong></p>
</li>
</ul>
<h4 id="三级页表"><a href="#三级页表" class="headerlink" title="三级页表"></a>三级页表</h4><p>PCB中持有<strong>当前进程的页目录表的指针, 页目录表中每一项指向一个个页表, 用页表检索物理内存页面</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/a7768bae-b28c-4fe2-98ec-941805f1f5cb-11197877.jpg" alt="三级页表"></p>
<p><img src="https://api2.mubu.com/v3/document_image/001da9ee-605d-4d7c-a0a7-100200b52c6e-11197877.jpg" alt="程序运行内存情况"></p>
<h4 id="线程之间共享的资源"><a href="#线程之间共享的资源" class="headerlink" title="线程之间共享的资源"></a>线程之间共享的资源</h4><ul>
<li><strong>文件描述符表</strong></li>
<li>每种<strong>信号的处理方式(线程和信号最好不要一起使用)</strong></li>
<li>当前<strong>工作目录</strong></li>
<li><strong>用户ID和组ID</strong></li>
<li><strong>内存地址空间(<code>.text/ .data/ .bss/ heap/共享库</code>)</strong></li>
</ul>
<h4 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h4><ul>
<li><strong>线程id</strong></li>
<li><strong>处理器现场和栈指针(内核栈)</strong></li>
<li><strong>独立的栈空间（用户空间栈）</strong></li>
<li>errno变量</li>
<li><strong>信号屏蔽字</strong></li>
<li>调度<strong>优先级</strong></li>
</ul>
<h4 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h4><p>优点： <strong>提高程序并发性，开销小，数据通信、共享数据方便</strong></p>
<p>缺点：库函数不稳定，调试编写困难、gdb不支持，对信号支持不好</p>
<p>linux下的实现方法使得进程和线程的差别不是很大。但<strong>可以通过在一个进程中开多个线程来达到抢占cpu的目的。</strong></p>
<h3 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h3><h4 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h4><p><strong>获取线程ID。其作用对应进程中getpid()函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>线程ID：<strong><code>pthread_t</code>类型，本质：在Linux下为无符号整数(<code>lu%</code>),其他系统中可能是结构体实现</strong></p>
<p>线程ID是进程内部的识别标志。(<strong>两个进程间的线程ID允许相同</strong>)</p>
<p>创建线程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread,<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr,<span class="keyword">void</span>* (*start_routine)(<span class="keyword">void</span>* ),<span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0, 失败返回errno;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p>不应使用全局变量<code>pthread_t tid</code>, 而应使用<code>pthread_self</code></p>
</li>
<li><p><strong>在子线程中通过<code>pthread_create</code>传出参数来获取线程ID</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread id is: %lu\n"</span>,pthread_self()); <span class="comment">//线程还没来得及输出进程就结束了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in main, thread id = %lu\n"</span>,pthread_self());</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>,thread_func,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthred_create error: %s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*父进程等待1秒,否则父进程一旦退出,地址空间被释放,子线程没机会执行*/</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="循环创建线程"><a href="#循环创建线程" class="headerlink" title="循环创建线程"></a>循环创建线程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int i = *(int *)arg; //注意传地址最后取出来的值</span></span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%dth thread id is: %lu\n"</span>,i,pthread_self()); <span class="comment">//线程还没来得及输出进程就结束了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret, i;</span><br><span class="line">    <span class="comment">// printf("in main, thread id = %lu\n",pthread_self());</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = pthread_create(&amp;tid, <span class="literal">NULL</span>,thread_func,(<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthred_create error: %s\n"</span>,strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//将当强进程退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意参数传递方式, <strong>先将int型的i强转成void*传入, 用到时再强转回int型</strong></p>
<h5 id="线程参数传递"><a href="#线程参数传递" class="headerlink" title="线程参数传递"></a>线程参数传递</h5><p>如果使<code>void*</code>过程中不用强转, 看似规规矩矩的传地址再解引用, 会出现问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这是一个出错的版本*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=*((<span class="keyword">int</span>*)arg);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I'm %dth thread,pid=%d,tid=%lu\n"</span>,i+<span class="number">1</span>,getpid(),pthread_self());</span><br><span class="line">	sleep(i);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">		ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="keyword">void</span>*)&amp;i);</span><br><span class="line">		<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">			perr_exit(<span class="string">"pthread_create error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sleep(i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/8c997c3d-e2c3-4946-b95c-ce9e924dd04e-11197877.jpg" alt="stack地址"></p>
<p>错误分析：<strong><code>main</code>中给<code>tfn</code>传入的是它的函数栈帧中局部变量<code>i</code>的地址, 这样<code>tfn</code>能随时访问到i的值, 考虑到线程之间是并发执行的, 每次中<code>main</code>中固定的地址中拿数据, 相当于各个线程共享了这块地址, 由于访问时刻随机, 所以访问到的各个值也是很随机的</strong></p>
<p><strong>使用强转可以保证变量<code>i</code>的实时性(C语言值传递的特性)</strong></p>
<h5 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h5><p><strong>线程默认共享数据段, 代码段等地址空间, 常用的是全局变量, 而进程不共享全局变量, 只能借助<code>mmap</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    var = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"befor pthread_create, var = %d\n"</span>,var);</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    tid = pthread_create(&amp;tid, <span class="literal">NULL</span>,fun, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after pthread_create, var = %d\n"</span>,var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h4><p>将单个线程退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* rerval)</span></span>;<span class="comment">//参数：retval表示线程退出状态，通常传NULL</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>exit()</code>函数用来<strong>退出当前进程, 不可以用在线程中</strong>, 否则全部退出（<strong>exit退出会使进程退出</strong>）</p>
</li>
<li><p><code>pthread_exit()</code>函数才是用来<strong>将单个的线程退出</strong></p>
</li>
<li><p><code>pthread_exit</code>或者<code>return</code>返回的指针所指向的内存单元必须是<strong>全局的或者<code>malloc</code>分配的</strong>, <strong>不能在线程函数的栈上分配, 因为其他线程得到这个返回指针时线程函数已经退出了</strong></p>
</li>
</ul>
<p><code>return</code>和<code>exit</code>的区别：</p>
<ul>
<li><strong>return是返回到调用者处，exit为退出进程</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread id is: %lu\n"</span>,pthread_self()); <span class="comment">//线程还没来得及输出进程就结束了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in main, thread id = %lu\n"</span>,pthread_self());</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>,thread_func,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthred_create error: %s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sleep(1);</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); <span class="comment">//主线程退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h4><p><strong>阻塞等待线程退出，获取进程退出状态</strong>。其作用对应进程中的<code>waitpid()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread,<span class="keyword">void</span>** retval)</span></span>;<span class="comment">//成功返回0，失败返回错误号.线程的退出状态是void*, 回收时传的就是void**</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回收子线程并获得返回值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">64</span>];</span><br><span class="line">&#125;<span class="keyword">exit_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thred_func</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">/*在堆区创建一个结构体*/</span></span><br><span class="line">    <span class="keyword">exit_t</span>* retvar = (<span class="keyword">exit_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">exit_t</span>));</span><br><span class="line">    retvar-&gt;ch = <span class="string">'m'</span>;</span><br><span class="line">    retvar-&gt;var = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(retvar-&gt;str,<span class="string">"my thread\n"</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)retvar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">exit_t</span> *val;</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thred_func,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/*pthread_join回收子线程*/</span></span><br><span class="line">    pthread_join(tid,(<span class="keyword">void</span>**)&amp;val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ch = %c, var = %d, str = %s\n"</span>,val-&gt;ch,val-&gt;var,val-&gt;str);</span><br><span class="line">    <span class="built_in">free</span>(val);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*在堆区创建一个结构体*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> <span class="title">tval</span>;</span></span><br><span class="line">	<span class="comment">/*给结构体赋值*/</span></span><br><span class="line">	tval.var=<span class="number">100</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(tval.str,<span class="string">"love you"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span>*)&amp;tval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不能将子线程的回调函数的局部变量返回, 由于该函数执行完毕返回后, 其栈帧消失, 栈上的局部变量也就消失, 返回的是无意义的</strong>。<strong>可以在main函数中创建局部变量</strong></p>
<h4 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h4><p>实现线程分离, <strong>线程终止会自动清理pcb, 无需回收</strong>，子线程分离后不能再调用<code>pthread_join</code>回收了。（<strong><code>detach</code>相当于自动回收, <code>join</code>相当于手动回收</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>; <span class="comment">//成功返回0，失败返回错误号</span></span><br></pre></td></tr></table></figure>
<p>线程分离状态：指定该状态，<strong>线程主动与主控线程断开关系</strong>。<strong>线程结束后，其退出状态不由其他线程获取，而是直接自己主动释放。网络、多线程服务器常用。</strong></p>
<p>进程若有该机制，将不会产生僵尸进程。<strong>僵尸进程的产生主要是由于进程死后，大部分资源被释放，一点残留资源仍然在系统中，导致内核以为该进程仍然存在。</strong></p>
<p>也可以使用<code>pthread_create</code> 函数的第2个参数来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n =<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread count %d\n"</span>,n);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr; <span class="comment">//通过线程属性来设置游离态</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    pthread_create(&amp;tid,&amp;attr, tfn,<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// pthread_detach(tid); //让线程分离，自动退出，无系统残留资源</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        err = pthread_join(tid, &amp;tret); <span class="comment">//阻塞等待子线程回收</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"--------------err = %d\n"</span>,err);</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"thread %s\n"</span>, strerror(err));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"thread exit code %d\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，线程终止后，其终止状态一直保留到其他线程调用<code>pthread_join</code>获取其状态为止。但是<strong>线程也可以被设置为<code>detach</code>状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。</strong></p>
<h4 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h4><p><strong>杀死（取消）线程， 作用对应于进程中的<code>kill()</code>函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;<span class="comment">//成功返回0,失败返回错误号</span></span><br></pre></td></tr></table></figure>
<p>注意：线程的取消并<strong>不是实时的，而是有一定的延时，需要等待线程到达某一个取消点(检查点，进入内核的契机），所以如果一个线程一直使用系统调用(一直不进内核), cancel就无法杀死该线程</strong></p>
<p>取消点：<strong>线程检查是否被取消，并按请求进行动作的一个位置：通常是一些系统调用</strong><code>create, open , pause, close, read, write...</code>执行命令<code>man 7 pthreads</code>可以查看具备这些取消点的系统调用列表。</p>
<p>可以粗略认为一个系统调用（进入内核）为一个取消点。<strong>如果线程中没有取消点，可以通过调用<code>pthread_testcancel</code>函数自行设置一个取消点。</strong></p>
<p>被取消的线程，退出值定义在linux的<code>pthread</code>库中。常数<code>PTHREAD_CANCELED</code>的值是-1,可在头文件pthread.h中找到定义：<code>#define PTHREAD_CANCELED((void*)-1)</code>。因此<strong>当对一个已经被取消的线程使用<code>pthread_join</code>回收时，得到的返回值为-1。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn1</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 1 returing\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn2</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 2 exiting\n"</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">222</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn3</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printf("thread 3: I'm going to die in 3 seconds...\n"); //取消点</span></span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">666</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span>* tret = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid, &amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 1 exit code = %d\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid, &amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 2 exit code = %d\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn3, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 3 exit code = %d\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">thread 1 returing</span></span><br><span class="line"><span class="comment">thread 1 exit code = 111</span></span><br><span class="line"><span class="comment">thread 2 exiting</span></span><br><span class="line"><span class="comment">thread 2 exit code = 222</span></span><br><span class="line"><span class="comment">thread 3: I'm going to die in 3 seconds...</span></span><br><span class="line"><span class="comment">thread 3 exit code = 666*/</span></span><br></pre></td></tr></table></figure>
<h4 id="pthread-equal"><a href="#pthread-equal" class="headerlink" title="pthread_equal"></a>pthread_equal</h4><p>比较<strong>两个线程ID是否相等</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_eaqul</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>linux下<strong>线程的属性可以根据实际项目需求来设置</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> stuct </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>     etachstate; <span class="comment">//线程的分离状态</span></span><br><span class="line">    <span class="keyword">int</span>     schedpolicy; <span class="comment">//线程的调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span>  <span class="title">schedparam</span>;</span> <span class="comment">//线程的调度参数</span></span><br><span class="line">    <span class="keyword">int</span>     inheritsched; <span class="comment">//线程的继承性</span></span><br><span class="line">    <span class="keyword">int</span>     scope; <span class="comment">//线程的作用域</span></span><br><span class="line">    <span class="keyword">size_t</span>  guardsize; <span class="comment">//线程末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span>     stackaddr_set;<span class="comment">//线程的栈设置</span></span><br><span class="line">    <span class="keyword">void</span>*   stackaddr; <span class="comment">//线程栈的位置</span></span><br><span class="line">    <span class="keyword">size_t</span>  stacksize; <span class="comment">//线程栈的大小</span></span><br><span class="line">&#125;<span class="keyword">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure>
<p><strong>默认情况为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</strong></p>
<p>线程<strong>栈大小查看命令</strong>：<code>ulimit -a</code></p>
<h4 id="线程属性初始化"><a href="#线程属性初始化" class="headerlink" title="线程属性初始化"></a>线程属性初始化</h4><p><strong>应先初始化线程属性，再pthread_create创建线程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>; <span class="comment">//成功返回0,失败返回错误号</span></span><br></pre></td></tr></table></figure>
<p><strong>销毁线程属性所占用的资源</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;<span class="comment">//成功返回0,失败返回错误号</span></span><br></pre></td></tr></table></figure>
<h4 id="线程的分离状态"><a href="#线程的分离状态" class="headerlink" title="线程的分离状态"></a>线程的分离状态</h4><p>调用<code>pthread_detach()</code>函数或者通过属性设置可以使线程分离。<strong>如果一个线程为分离线程，而这个线程又运行非常之快，它很可能在<code>pthread_create</code>函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用<code>pthread_create</code>的线程就得到了错误的线程号。要避免这种情况的发生可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用<code>pthread_cond_timewait</code>函数，让这个线程等待一会，留出足够的时间让函数pthread_create返回</strong>。设置一段等待时间，是在多线程中常用的方法。但注意<strong>不要使用<code>wait()</code>之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设置线程属性:分离或非分离*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span>* attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="comment">/*获取线程属性*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr, <span class="keyword">int</span>* detachstate)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">detachstate取值:</span></span><br><span class="line"><span class="comment">PTHREAD_CREATE_DETACHED</span></span><br><span class="line"><span class="comment">PTHREAD_CREATE_JOINABLE	*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">	<span class="comment">/*初始化属性结构体*/</span></span><br><span class="line">	ret=pthread_attr_init(&amp;attr);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"pthread_attr_init error"</span>,ret);</span><br><span class="line">	<span class="comment">/*给属性结构体添加分离属性*/</span></span><br><span class="line">	pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"pthread_attr_setdetachstate error"</span>,ret);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main:pid=%d,tid=%lu\n"</span>,getpid(),pthread_self());</span><br><span class="line">	<span class="comment">/*创建子线程*/</span></span><br><span class="line">	ret=pthread_create(&amp;tid,&amp;attr,tfn,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"pthread_create error"</span>,ret);</span><br><span class="line">	<span class="comment">/*join试一下,由于线程已经分离了,会出错*/</span></span><br><span class="line">	ret=pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"pthread_join error"</span>,ret);</span><br><span class="line">	<span class="comment">/*销毁线程属性结构体*/</span></span><br><span class="line">	ret=pthread_attr_destroy(&amp;attr);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"pthread_attr_destory error"</span>,ret);</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程的栈地址"><a href="#线程的栈地址" class="headerlink" title="线程的栈地址"></a>线程的栈地址</h4><p><strong>当进程栈空间地址不够用时，指定新建线程使用由<code>malloc</code>分配的空间作为自己的栈空间（各个子线程会均分进程的栈空间, 但是线程的栈空间大小是可以调整的）</strong>。通过<code>pthread_attr_setstack</code>和<code>pthread_attr_getstack</code>两个函数分别设置和获取进程的栈地址。</p>
<h4 id="线程的栈大小"><a href="#线程的栈大小" class="headerlink" title="线程的栈大小"></a>线程的栈大小</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_atrt_getstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> *stacksize)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h4 id="同步概念"><a href="#同步概念" class="headerlink" title="同步概念"></a>同步概念</h4><p>同步，即同时起步，协调一致。不同的对象，对同步的理解方式不同。例如：设备同步指在两个设备之间规定一个共同的时间参考。 数据库同步指让两个或多个数据库内容保持一致，或者按需要部分保持一致。文件一致指让两个或多个文件夹中的文件保持一致。</p>
<h4 id="线程同步-1"><a href="#线程同步-1" class="headerlink" title="线程同步"></a>线程同步</h4><p><strong>一个线程发出某一功能调用时，再没有得到结果之前，该调用不返回。同时其他线程为保证数据的一致性，不能调用该功能。</strong></p>
<p>避免产生<strong>与时间有关的错误</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/31/linux-%E7%B3%BB%E7%BB%9F-09%E4%BC%9A%E8%AF%9D%E5%8F%8A%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/31/linux-%E7%B3%BB%E7%BB%9F-09%E4%BC%9A%E8%AF%9D%E5%8F%8A%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">linux系统-会话及守护进程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-31 15:12:40" itemprop="dateCreated datePublished" datetime="2020-03-31T15:12:40+08:00">2020-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-26 16:04:14" itemprop="dateModified" datetime="2021-03-26T16:04:14+08:00">2021-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>多个<strong>进程组的集合</strong>。</p>
<p>创建一个会话需要注意的点：</p>
<ul>
<li>调用进程不能是进程组组长，该进程变成会话首进程(<code>session header</code>)「</li>
<li>该进程成为一个新进程组的组长进程</li>
<li>需要<code>root</code>权限(ubuntu不需要)</li>
<li><strong>新会话丢弃原有的控制终端，该会话没有控制终端</strong></li>
<li>该调用进程是组长进程，则出错返回</li>
<li>建立新会话时，先调用<code>fork</code>,父进程终止，子进程调用<code>setsid</code></li>
</ul>
<p><code>setsid</code>函数:</p>
<p>创建一个会话, 并以自己的ID设置进程组ID, 同时也是新会话的ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//成功返回调用进程的会话ID, 失败返回-1并设置errno</span></span><br></pre></td></tr></table></figure>
<p><strong>调用了<code>setsid</code>函数的进程, 既是新的会长, 也是新的组长</strong></p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>Daemon(精灵)进程，是Linux中的<strong>后台服务进程</strong>，<strong>通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件</strong>。一般采用d结尾的名字。</p>
<p>Linux后台的一些系统服务进程，<strong>没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行</strong>。这些进程属于守护进程。如：预读入缓输出机制的实现，<code>ftp</code>服务器，<code>nfs</code>服务器等。</p>
<p>创建守护进程，最关键的步骤：调用<code>setsid</code>函数创建一个新的Session,并成为Session Leader.</p>
<h4 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h4><ul>
<li><p>创建子进程, 父进程退出: 所有工作在子进程中形式上脱离了控制终端</p>
</li>
<li><p><strong>在子进程中创建新会话: <code>setsid()</code>函数, 使子进程完全独立出来, 脱离控制</strong></p>
</li>
<li><p><strong>改变当前工作目录位置: <code>chdir()</code>函数, 防止占用可卸载的文件系统</strong></p>
</li>
<li><p>重设<strong>文件权限掩码</strong>: <code>umask()</code>函数, <strong>防止继承的文件创建屏蔽字拒绝某些权限</strong></p>
</li>
<li><p>关闭文件描述符: <strong>继承的打开文件不会用到, 浪费系统资源, 无法卸载</strong></p>
</li>
<li><p>开始执行守护进程核心工作</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建守护进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> fd=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*创建新会话*/</span></span><br><span class="line">	pid=setsid();</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"setsid error"</span>);</span><br><span class="line"></span><br><span class="line">	ret=chdir(<span class="string">"/home/dongshifu"</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"chdir error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*重设文件权限掩码*/</span></span><br><span class="line">	umask(<span class="number">0022</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*关闭标准输入*/</span></span><br><span class="line">	<span class="built_in">close</span>(STDIN_FILENO);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*将标准输出和标准出错重定向到文件黑洞*/</span></span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">"/dev/null"</span>,O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"open error"</span>);</span><br><span class="line">	dup2(fd,STDOUT_FILENO);</span><br><span class="line">	dup2(fd,STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*模拟业务逻辑*/</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShifuDong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShifuDong</p>
  <div class="site-description" itemprop="description">记录生活， 记录学习， 分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/mailto:sfd_w@foxmail.com" title="E-Mail → mailto:sfd_w@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShifuDong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  



    </div>
</body>
</html>
