<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ShifuDong" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="记录生活， 记录学习， 分享知识">
<meta name="keywords" content="生活，C++, C, go, java, OS, 网络， 存储， 联邦学习， 机器学习，python">
<meta property="og:type" content="website">
<meta property="og:title" content="ShifuDong">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="ShifuDong">
<meta property="og:description" content="记录生活， 记录学习， 分享知识">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ShifuDong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShifuDong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Knowledge Sharing</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dongshifu" class="github-corner" title="ShifuDong GitHub" aria-label="ShifuDong GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/02/Go%20%E6%8E%A5%E5%8F%A3_2Go%E8%AF%AD%E8%A8%80%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/02/Go%20%E6%8E%A5%E5%8F%A3_2Go%E8%AF%AD%E8%A8%80%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB/" class="post-title-link" itemprop="url">Go鸭子类型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-02 21:30:16" itemprop="dateCreated datePublished" datetime="2020-01-02T21:30:16+08:00">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-10 08:21:27" itemprop="dateModified" datetime="2021-03-10T08:21:27+08:00">2021-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-interface/" itemprop="url" rel="index">
                    <span itemprop="name">Go interface</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h3><p>维基百科: 如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。</p>
<ul>
<li><p><code>Duck Typing</code>，鸭子类型，是<strong>动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身</strong>。</p>
</li>
<li><p>Go 语言作为一门静态语言，它通过<strong>通过接口的方式完美支持鸭子类型</strong>。</p>
</li>
</ul>
<h3 id="动态语言实现"><a href="#动态语言实现" class="headerlink" title="动态语言实现"></a>动态语言实现</h3><p>动态语言的特点：</p>
<blockquote>
<p>变量绑定的类型是不确定的，在运行期间才能确定<br>函数和方法可以接收任何类型的参数，且调用时不检查参数类型<br>不需要实现接口</p>
</blockquote>
<p>在动态语言 python 中，定义一个这样的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">(coder)</span>:</span></span><br><span class="line">    coder.say_hello()</span><br></pre></td></tr></table></figure>
<p>当调用此函数的时候，可以传入任意类型，只要它实现了 <code>say_hello()</code> 函数就可以。如果没有实现，<strong>运行过程</strong>中会出现错误。</p>
<h3 id="静态语言实现"><a href="#静态语言实现" class="headerlink" title="静态语言实现"></a>静态语言实现</h3><p>而在静态语言如 Java, C++ 中，必须要<strong>显示地声明实现了某个接后，才能用在任何需要这个接口的地方。</strong> <strong>如果你在程序中调用 <code>hello_world</code> 函数，却传入了一个根本就没有实现 <code>say_hello()</code> 的类型，那在编译阶段就不会通过。</strong>这也是静态语言比动态语言更安全的原因。</p>
<p>动态语言和静态语言的差别在此就有所体现。<strong>静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。</strong></p>
<p>静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，eg. python 。</p>
<h3 id="Go鸭子类型实现"><a href="#Go鸭子类型实现" class="headerlink" title="Go鸭子类型实现"></a>Go鸭子类型实现</h3><p>Go 语言作为一门现代静态语言，是有后发优势的。它<strong>引入了动态语言的便利，同时又会进行静态语言的类型检查</strong>，写起来是非常高效的。</p>
<p>Go 采用了折中的做法：<strong>不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。</strong></p>
<p>例子：</p>
<p>定义一个接口，和使用此接口作为参数的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IGreeting <span class="keyword">interface</span> &#123;</span><br><span class="line">	sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(i IGreeting)</span></span> &#123;</span><br><span class="line">	i.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义两个结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Go <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Go)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hi, I am GO!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PHP <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PHP)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hi, I am PHP!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在 main 函数里调用 sayHello() 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	golang := Go&#123;&#125;</span><br><span class="line">	php := PHP&#123;&#125;</span><br><span class="line"></span><br><span class="line">	sayHello(golang)</span><br><span class="line">	sayHello(php)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi, I am GO!</span><br><span class="line">Hi, I am PHP!</span><br></pre></td></tr></table></figure>
<p><strong>在 main 函数中，调用 sayHello() 函数时，传入了 <code>golang, php</code> 对象，它们并没有显式地声明实现了 IGreeting 类型，只是实现了接口所规定的 sayHello() 函数。实际上，编译器在调用 sayHello() 函数时，会隐式地将 <code>golang, php</code> 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>鸭子类型是一种动态语言的风格，在这种风格中，<strong>一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它”当前方法和属性的集合”决定。Go 作为一种静态语言，通过接口实现了 <code>鸭子类型</code>，实际上是 Go 的编译器在其中作了隐匿的转换工作。</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【Golang 与鸭子类型，讲得比较好】<a href="https://blog.csdn.net/cszhouwei/article/details/33741731" target="_blank" rel="noopener">https://blog.csdn.net/cszhouwei/article/details/33741731</a></p>
<p>【各种面向对象的名词】<a href="https://cyent.github.io/golang/other/oo/" target="_blank" rel="noopener">https://cyent.github.io/golang/other/oo/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/02/Go%20%E6%8E%A5%E5%8F%A3_1Go%E4%B8%8E%20C++%20%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/02/Go%20%E6%8E%A5%E5%8F%A3_1Go%E4%B8%8E%20C++%20%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C/" class="post-title-link" itemprop="url">Go接口与C++接口的异同</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-02 21:29:16" itemprop="dateCreated datePublished" datetime="2020-01-02T21:29:16+08:00">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 14:33:32" itemprop="dateModified" datetime="2021-03-08T14:33:32+08:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-interface/" itemprop="url" rel="index">
                    <span itemprop="name">Go interface</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="接口设计的意义"><a href="#接口设计的意义" class="headerlink" title="接口设计的意义"></a>接口设计的意义</h3><ul>
<li>泛型编程：使用 interface 可以实现泛型编程</li>
<li>隐藏具体实现：设计一个函数返回一个 interface，那么<strong>只能通过 interface 里面的方法来做一些操作，但是内部的具体实现是完全不知道的。</strong></li>
</ul>
<h3 id="golang中的接口"><a href="#golang中的接口" class="headerlink" title="golang中的接口"></a>golang中的接口</h3><p>接口定义了一种<strong>规范，描述了类的行为和功能，而不做具体实现</strong>。</p>
<p>Interface定义了一个或一组method(s)，<strong>这些method(s)只有函数签名，没有具体的实现代码</strong>.</p>
<p>若某个数据类型实现了Interface中定义的那些被称为”methods”的函数，则称这些<strong>数据类型实现（implement）了interface。</strong></p>
<h3 id="C-中的接口实现方法"><a href="#C-中的接口实现方法" class="headerlink" title="C++中的接口实现方法"></a>C++中的接口实现方法</h3><p>C++ 的接口是使用<strong>抽象类</strong>来实现的，如果类中至少有一个函数被声明为<strong>纯虚函数</strong>，则这个类就是抽象类。<strong>纯虚函数是通过在声明中使用 “= 0” 来指定的</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 纯虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="built_in">string</span> name;      <span class="comment">// 名称</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设计抽象类的目的:<strong>为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</strong></p>
<p><strong>派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数</strong>。</p>
<h3 id="golang接口与C-接口区别"><a href="#golang接口与C-接口区别" class="headerlink" title="golang接口与C++接口区别"></a>golang接口与C++接口区别</h3><ul>
<li><p>C++ 定义接口的方式称为“侵入式”</p>
</li>
<li><p>Go 采用的是 “非侵入式”，<strong>不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。</strong></p>
</li>
<li><p>底层实现不同</p>
<ul>
<li>实现方式：C++ 通过<strong>虚函数表来实现基类调用派生类的函数</strong>；而 Go 通过 <code>itab</code> 中的 <code>fun</code> 字段来实现接口变量调用实体类型的函数。</li>
<li>编译生成过程：C++ 中的<strong>虚函数表是在编译期生成</strong>的；而 Go 的 <code>itab</code> 中的 <code>fun</code> 字段是在<strong>运行期间动态生成</strong>的。原因在于，<strong>Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 <code>itab</code></strong>， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/01/Go_struct_2%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/01/Go_struct_2%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">Go 编译器自动检测类型是否实现接口</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-01 20:29:16" itemprop="dateCreated datePublished" datetime="2020-01-01T20:29:16+08:00">2020-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-09 18:12:53" itemprop="dateModified" datetime="2021-03-09T18:12:53+08:00">2021-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-struct/" itemprop="url" rel="index">
                    <span itemprop="name">Go struct</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Go-编译器自动检测类型是否实现接口"><a href="#Go-编译器自动检测类型是否实现接口" class="headerlink" title="Go 编译器自动检测类型是否实现接口"></a>Go 编译器自动检测类型是否实现接口</h3><p>开源库里会有一些类似下面这种奇怪的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。<strong>编译器会由此检查 <code>*myWriter</code> 类型是否实现了 <code>io.Writer</code> 接口。</strong></p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"io"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myWriter <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*func (w myWriter) Write(p []byte) (n int, err error) &#123;</span></span><br><span class="line"><span class="comment">	return</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查 *myWriter 类型是否实现了 io.Writer 接口</span></span><br><span class="line">    <span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 myWriter 类型是否实现了 io.Writer 接口</span></span><br><span class="line">    <span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释掉为 myWriter 定义的 Write 函数后，运行程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">command</span>-line-arguments</span></span><br><span class="line">src/learn/tongbu/tongbu.go:14:6: cannot use (*myWriter)(nil) (type *myWriter) as type io.Writer in assignment:</span><br><span class="line">	*myWriter does not implement io.Writer (missing Write method)</span><br><span class="line">src/learn/tongbu/tongbu.go:17:6: cannot use myWriter&#123;&#125; (type myWriter) as type io.Writer in assignment:</span><br><span class="line">	myWriter does not implement io.Writer (missing Write method)</span><br></pre></td></tr></table></figure>
<p>报错信息：<strong>*myWriter/myWriter 未实现 io.Writer 接口，也就是未实现 Write 方法。</strong></p>
<p>解除注释后，运行程序不报错。</p>
<p>实际上，上述赋值语句会发生<strong>隐式地类型转换</strong>，<strong>在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。</strong></p>
<p>总结: 可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/01/Go_struct_1%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/01/Go_struct_1%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Go struct方法的值接收者与指针接收者区别</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-01 20:29:10" itemprop="dateCreated datePublished" datetime="2020-01-01T20:29:10+08:00">2020-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 14:25:44" itemprop="dateModified" datetime="2021-03-08T14:25:44+08:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-struct/" itemprop="url" rel="index">
                    <span itemprop="name">Go struct</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><p>方法能<strong>给用户自定义的类型添加新的行为</strong>。和函数的区别在于<strong>方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是<code>值接收者</code>，也可以是<code>指针接收者</code>。</strong></p>
<p>在调用方法的时候，值类型既可以调用<code>值接收者</code>的方法，也可以调用<code>指针接收者</code>的方法；指针类型既可以调用<code>指针接收者</code>的方法，也可以调用<code>值接收者</code>的方法。</p>
<p>也就是说，<strong>不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。</strong></p>
<p>例1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">howOld</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// qcrao 是值类型</span></span><br><span class="line">	qcrao := Person&#123;age: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 值类型 调用接收者也是值类型的方法</span></span><br><span class="line">	fmt.Println(qcrao.howOld())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 值类型 调用接收者是指针类型的方法</span></span><br><span class="line">	qcrao.growUp()</span><br><span class="line">	fmt.Println(qcrao.howOld())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// stefno 是指针类型</span></span><br><span class="line">	stefno := &amp;Person&#123;age: <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针类型 调用接收者是值类型的方法</span></span><br><span class="line">	fmt.Println(stefno.howOld())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针类型 调用接收者也是指针类型的方法</span></span><br><span class="line">	stefno.growUp()</span><br><span class="line">	fmt.Println(stefno.howOld())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">18</span><br><span class="line">19</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td></tr></table></figure></p>
<p><strong>调用了 <code>growUp</code> 函数后，不管调用者是值类型还是指针类型，它的 <code>Age</code> 值都改变了。</strong></p>
<h3 id="编译器背后工作"><a href="#编译器背后工作" class="headerlink" title="编译器背后工作"></a>编译器背后工作</h3><p>实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>-</th>
<th>值接收者</th>
<th>指针接收者</th>
</tr>
</thead>
<tbody>
<tr>
<td>值类型调用者</td>
<td>方法会使用调用者的一个<strong>副本，类似于“传值”</strong></td>
<td>使用<strong>值的引用来调用方法，上例中，<code>qcrao.growUp()</code> 实际上是 <code>(&amp;qcrao).growUp()</code></strong></td>
</tr>
<tr>
<td>指针类型调用者</td>
<td>指针被<strong>解引用为值</strong>，上例中，<code>stefno.howOld()</code> <strong>实际上是 <code>(*stefno).howOld()</code></strong></td>
<td>实际上也是“传值”，方法里的操作会影响到调用者，<strong>类似于指针传参，拷贝了一份指针</strong></td>
</tr>
</tbody>
</table>
</div>
<h3 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h3><p>不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。</p>
<p>结论：<strong>实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。</strong></p>
<p>例2:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">	code()</span><br><span class="line">	debug()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">	language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"I am coding %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Gopher)</span> <span class="title">debug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"I am debuging %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c coder = &amp;Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line">	c.code()</span><br><span class="line">	c.debug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码里定义了一个接口 <code>coder</code>，接口定义了两个函数：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code()</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>
<p>接着定义了一个结构体 <code>Gopher</code>，它实现了两个方法，一个值接收者，一个指针接收者。</p>
<p>最后，我们在 <code>main</code> 函数里通过接口类型的变量调用了定义的两个函数。</p>
<p>运行，结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am coding Go language</span><br><span class="line">I am debuging Go language</span><br></pre></td></tr></table></figure>
<p>如果把 <code>main</code> 函数的第一条语句换一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c coder = Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line">	c.code()</span><br><span class="line">	c.debug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下，报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">command</span>-line-arguments</span></span><br><span class="line">src/learn/tongbu/tongbu.go:25:6: cannot use Gopher&#123;...&#125; (type Gopher) as type coder in assignment:</span><br><span class="line">	Gopher does not implement coder (debug method has pointer receiver)</span><br></pre></td></tr></table></figure>
<p>两处代码的差别: 第一次是将 <code>&amp;Gopher</code> 赋给了 <code>coder</code>；第二次则是将 <code>Gopher</code> 赋给了 <code>coder</code>。</p>
<p>第二次报错是说，<code>Gopher</code> 没有实现 <code>coder</code>。很明显，<strong>因为 <code>Gopher</code> 类型并没有实现 <code>debug</code> 方法；表面上看， <code>*Gopher</code> 类型也没有实现 <code>code</code> 方法，但是因为 <code>Gopher</code> 类型实现了 <code>code</code> 方法，所以让 <code>*Gopher</code> 类型自动拥有了 <code>code</code> 方法。</strong></p>
<p>当然，上面的说法有一个简单的解释：<strong>接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响。</strong></p>
<p>所以，<strong>当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。</strong></p>
<p>最后，需要记住：</p>
<blockquote>
<p>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。</p>
</blockquote>
<h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p><strong>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</strong></p>
<p>使用指针作为方法的接收者的理由：</p>
<ul>
<li><strong>方法能够修改接收者指向的值。</strong></li>
<li><strong>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</strong></li>
</ul>
<p><strong>是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的<code>本质</code>。</strong></p>
<p><strong>如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 <code>header</code>， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 <code>header</code>，而 <code>header</code> 本身就是为复制设计的。</strong></p>
<p><strong>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份<code>实体</code>。</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【飞雪无情 Go实战笔记】<a href="https://www.flysnow.org/2017/04/03/go-in-action-go-interface.html" target="_blank" rel="noopener">https://www.flysnow.org/2017/04/03/go-in-action-go-interface.html</a></p>
<p>【何时使用指针接收者】<a href="http://ironxu.com/711" target="_blank" rel="noopener">http://ironxu.com/711</a></p>
<p>【理解Go Interface】<a href="http://lanlingzi.cn/post/technical/2016/0803_go_interface/" target="_blank" rel="noopener">http://lanlingzi.cn/post/technical/2016/0803_go_interface/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/30/Go%20%E6%8E%A5%E5%8F%A3_0Go%E7%94%A8%20interface%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/30/Go%20%E6%8E%A5%E5%8F%A3_0Go%E7%94%A8%20interface%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/" class="post-title-link" itemprop="url">Go 用interface实现多态</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-30 21:29:16" itemprop="dateCreated datePublished" datetime="2019-12-30T21:29:16+08:00">2019-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 14:33:17" itemprop="dateModified" datetime="2021-03-08T14:33:17+08:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-interface/" itemprop="url" rel="index">
                    <span itemprop="name">Go interface</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Go-用interface实现多态"><a href="#Go-用interface实现多态" class="headerlink" title="Go 用interface实现多态"></a>Go 用interface实现多态</h3><p>Go 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。</p>
<p>多态是一种运行期的行为，它有以下几个特点：</p>
<blockquote>
<ol>
<li>一种类型具有多种类型的能力</li>
<li>允许不同的对象对同一消息做出灵活的反应</li>
<li>以一种通用的方式对待个使用的对象</li>
<li>非动态语言必须通过继承和接口的方式来实现</li>
</ol>
</blockquote>
<p>看一个实现了多态的代码例子：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	qcrao := Student&#123;age: <span class="number">18</span>&#125;</span><br><span class="line">	whatJob(&amp;qcrao)</span><br><span class="line"></span><br><span class="line">	growUp(&amp;qcrao)</span><br><span class="line">	fmt.Println(qcrao)</span><br><span class="line"></span><br><span class="line">	stefno := Programmer&#123;age: <span class="number">100</span>&#125;</span><br><span class="line">	whatJob(stefno)</span><br><span class="line"></span><br><span class="line">	growUp(stefno)</span><br><span class="line">	fmt.Println(stefno)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">whatJob</span><span class="params">(p Person)</span></span> &#123;</span><br><span class="line">	p.job()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growUp</span><span class="params">(p Person)</span></span> &#123;</span><br><span class="line">	p.growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">	job()</span><br><span class="line">	growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Student)</span> <span class="title">job</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"I am a student."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Student)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.age += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Programmer)</span> <span class="title">job</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"I am a programmer."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Programmer)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 程序员老得太快 ^_^</span></span><br><span class="line">	p.age += <span class="number">10</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里先定义了 1 个 <code>Person</code> 接口，包含两个函数：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job()</span><br><span class="line">growUp()</span><br></pre></td></tr></table></figure>
<p>然后，又定义了 2 个结构体，<code>Student</code> 和 <code>Programmer</code>，同时，类型 <code>*Student</code>、<code>Programmer</code> 实现了 <code>Person</code> 接口定义的两个函数。注意，<code>*Student</code> 类型实现了接口， <code>Student</code> 类型却没有。</p>
<p>之后，我又定义了函数参数是 <code>Person</code> 接口的两个函数：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">whatJob</span><span class="params">(p Person)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growUp</span><span class="params">(p Person)</span></span></span><br></pre></td></tr></table></figure>
<p><code>main</code> 函数里先生成 <code>Student</code> 和 <code>Programmer</code> 的对象，再将它们分别传入到函数 <code>whatJob</code> 和 <code>growUp</code>。函数中，直接调用接口函数，实际执行的时候是看最终传入的实体类型是什么，调用的是实体类型实现的函数。于是，不同对象针对同一消息就有多种表现，<code>多态</code>就实现了。</p>
<p>更深入一点来说的话，在函数 <code>whatJob()</code> 或者 <code>growUp()</code> 内部，接口 <code>person</code> 绑定了实体类型 <code>*Student</code> 或者 <code>Programmer</code>。根据前面分析的 <code>iface</code> 源码，这里会直接调用 <code>fun</code> 里保存的函数，类似于： <code>s.tab-&gt;fun[0]</code>，而因为 <code>fun</code> 数组里保存的是实体类型实现的函数，所以当函数传入不同的实体类型时，调用的实际上是不同的函数实现，从而实现多态。</p>
<p>运行一下代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am a student.</span><br><span class="line">&#123;19&#125;</span><br><span class="line">I am a programmer.</span><br><span class="line">&#123;100&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【各种面向对象的名词】<a href="https://cyent.github.io/golang/other/oo/" target="_blank" rel="noopener">https://cyent.github.io/golang/other/oo/</a></p>
<p>【多态与鸭子类型】<a href="https://www.jb51.net/article/116025.htm" target="_blank" rel="noopener">https://www.jb51.net/article/116025.htm</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/27/c_%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/27/c_%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">C语言条件编译</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-27 21:29:16" itemprop="dateCreated datePublished" datetime="2019-12-27T21:29:16+08:00">2019-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 15:55:01" itemprop="dateModified" datetime="2021-03-08T15:55:01+08:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>要开发一个C语言程序，让它输出红色的文字，并且要求跨平台，在 Windows 和 Linux 下都能运行，怎么办呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> _WIN32</span></span><br><span class="line">        system(<span class="string">"color 0c"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"xxxxtest1\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">elif</span> __linux__</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\033[22;31mxxxtest2m"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"xxxxtest3n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#if、#elif、#else 和 #endif 都是预处理命令，整段代码的意思是：如果宏 <em>WIN32 的值为真，就保留第 4、5  行代码，删除第 7、9 行代码；如果宏 <em>_linux</em></em> 的值为真，就保留第 7 行代码；如果所有的宏都为假，就保留第 9 行代码。</p>
<p> <strong>这些操作都是在预处理阶段完成的，多余的代码以及所有的宏都不会参与编译，不仅保证了代码的正确性，还减小了编译后文件的体积。</strong></p>
<p> 这种能够<strong>根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。条件编译是预处理程序的功能，不是编译器的功能。</strong></p>
<h4 id="if用法"><a href="#if用法" class="headerlink" title="#if用法"></a>#if用法</h4><p>#if 用法的一般格式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">if</span> 整型常量表达式1</span></span><br><span class="line">  程序段<span class="number">1</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">elif</span> 整型常量表达式2</span></span><br><span class="line">  程序段<span class="number">2</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">elif</span> 整型常量表达式3</span></span><br><span class="line">  程序段<span class="number">3</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  程序段<span class="number">4</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>它的意思是：如常“表达式1”的值为真（非0），就对“程序段1”进行编译，否则就计算“表达式2”，结果为真的话就对“程序段2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 #else。这一点和 if else 非常类似。</p>
<p>#elif 和 #else 也可以省略，如下所示： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> _WIN32</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is Windows!\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Unknown platform!\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> __linux__</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is Linux!\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ifdef用法"><a href="#ifdef用法" class="headerlink" title="#ifdef用法"></a>#ifdef用法</h4><p>#ifdef 用法的一般格式为： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  宏名</span></span><br><span class="line">    程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>它的意思是，如果当前的宏已被定义过，则对“程序段1”进行编译，否则对“程序段2”进行编译。</p>
<p>也可以省略 #else： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  宏名</span></span><br><span class="line">    程序段</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>VS/VC 有两种编译模式，Debug 和 Release。在学习过程中，我们通常使用 Debug 模式，这样便于程序的调试；而最终发布的程序，要使用 Release 模式，这样编译器会进行很多优化，提高程序运行效率，删除冗余信息。</p>
<p>为了能够清楚地看到当前程序的编译模式，我们不妨在程序中增加提示，请看下面的代码： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"正在使用 Debug 模式编译程序...\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"正在使用 Release 模式编译程序...\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当以 Debug 模式编译程序时，宏 _DEBUG 会被定义，预处器会保留第 5 行代码，删除第 7 行代码。反之会删除第 5 行，保留第 7 行。</p>
<h4 id="ifndef-的用法"><a href="#ifndef-的用法" class="headerlink" title="#ifndef 的用法"></a>#ifndef 的用法</h4><p>#ifndef 用法的一般格式为： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> 宏名</span></span><br><span class="line">    程序段<span class="number">1</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">    程序段<span class="number">2</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>与 #ifdef 相比，仅仅是将 #ifdef 改为了 #ifndef。它的意思是，如果当前的宏未被定义，则对“程序段1”进行编译，否则对“程序段2”进行编译，这与 #ifdef 的功能正好相反。</p>
<h4 id="区别与注意"><a href="#区别与注意" class="headerlink" title="区别与注意"></a>区别与注意</h4><p>#if 后面跟的是“整型常量表达式”，而 #ifdef 和 #ifndef 后面跟的只能是一个宏名，不能是其他的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> NUM == 10 || NUM == 20</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NUM: %d\n"</span>, NUM);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NUM Error\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再如，两个宏都存在时编译代码A，否则编译代码B： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM1 10</span></span><br><span class="line"><span class="comment">// #define NUM2 20</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> (defined NUM1 &amp;&amp; defined NUM2)</span></span><br><span class="line">        <span class="comment">//代码A</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NUM1: %d, NUM2: %d\n"</span>, NUM1, NUM2);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">//代码B</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ifdef-可以认为是-if-defined-的缩写"><a href="#ifdef-可以认为是-if-defined-的缩写" class="headerlink" title="ifdef 可以认为是 #if defined 的缩写"></a>ifdef 可以认为是 #if defined 的缩写</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/26/linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/26/linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" class="post-title-link" itemprop="url">linux环境变量设置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-26 15:29:16" itemprop="dateCreated datePublished" datetime="2019-12-26T15:29:16+08:00">2019-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-27 15:56:07" itemprop="dateModified" datetime="2021-02-27T15:56:07+08:00">2021-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Ubuntu环境变量的添加和删除"><a href="#Ubuntu环境变量的添加和删除" class="headerlink" title="Ubuntu环境变量的添加和删除"></a>Ubuntu环境变量的添加和删除</h3><h4 id="添加环境变量的位置"><a href="#添加环境变量的位置" class="headerlink" title="添加环境变量的位置"></a>添加环境变量的位置</h4><ul>
<li>/etc/profile 该文件为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行，并从/etc/profile.d目录的配置文件中搜集shell的设置。</li>
<li>/etc/environment 登录操作系统使用的第二个文件，系统在读取自己的profile之前，设置环境文件的环境变量</li>
<li>/etc/bashrc 为每一个运行bash shell的用户执行该文件。当bash shell被打开时，该文件被读取</li>
<li>~/.profile 每个用户都可以使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次。默认情况下设置一些环境变量，执行用户的.bashrc文件</li>
<li>~/.bashrc 该文件包含专用的bash shell的bash信息，当登录以及每次打开新的shell时，该文件被读取。</li>
</ul>
<h4 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h4><ul>
<li>方法一：直接修改/etc/enviroment文件，这种方法的作用域是<strong>全局的，永久性</strong>的。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打开/etc/environment文件，其内容如下：</span></span><br><span class="line">PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games" </span><br><span class="line"><span class="meta">#</span><span class="bash">在环境变量PATH中添加你要添加的路径即可。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：修改/etc/profile文件，这种方法的作用域是<strong>全局的，永久性</strong>的。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">这个文件不是保存环境变量信息的文件，在登录时，系统只是根据它的内容对环境变量进行设置。</span></span><br><span class="line">export PATH=$PATH:[your path1]:[your path2]:[...]  </span><br><span class="line">export PATH=[your path1]:[your path2]:[...]:$PATH #其中，各个PATH之间用冒号分隔，$PATH指代添加your path前的环境变量。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法三：修改/etc/bashrc或者~/.bashrc文件，这两个文件<strong>不是为了保存环境变量，只是在使用bash shell时进行设置而已，所以设置方法和二中一样。对于/etc/bashrc文件，修改的作用于所有用户，但对于~/.bashrc文件，修改的仅仅作用于当前用户。这种修改的作用也是永久性的。</strong></p>
</li>
<li><p>方法四：<strong>修改~/.profile文件，作用仅限于当前用户，但同样也是永久性的。这种方法和修改/etc/profile本质上是一样的，这种之不过是仅仅修改了当前用户自己的配置文件。所以作用仅限于当前用户，但同样也是永久性的。</strong></p>
</li>
<li><p>方法五：在Terminal中使用shell命令，只在当前Terminal中起作用，关闭了当前Terminal就无效了。对其他Terminal也无效</p>
</li>
</ul>
<h4 id="显示环境变量"><a href="#显示环境变量" class="headerlink" title="显示环境变量"></a>显示环境变量</h4><ul>
<li>显示所有环境变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env #打印所有的环境变量</span><br></pre></td></tr></table></figure>
<ul>
<li>显示指定环境变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH #打印PATH环境变量</span><br></pre></td></tr></table></figure>
<h4 id="让修改生效"><a href="#让修改生效" class="headerlink" title="让修改生效"></a>让修改生效</h4><p>使用source命令也可以让修改立即生效。使用方法为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source [file name]  # file name 指的是上面修改过的文件的file name</span><br></pre></td></tr></table></figure>
<h4 id="删除对环境变量的修改"><a href="#删除对环境变量的修改" class="headerlink" title="删除对环境变量的修改"></a>删除对环境变量的修改</h4><p>将以上方法中对配置文件的修改还原回去即可。另外，由于第五种方法由于是临时性质的且局部的，只需要关闭这个Terminal就好了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/26/linux%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/26/linux%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">linux相关操作笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-26 15:29:16" itemprop="dateCreated datePublished" datetime="2019-12-26T15:29:16+08:00">2019-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-27 16:06:20" itemprop="dateModified" datetime="2021-02-27T16:06:20+08:00">2021-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>linux只是操作系统的内核。</p>
<ul>
<li><p>Redhat系列：企业版：redhat，centos</p>
</li>
<li><p>Debian系列：debian，ubuntu</p>
</li>
</ul>
<p>Ubuntu:</p>
<ul>
<li>命名规则：前两位数字：发行时的年份的最后两位数字，</li>
<li>后两位：发行的月份，04表示4月份发行的稳定版;10表示10月份发行的测试版。</li>
</ul>
<p>版本：</p>
<ul>
<li>桌面版：至少三年的技术支持</li>
<li><p>服务器版：至少五年的技术支持</p>
</li>
<li><p>发布频率：一年两次</p>
<ul>
<li>单数年，段期支持</li>
<li>双数年，长期支持，LTS</li>
</ul>
</li>
</ul>
<h2 id="Linux快捷键"><a href="#Linux快捷键" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h2><h3 id="命令解析器"><a href="#命令解析器" class="headerlink" title="命令解析器"></a>命令解析器</h3><p>shell — unix操作系统</p>
<p>bash — linux操作系统 Bone重新写了shell</p>
<p>本质：<strong>根据命令的名字，调用对应的可执行程序，命令解析器调用</strong></p>
<h3 id="Linux快捷键-1"><a href="#Linux快捷键-1" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h3><p>ctrl  + p  历史命令向上</p>
<p>ctrl + n 历史命令向下</p>
<p>ctrl + b 命令光标向前</p>
<p>ctrl + f 命令光标向后</p>
<p>ctrl + a 光标到行首</p>
<p>ctrl + e 行尾部</p>
<p>字符删除：</p>
<p>删除前面的：ctrl + h</p>
<p>删除后面的：ctrl + d</p>
<p>删除一部分：</p>
<p>前面： crtl + u</p>
<p>Tab键智能提示，自动补充命令，路径</p>
<h3 id="Linux下的目录结构"><a href="#Linux下的目录结构" class="headerlink" title="Linux下的目录结构"></a>Linux下的目录结构</h3><p>/ 根目录 ls /</p>
<p>/bin  Binary 缩写，<strong>该目录存放经常使用的命令</strong>。自动配置了环境变量，执行过程自动加载目录</p>
<p>/boot <strong>存放开机启动项文件</strong>，包括一些连接文件以及镜像文件</p>
<p>/dev Device的缩写，该目录下存放Linux的外部设备，在Linux中访问设备的方式和访问文件相同。</p>
<p>/etc <strong>存放所有系统管理所需要的配置文件和子目录</strong>。</p>
<p>/home <strong>用户的主目录，在linux中，每个用户都有一个自己的目录，一般该目录名是以用户的帐号命名的。</strong></p>
<p>/lib <strong>该目录存放系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件，几乎所有的应用程序都需要这些共享库。</strong></p>
<p>/lost+found 一般情况下都是空，当系统非法关机后，这里存放一些文件碎片。</p>
<p>/media linux系统自动识别一些设备，例如U盘，光驱等。<strong>当识别后，linux会将识别的设备挂载到这个目录。</strong></p>
<p>/mnt <strong>为了让用户临时挂载别的文件系统，可以将光驱挂载在/mnt上</strong>，然后进入该目录就可以查看光驱里的内容。</p>
<p>/opt 给主机额外安装软件所摆放的目录</p>
<p>/root <strong>系统管理员，也称为超级权限者的用户主目录</strong></p>
<p><strong>/sbin S为Super User的意思，存放的是系统管理者使用的系统管理程序。</strong></p>
<p>/usr <strong>user software resource，用户的很多应用程序和文件都在这个目录下，类似windows下的program files目录</strong></p>
<p>/var 存放不断扩充的东西，习惯将经常修改的目录放在这个目录下，包括各种日志文件</p>
<h3 id="用户目录"><a href="#用户目录" class="headerlink" title="用户目录"></a>用户目录</h3><p>绝对路径:  知道如何写，从根目录开始写</p>
<p>相对路径： </p>
<ul>
<li>. 当前目录</li>
<li>.. 上一级目录</li>
<li>- 邻近的两个目录间切换</li>
</ul>
<p>dongshifu@dong:~$</p>
<ul>
<li>dongshifu:当前登录的用户</li>
<li>@ 在 dong这台主机下</li>
<li>~:用户的家目录（宿主目录）</li>
<li>$: 当前用户的普通用户。若为# 则表示超级用户</li>
</ul>
<h3 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h3><p>查看目录：</p>
<ul>
<li>tree ，一般情况下文件和目录的颜色。白色，红色，绿色，蓝色，黄色</li>
<li>ls</li>
</ul>
<p>目录切换</p>
<ul>
<li>cd +目录</li>
<li>pwd 查看当前位置</li>
</ul>
<p>创建目录</p>
<ul>
<li>mkdir dirname</li>
<li>创建复合目录（多级目录） mkdir -p </li>
</ul>
<p>删除目录</p>
<ul>
<li>rmdir 删除空目录</li>
<li>rm -rf (r表示递归，-i会提示)  -f 强制删除</li>
</ul>
<p>在目录中创建文件</p>
<ul>
<li>touch 若文件不存在，创建文件，若文件存在，修改文件的时间</li>
</ul>
<p>文件的拷贝</p>
<ul>
<li>cp eg. cp hello.c tmp（文件不存在则创建文件，文件存在则覆盖文件）</li>
</ul>
<p><strong>目录的拷贝</strong></p>
<ul>
<li><strong>cp 要拷贝目录  newdir -r</strong></li>
</ul>
<p>查看文件具体信息</p>
<ul>
<li>ls -al</li>
<li>cat 文件名 适合内容少的文件</li>
<li>more 空格翻页，q退出</li>
<li>less </li>
<li>head 文件的前多少行 - number</li>
<li>tail 文件的后多少行</li>
</ul>
<p>mv命令</p>
<ul>
<li>mv</li>
<li>移动文件 mv</li>
</ul>
<p>软链接相当于快捷方式</p>
<ul>
<li>创建软链接，源文件要使用绝对路径</li>
<li>软链接大小：源文件+路径的总字节数</li>
<li>目录可以创建软链接</li>
</ul>
<p>eg. ln -s /home/a.txt（源文件名+绝对路径） a.test(软链接的名字)</p>
<p>硬链接：映射到inode，不占用磁盘空间。 ln hello.c hello.hard</p>
<ul>
<li>以文件副本的形式存在。但不占用实际空间</li>
<li>不允许给目录创建硬链接</li>
<li>硬链接只有在同一个文件系统中才能创建</li>
</ul>
<p>硬链接能够同步更新：</p>
<ul>
<li>linux下每一个文件都对应一个Inode，创建硬链接后，两个文件的Inode是相同的</li>
<li>查看文件的Inode: stat a.txt</li>
<li>文件创建硬链接后，硬链接计数+1, 删除一个硬链接，硬链接计数-1</li>
</ul>
<p><strong>linux文件系统的存储单位是块。inode — i结点(相当于索引)，保存了一些文件信息，通过inode找到对应的文件。硬链接映射的都是文件的inode（可以理解为某一个位置）。</strong></p>
<p>软链接需要指定绝对地址。</p>
<h4 id="文件或目录属性"><a href="#文件或目录属性" class="headerlink" title="文件或目录属性"></a>文件或目录属性</h4><ul>
<li>wc 获取<strong>文本文件</strong>的基本信息（行数，单词个数[空格区分]，字节数，文件名）</li>
<li>od -t （指定数据的显示格式） 二进制文件查看 </li>
<li>du 查看当前目录的大小 du -h (human)</li>
<li>df 磁盘的使用情况 df -h</li>
</ul>
<p>which  命令：查看使用的命令（只能查看外部的命令，内建命令难以查询）所在的目录</p>
<h4 id="文件权限，用户，用户组"><a href="#文件权限，用户，用户组" class="headerlink" title="文件权限，用户，用户组"></a>文件权限，用户，用户组</h4><p>查看当前登录的用户： whoami</p>
<p>修改文件权限：</p>
<ul>
<li>文字设定法：chmod [who] [+]-[=] [mode]<ul>
<li>who: 文件所有者 u, 文件所属组：g, 其他人: o， 所有的人：a</li>
<li>+/ 增加权限 - 减少权限， = 覆盖原来的权限</li>
<li>mode ： r读，w写，x执行</li>
<li>eg： chmod o+w temp</li>
<li>chmod a=w temp</li>
</ul>
</li>
<li>数字设定法<ul>
<li>- 表示没有</li>
<li>r  4</li>
<li>w 2</li>
<li>x 1</li>
<li>765 —-rwx—-文件所有者 —-rw—-文件所属组 —-r-x—-其他人</li>
<li>chmod -001 </li>
</ul>
</li>
</ul>
<h4 id="修改文件所有者和所属组"><a href="#修改文件所有者和所属组" class="headerlink" title="修改文件所有者和所属组"></a>修改文件所有者和所属组</h4><p>chown 用户名 文件/目录名</p>
<p>chown 所有者:所属组 文件/目录名</p>
<p>chgrp ABC temp 修改temp所属组为ABC</p>
<h4 id="目录必须有的权限"><a href="#目录必须有的权限" class="headerlink" title="目录必须有的权限"></a>目录必须有的权限</h4><p>必须有执行权限，否则无法进入</p>
<p>chmod a-x mytest # mytest的用户、组以及其他用户都减执行权限</p>
<h4 id="文件的查找"><a href="#文件的查找" class="headerlink" title="文件的查找"></a>文件的查找</h4><p>查找某个目录下是否有某个文件：</p>
<p>按文件属性查找：</p>
<ul>
<li>按照文件名字查找： find + 查找的目录 + -name  +“文件的名字”</li>
<li>按照文件大小查找： find  + 查找的目录 + -size  + 大小(+表示大小， -表示小于)。 find /home -size +10K -size -100M</li>
<li>按照文件类型查找：find + 查找目录 + -type +d/f/c/s/p/l</li>
</ul>
<p>按文件内容查找：</p>
<ul>
<li>grep -r(递归查找) “查找的内容” + 查找的路径</li>
</ul>
<p>通配符： * 所有， ？一个字符</p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p><img src="./figure/install.png" alt=""></p>
<p>软件列表：存放软件的名字和下载地址</p>
<h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>磁盘设备种类：</p>
<ul>
<li>sd :SCSI Device</li>
<li>hd : Hard Disk硬盘</li>
<li>fd : Floppy Disk 软盘</li>
</ul>
<p>硬盘1:sda </p>
<ul>
<li>主分区：最多有四个<ul>
<li>主分区1：sda1</li>
<li>主分区2:  sda2</li>
<li>主分区3:  sda3</li>
<li>主分区4: sda4</li>
</ul>
</li>
<li>扩展分区：第一个逻辑分区从sda5开始：<ul>
<li>逻辑分区1:sda5</li>
<li>逻辑分区2: sda6</li>
</ul>
</li>
</ul>
<p>mount 命令会临时覆盖挂载目录，umount后则恢复。</p>
<h4 id="压缩包管理"><a href="#压缩包管理" class="headerlink" title="压缩包管理"></a>压缩包管理</h4><p>扩展版：</p>
<ul>
<li>gzip：.gz格式的压缩包<ul>
<li>不会保留原文件，默认不会打包压缩</li>
<li>gunzip 解压</li>
<li>不能压缩目录</li>
</ul>
</li>
<li>bzip: .bz2格式的压缩包<ul>
<li>不会保留原文件，默认不会打包压缩  -k选项可以保留原文件</li>
<li>bunzip 解压</li>
<li>不能压缩目录</li>
</ul>
</li>
</ul>
<p>好用版：</p>
<ul>
<li>tar<ul>
<li>参数<ul>
<li>c —创建：压缩</li>
<li>x —解压缩，释放</li>
<li>v — 显示提示信息</li>
<li>f —指定压缩文件的名字</li>
<li>z —使用gzip的方式压缩文件， 后缀为.gz</li>
<li>j —使用bzip2的方式压缩文件， —bz2</li>
</ul>
</li>
<li>压缩<ul>
<li>tar zcvf 生成压缩包的名字(xxx.tar.gz)  要压缩的文件或目录</li>
<li>tar jcvf 生成压缩包的名字(xxx.tar.bz2) 要压缩的文件或目录</li>
</ul>
</li>
<li>解压缩<ul>
<li>tar jxvf 压缩包的名字(解压到当前目录)</li>
<li>-C 指定解压目录</li>
</ul>
</li>
</ul>
</li>
<li>rar<ul>
<li>参数<ul>
<li>压缩： a</li>
<li>解压缩 : x</li>
</ul>
</li>
<li>压缩<ul>
<li>rar a 生成文件 要压缩的文件</li>
</ul>
</li>
<li>解压缩<ul>
<li>rar x 要解压的文件 解压目录</li>
</ul>
</li>
</ul>
</li>
<li>zip<ul>
<li>参数</li>
<li>压缩<ul>
<li>zip 要生成压缩包名字 压缩的文件或目录</li>
</ul>
</li>
<li>解压缩<ul>
<li>unzip 压缩包的名字</li>
<li>unzip 压缩包的名字 -d 目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="PS命令使用"><a href="#PS命令使用" class="headerlink" title="PS命令使用"></a>PS命令使用</h4><p>who 命令：查看当前终端登录情况</p>
<p>ps a :查看当前操作系统所有用户</p>
<p>ps au:  查看用户的信息</p>
<p>ps aux: 查看没有终端的应用程序(不能与用户进行交互的进程[输入、输出])，TTY为?的进程</p>
<p><strong>管道 |：指令1 | 指令2 ：指令1的输出作为指令2的输入，指令2处理完毕，将信息输出到屏幕</strong></p>
<h4 id="env和top"><a href="#env和top" class="headerlink" title="env和top"></a>env和top</h4><p>Linux下的环境变量的格式: key - value</p>
<p>key=value:value:value</p>
<h4 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h4><p>ifconfig /ipconfig</p>
<p>nslookup :查看域名对应的ip</p>
<h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p>创建用户:</p>
<ul>
<li>sudo adduser +用户名  </li>
<li>sudo useradd -s /bin/bash -g shifudong -d /home/shifudong -m shifudong <ul>
<li>-s 指定新用户登录时shell类型</li>
<li>-g 指定所属组，该组必须已经存在</li>
<li>-d 用户家目录</li>
<li>-m 用户家目录不存在时，自动创建该目录</li>
</ul>
</li>
</ul>
<p>设置用户组：</p>
<ul>
<li>sudo groupadd itcast</li>
</ul>
<p>切换用户：</p>
<ul>
<li>su + 用户名</li>
</ul>
<p>修改密码：</p>
<ul>
<li>sudo passwd +用户名</li>
</ul>
<p>删除用户：</p>
<ul>
<li>sudo deluser + 用户名</li>
<li>sudo userdel -r itcast （选项-r是把用户的主目录也一起删除）</li>
</ul>
<h4 id="ftp服务器：vsftp"><a href="#ftp服务器：vsftp" class="headerlink" title="ftp服务器：vsftp"></a>ftp服务器：vsftp</h4><p>作用：负责文件的上传和下载</p>
<p>put/get file</p>
<p>不允许操作目录，如果想操作目录，打包</p>
<p>lftp：客户端工具</p>
<h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><p>使用格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r 目标用户名@目标主机IP地址:/目标文件的绝对路径 /保存到本机的绝对（相对）路径</span><br></pre></td></tr></table></figure>
<p>拷贝目录需要加参数 -r</p>
<h4 id="man-和echo"><a href="#man-和echo" class="headerlink" title="man 和echo"></a>man 和echo</h4><p>alias 查看命令是否被封装（设置或查看别名）</p>
<ul>
<li>查看 alias</li>
<li>设置: alias pag=’ps aux | grep’（需要长久有效需要设置配置文件: .bashrc）</li>
</ul>
<h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><p>工作模式</p>
<ul>
<li><p>命令模式：打开文件之后，默认进入命令模式</p>
<ul>
<li>光标的移动：H J K L（前，下，上，后），0到行首，$到行尾。gg到文件首，G到文件尾部，500G到第五百行</li>
</ul>
</li>
<li>删除操作：X删除光标前面的，x删除光标后面的，dw删除一个单词，u撤回删除操作，d0删除当前词行之前的， d$删除后面的。D删除光标后面的。dd删除一行 。5D删除(剪切)5行=5dd<ul>
<li>粘贴：p不换行，P换行</li>
</ul>
</li>
<li><p>复制：yy复制行，<strong>可视模式下y复制，d删除</strong></p>
<ul>
<li><p>查找：</p>
<ul>
<li><p>/stdio:从光标位置，向下，最下边之后返回到头部。</p>
</li>
<li><p>?stdio:从光标位置，向上查找，顶部之后，返回到尾部。</p>
</li>
</ul>
</li>
<li>找到相应的要查找字符串，按#键盘可查找<ul>
<li>缩进：&lt;&lt;, &gt;&gt;</li>
</ul>
</li>
<li>shift+k进入man文档， 3+shift+k进入man 文档第三章</li>
</ul>
</li>
<li><p>编辑模式</p>
</li>
<li><p>末行模式：在末行模式下可以输入一些指令</p>
</li>
</ul>
<p>可视模式：命令模式下 v进入</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="C库函数"><a href="#C库函数" class="headerlink" title="C库函数"></a>C库函数</h3><p>fopen, fclose, fread, fwrite, fgets,fputs, fscanf,fprintf,fseek, fgetc, fputc, ftell, feof, flush…</p>
<p>硬盘为什么慢：大部分硬盘都是机械硬盘，读取寻道时间和写入寻道时间都是毫秒级。内存是纳秒级别。</p>
<p>通过文件描述符可以索引到文件对应的磁盘文件。</p>
<p>文件读写指针位置：读写文件过程中指针的实际位置。</p>
<p>I/O缓冲区（内存地址）：通过寻址找到对应的内存块。</p>
<p>为什么需要I/O缓冲区：减少对硬盘的访问，读的放到缓冲区，当缓冲区满之后再放入到硬盘中。</p>
<p>把缓存中的数据存到硬盘上：</p>
<ul>
<li>刷新缓冲区：fflush</li>
<li>缓冲区已满</li>
<li>正常关闭文件<ul>
<li>fclose</li>
<li>return（main函数）</li>
<li>exit（main函数）</li>
</ul>
</li>
</ul>
<p>对于32位系统，linux为每一个运行的程序（进程）分配一个0-4G的地址空间（虚拟地址空间）</p>
<p>内核空间：受保护，用户不能对该空间进行读写操作，否则会出现段错误。</p>
<p>linux内核中有PCB进程控制块：文件描述符表(数组)：存储文件描述符，每打开一个新文件则占用一个文件描述符，而且使用的是空闲的最小的一个文件描述符。默认文件描述符的0,1,2是打开的，分别对应：标准输入(STDIN_FILENO)，标准输出(STDOUT_FILENO，标准错误。</p>
<p>用户空间：</p>
<p>linux下可执行文件格式：ELF</p>
<ul>
<li>ELF区中包含的区域：.bss(未初始化全局变量)，.data(已初始化全局变量)，.txt(代码段，二进制机器指令)，其他的只读数据段，符号段等</li>
<li>受保护的地址(0-4K)， 例如：#define NULL(void *) 0</li>
<li>栈空间（小）：局部变量存储</li>
<li>堆空间（大）：用户申请内存</li>
<li>共享库：动态库，生成与位置无关的代码，相对地址</li>
<li>命令行参数</li>
<li>环境变量(env)</li>
</ul>
<p>cpu为什么需要使用虚拟地址空间与物理地址空间映射？</p>
<ul>
<li>方便编译器和操作系统安排程序的地址分离：程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区</li>
<li>方便进程之间的隔离：不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程使用的物理内存</li>
<li>方便OS使用较少的内存。程序可以使用一序列虚拟地址来访问大于可用物理内存的内容缓冲区。当物理内存供应量变小时。内存管理器会将物理内存页（通常为4KB)保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘间移动。</li>
</ul>
<h3 id="C库函数与系统函数的关系"><a href="#C库函数与系统函数的关系" class="headerlink" title="C库函数与系统函数的关系"></a>C库函数与系统函数的关系</h3><p>linux<strong>系统的API分为三层：应用层，系统调用，内核层。层层调用。</strong></p>
<p>man 2 + 函数可以查找系统调用的帮助手册</p>
<h4 id="open函数："><a href="#open函数：" class="headerlink" title="open函数："></a>open函数：</h4><p>打开方式：</p>
<p>​    必选项：</p>
<p>​        O_RDONLY</p>
<p>​        O_WRONLY</p>
<p>​        O_EDWR</p>
<p>​    可选项：</p>
<p>​        O_CREATE 文件权限：本地有一个掩码（unmask可以显示,也可以修改: unmask 0002），</p>
<p>​        文件的实际权限：给定的权限 与本地掩码取反进行按位&amp;操作 111111111&amp; 111111101 得到775</p>
<p>​        O_EXCL</p>
<p>​        O_TRUNC  文件截断为0，类似清空</p>
<p>​        O_APPEND                </p>
<p>直接看man 2 open</p>
<p>errno: 文件出错的时候的返回值，定义在errno.h中的全局变量，错误宏定义位置</p>
<p>void perror(const char  *s)，头文件 stdio.h.用来将上一个函数发生错误的原因输出到标准设备(stderr) 。参数s所指的字符串会先打印，后面再加上错误原因字符串。此错误原因依照全局变量errno的值来决定要输出的字符串。</p>
<p><strong>shift +k + 数字可以跳转到对应的帮助文档</strong></p>
<h4 id="read-write-lseek"><a href="#read-write-lseek" class="headerlink" title="read,write,lseek"></a>read,write,lseek</h4><p>read(int fd, void *buf, size_t count);</p>
<p>返回值：</p>
<p>​    -1 读文件失败</p>
<p>​    0 文件读完</p>
<p>​    >0 读取的字节数</p>
<p>write(int fd, const void *buf, size_t count);</p>
<p>off_t lseek(int fd, off_t offset, int whence); //移动文件指针，获取文件的长度</p>
<h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><p>gdb 命令</p>
<ol>
<li><p>前提条件，可执行文件必须包含调试信息 gcc -g</p>
</li>
<li><p>gdb + 文件名 启动dgb调试</p>
</li>
<li>查看代码的命令<ol>
<li>当前文件： list +行号（或函数的名字）</li>
<li>指定文件：文件名:行号（函数名）</li>
</ol>
</li>
<li>设置断点<ol>
<li>当前文件： b + 行号（函数名）</li>
<li>指定文件: b+ 行号（函数名）</li>
<li>设置条件断点： b + 行号 if value == 3</li>
<li>查看断点信息： info</li>
<li>删除断点： d + 断点编号</li>
</ol>
</li>
<li>开始调试<ol>
<li>只执行一行代码： start ,继续执行停在断点处：continue — c</li>
<li>直接停在断点处：run — r</li>
</ol>
</li>
<li>单步调试<ol>
<li>进入到函数体： step — s<ol>
<li>跳出函数体： finish(如果在循环处有断点，需要删除断点)</li>
</ol>
</li>
<li>不进入函数体： next — n</li>
</ol>
</li>
<li>追踪变量<ol>
<li>自动打印变量的值：display 变量名</li>
<li>取消变量的追踪： undisplay 编号<ol>
<li>获取编号： info display</li>
</ol>
</li>
<li>手动打印变量的值： print - p</li>
<li>获取变量对应的类型: ptype</li>
</ol>
</li>
<li>跳出当前循环： u</li>
<li>退出gdb :quit</li>
</ol>
<p>Makefile</p>
<ol>
<li><p>一个规则</p>
<ol>
<li><p>三要素：目标，依赖，命令</p>
<p>目标: 依赖</p>
<p>​    命令</p>
</li>
<li><p>第一条规则是用来生成终极目标的规则</p>
<ol>
<li>如果规则中的依赖不存在，向下查找其他的规则</li>
<li>更新机制：比较的是目标文件和依赖文件的时间</li>
</ol>
</li>
</ol>
</li>
<li><p>两个函数</p>
<ol>
<li>查找指定目录下，知道类型的文件 src = $(vildcard ~/aa/*.c)取到所有的.c文件名</li>
<li>匹配替换函数 obj = $(partsubs %.c %.o $(src))  obj得到所有.o文件</li>
</ol>
</li>
<li><p>三个自动变量</p>
<ol>
<li>$&lt; 规则中的第一个依赖</li>
<li>$” 规则中的所有依赖</li>
<li>$@ 规则中的目标</li>
<li>三个自动变量只能在规则命令中使用</li>
</ol>
</li>
<li><p>模式规则</p>
<ol>
<li>%.o:%.c    gcc -c $&lt; -o $@</li>
</ol>
</li>
</ol>
<p>Linux 系统IO函数</p>
<ol>
<li><p>文件描述符</p>
<ol>
<li>int 类型</li>
<li>一个进程最多可以打开1024个文件</li>
</ol>
</li>
<li><p>PCB ：进程控制块</p>
<ol>
<li>在其中有一个文件描述符号表 数组[1024]</li>
</ol>
</li>
<li><p>虚拟地址空间</p>
<ol>
<li>用户区，内核区</li>
<li>代码段</li>
<li>已经初始化的全局变量</li>
<li>未被初始化的全局变量</li>
<li>堆：从下往上增长</li>
<li>共享库</li>
<li>栈：从下往上</li>
<li>环境变量</li>
<li>内核区</li>
</ol>
</li>
<li>读大文件然后写入另外一个文件<ol>
<li>read write 每次读一个byte</li>
<li>getc putc 每次读一个byte 效率更高，标准c库函数内部有一个缓冲区</li>
<li>两种方式，哪个效率高</li>
</ol>
</li>
</ol>
<h4 id="read-write函数读写文件"><a href="#read-write函数读写文件" class="headerlink" title="read write函数读写文件"></a>read write函数读写文件</h4><p>read_write.c</p>
<h4 id="lseek-函数"><a href="#lseek-函数" class="headerlink" title="lseek 函数"></a>lseek 函数</h4><ol>
<li>获取文件大小</li>
<li>移动文件指针</li>
<li>文件拓展</li>
</ol>
<h4 id="Linux文件操作相关函数"><a href="#Linux文件操作相关函数" class="headerlink" title="Linux文件操作相关函数"></a>Linux文件操作相关函数</h4><ol>
<li>stat函数 对应stat命令<ol>
<li>穿透函数 — 相对软链接而言, 操作：vi</li>
</ol>
</li>
<li>lstat函数<ol>
<li>不穿透，不追踪</li>
<li>不追踪链接的操作：ls -al ,rm </li>
</ol>
</li>
<li>access函数：测试文件是否拥有某种权限</li>
<li>chmod函数</li>
<li>chown函数</li>
<li>truncate函数：文化扩展函数<ol>
<li>文件长度为100,第二个参数指定为20,20以后的被覆盖，第二个参数为300,文件拓展。</li>
</ol>
</li>
<li>链接<ol>
<li>link</li>
<li>symlink</li>
<li>readlink</li>
<li>unlink:删除一个文件的目录项并减少对它的链接数。如果是符号链接，删除符号链接。如果是硬连接，硬链接数减1,当减少为0时，释放数据块和inode。如果文件硬链接数为0,但有进程已经打开这个文件，并持有文件的描述符，则等该进程关闭该文件时，kernel才真正删除该文件。利用该特性创建临时文件（例如：缓存文件），先open,create，然后unlink,接着还可以操作文件。</li>
</ol>
</li>
<li>rename</li>
<li>chdir</li>
<li>getcwd</li>
<li>mkdir</li>
<li>rmdir</li>
<li>opendir<ol>
<li>man 3 opendir</li>
</ol>
</li>
<li>readdir</li>
<li>closedir</li>
</ol>
<p>递归获取目录个数：myFileNum.c</p>
<ol>
<li>dup 和dup2<ol>
<li>用于复制文件描述符</li>
<li>dup返回的是文件描述表中没被占用的最小的文件描述符</li>
<li>dup2(old, new)<ol>
<li>old-&gt;new 如果new是一个被打开的文件描述符，在拷贝前先关掉new</li>
<li>old和new是同一个文件描述符，new不会被关掉，直接返回old</li>
</ol>
</li>
</ol>
</li>
<li>fcntl函数：改变已经打开的文件的属性：获得/设置文件描述标记符，获得/设置文件状态标记，获得/设置异步I/O所有权，获得/设置记录锁<ol>
<li>打开文件的时候：只读</li>
<li>要向文件中添加内容，需要修改文件的属性</li>
</ol>
</li>
</ol>
<p>索引结点inode:保存的其实是实际的数据的一些信息，这些信息称为“元数据”（也就是对文件属性的描述）。例如：文件大小，设备标识符，用户组标识符，文件模式，扩展属性，文件读取或修改的时间戳，链接数量，指向存储该内容的磁盘区块的指针，文件分类等。</p>
<p>注意：数据分为：元数据+数据本身</p>
<p>注意inode号：inode号是惟一的，表示不同的文件。其实在linux内部的时候，访问文件都是通过inode号来进行的，所谓文件名仅仅是给用户容易使用的。当我们打开一个文件的时候。首先，系统找到这个文件名对应的inode号;然后通过inode号得到inode信息。最后，又inode找到文件数据所在的block，这样就可以处理文件数据了。</p>
<p>inode和文件的关系：当创建一个文件的时候，就给文件分配了一个inode。一个inode只对应一个实际文件，一个文件也只会有一个inode。inode最大数量就是文件的最大数量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/27/linux_shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/27/linux_shell/" class="post-title-link" itemprop="url">Linux shell学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-27 19:29:16" itemprop="dateCreated datePublished" datetime="2019-11-27T19:29:16+08:00">2019-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-12 14:54:47" itemprop="dateModified" datetime="2021-03-12T14:54:47+08:00">2021-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><ul>
<li>一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。</li>
<li><p>Shell 既是一种<strong>命令语言</strong>，又是一种<strong>程序设计语言</strong>。</p>
</li>
<li><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，<strong>用户通过这个界面访问操作系统内核的服务</strong>。</p>
</li>
</ul>
<p>真正能够控制计算机硬件（CPU、内存、显示器等）的只有操作系统内核（Kernel），图形界面和<strong>命令行只是架设在用户和内核之间的一座桥梁</strong>。由于安全、复杂、繁琐等原因，用户不能直接接触内核（也没有必要），需要另外再开发一个程序，让用户直接使用这个程序；<strong>该程序的作用就是接收用户的操作（点击图标、输入命令），并进行简单的处理，然后再传递给内核</strong>。如此一来，用户和内核之间就多了一层“代理”，这层“代理”既简化了用户的操作，也保护了内核。用户界面和命令行就是这个另外开发的程序，就是这层“代理”。在Linux下，这个命令行程序叫做 <strong>Shell</strong>。</p>
<h4 id="shell的作用"><a href="#shell的作用" class="headerlink" title="shell的作用"></a>shell的作用</h4><ul>
<li>调用其他程序，给其他程序传递数据或参数，并获取程序的处理结果；</li>
<li>在多个程序之间传递数据，把一个程序的输出作为另一个程序的输入；</li>
<li>Shell 本身也可以被其他程序调用。</li>
</ul>
<p>Shell 本身支持的命令并不多，但是它可以<strong>调用其他的程序</strong>，每个程序就是一个命令，这使得 Shell 命令的数量可以无限扩展，其结果就是  Shell 的功能非常强大，完全能够胜任 Linux  的日常管理工作，如文本或字符串检索、文件的查找或创建、大规模软件的自动部署、更改系统设置、监控服务器性能、发送报警邮件、抓取网页内容、压缩文件等。</p>
<p>Shell 主要用来开发一些实用的、自动化的小工具，而不是用来开发具有复杂业务逻辑的中大型软件，例如检测计算机的硬件参数、一键搭建Web开发环境、日志分析等。</p>
<h4 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h4><p>任何代码最终都要被“翻译”成二进制的形式才能在计算机中执行。</p>
<ul>
<li><p>编译型语言：</p>
<ul>
<li>如 C/C++、Pascal、Go语言、汇编等，必须在程序运行之前将所有代码都翻译成二进制形式，也就是生成可执行文件，用户拿到的是最终生成的可执行文件，看不到源码。</li>
<li>这个过程叫做编译（Compile），这样的编程语言叫做编译型语言，完成编译过程的软件叫做<strong>编译器</strong>（Compiler）。</li>
<li>编译型语言的优点是执行速度快、对硬件要求低、保密性好，适合开发操作系统、大型应用程序、数据库等。</li>
</ul>
</li>
<li><p>解释型语言或者脚本语言（Script）</p>
<ul>
<li>如 Shell、JavaScript、Python、PHP等，需要<strong>一边执行一边翻译，不会生成任何可执行文件，用户必须拿到源码才能运行程序。程序运行后会即时翻译，翻译完一部分执行一部分，不用等到所有代码都翻译完。</strong></li>
<li>这个过程叫做解释，这样的编程语言叫做解释型语言或者脚本语言（Script），完成解释过程的软件叫做<strong>解释器</strong>。</li>
<li>脚本语言的优点是使用灵活、部署容易、跨平台性好，非常适合Web开发以及小工具的制作。</li>
<li>Shell 就是一种脚本语言，我们编写完源码后不用编译，直接运行源码即可。</li>
</ul>
</li>
</ul>
<p>Shell 脚本很适合处理纯文本类型的数据，而 Linux 中几乎所有的配置文件、日志文件（如 NFS、Rsync、Httpd、Nginx、MySQL 等），以及绝大多数的启动文件都是纯文本类型的文件。</p>
<p>Shell 脚本是实现 Linux 系统自动管理以及自动化运维所必备的工具，Linux 的底层以及基础应用软件的核心大都涉及 Shell 脚本的内容。</p>
<p>Shell 脚本的优势在于处理偏操作系统底层的业务，例如，Linux 内部的很多应用（有的是应用的一部分）都是使用 Shell 脚本开发的，因为有 1000 多个 Linux 系统命令为它作支撑。</p>
<h3 id="常见的shell：sh-bash-csh-tcsh-ash"><a href="#常见的shell：sh-bash-csh-tcsh-ash" class="headerlink" title="常见的shell：sh, bash, csh, tcsh, ash"></a>常见的shell：sh, bash, csh, tcsh, ash</h3><p>Linux由多个组织机构开发，<strong>不同的组织机构为了发展自己的 Linux 分支可能会开发出功能类似的软件，它们各有优缺点，用户可以自由选择</strong>。Shell  就是这样的一款软件，不同的组织机构开发了不同的 Shell，它们各有所长，有的占用资源少，有的支持高级编程功能，有的兼容性好，有的重视用户体验。 </p>
<p><strong>Shell 既是一种脚本编程语言，也是一个连接内核和用户的软件。</strong></p>
<p>常见的 Shell 有 sh、bash、csh、tcsh、ash 等。</p>
<h4 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h4><p>sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名。</p>
<p>sh 是 UNIX 上的标准 shell，很多 UNIX 版本都配有 sh。sh 是第一个流行的 Shell。</p>
<h4 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h4><p>sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy (Bill Joy 是一个风云人物，他创立了 BSD 操作系统，开发了 vi 编辑器，还是 Sun 公司的创始人之一)。设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p>
<p><strong>BSD 是 UNIX 的一个重要分支</strong>，后人在此基础上发展出了很多现代的操作系统，最著名的有 FreeBSD、OpenBSD 和 NetBSD，就连 Mac OS X 在很大程度上也基于BSD。</p>
<h4 id="tcsh"><a href="#tcsh" class="headerlink" title="tcsh"></a>tcsh</h4><p>tcsh 是 csh 的增强版，加入了命令补全功能，提供了更加强大的语法支持。</p>
<h4 id="ash"><a href="#ash" class="headerlink" title="ash"></a>ash</h4><p>一个简单的轻量级的 Shell，<strong>占用资源少，适合运行于低内存环境</strong>，但是与下面讲到的 bash shell 完全兼容。</p>
<h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h4><p><strong>bash shell 是 Linux 的默认 shell</strong>. bash 兼容 sh ：<strong>针对 sh 编写的 Shell 代码可以不加修改地在 bash 中运行</strong>。</p>
<p>bash 和 sh 的一些不同之处： </p>
<ul>
<li>bash 扩展了一些命令和参数；</li>
<li>bash 并不完全和 sh 兼容，它们有些行为并不一致，但在大多数企业运维的情况下区别不大，特殊场景可以使用 bash 代替 sh。</li>
</ul>
<h4 id="shell查看"><a href="#shell查看" class="headerlink" title="shell查看"></a>shell查看</h4><p>Shell 是一个程序，一般都是放在<code>/bin</code>或者<code>/user/bin</code>目录下，当前 Linux 系统可用的 Shell 都记录在<code>/etc/shells</code>文件中。<code>/etc/shells</code>是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令（cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上）查看。</p>
<p>通过 cat 命令来查看当前 Linux 系统的可用 Shell：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cat /etc/shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/rbash</span><br></pre></td></tr></table></figure>
<p>在现代的 Linux 上，sh 已经被 bash 代替，<code>/bin/sh</code>往往是指向<code>/bin/bash</code>的符号链接。</p>
<p>如果希望查看当前 Linux 的默认 Shell，那么可以输出 SHELL 环境变量： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$SHELL</span></span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<p>输出结果表明默认的 Shell 是 bash。</p>
<p><code>echo</code>是一个 Shell 命令，用来输出变量的值，<code>SHELL</code>是 Linux 系统中的<strong>环境变量</strong>，它<strong>指明了当前使用的 Shell 程序的位置，也就是使用的哪个 Shell。</strong></p>
<h3 id="终端使用shell"><a href="#终端使用shell" class="headerlink" title="终端使用shell"></a>终端使用shell</h3><p>一种进入 Shell 的方法是让 Linux 系统退出图形界面模式，进入控制台模式，这样一来，显示器上只有一个简单的带着白色文字的“黑屏”，就像图形界面出现之前的样子。这种模式称为 Linux 控制台（Console）。</p>
<p>现代 Linux 系统在启动时会自动创建几个虚拟控制台（Virtual Console），其中一个供图形桌面程序使用，其他的保留原生控制台的样子。虚拟控制台其实就是 Linux 系统内存中运行的虚拟终端（Virtual Terminal）。</p>
<p>从图形界面模式进入控制台模式也很简单，往往按下<code>Ctrl + Alt + Fn(n=1,2,3,4,5...)</code>快捷键就能够来回切换。</p>
<p>例如，CentOS 在启动时会创建 6 个虚拟控制台，按下快捷键<code>Ctrl + Alt + Fn(n=2,3,4,5,6)</code>可以从图形界面模式切换到控制台模式，按下<code>Ctrl + Alt + F1</code>可以从控制台模式再切换回图形界面模式。可以发现，1号控制台被图形桌面程序占用了。</p>
<p>Ubuntu中<code>Ctrl + Alt + F7</code>对应图形界面。</p>
<p>输入用户名和密码，登录成功后就可以进入 Shell 了。<code>$</code>是命令提示符，我们可以在它后面输入 Shell 命令。 </p>
<blockquote>
<p> 在图形界面模式下，输入密码时往往会显示为<em>，密码有几个字符就显示几个</em>；而在控制台模式下，输入密码什么都不会显示，好像按键无效一样，但只要输入的密码正确就能够登录。</p>
</blockquote>
<p>图形界面也是一个程序，会占用CPU时间和内存空间，当 Linux 作为服务器系统时，安装调试完毕后，应该让 Linux 运行在控制台模式下，以节省服务器资源。正是由于这个原因，很多服务器甚至不安装图形界面程序，管理员只能使用命令来完成各项操作。</p>
<p>在Ubuntu中也可以用快捷键<code>Ctrl + Alt + t</code>快速启动一个终端。打开终端后即可输入Shell命令。</p>
<h4 id="shell提示符"><a href="#shell提示符" class="headerlink" title="shell提示符"></a>shell提示符</h4><p>启动终端模拟包或者从 Linux 控制台登录后，便可以看到 Shell 提示符。</p>
<p>对于<strong>普通用户</strong>，Base shell 默认的提示符是美元符号<code>$</code>；对于<strong>超级用户</strong>（root 用户），Bash Shell 默认的提示符是井号<code>#</code>（可使用<code>sudo su</code>切换到超级用户）。该符号表示 Shell 等待输入命令。</p>
<p>同的 Linux 发行版使用的提示符格式不同。例如在 Ubuntu中，默认的提示符格式为：<code>dongshifu@dong:~$</code></p>
<p> 这种格式包含了以下三个方面的信息： </p>
<ul>
<li>启动 Shell 的用户名，也即 dongshifu；</li>
<li>本地主机名称，也即dong；</li>
<li>当前目录，波浪号<code>~</code>是主目录的简写表示法。</li>
</ul>
<h4 id="shell脚本编辑与运行"><a href="#shell脚本编辑与运行" class="headerlink" title="shell脚本编辑与运行"></a>shell脚本编辑与运行</h4><p>打开文本编辑器，新建文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意即可。</p>
<p>输入shell代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "Hello World !"</span><br></pre></td></tr></table></figure>
<p>“#!” <strong>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。</strong>echo命令用于向窗口输出文本。</p>
<p>运行shell脚本的方法：</p>
<ul>
<li>作为可执行程序</li>
</ul>
<p>将上面的代码保存为test.sh，并 cd 到相应目录： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure>
<p>注意，<strong>一定要写成./test.sh，而不是test.sh。运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin,  /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</strong></p>
<p> 通过这种方式运行bash脚本，第一行一定要写对，好让shell查找到正确的解释器。</p>
<ul>
<li>作为解释器参数</li>
</ul>
<p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash test.sh</span><br></pre></td></tr></table></figure>
<p>这种方式运行的脚本<strong>，不需要在第一行指定解释器信息</strong>，写了也没用。</p>
<p>例子：用read命令从stdin获取输入并赋值给PERSON变量，最后在stdout输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "what is your name?"</span><br><span class="line">read PERSON</span><br><span class="line">echo "Hello, $PERSON"</span><br></pre></td></tr></table></figure>
<h3 id="shell变量：shell变量的定义、删除变量、只读变量、变量类型"><a href="#shell变量：shell变量的定义、删除变量、只读变量、变量类型" class="headerlink" title="shell变量：shell变量的定义、删除变量、只读变量、变量类型"></a>shell变量：shell变量的定义、删除变量、只读变量、变量类型</h3><p>脚本语言在定义变量时通常<strong>不需要指明类型，直接赋值就可以</strong>，Shell 变量也遵循这个规则。</p>
<p>在 Bash shell 中，<strong>每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储</strong>。这意味着，<strong>Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串</strong>，这一点和大部分的编程语言不同。 </p>
<p>如果有必要，你也可以<strong>使用 declare 关键字显式定义变量的类型</strong>，但在一般情况下没有这个需求。</p>
<h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><p>三种定义变量方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable=value</span><br><span class="line">variable='value'</span><br><span class="line">variable="value"</span><br></pre></td></tr></table></figure>
<p>variable 是<strong>变量名，value 是赋给变量的值</strong>。如<strong>果 value 不包含任何空白符（例如空格、Tab缩进等），那么可以不使用引号；如果 value 包含了空白符，那么就必须使用引号包围起来</strong>。使用单引号和使用双引号有区别。</p>
<p><strong>注意，赋值号的周围不能有空格</strong></p>
<p>Shell 变量的命名规范和大部分编程语言都一样： </p>
<ul>
<li>变量名由数字、字母、下划线组成；</li>
<li>必须以字母或者下划线开头；</li>
<li>不能使用 Shell 里的关键字（通过 help 命令可以查看保留关键字）。</li>
</ul>
<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p>使用一个定义过的变量，只要在变量名前面加美元符号<code>$</code>即可，如： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">skill="Java"</span><br><span class="line">echo "I am good at $&#123;skill&#125;Script"</span><br></pre></td></tr></table></figure>
<p>变量名外面的花括号<code>{ }</code>是可选的，加不加都行，<strong>加花括号是为了帮助解释器识别变量的边界</strong>，如果不给 skill 变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code>，解释器就会把 $skillScript 当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>
<h4 id="修改变量的值"><a href="#修改变量的值" class="headerlink" title="修改变量的值"></a>修改变量的值</h4><p>已定义的变量，可以被重新赋值，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lang=shell</span><br><span class="line">echo $&#123;lang&#125;</span><br><span class="line">lang=python</span><br><span class="line">echo $&#123;lang&#125;</span><br></pre></td></tr></table></figure>
<p>第二次对变量赋值时不能在变量名前加<script type="math/tex">`，只有在使用变量时才能加`</script>。 </p>
<h4 id="单引号与双引号的区别"><a href="#单引号与双引号的区别" class="headerlink" title="单引号与双引号的区别"></a>单引号与双引号的区别</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">test="you are so cute"</span><br><span class="line">chare='hi,$&#123;test&#125;'</span><br><span class="line">chare2="hi,$&#123;test&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">hi,<span class="variable">$&#123;test&#125;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">hi,you are so cute</span></span><br></pre></td></tr></table></figure>
<p><strong>以单引号<code>&#39; &#39;</code>包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出</strong>。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</p>
<p><strong>以双引号” “包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。</strong>这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</p>
<p>如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。</p>
<h4 id="将命令的结果赋值给变量"><a href="#将命令的结果赋值给变量" class="headerlink" title="将命令的结果赋值给变量"></a>将命令的结果赋值给变量</h4><p>shell支持将命令的执行结果赋值给变量，常见的方式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable=`command`</span><br><span class="line">variable=$(command)</span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test=$(ls -al)</span><br><span class="line">echo $test</span><br></pre></td></tr></table></figure>
<h4 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h4><p>使用 <strong>readonly</strong> 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test="you are so cute"</span><br><span class="line">readonly test</span><br><span class="line">test="you"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">bash: <span class="built_in">test</span>: 只读变量</span></span><br></pre></td></tr></table></figure>
<h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>使用 <strong>unset</strong>命令可以删除变量。语法： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset variable_name</span><br></pre></td></tr></table></figure>
<p> 变量被删除后不能再次使用；unset 命令不能删除只读变量。</p>
<h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p> 运行shell时，会同时存在三种变量：</p>
<h6 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1) 局部变量"></a>1) 局部变量</h6><p>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 </p>
<h6 id="2-环境变量"><a href="#2-环境变量" class="headerlink" title="2) 环境变量"></a>2) 环境变量</h6><p><strong>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</strong> </p>
<h6 id="3-shell变量"><a href="#3-shell变量" class="headerlink" title="3) shell变量"></a>3) shell变量</h6><p>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</p>
<h4 id="shell特殊变量：Shell-0-​-和命令行参数"><a href="#shell特殊变量：Shell-0-​-和命令行参数" class="headerlink" title="shell特殊变量：Shell $0, $#, $​*, $@, $?, $$和命令行参数"></a>shell特殊变量：Shell $0, $#, $​*, $@, $?, $$和命令行参数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td>当前脚本的文件名</td>
</tr>
<tr>
<td>$n</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数。</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或函数的返回值。</td>
</tr>
<tr>
<td>$$</td>
<td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p>运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 $n$ 表示，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo "file name: $0"</span><br><span class="line">echo "First parameter: $1"</span><br><span class="line">echo "Second parameter: $2"</span><br><span class="line">echo "Quoted values: $@"</span><br><span class="line">echo "Quoted values: $*"</span><br><span class="line">echo "Total number of parameters: $#"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行结果</span></span><br><span class="line">./test1.sh shifu dong</span><br><span class="line">file name: ./test1.sh</span><br><span class="line">First parameter: shifu</span><br><span class="line">Second parameter: dong</span><br><span class="line">Quoted values: shifu dong</span><br><span class="line">Quoted values: shifu dong</span><br><span class="line">Total number of parameters: 2</span><br></pre></td></tr></table></figure>
<h4 id="的区别"><a href="#的区别" class="headerlink" title="$* ,$@的区别"></a>$* ,$@的区别</h4><p>$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。</p>
<p>但是当它们被双引号(“ “)包含时，”$*” 会将所有的参数作为一个整体，以”$1 $2 … ​$n”的形式输出所有参数；”​$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "\$*=" $*</span><br><span class="line">echo "\"\$*\"=" "$*"</span><br><span class="line"></span><br><span class="line">echo "\$@=" $@</span><br><span class="line">echo "\"\$@\"=" "$@"</span><br><span class="line"></span><br><span class="line">echo "print each param from \$*"</span><br><span class="line">for var in $*</span><br><span class="line">do </span><br><span class="line">    echo "$var"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "print each parm from \$@"</span><br><span class="line">for var in $@</span><br><span class="line">do </span><br><span class="line">    echo $var</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "print each parm form \"\$*\""</span><br><span class="line">for var in "$*"</span><br><span class="line">do </span><br><span class="line">    echo $var</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "print each parm from \"\$@\""</span><br><span class="line">for var in "$@"</span><br><span class="line">do </span><br><span class="line">    echo $var</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">./test2.sh "A" "B"</span><br><span class="line"><span class="meta">$</span><span class="bash">*= A B</span></span><br><span class="line">"$*"= A B</span><br><span class="line"><span class="meta">$</span><span class="bash">@= A B</span></span><br><span class="line">"$@"= A B</span><br><span class="line">print each param from $*</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">print each parm from $@</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">print each parm form "$*"</span><br><span class="line">A B</span><br><span class="line">print each parm from "$@"</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/27/linux_server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/27/linux_server/" class="post-title-link" itemprop="url">Linux服务管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-27 19:29:16" itemprop="dateCreated datePublished" datetime="2019-11-27T19:29:16+08:00">2019-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-12 14:36:59" itemprop="dateModified" datetime="2021-03-12T14:36:59+08:00">2021-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux服务管理"><a href="#Linux服务管理" class="headerlink" title="Linux服务管理"></a>Linux服务管理</h2><h3 id="服务分类"><a href="#服务分类" class="headerlink" title="服务分类"></a>服务分类</h3><p>Linux服务</p>
<ul>
<li><p>RPM包默认安装的服务</p>
<p>— 独立的服务</p>
<p>— 基于xinetd服务</p>
</li>
<li><p>源码包安装的服务</p>
</li>
</ul>
<p>启动与自启动</p>
<ul>
<li>服务启动：在当前系统中让服务运行，并提供功能</li>
<li>服务自启动：服务在系统开机或重启之后，随着系统的启动而自动启动服务</li>
</ul>
<p>RPM安装服务和源码安装服务区别就在于安装位置的不同。</p>
<p>service不可以启动RPM安装的软件</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShifuDong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShifuDong</p>
  <div class="site-description" itemprop="description">记录生活， 记录学习， 分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShifuDong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  



    </div>
</body>
</html>
