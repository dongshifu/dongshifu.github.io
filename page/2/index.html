<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ShifuDong" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="记录生活， 记录学习， 分享知识">
<meta name="keywords" content="生活，C++, C, go, java, OS, 网络， 存储， 联邦学习， 机器学习，python">
<meta property="og:type" content="website">
<meta property="og:title" content="ShifuDong">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="ShifuDong">
<meta property="og:description" content="记录生活， 记录学习， 分享知识">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ShifuDong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShifuDong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Knowledge Sharing</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-2%E5%8F%AF%E6%89%A9%E5%B1%95%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-2%E5%8F%AF%E6%89%A9%E5%B1%95%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">可扩展分布式系统实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-20 15:03:58" itemprop="dateCreated datePublished" datetime="2021-01-20T15:03:58+08:00">2021-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 08:32:51" itemprop="dateModified" datetime="2021-05-12T08:32:51+08:00">2021-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">分布式对象存储</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="可扩展分布式系统"><a href="#可扩展分布式系统" class="headerlink" title="可扩展分布式系统"></a>可扩展分布式系统</h3><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><p>一个分布式系统要求<strong>各节点分布在网络上，并通过消息传递来合作完成一个共同目标</strong>。</p>
<p>分布式系统的三大关键特征:</p>
<ul>
<li>节点之间<strong>并发</strong>工作</li>
<li>没有全局锁</li>
<li>某个节点上发生的错误不影响其他节点。</li>
</ul>
<p>分布式系统的好处在于<strong>可扩展性，只需要加入新的节点就可以自由扩展集群的性能。</strong></p>
<p>实现分布式系统的关键是实现接口和具体实现的解耦。</p>
<h4 id="接口服务和数据存储服务分离"><a href="#接口服务和数据存储服务分离" class="headerlink" title="接口服务和数据存储服务分离"></a>接口服务和数据存储服务分离</h4><p>如图所示，<strong>接口服务层提供了对外的REST接口</strong>，而<strong>数据服务层则提供数据的存储功能</strong>。接口服务处理客户端的请求，然后向数据服务存取对象，数据服务处理来自接口服务的请求并在本地磁盘上存取对象。</p>
<p><img src="https://api2.mubu.com/v3/document_image/fd1e34fc-3de6-44cc-a135-143050dd1ac8-11197877.jpg" alt="接口服务和数据存储服务分离"></p>
<p>接口服务和数据服务之间的两种接口：</p>
<ul>
<li>实现<strong>对象存取</strong>的接口：对象的存取使用REST 接口。也就是说数据服务本身也提供REST 接口。此时，<strong>接口服务节点作为HTTP客户端向数据服务请求对象</strong>。</li>
<li>第二种接口通过RabbitMQ消息队列进行通信，对 RabbitMQ 的使用分为两种模式。<ul>
<li>一种模式是向某个exchange进行<strong>一对多</strong>的消息<strong>群发</strong></li>
<li>另一种模式则是向某个消息队列进行<strong>一对一</strong>的消息<strong>单发</strong>。</li>
</ul>
</li>
</ul>
<p><strong>每一个数据服务节点都需要向所有的接口服务节点通知自身的存在</strong>，为此，创建一个名为apiServers 的 exchange<strong>,每一台数据服务节点都会持续向这个exchange发送心跳消息。所有的接口服务节点在启动以后都会创建一个消息队列来绑定这个exchange，任何发往这个exchange 的消息都会被转发给绑定它的所有消息队列，也就是说每一个接口服务节点都会接收到任意一台数据服务节点的心跳消息。</strong></p>
<p>接口服务需要在收到对象GET 请求时<strong>定位该对象被保存在哪个数据服务节点上</strong>，所以还需要创建一个名为dataServers的exchange。<strong>所有的数据服务节点绑定这个exchange并接收来自接口服务的定位消息。拥有该对象的数据服务节点则使用消息单发通知该接口服务节点。</strong></p>
<p>之所以必须使用REST和消息队列这两种不同类型的接口是为了满足不同的需求:<strong>对象存取的特点是数据量有可能很大，不适合将一个巨大的对象通过消息队列传输。而REST接口虽然能够处理大数据量传输，但是对于群发却显得力不从心。</strong></p>
<h5 id="REST接口"><a href="#REST接口" class="headerlink" title="REST接口"></a>REST接口</h5><ul>
<li>对于数据服务来说，它的REST接口和单机版本完全相同，也就是对象的PUT和GET方法。</li>
<li>对于接口服务来说，除了对象的PUT和GET 方法之外，还应另外提供一个<strong>用于定位的 locate接口，用来帮助验证架构。</strong><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /locate/&lt;object_name&gt;</span><br><span class="line">响应正文</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>客户端通过GET方法发起对象定位请求，<strong>接口服务节点收到该请求后通过dataServers exchange会向数据服务层群发一个定位消息，然后等待数据服务节点的反馈</strong>。<strong>如果有数据服务节点发回确认消息，则返回该数据服务节点的地址;如果超过一定时间没有任何反馈,则返回HTTP错误代码<code>404 NOT FOUND</code>.</strong></p>
<h5 id="RabbitMQ消息设计"><a href="#RabbitMQ消息设计" class="headerlink" title="RabbitMQ消息设计"></a>RabbitMQ消息设计</h5><p>数据服务需要通过RabbitMQ将自身的存在通知给所有的接口服务，这样的消息称为<strong>心跳消息。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/c2721c9a-25ea-4f7c-ae66-f47e56243975-11197877.jpg" alt="数据服务心跳消息"></p>
<p>apiServers和dataServers这两个exchange需要在RabbitMQ服务器上预先创建。<strong>每个接口服务节点在启动后都会创建自己的消息队列并绑定至 apiServers exchange。</strong> <strong>每个数据服务节点在启动后每隔5s就会发送一条消息给apiServers exchange，消息的正文就是该数据服务节点的 HTTP监听地址。接口服务节点在收到该消息后就会记录这个地址。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/3c415222-3bad-43dc-a1fe-d70b137c92c9-11197877.jpg" alt="定位流程"></p>
<p>每个数据服务节点在启动时都必须创建自己的消息队列并绑定至dataServers exchange。<strong>当接口服务需要定位时，会创建一个临时消息队列，然后发送一条消息给dataServers exchange</strong>，<strong>消息的正文是需要定位的对象，返回地址则是该临时队列的名字。定位成功的数据服务节点需要将反馈消息发送给这个临时队列，反馈消息的正文是该数据服务节点自身的监听地址</strong>。<strong>临时消息队列会在一定时间后关闭。如果在关闭前没有收到任何反馈则该对象定位失败,接口服务节点就会知道该对象不存在于数据服务层。</strong></p>
<h5 id="接口和存储分离的对象PUT流程"><a href="#接口和存储分离的对象PUT流程" class="headerlink" title="接口和存储分离的对象PUT流程"></a>接口和存储分离的对象PUT流程</h5><p><img src="https://api2.mubu.com/v3/document_image/b406ad2b-b000-4a1b-82a8-de523383823e-11197877.jpg" alt="接口和存储分离的对象PUT流程"></p>
<p>客户端向接口服务发送HTTP的PUT 请求并提供了<code>&lt;object_name&gt;</code>和<code>&lt;contentof object&gt;</code>，接口服务选出一个随机数据服务节点并向它转发这个PUT请求，数据服务节点将<code>&lt;content of object&gt;</code>写入<code>$STORAGE_ROOT/objects/&lt;object_name&gt;</code>文件。</p>
<h5 id="接口和存储分离的对象GET流程"><a href="#接口和存储分离的对象GET流程" class="headerlink" title="接口和存储分离的对象GET流程"></a>接口和存储分离的对象GET流程</h5><p><img src="https://api2.mubu.com/v3/document_image/31754790-b3b4-4498-8e1b-e84c17faa6d8-11197877.jpg" alt="接口和存储分离的对象GET流程"></p>
<p>客户端的GET 请求提供了<code>&lt;object_name&gt;</code>，接口服务在收到GET请求后会对该object进行定位，如果定位失败则返回<code>404 Not Found</code>;如果定位成功，<strong>接口服务会接收到某个数据服务的地址，就可以向该地址转发来自客户端的GET请求，由数据服务读取本地磁盘上的文件并将其内容写入HTTP响应的正文。</strong></p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="数据服务"><a href="#数据服务" class="headerlink" title="数据服务"></a>数据服务</h5><p>为支持新的功能，数据服务的在实现上扩展了单机版的相关功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> heartbeat.StartHeartbeat()</span><br><span class="line">	<span class="keyword">go</span> locate.StartLocate()</span><br><span class="line">	http.HandleFunc(<span class="string">"/objects/"</span>, objects.Handler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(os.Getenv(<span class="string">"LISTEN_ADDRESS"</span>), <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据服务的heartbeat包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每隔5s向apiServers exchange发送一条消息</span></span><br><span class="line"><span class="comment">// 将本服务节点的监听对地址发送出去</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartHeartbeat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 调用rabbitmq.New创建一个rabbitmq.RabbitMQ结构体</span></span><br><span class="line">	q := rabbitmq.New(os.Getenv(<span class="string">"RABBITMQ_SERVER"</span>))</span><br><span class="line">	<span class="keyword">defer</span> q.Close()</span><br><span class="line">	<span class="comment">// 无限循环调用Publish方法向apiServers exchange发送本节点的监听地址</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		q.Publish(<span class="string">"apiServers"</span>, os.Getenv(<span class="string">"LISTEN_ADDRESS"</span>))</span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据服务的locate包：</p>
<p>locate包有两个函数，分别是用<strong>于实际定位对象的Locate函数和用于监听定位消息的StartLocate函数</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际定位对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Locate</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// os.Stat访问磁盘上对应的文件名</span></span><br><span class="line">	_, err := os.Stat(name)</span><br><span class="line">	<span class="comment">// 判断文件名是否存在，存在返回true,失败返回false</span></span><br><span class="line">	<span class="keyword">return</span> !os.IsNotExist(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于监听定位消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartLocate</span><span class="params">()</span></span> &#123;</span><br><span class="line">	q := rabbitmq.New(os.Getenv(<span class="string">"RABBITMQ_SERVER"</span>))</span><br><span class="line">	<span class="keyword">defer</span> q.Close()</span><br><span class="line">	<span class="comment">// 绑定dataServers exchange</span></span><br><span class="line">	q.Bind(<span class="string">"dataServers"</span>)</span><br><span class="line">	<span class="comment">// 返回一个channel</span></span><br><span class="line">	c := q.Consume()</span><br><span class="line">	<span class="comment">// range遍历channel,接收消息</span></span><br><span class="line">	<span class="keyword">for</span> msg := <span class="keyword">range</span> c &#123;</span><br><span class="line">		<span class="comment">// JSON编码使得对象名字上有一对双引号，使用strconv.Unquote将输入的字符串前后的双引号去除并作为结果返回</span></span><br><span class="line">		object, e := strconv.Unquote(<span class="keyword">string</span>(msg.Body))</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(e)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> Locate(os.Getenv(<span class="string">"STORAGE_ROOT"</span>) + <span class="string">"/objects/"</span> + object) &#123;</span><br><span class="line">			<span class="comment">//文件存在，调用Send方法向消息的发送方返回本服务节点的监听地址，表示该对象存在于本服务节点上。</span></span><br><span class="line">			q.Send(msg.ReplyTo, os.Getenv(<span class="string">"LISTEN_ADDRESS"</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="接口服务"><a href="#接口服务" class="headerlink" title="接口服务"></a>接口服务</h5><p>接口服务除了<strong>提供对象的REST接口以外还需要提供locate功能</strong>，其main函数为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 提供locate功能</span></span><br><span class="line">	<span class="keyword">go</span> heartbeat.ListenHeartbeat()</span><br><span class="line">	<span class="comment">// 处理URL以/objects/开头的对象请求</span></span><br><span class="line">	http.HandleFunc(<span class="string">"/objects/"</span>, objects.Handler)</span><br><span class="line">	<span class="comment">// 处理URL以/locate/开头的定位请求</span></span><br><span class="line">	http.HandleFunc(<span class="string">"/locate/"</span>, locate.Handler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(os.Getenv(<span class="string">"LISTEN_ADDRESS"</span>), <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：接口服务层和数据服务层的objects包以及heartbeat、locate包虽然名字相同，但具体实现差距较大。</p>
<ul>
<li>数据服务的objects包负责对象在<strong>本地磁盘上的存取</strong>;而接口服务的objects包则负责将<strong>对象请求转发给数据服</strong>务。</li>
<li>数据服务的heartbeat包用于<strong>发送心跳消息</strong>;而接口服务的heartbeat包则用于<strong>接收数据服务节点的心跳消息</strong>。</li>
<li>数据服务的locate包用于<strong>接收定位消息、定位对象以及发送反馈消息</strong>；而接口服务的locate包则用于<strong>发送定位消息并处理反馈消息</strong>。</li>
</ul>
<p>接口服务的heartbeat包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map,整个包可见，用于缓存所有的数据服务节点</span></span><br><span class="line"><span class="keyword">var</span> dataServers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]time.Time)</span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenHeartbeat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建消息队列绑定apiServers exchange</span></span><br><span class="line">	q := rabbitmq.New(os.Getenv(<span class="string">"RABBITMQ_SERVER"</span>))</span><br><span class="line">	<span class="keyword">defer</span> q.Close()</span><br><span class="line">	q.Bind(<span class="string">"apiServers"</span>)</span><br><span class="line">	<span class="comment">// 通过go channel监听每个来自数据服务节点的心跳信息</span></span><br><span class="line">	c := q.Consume()</span><br><span class="line">	<span class="keyword">go</span> removeExpiredDataServer() <span class="comment">//goroutine并行处理</span></span><br><span class="line">	<span class="keyword">for</span> msg := <span class="keyword">range</span> c &#123;</span><br><span class="line">		<span class="comment">//将数据服务节点的监听地址作为map的键，收到消息的时间作为值存入map中</span></span><br><span class="line">		dataServer, e := strconv.Unquote(<span class="keyword">string</span>(msg.Body))</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(e)</span><br><span class="line">		&#125;</span><br><span class="line">		mutex.Lock()</span><br><span class="line">		dataServers[dataServer] = time.Now()</span><br><span class="line">		mutex.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每隔5s扫描一遍map,清除其中超过10s没有收到心跳消息的数据服务节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeExpiredDataServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">		mutex.Lock()</span><br><span class="line">		<span class="keyword">for</span> s, t := <span class="keyword">range</span> dataServers &#123;</span><br><span class="line">			<span class="keyword">if</span> t.Add(<span class="number">10</span> * time.Second).Before(time.Now()) &#123;</span><br><span class="line">				<span class="built_in">delete</span>(dataServers, s)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		mutex.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历map并返回当前所有的数据服务节点</span></span><br><span class="line"><span class="comment">// 为防止多个goroutine并发读写map造成错误，map读写全部需要mutex的保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDataServers</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">	ds := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> s, _ := <span class="keyword">range</span> dataServers &#123;</span><br><span class="line">		ds = <span class="built_in">append</span>(ds, s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从当前所有的数据服务节点中随机选择一个节点并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ChooseRandomDataServer</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	ds := GetDataServers()</span><br><span class="line">	n := <span class="built_in">len</span>(ds)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ds[rand.Intn(n)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口服务的locate包：主要用于<strong>向数据服务节点群发定位消息并接收反馈</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理HTTP请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	m := r.Method</span><br><span class="line">	<span class="keyword">if</span> m != http.MethodGet &#123;</span><br><span class="line">		w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将文件名作为Locate函数的参数进行定位</span></span><br><span class="line">	info := Locate(strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>])</span><br><span class="line">	<span class="comment">// 为空，说明定位失败</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(info) == <span class="number">0</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusNotFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 不为空，则拥有该对象的一个数据服务节点的地址，将地址作为HTTP响应的正文输出</span></span><br><span class="line">	b, _ := json.Marshal(info)</span><br><span class="line">	w.Write(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Locate</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建一个消息队列</span></span><br><span class="line">	q := rabbitmq.New(os.Getenv(<span class="string">"RABBITMQ_SERVER"</span>))</span><br><span class="line">	<span class="comment">// 向dataServers exchange群发对象名字的定位信息</span></span><br><span class="line">	q.Publish(<span class="string">"dataServers"</span>, name)</span><br><span class="line">	c := q.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//1s后关闭临时消息队列</span></span><br><span class="line">		<span class="comment">//设置超时机制，避免无止境的等待。</span></span><br><span class="line">		<span class="comment">//1s后没有任何反馈，消息队列关闭，收到一个长度为0的消息，返回一个空字符串</span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		q.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">//阻塞等待数据服务节点向自己发送反馈消息</span></span><br><span class="line">	<span class="comment">//若在1s内有来自数据服务节点的消息，返回该消息的正文内容，也就是该数据服务节点的监听地址</span></span><br><span class="line">	msg := &lt;-c</span><br><span class="line">	s, _ := strconv.Unquote(<span class="keyword">string</span>(msg.Body))</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查Locate结果是否为空字符串来判定对象是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Exist</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Locate(name) != <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口服务的objects包：</p>
<p>接口服务的objects包跟数据服务有很大区别，其put函数和get函数并不会访问本地磁盘上的对象，而是将HTTP请求转发给数据服务。put函数负责处理对象PUT请求，其相关函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">put</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 从URL中获取objects_name</span></span><br><span class="line">	object := strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="comment">// 将r.Body和objects作为参数调用storeObject</span></span><br><span class="line">	<span class="comment">// 第一个返回值为int类型的变量，用于表示HTTP错误码</span></span><br><span class="line">	<span class="comment">// 第二个返回值为error,如果error不为nil，出错并打印</span></span><br><span class="line">	c, e := storeObject(r.Body, object)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">	&#125;</span><br><span class="line">	w.WriteHeader(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">storeObject</span><span class="params">(r io.Reader, object <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	stream, e := putStream(object)</span><br><span class="line">	<span class="comment">// 没有找到可用的数据服务节点</span></span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> http.StatusServiceUnavailable, e</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到可用的数服务节点并得到一个objectstream.PutStream的指针</span></span><br><span class="line">	<span class="comment">// objectstream.PutStream实现了Write方法，是一个io.Write接口</span></span><br><span class="line">	<span class="comment">// 用io.Copy将HTTP请求的正文写入stream</span></span><br><span class="line">	io.Copy(stream, r)</span><br><span class="line">	e = stream.Close()</span><br><span class="line">	<span class="comment">//写入出错</span></span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> http.StatusInternalServerError, e</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//写入成功</span></span><br><span class="line">	<span class="keyword">return</span> http.StatusOK, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putStream</span><span class="params">(object <span class="keyword">string</span>)</span> <span class="params">(*objectstream.PutStream, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先获得一个随机数服务节点的地址</span></span><br><span class="line">	server := heartbeat.ChooseRandomDataServer()</span><br><span class="line">	fmt.Println(<span class="string">"data server ="</span>, server)</span><br><span class="line">	<span class="comment">// 没有可用的数据服务节点，返回objectstream.PutStream的空指针</span></span><br><span class="line">	<span class="keyword">if</span> server == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"cannot find any dataServer"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> objectstream.NewPutStream(server, object), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objectstream包：对Go中的http包的一个封装，用于将一些http函数的调用转换成写流的形式，方便处理。具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> PutStream <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// writer用于实现Write方法</span></span><br><span class="line">	writer *io.PipeWriter</span><br><span class="line">	<span class="comment">// c用于把在一个gouroutine传输数据过程中发生的错误传回主线程</span></span><br><span class="line">	c      <span class="keyword">chan</span> error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于生成一个PutStream结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPutStream</span><span class="params">(server, object <span class="keyword">string</span>)</span> *<span class="title">PutStream</span></span> &#123;</span><br><span class="line">	<span class="comment">// 用io.Pipe创建一对reader和writer,类型为*io.PipeReader和*io.PipeWriter</span></span><br><span class="line">	<span class="comment">// 管道互联，写入writer的内容可以从reader中读出</span></span><br><span class="line">	<span class="comment">// 希望以写入数据流的方法操作HTTP的PUT请求</span></span><br><span class="line">	reader, writer := io.Pipe()</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 生成put请求，需要提供一个io.Reader作为http.NewRequest的参数</span></span><br><span class="line">		request, _ := http.NewRequest(<span class="string">"PUT"</span>, <span class="string">"http://"</span>+server+<span class="string">"/objects/"</span>+object, reader)</span><br><span class="line">		<span class="comment">// http.Client负责从request中读取需要PUT的内容</span></span><br><span class="line">		client := http.Client&#123;&#125;</span><br><span class="line">		<span class="comment">// 由于管道的读写阻塞特性，在goroutine中调用client.Do方法</span></span><br><span class="line">		r, e := client.Do(request)</span><br><span class="line">		<span class="keyword">if</span> e == <span class="literal">nil</span> &amp;&amp; r.StatusCode != http.StatusOK &#123;</span><br><span class="line">			e = fmt.Errorf(<span class="string">"dataServer return http code %d"</span>, r.StatusCode)</span><br><span class="line">		&#125;</span><br><span class="line">		c &lt;- e</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> &amp;PutStream&#123;writer, c&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于写入writer,实现该方法PutStream才被认为实现了io.Write接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *PutStream)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> w.writer.Write(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭writer,为了让管道另一端的reader读到io.EOF，否则在gouroutine中运行的client.Do将始终阻塞无法返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *PutStream)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	w.writer.Close()</span><br><span class="line">	<span class="comment">// 从c中读取发送自goroutine得错误并返回</span></span><br><span class="line">	<span class="keyword">return</span> &lt;-w.c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口服务层object包用于处理GET请求具体实现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	object := strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="comment">// 调用getStream生成一个类型为io.Reader的stream</span></span><br><span class="line">	stream, e := getStream(object)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusNotFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用io.Copy将stream的内容写入HTTP响应的正文</span></span><br><span class="line">	io.Copy(w, stream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getStream</span><span class="params">(object <span class="keyword">string</span>)</span> <span class="params">(io.Reader, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定位object对象</span></span><br><span class="line">	server := locate.Locate(object)</span><br><span class="line">	<span class="keyword">if</span> server == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"object %s locate fail"</span>, object)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用objectstream.NewGetStream并返回结果</span></span><br><span class="line">	<span class="keyword">return</span> objectstream.NewGetStream(server, object)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objectstream包的GetStream相关实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetStream <span class="keyword">struct</span> &#123;</span><br><span class="line">	reader io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGetStream</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(*GetStream, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 输入的url表示用于获取数据流的HTTP服务地址</span></span><br><span class="line">	<span class="comment">// 调用http.Get发起一个GET请求，获取该地址的HTTP响应</span></span><br><span class="line">	r, e := http.Get(url) <span class="comment">//返回的r类型为*http.Response,其body是用于读取HTTP响应正文的io.Reader</span></span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, e</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r.StatusCode != http.StatusOK &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"dataServer return http code %d"</span>, r.StatusCode)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;GetStream&#123;r.Body&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装newGetStream函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGetStream</span><span class="params">(server, object <span class="keyword">string</span>)</span> <span class="params">(*GetStream, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> server == <span class="string">""</span> || object == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid server %s object %s"</span>, server, object)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 内部拼凑一个url传给newGetStream，对外隐藏url的细节</span></span><br><span class="line">	<span class="keyword">return</span> newGetStream(<span class="string">"http://"</span> + server + <span class="string">"/objects/"</span> + object)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于读取reader成员，实现该方法，则GetStream结构体实现io.Reader接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *GetStream)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.reader.Read(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rabbitmq包实现：</p>
<p>为使用RabbitMQ,需要下载RabbitMQ提供的Go语言包<code>&quot;github.com/streadway/amqp&quot;</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u <span class="string">"github.com/streadway/amqp"</span></span><br></pre></td></tr></table></figure>
<p>为方便使用，实现一个rabbitmq包，该包对<code>&quot;github.com/streadway/amqp</code>进行封装以简化接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rabbitmq</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"github.com/streadway/amqp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RabbitMQ <span class="keyword">struct</span> &#123;</span><br><span class="line">	channel  *amqp.Channel</span><br><span class="line">	conn     *amqp.Connection</span><br><span class="line">	Name     <span class="keyword">string</span></span><br><span class="line">	exchange <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的rabbitmq.RabbitMQ结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">RabbitMQ</span></span> &#123;</span><br><span class="line">	conn, e := amqp.Dial(s)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ch, e := conn.Channel()</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	q, e := ch.QueueDeclare(</span><br><span class="line">		<span class="string">""</span>,    <span class="comment">// name</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// durable</span></span><br><span class="line">		<span class="literal">true</span>,  <span class="comment">// delete when unused</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// exclusive</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// no-wait</span></span><br><span class="line">		<span class="literal">nil</span>,   <span class="comment">// arguments</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mq := <span class="built_in">new</span>(RabbitMQ)</span><br><span class="line">	mq.channel = ch</span><br><span class="line">	mq.conn = conn</span><br><span class="line">	mq.Name = q.Name</span><br><span class="line">	<span class="keyword">return</span> mq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将自己的消息队列和一个exchange绑定</span></span><br><span class="line"><span class="comment">// 所有发往该exchange的消息都能在自己的消息队列中被接收到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span> <span class="title">Bind</span><span class="params">(exchange <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	e := q.channel.QueueBind(</span><br><span class="line">		q.Name,   <span class="comment">// queue name</span></span><br><span class="line">		<span class="string">""</span>,       <span class="comment">// routing key</span></span><br><span class="line">		exchange, <span class="comment">// exchange</span></span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">	q.exchange = exchange</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往某个消息队列发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span> <span class="title">Send</span><span class="params">(queue <span class="keyword">string</span>, body <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	str, e := json.Marshal(body)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">	e = q.channel.Publish(<span class="string">""</span>,</span><br><span class="line">		queue,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			ReplyTo: q.Name,</span><br><span class="line">			Body:    []<span class="keyword">byte</span>(str),</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往某个exchange发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span> <span class="title">Publish</span><span class="params">(exchange <span class="keyword">string</span>, body <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	str, e := json.Marshal(body)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">	e = q.channel.Publish(exchange,</span><br><span class="line">		<span class="string">""</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			ReplyTo: q.Name,</span><br><span class="line">			Body:    []<span class="keyword">byte</span>(str),</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个接收消息的go channel,使客户程序可以通过Go的原生机制接收队列中的消息。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span> <span class="title">Consume</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">amqp</span>.<span class="title">Delivery</span></span> &#123;</span><br><span class="line">	c, e := q.channel.Consume(q.Name,</span><br><span class="line">		<span class="string">""</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">	q.channel.Close()</span><br><span class="line">	q.conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><p>测试环境：包括6个数据服务节点和2个接口服务节点，共8个节点。为了方便测试,8个节点其实都运行在同一台服务器上，只是绑定了8个不同的地址加以区分。<br>6个数据服务节点地址分别是<code>10.29.1.1:12346、10.29.1.2:12346、10.29.1.3:12346、10.29.1.4:12346、10.29.1.5:12346、10.29.1.6:12346</code>。2个接口服务节点地址是<code>10.29.2.1:12346,10.29.2.2:12346</code></p>
<p>在同一台服务器上绑定多个地址命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig eno1:1 10.29.1.1/16</span><br><span class="line">sudo ifconfig eno1:2 10.29.1.2/16</span><br><span class="line">sudo ifconfig eno1:3 10.29.1.3/16</span><br><span class="line">sudo ifconfig eno1:4 10.29.1.4/16</span><br><span class="line">sudo ifconfig eno1:5 10.29.1.5/16</span><br><span class="line">sudo ifconfig eno1:6 10.29.1.6/16</span><br><span class="line">sudo ifconfig eno1:7 10.29.2.1/16</span><br><span class="line">sudo ifconfig eno1:8 10.29.2.2/16</span><br></pre></td></tr></table></figure>
<p>eno1是这台机器的网络接口，可使用<code>ifconfig</code>查询得到，由于Ubuntu 16.0.4的内核支持接口别名，只需要在ifconfig 命令上使用别名接口(eno1后面加上冒号和一个数字)就可以在同一个接口上绑定多个地址。<br>为了让节点能够建立消息队列，还需要一台 RabbitMQ服务器（地址设置为本地即可)，在其上安装rabbitmq-server：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install rabbitmq-server</span><br><span class="line"><span class="comment"># 下载rabbitmqadmin管理工具</span></span><br><span class="line">sudo rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_managements </span><br><span class="line">wget localhost:15672/cli /rabbitmqadmin</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建apiServers 和 dataServers这两个exchange.</span></span><br><span class="line">$ python3 rabbitmqadmin <span class="built_in">declare</span> exchange name=apiServers <span class="built_in">type</span>=fanout</span><br><span class="line">$ python3 rabbitmqadmin <span class="built_in">declare</span> exchange name=dataServers <span class="built_in">type</span>=fanout</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加用户test，密码test。</span></span><br><span class="line">$ sudo rabbitmqctl add_user <span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment">#给test用户添加访问所有exchange的权限。</span></span><br><span class="line">$ sudo rabbitmqctl set_permissions -p / <span class="built_in">test</span> <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure>
<p>消息队列服务器就绪，现在需要同时启动8个服务程序，在启动前还要记得创建相应的<code>$STORAGE_ROOT</code>目录及其子目录<code>objects</code>,接下来的操作可使用shell脚本进行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#clean environment</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 6`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    rm -rf /tmp/<span class="variable">$i</span>/objects/*</span><br><span class="line">    rm -rf /tmp/<span class="variable">$i</span>/temp/*</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare the distributed envrionment</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 6`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    mkdir -p /tmp/<span class="variable">$i</span>/objects</span><br><span class="line">    mkdir -p /tmp/<span class="variable">$i</span>/temp</span><br><span class="line">    mkdir -p /tmp/<span class="variable">$i</span>/garbage</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rabbitmq env</span></span><br><span class="line"><span class="comment"># wget localhost:15672/cli/rabbitmqadmin #rabbitmq访问</span></span><br><span class="line">python3 rabbitmqadmin <span class="built_in">declare</span> exchange name=apiServers <span class="built_in">type</span>=fanout</span><br><span class="line">python3 rabbitmqadmin <span class="built_in">declare</span> exchange name=dataServers <span class="built_in">type</span>=fanout</span><br><span class="line"><span class="comment">#sudo rabbitmqctl add_user test test #首次运行需要创建用户和密码</span></span><br><span class="line"><span class="comment">#sudo rabbitmqctl set_permissions -p / test ".*" ".*" ".*" #修改访问权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start test env</span></span><br><span class="line"><span class="built_in">export</span> RABBITMQ_SERVER=amqp://<span class="built_in">test</span>:<span class="built_in">test</span>@localhost:5672</span><br><span class="line"><span class="built_in">export</span> ES_SERVER=localhost:9200</span><br><span class="line"></span><br><span class="line">LISTEN_ADDRESS=10.29.1.1:12346 STORAGE_ROOT=/tmp/1 go run ../dataServer/dataServer.go &amp;</span><br><span class="line">LISTEN_ADDRESS=10.29.1.2:12346 STORAGE_ROOT=/tmp/2 go run ../dataServer/dataServer.go &amp;</span><br><span class="line">LISTEN_ADDRESS=10.29.1.3:12346 STORAGE_ROOT=/tmp/3 go run ../dataServer/dataServer.go &amp;</span><br><span class="line">LISTEN_ADDRESS=10.29.1.4:12346 STORAGE_ROOT=/tmp/4 go run ../dataServer/dataServer.go &amp;</span><br><span class="line">LISTEN_ADDRESS=10.29.1.5:12346 STORAGE_ROOT=/tmp/5 go run ../dataServer/dataServer.go &amp;</span><br><span class="line">LISTEN_ADDRESS=10.29.1.6:12346 STORAGE_ROOT=/tmp/6 go run ../dataServer/dataServer.go &amp;</span><br><span class="line"></span><br><span class="line">LISTEN_ADDRESS=10.29.2.1:12346 go run ../apiServer/apiServer.go &amp;</span><br><span class="line">LISTEN_ADDRESS=10.29.2.2:12346 go run ../apiServer/apiServer.go &amp;</span><br></pre></td></tr></table></figure>
<p>使用curl测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">curl -v <span class="number">10.29</span><span class="number">.2</span><span class="number">.1</span>:<span class="number">12346</span>/objects/test2 -XPUT -d<span class="string">"this is object test2"</span></span><br><span class="line"></span><br><span class="line">curl <span class="number">10.29</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">12346</span>/locate/test2</span><br><span class="line">echo</span><br><span class="line">curl <span class="number">10.29</span><span class="number">.2</span><span class="number">.1</span>:<span class="number">12346</span>/objects/test2</span><br><span class="line">echo</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">*   Trying 10.29.2.1...</span><br><span class="line">* TCP_NODELAY <span class="built_in">set</span></span><br><span class="line">* Connected to 10.29.2.1 (10.29.2.1) port 12346 (<span class="comment">#0)</span></span><br><span class="line">&gt; PUT /objects/test2 HTTP/1.1</span><br><span class="line">&gt; Host: 10.29.2.1:12346</span><br><span class="line">&gt; User-Agent: curl/7.63.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; Content-Length: 20</span><br><span class="line">&gt; Content-Type: application/x-www-form-urlencoded</span><br><span class="line">&gt; </span><br><span class="line">* upload completely sent off: 20 out of 20 bytes</span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Sat, 10 Apr 2021 08:11:54 GMT</span><br><span class="line">&lt; Content-Length: 0</span><br><span class="line">&lt; </span><br><span class="line">* Connection <span class="comment">#0 to host 10.29.2.1 left intact</span></span><br><span class="line"><span class="string">"10.29.1.4:12346"</span></span><br><span class="line">this is object test2</span><br></pre></td></tr></table></figure>
<p>完整代码可见：<a href="https://github.com/dongshifu/distributed_object_storage_dong/tree/main/v1" target="_blank" rel="noopener">可扩展分布式系统实现</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>《分布式对象存储—原理、架构及Go语言实现》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-1/" class="post-title-link" itemprop="url">分布式对象存储介绍及单机实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-09 15:03:58" itemprop="dateCreated datePublished" datetime="2021-01-09T15:03:58+08:00">2021-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 10:08:33" itemprop="dateModified" datetime="2021-05-12T10:08:33+08:00">2021-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">分布式对象存储</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><h4 id="网络存储"><a href="#网络存储" class="headerlink" title="网络存储"></a>网络存储</h4><ul>
<li>NAS: Network Attached Storage的简称，是一个提供了<strong>存储功能</strong>和<strong>文件系统</strong>的<strong>网络服务器</strong>。客户端可以<strong>访问</strong>NAS上的文件系统，还可以<strong>上传和下载</strong>文件。NAS客户端和服务端之间使用的协议有SMB、NFS 以及AFS等<strong>网络文件系统协议</strong>。对于客户端来说，NAS就是一个网络上的文件服务器。</li>
<li>SAN： Storage Area Network 的简称。和NAS的区别是<strong>SAN只提供了块存储，而把文件系统的抽象交给客户端来管理</strong>。SAN 的客户端和服务端之间的协议有FibreChannel、iSCSI、ATA over Ethernet(AoE）和 HyperSCSI。对于客户端来说，<strong>SAN就是一块磁盘,可以对其格式化、创建文件系统并挂载。</strong></li>
</ul>
<p>现代的网络存储通常混合使用NAS和SAN，同时提供文件级别的协议和块级别的协议。</p>
<h4 id="网络文件系统、块存储与对象存储的区别"><a href="#网络文件系统、块存储与对象存储的区别" class="headerlink" title="网络文件系统、块存储与对象存储的区别"></a>网络文件系统、块存储与对象存储的区别</h4><h5 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h5><ul>
<li>网络文件系统：数据是以一个个<strong>文件的形式来管理</strong></li>
<li>块存储：数据是以<strong>数据块的形式来管理</strong>的，<strong>每个数据块有它自己的地址，但是没有额外的背景信息</strong>。</li>
<li>对象存储：以<strong>对象</strong>的方式来管理数据的，一个对象通常包含了3个部分:<strong>对象的数据、对象的元数据以及一个全局唯一的标识符（即对象的ID)</strong>。其中<ul>
<li>对象的数据就是该对象中存储的<strong>数据本身</strong>。一个对象可以用来保存大量无结构的数据(例如：音乐的具体内容)。</li>
<li>对象的元数据是对象的<strong>描述信息</strong>，为了和对象的数据本身区分开来，称其为元数据(例如：音乐的名字、大小等)。</li>
<li>对象的标识符用于引用该对象。和对象的名字不同，标识符具有<strong>全局唯一性</strong>。名字不具有这个特性。通常用<strong>对象的散列值来做其标识符</strong></li>
</ul>
</li>
</ul>
<h5 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h5><ul>
<li>网络文件系统的客户端通过NFS等<strong>网络协议</strong>访问某个远程服务器上存储的文件。</li>
<li>块存储的客户端通过<strong>数据块的地址</strong>访问SAN上的数据块。</li>
<li>对象存储则通过<strong>REST网络服务</strong>访问对象。</li>
</ul>
<p>REST为Representational State Transfer的简称。REST网络服务通过<strong>标准HTTP服务对网络资源提供一套预先定义的无状态操作</strong>。网络资源被定义为可以<strong>通过URL 访问的文档或文件</strong>。更广发的：网络上一切可以通过任何方式被标识、命名、引用或处理的东西都是一种网络资源。</p>
<p>对于对象存储来说，<strong>对象就是一种网络资源，但除了对象本身以外，还需要提供一些其他的网络资源用来访问对象存储的各种功能</strong>。客户端向 REST网络服务发起请求并接收响应，以确认网络资源发生了某种变化。HTTP预定义的请求方法(Request Method)通常包括且不限于GET、POST、PUT、DELETE等。它们分别对应不同的处理方式:GET方法在REST 标准中通常用来获取某个网络资源，PUT通常用于<strong>创建或替换</strong>某个网络资源（注意，它跟<strong>PUT的区别是POST一般不同于替换网络资源，如果该资源已经存在，POST通常会返回一个错误而不是覆盖它，POST通常用于创建某个网络资源，DELETE通常用于删除某个网络资源。</strong></p>
<h5 id="对象存储的优势"><a href="#对象存储的优势" class="headerlink" title="对象存储的优势"></a>对象存储的优势</h5><ul>
<li>扩展方便：扩展只需要添加新的存储节点就可以</li>
<li>低代价的数据冗余能力</li>
</ul>
<h3 id="单机版对象存储系统"><a href="#单机版对象存储系统" class="headerlink" title="单机版对象存储系统"></a>单机版对象存储系统</h3><p>通过在一台服务器上运行一个<strong>HTTP服务提供的REST接口</strong>，并通过接口实现本地服务器上的对象存取。</p>
<p><img src="https://api2.mubu.com/v3/document_image/d0432f98-00b4-4a53-b82d-906980f1bcd5-11197877.jpg" alt="单机版分布式存储系统"></p>
<h4 id="REST接口"><a href="#REST接口" class="headerlink" title="REST接口"></a>REST接口</h4><p>实现PUT方法和GET方法</p>
<h5 id="对象PUT"><a href="#对象PUT" class="headerlink" title="对象PUT"></a>对象PUT</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /object/&lt;object_name&gt;</span><br><span class="line">请求正文(Request Body)</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/d7a4de74-3320-4ec9-9ae7-760aedea5e94-11197877.jpg" alt="单机版put操作"></p>
<p>客户端通过PUT方法将一个对象上传至服务器，服务器则将该对象保存在本地磁盘上。<strong><code>/objects/&lt;object_name&gt;</code>是标识该对象网络资源的URL</strong>。URL是Uniform Resource Locator  的简称，也就是一个网络地址，用于引用某个网络资源在网络上的位置。</p>
<p>在对象存储中，通常使用<strong>PUT方法来上传一个对象</strong>。客户端的PUT请求提供了对象的名字<code>&lt;object_name&gt;</code>和对象的数据<code>&lt;content of object&gt;</code>,它们最终被保存在本地磁盘上的文件<code>STORAGE_ROOT/objects/&lt;object_name&gt;</code>中。<code>$STORAGE_ROOT</code>环境变量保存着在<strong>本地磁盘上的存储根目录的名字。</strong></p>
<h5 id="对象GET"><a href="#对象GET" class="headerlink" title="对象GET"></a>对象GET</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /objects/&lt;object_name&gt;</span><br><span class="line">响应正文 (Response Body)</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/8c258fbb-a251-429e-8c7d-4f64c0bb7687-11197877.jpg" alt="单机版get操作"></p>
<p>客户端通过GET方法从服务器上<strong>下载</strong>一个对象，<strong>服务器在本地磁盘上查找并读取该对象，如果该对象不存在，则服务器返回HTTP错误代码<code>404 Not Found</code>。</strong></p>
<p>在对象存储中，总是使用GET方法来下载一个对象。客户端的GET请求提供了<code>&lt;object_name&gt;</code>，服务进程从本地磁盘上的文件<code>$STORAGE_ROOT/objects/&lt;object_name&gt;</code>中<strong>读取对象并将其写入HTTP响应正文。</strong></p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>main函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//注册HTTP处理函数objects.Handler,若有客户端访问该服务器的HTTP服务且URL以"objects/"开头，</span></span><br><span class="line">	<span class="comment">//则请求将由objects.Handler负责处理。除此之外的HTTP请求会默认返回HTTP错误代码404 Not Found.</span></span><br><span class="line">	http.HandleFunc(<span class="string">"/objects/"</span>, objects.Handler)</span><br><span class="line">	<span class="comment">//监听端口</span></span><br><span class="line">	<span class="comment">//正常情况下没有返回，程序运行后开始监听端口上的请求</span></span><br><span class="line">	<span class="comment">//非正常情况下，该函数将错误返回，log.Fatal打印错误信息并退出程序</span></span><br><span class="line">	log.Fatal(http.ListenAndServe(os.Getenv(<span class="string">"LISTEN_ADDRESS"</span>), <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objects包下的<code>Handler</code>函数、<code>get、put</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> objects</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查HTTP请求方法:PUT则调用put函数，GET则调用共get函数。其余则返回405 Method Not Allowed错误代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	m := r.Method <span class="comment">//Method记录该HTTP请求的方法</span></span><br><span class="line">	<span class="keyword">if</span> m == http.MethodPut &#123;</span><br><span class="line">		put(w, r)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> m == http.MethodGet &#123;</span><br><span class="line">		get(w, r)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//写HTTP响应的代码</span></span><br><span class="line">	w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> objects</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">put</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Println(r.URL.EscapedPath())</span><br><span class="line">	<span class="comment">//r.URL.EsccapedPath得到request的路径，此处为/objects/xxx</span></span><br><span class="line">	f, e := os.Create(os.Getenv(<span class="string">"STORAGE_ROOT"</span>) + <span class="string">"/objects/"</span> +</span><br><span class="line">		strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]) <span class="comment">//得到文件名</span></span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//创建文件失败</span></span><br><span class="line">		log.Println(e)</span><br><span class="line">		<span class="comment">//写入HTTP响应的代码</span></span><br><span class="line">		w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	io.Copy(f, r.Body) <span class="comment">//将r.Body写入文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> objects</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	f, e := os.Open(os.Getenv(<span class="string">"STORAGE_ROOT"</span>) + <span class="string">"/objects/"</span> +</span><br><span class="line">		strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>])</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusNotFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	io.Copy(w, f) </span><br><span class="line">	<span class="comment">//f本身的类型是*os.File,同时实现了io.Writer和io.Reader两个接口，即实现了Write和Read方法</span></span><br><span class="line">	<span class="comment">//http.ResponseWriter也是接口，该接口实现了Write方法，也是一个io.Write接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="linux下功能测试"><a href="#linux下功能测试" class="headerlink" title="linux下功能测试"></a>linux下功能测试</h3><p>运行服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/objects</span><br><span class="line">LISTEN_ADDRESS=:12345 STORAGE_ROOT=/tmp go run server.go</span><br></pre></td></tr></table></figure>
<p>curl 进行http访问：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -v 10.29.102.172:12345/objects/<span class="built_in">test</span> <span class="comment">#默认get操作，此时没有数据，返回404 Not Found</span></span><br><span class="line"></span><br><span class="line">curl -v 10.29.102.172:12345/objects/<span class="built_in">test</span> -XPUT -d<span class="string">"this is a test object"</span> <span class="comment"># put一个对象</span></span><br><span class="line"></span><br><span class="line">curl -v 10.29.102.172:12345/objects/<span class="built_in">test</span> <span class="comment">#默认get操作，成功返回200 OK</span></span><br></pre></td></tr></table></figure>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>《分布式对象存储—原理、架构及Go语言实现》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/03/Go-channel-3channel%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/03/Go-channel-3channel%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">channel发送和接收数据的过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-03 20:03:09" itemprop="dateCreated datePublished" datetime="2021-01-03T20:03:09+08:00">2021-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 10:57:04" itemprop="dateModified" datetime="2021-04-08T10:57:04+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="channel发送和接收元素的本质"><a href="#channel发送和接收元素的本质" class="headerlink" title="channel发送和接收元素的本质"></a>channel发送和接收元素的本质</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">All transfer of value on the go channels happens with the copy of value.</span><br><span class="line">channel 的发送和接收操作本质上都是 “值的拷贝”，无论是从 sender goroutine 的栈到 chan buf，还是从 chan buf 到 receiver goroutine，或者是直接从 sender goroutine 到 receiver goroutine。</span><br></pre></td></tr></table></figure>
<p>举例分析：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = user&#123;name: <span class="string">"Ankur"</span>, age: <span class="number">25</span>&#125;</span><br><span class="line"><span class="keyword">var</span> g = &amp;u</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyUser</span><span class="params">(pu *user)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"modifyUser Received Vaule"</span>, pu)</span><br><span class="line">	pu.name = <span class="string">"Anand"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printUser</span><span class="params">(u &lt;-<span class="keyword">chan</span> *user)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"printUser goRoutine called"</span>, &lt;-u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> *user, <span class="number">5</span>)</span><br><span class="line">	c &lt;- g</span><br><span class="line">	fmt.Println(g)</span><br><span class="line">	<span class="comment">// modify g</span></span><br><span class="line">	g = &amp;user&#123;name: <span class="string">"Ankur Anand"</span>, age: <span class="number">100</span>&#125;</span><br><span class="line">	<span class="keyword">go</span> printUser(c)</span><br><span class="line">	<span class="keyword">go</span> modifyUser(g)</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Println(g)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">&amp;&#123;Ankur 25&#125;</span></span><br><span class="line"><span class="comment">modifyUser Received Vaule &amp;&#123;Ankur Anand 100&#125;</span></span><br><span class="line"><span class="comment">printUser goRoutine called &amp;&#123;Ankur 25&#125;</span></span><br><span class="line"><span class="comment">&amp;&#123;Anand 100&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>一开始构造一个结构体 u，地址是 0x56420，图中地址上方就是它的内容。接着把 <code>&amp;u</code> 赋值给指针 <code>g</code>，g 的地址是 0x565bb0，它的内容就是一个地址，指向 u。</p>
<p>main 程序里，先把 g 发送到 c，根据 <code>copy value</code> 的本质，进入到 chan buf 里的就是 <code>0x56420</code>，它是指针 g 的值（不是它指向的内容），所以打印从 channel 接收到的元素时，它就是 <code>&amp;{Ankur 25}</code>。因此，这里并不是将指针 g “发送” 到了 channel 里，只是拷贝它的值而已。</p>
<h3 id="向channel发送数据的过程"><a href="#向channel发送数据的过程" class="headerlink" title="向channel发送数据的过程"></a>向channel发送数据的过程</h3><p>发送操作最终转化为 <code>chansend</code> 函数，关注主流程(hchan源码分析见<a href="https://dongshifu.github.io/2021/01/02/Go-channel-2%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">channel底层实现原理</a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 src/runtime/chan.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果 channel 是 nil</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 不能阻塞，直接返回 false，表示未发送成功</span></span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当前 goroutine 被挂起</span></span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"chan send (nil chan)"</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略 debug 相关……</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于不阻塞的 send，快速检测失败场景</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：</span></span><br><span class="line">	<span class="comment">// 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine</span></span><br><span class="line">	<span class="comment">// 2. channel 是缓冲型的，但循环数组已经装满了元素</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">		(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 锁住 channel，并发安全</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 channel 关闭了</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="comment">// 直接 panic</span></span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果接收队列里有 goroutine，直接将要发送的数据拷贝到接收 goroutine</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于缓冲型的 channel，如果还有缓冲空间</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// qp 指向 buf 的 sendx 位置</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将数据从 ep 处拷贝到 qp</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		<span class="comment">// 发送游标值加 1</span></span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="comment">// 如果发送游标值等于容量值，游标值归 0</span></span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 缓冲区的元素数量加一</span></span><br><span class="line">		c.qcount++</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不需要阻塞，则直接返回错误</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// channel 满了，发送方会被阻塞。接下来会构造一个 sudog</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前 goroutine 的指针</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前 goroutine 进入发送等待队列</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前 goroutine 被挂起</span></span><br><span class="line">	goparkunlock(&amp;c.lock, <span class="string">"chan send"</span>, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从这里开始被唤醒了（channel 有机会可以发送了）</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 被唤醒后，channel 关闭了。坑爹啊，panic</span></span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 去掉 mysg 上绑定的 channel</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/02/Go-channel-2%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/Go-channel-2%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">channel的底层实现原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 19:06:50" itemprop="dateCreated datePublished" datetime="2021-01-02T19:06:50+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 10:56:49" itemprop="dateModified" datetime="2021-04-08T10:56:49+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>源码( go 1.9.2)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// chan 里元素数量</span></span><br><span class="line">	qcount   <span class="keyword">uint</span></span><br><span class="line">	<span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span></span><br><span class="line">	<span class="comment">// 指向底层循环数组的指针</span></span><br><span class="line">	<span class="comment">// 只针对有缓冲的 channel</span></span><br><span class="line">	buf      unsafe.Pointer</span><br><span class="line">	<span class="comment">// chan 中元素大小</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	<span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	<span class="comment">// chan 中元素类型</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	<span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	<span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	<span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	<span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保护 hchan 中所有字段</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重点字段"><a href="#重点字段" class="headerlink" title="重点字段"></a>重点字段</h4><ul>
<li><p><code>buf</code> <strong>指向底层循环数组</strong>，只有<strong>缓冲型</strong>的 channel 才有。</p>
</li>
<li><p><code>sendx</code>，<code>recvx</code> 均指向底层循环数组，表示<strong>当前可以发送和接收的元素位置索引值（相对于底层数组）</strong>。</p>
</li>
<li><p><code>sendq</code>，<code>recvq</code> 分别表示<strong>被阻塞的 goroutine</strong>，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。</p>
</li>
<li><p><code>waitq</code> 是 <code>sudog</code> 的一个<strong>双向链表</strong>，而 <code>sudog</code> 实际上是对 goroutine 的一个封装：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lock</code> 用来保证每个读 channel 或写 channel 的操作都是原子的。</li>
</ul>
<p>例如，创建一个容量为 6 的，元素为 int 型的 channel 数据结构如下 ：</p>
<p><img src="https://api2.mubu.com/v3/document_image/a8f442cb-91ec-4811-a781-42ffacce965b-11197877.jpg" alt="channel数据结构"></p>
<h3 id="channel的创建过程"><a href="#channel的创建过程" class="headerlink" title="channel的创建过程"></a>channel的创建过程</h3><p>通道有两个方向，发送和接收。理论上来说，可以创建一个只发送或只接收的通道，但是这种通道创建出来后，怎么使用呢？一个只能发的通道，怎么接收呢？同样，一个只能收的通道，如何向其发送数据呢？</p>
<p>一般而言，使用 <code>make</code> 创建一个能收能发的通道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲通道</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 有缓冲通道</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>创建 chan 的函数是 <code>makechan</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span></span><br></pre></td></tr></table></figure>
<p>从函数原型来看，<strong>创建的 chan 是一个指针。所以能在函数间直接传递 channel，而不用传递 channel 的指针。</strong></p>
<p>具体过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="keyword">uintptr</span>(-<span class="keyword">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略了检查 channel size，align 的代码</span></span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="comment">// 如果元素类型不含指针 或者 size 大小为 0（无缓冲类型）</span></span><br><span class="line">	<span class="comment">// 只进行一次内存分配</span></span><br><span class="line">	<span class="keyword">if</span> elem.kind&amp;kindNoPointers != <span class="number">0</span> || size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素</span></span><br><span class="line">		<span class="comment">// 只分配 "hchan 结构体大小 + 元素大小*个数" 的内存</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+<span class="keyword">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="comment">// 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct&#123;&#125;）</span></span><br><span class="line">		<span class="keyword">if</span> size &gt; <span class="number">0</span> &amp;&amp; elem.size != <span class="number">0</span> &#123;</span><br><span class="line">			c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// race detector uses this l是ocation for synchronization</span></span><br><span class="line">			<span class="comment">// Also prevents us from pointing beyond the allocation (see issue 9401).</span></span><br><span class="line">			<span class="comment">// 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处</span></span><br><span class="line">			<span class="comment">// 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct&#123;&#125;，也无影响</span></span><br><span class="line">			<span class="comment">// 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）</span></span><br><span class="line">			c.buf = unsafe.Pointer(c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 进行两次内存分配操作</span></span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = newarray(elem, <span class="keyword">int</span>(size))</span><br><span class="line">	&#125;</span><br><span class="line">	c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	<span class="comment">// 循环数组长度</span></span><br><span class="line">	c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 hchan 指针</span></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个 chan 后，<strong>内存在堆上分配</strong>，大概长这样：</p>
<p><img src="https://api2.mubu.com/v3/document_image/59aacc73-c65d-4b7c-a17d-d9f2144fc32d-11197877.jpg" alt="chan的内存分配情况"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/02/Go-channel_1%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/Go-channel_1%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">channel用法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 14:29:34" itemprop="dateCreated datePublished" datetime="2021-01-02T14:29:34+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 10:56:36" itemprop="dateModified" datetime="2021-04-08T10:56:36+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>Go的并发依赖CSP模型，基于channel实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Do not communicate by sharing memory; instead, share memory by communicating.</span><br><span class="line">不要通过共享内存来通信，而要通过通信来实现内存共享。</span><br></pre></td></tr></table></figure>
<p>CSP 全称是 “Communicating Sequential Processes”，用于描述两个独立的并发实体通过共享 channel（管道）进行通信的并发模型。Go语言并没有完全实现了 CSP 并发模型的所有理论，仅仅是实现了 process 和 channel 这两个概念。process 就是Go语言中的 goroutine，每个 goroutine 之间是通过 channel 通讯来实现数据共享。</p>
<p>大多数的编程语言的并发编程模型是基于线程和内存同步访问控制，Go 的并发编程的模型则用 goroutine 和 channel 来替代。Goroutine 和线程类似，channel 和 mutex (用于内存同步访问控制)类似。</p>
<p>Go 的并发原则非常优秀，目标就是<strong>简单</strong>：尽量使用 channel；把 goroutine 当作免费的资源，随便用。</p>
<h3 id="操作channel的结果"><a href="#操作channel的结果" class="headerlink" title="操作channel的结果"></a>操作channel的结果</h3><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>nil channel</th>
<th>closed channel</th>
<th>not nil, not closed channel</th>
</tr>
</thead>
<tbody>
<tr>
<td>close</td>
<td>panic</td>
<td>panic</td>
<td>正常关闭</td>
</tr>
<tr>
<td>读 &lt;- ch</td>
<td>阻塞</td>
<td><strong>读到对应类型的零值</strong></td>
<td><strong>阻塞或正常读取数据</strong>。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞</td>
</tr>
<tr>
<td>写 ch &lt;-</td>
<td>阻塞</td>
<td>panic</td>
<td>阻塞或正常写入数据。非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞</td>
</tr>
</tbody>
</table>
</div>
<p>总结一下，<strong>发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。</strong></p>
<p>读、写一个 nil channel 都会被阻塞。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/21/mysql_3%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/mysql_3%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/" class="post-title-link" itemprop="url">mysql事务</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-21 21:29:27" itemprop="dateCreated datePublished" datetime="2020-12-21T21:29:27+08:00">2020-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-30 13:43:38" itemprop="dateModified" datetime="2021-03-30T13:43:38+08:00">2021-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h3><p>转账场景：要给朋友小王转100块钱，而此时银行卡只有100块钱。转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，100块钱完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念。</p>
<p>简单来说，<strong>事务就是要保证一组数据库操作，要么全部成功，要么全部失败</strong>。在<strong>MySQL中，事务支持是在引擎层实现的</strong>。MySQL是一个支持多引擎的系统<strong>，但并不是所有的引擎都支持事务</strong>。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。</p>
<h3 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h3><p>事务的四要素:ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。本次主要学习隔离性。</p>
<p>当数据库上有多个事务同时执行的时候，就可能出现<a href="https://dongshifu.github.io/2020/12/17/mysql-4mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%94%81/" target="_blank" rel="noopener">脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</a>. 为了解决这些问题，就有了“隔离级别”的概念。</p>
<p><strong>隔离得越严实，效率就会越低</strong>。因此很多时候，我们都要在二者之间寻找一个<strong>平衡点</strong>。SQL标准的事务隔离级别包括：<strong>读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）</strong>。</p>
<ul>
<li>读未提交是指，<strong>一个事务还没提交时，它做的变更就能被别的事务看到</strong>。</li>
<li>读提交是指，一个事务<strong>提交之后，它做的变更才会被其他事务看到</strong>。</li>
<li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然<strong>在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</strong></li>
<li>串行化，顾名思义是<strong>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</strong></li>
</ul>
<p>举例说明事务的隔离性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/da798e7f-1080-480e-a530-6a73973f01dd-11197877.jpg" alt="事务的隔离性"></p>
<p>在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。</p>
<ul>
<li>若隔离级别是“读未提交”，<strong>事务B虽然还没有提交，但是结果已经被A看到</strong>了。v1 为2，v2为2，v3为2</li>
<li>若隔离级别是“读提交”，<strong>事务B的更新在提交后才能被A看到</strong>。v1为1，v2为2，v3为2</li>
<li>若隔离级别是“可重复读”，事务在执行期间看到的数据前后必须是一致的。v1为1，v2为1，v3为2</li>
<li>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</li>
</ul>
<p>在实现上，数据库里面会创建一个<strong>视图</strong>，<strong>访问的时候以视图的逻辑结果为准</strong>。在<strong>“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</strong></p>
<p>在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，一定要记得将MySQL的隔离级别设置为“读提交”。</p>
<h4 id="配置隔离级别"><a href="#配置隔离级别" class="headerlink" title="配置隔离级别"></a>配置隔离级别</h4><p>配置的方式是，将启动参数<code>transaction-isolation</code>的值设置成<code>READ-COMMITTED</code>。你可以用<code>show variables</code>来查看当前的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'transaction_isolation';</span><br><span class="line">或 <span class="keyword">select</span> @@tx_isolation;</span><br><span class="line">mysql&gt;  set global transaction_isolation=0; -- 读未提交</span><br><span class="line">mysql&gt;  set global transaction_isolation=1; -- 读提交</span><br><span class="line">mysql&gt;  set global transaction_isolation=2; -- 可重复读</span><br><span class="line">mysql&gt;  set global transaction_isolation=3; -- 串行化</span><br><span class="line"><span class="keyword">set</span> [glogal|<span class="keyword">session</span>] <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> 隔离级别名称;</span><br></pre></td></tr></table></figure>
<p><strong>需要“可重复读”的场景</strong>：假设在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响校对结果。这时候使用“可重复读”隔离级别就很方便。<strong>事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</strong></p>
<h4 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h4><p>展开说明“可重复读”事务隔离的具体实现：</p>
<p>在MySQL中，实际上每条记录在<strong>更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值</strong>。假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录：</p>
<p><img src="https://api2.mubu.com/v3/document_image/e3437af8-6bab-4bcb-aa8a-6b603f4d1596-11197877.jpg" alt="回滚记录"></p>
<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，<strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong>。对于read-view A，要得到1，就<strong>必须将当前值依次执行图中所有的回滚操作得到</strong>。另外，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p>
<p><strong>回滚日志总不能一直保留，什么时候删除</strong>呢？答案是，<strong>在不需要的时候才删除</strong>。也就是说，<strong>系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除</strong>。</p>
<p>什么时候不需要？就是<strong>当系统里没有比这个回滚日志更早的read-view的时候。</strong></p>
<h4 id="为什么建议尽量不要使用长事务"><a href="#为什么建议尽量不要使用长事务" class="headerlink" title="为什么建议尽量不要使用长事务"></a>为什么建议尽量不要使用长事务</h4><p>长事务意味着系统里面会<strong>存在很老的事务视图</strong>。由于<strong>这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</strong></p>
<p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，<strong>即使长事务最终提交，回滚段被清理，文件也不会变小。若回滚段太大，最终只好为了清理回滚段，重建整个库。</strong> <strong>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库</strong></p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>MySQL的事务启动方式有以下几种：</p>
<ul>
<li><p>显式启动事务语句， <code>begin</code> 或 <code>start transaction</code>。配套的提交语句是<code>commit</code>，回滚语句是<code>rollback</code>。</p>
</li>
<li><p><code>set autocommit=0</code>，这个命令<strong>会将这个线程的自动提交关掉。意味着如果只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到主动执行commit 或 rollback 语句，或者断开连接。</strong></p>
</li>
</ul>
<p>有些客户端连接框架会默认连接成功后先执行一个<code>set autocommit=0</code>的命令。这就<strong>导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</strong></p>
<p>因此<strong>，建议总是使用<code>set autocommit=1</code>, 通过显式语句的方式来启动事务。</strong></p>
<p>对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果也有这个顾虑，建议使用commit work and chain语法: <strong>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</strong></p>
<p>可以在information_schema库的<code>innodb_trx</code>表中<strong>查询长事务</strong>，比如下面这个语句，用于查找持续时间超过60s的事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure>
<h4 id="如何避免长事务对业务的影响？"><a href="#如何避免长事务对业务的影响？" class="headerlink" title="如何避免长事务对业务的影响？"></a>如何避免长事务对业务的影响？</h4><p>从应用开发端和数据库端来看。</p>
<p><strong>首先，从应用开发端来看：</strong></p>
<ul>
<li><p>确认是否使用了set autocommit=0。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的<strong>目标就是把它改成1。</strong></p>
</li>
<li><p>确认是否有<strong>不必要的只读事务</strong>。有些框架会习惯不管什么语句先用begin/commit框起来。我见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务可以去掉。</p>
</li>
<li><p>业务连接数据库的时候，根据业务本身的预估，通过<code>SET MAX_EXECUTION_TIME</code>命令，来<strong>控制每个语句执行的最长时间，避免单个语句意外执行太长时间</strong>。</p>
</li>
</ul>
<p><strong>其次，从数据库端来看：</strong></p>
<ul>
<li><p>监控 <code>information_schema.Innodb_trx</code>表，<strong>设置长事务阈值，超过就报警/或者kill；</strong></p>
</li>
<li><p>Percona的pt-kill这个工具不错，推荐使用；</p>
</li>
<li><p>在业务功能测试阶段要求输出所有的general_log，<strong>分析日志行为提前发现问题</strong>；</p>
</li>
<li><p>如果使用的是MySQL 5.6或者更新版本，把<code>innodb_undo_tablespaces</code>设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/21/mysql_2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/mysql_2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">mysql日志系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-21 21:29:27" itemprop="dateCreated datePublished" datetime="2020-12-21T21:29:27+08:00">2020-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-30 13:43:39" itemprop="dateModified" datetime="2021-03-30T13:43:39+08:00">2021-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h3><p>MySQL可以恢复到半个月内任意一秒的状态，这是怎样做到的？</p>
<p>考虑一条更新语句的执行流程？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>
<p>更新语句会与查询语句有很多相似地方(连接、缓存查询，分析等)，与查询流程不一样的是，<strong>更新流程还涉及两个重要的日志模块</strong>：<code>redo log</code>（重做日志）和 <code>binlog</code>（归档日志）。</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>在MySQL里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了WAL技术，<strong>WAL的全称是Write-Ahead Logging，它的关键点是先写日志，再写磁盘。</strong></p>
<p>具体来说，当有一条记录需要更新的时候，<strong>InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做</strong>。</p>
<p>InnoDB的<strong>redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作</strong>。<strong>从头开始写，写到末尾就又回到开头循环写，如下面这个图所示：</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/fa0cd9fa-4d34-4017-b30d-84b7b04d3c4f-11197877.jpg" alt="redo_log"></p>
<p>write pos是<strong>当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头</strong>。checkpoint是<strong>当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</strong></p>
<p>write pos和checkpoint之间的是还空着的部分（write pos后面以及checkpoint前面的部分），可以用来记录新的操作。<strong>如果write pos追上checkpoint，表示log满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下</strong>。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<p><code>innodb_flush_log_at_trx_commit</code>这个参数设置成1的时候，表示<strong>每次事务的redo log都直接持久化到磁盘</strong>。这个参数建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p><strong>redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</strong></p>
<p>会有两份日志？因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，<strong>binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</strong></p>
<p>两种日志的不同点：</p>
<ul>
<li><p>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</p>
</li>
<li><p>redo log是<strong>物理日志，记录的是“在某个数据页上做了什么修改”</strong>；binlog是<strong>逻辑日志，记录的是这个语句的原始逻辑</strong>，比如“给ID=2这一行的c字段加1 ”。</p>
</li>
<li><p>redo log是<strong>循环写</strong>的，<strong>空间固定会用完</strong>；binlog是<strong>可以追加写入</strong>的。“追加写”是指<strong>binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</strong>。</p>
</li>
</ul>
<p><code>sync_binlog</code>这个参数设置成1的时候，表示<strong>每次事务的binlog都持久化到磁盘。这个参数建议设置成1，这样可以保证MySQL异常重启之后binlog不丢失</strong>。</p>
<p>执行器和InnoDB引擎在执行一个简单的update(<code>update T set c=c+1 where ID=2</code>)语句时的内部流程：</p>
<ul>
<li><p>执行器先找引擎取ID=2这一行。ID是<strong>主键</strong>，引擎直接用<strong>树搜索</strong>找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li><p>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，<strong>得到新的一行数据，再调用引擎接口写入这行新数据。</strong></p>
</li>
<li><p>引擎将这行<strong>新数据更新到内存中，同时将这个更新操作记录到redo log里面</strong>，此时<strong>redo log处于prepare状态</strong>。然后告知执行器执行完成了，随时可以提交事务。</p>
</li>
<li><p><strong>执行器生成这个操作的binlog，并把binlog写入磁盘。</strong></p>
</li>
<li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成<strong>提交（commit）状态，更新完成。</strong></p>
</li>
</ul>
<p>将redo log的写入拆成了两个步骤：prepare和commit，这就是<strong>“两阶段提交”</strong>。</p>
<h4 id="redo-log的两阶段提交"><a href="#redo-log的两阶段提交" class="headerlink" title="redo log的两阶段提交"></a>redo log的两阶段提交</h4><p>两阶段提交的目的是<strong>为了让两份日志之间的逻辑一致</strong>。</p>
<p>反证法：</p>
<p>仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p>
<ul>
<li><p><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。前面说过，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后会发现，<strong>如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</strong></p>
</li>
<li><p><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，<strong>由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</strong></p>
</li>
</ul>
<p>可以看到，<strong>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</strong></p>
<p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，可以这么做：</p>
<ul>
<li>首先，<strong>找到最近的一次全量备份</strong>，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到<strong>临时库</strong>；</li>
<li>然后，<strong>从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</strong></li>
</ul>
<p>这样临时库就跟误删之前的线上库一样了，然后可以<strong>把表数据从临时库取出来，按需要恢复到线上库去。</strong>不只是误操作后需要用这个过程来恢复数据。当需要<strong>扩容</strong>的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用<strong>全量备份加上应用binlog来实现的</strong>，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p>
<p>简单说，<strong>redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/20/mysql-5mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-mvcc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/20/mysql-5mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-mvcc/" class="post-title-link" itemprop="url">mysql性能优化-mvcc</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-20 17:02:01" itemprop="dateCreated datePublished" datetime="2020-12-20T17:02:01+08:00">2020-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-17 21:34:36" itemprop="dateModified" datetime="2021-03-17T21:34:36+08:00">2021-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>实验1:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> autocommit=<span class="keyword">off</span>;  </span><br><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> lastUpdate=<span class="keyword">now</span>() <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">--在未做commit/rollback操作之前  </span></span><br><span class="line"><span class="comment">--在其他的事务能不能进行对应数据的查询(特别是加上了X锁的数据)  </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">1</span>; </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>实验2:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> lastUpdate=<span class="keyword">now</span>() <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>两个实验从结果上来看是一致的，底层实现是一样的吗？跟MVCC有什么关系？ </p>
<h4 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC"></a>MVCC</h4><p>multiversion concurrency control （多版本并发控制）：并发访问(读或写)数据库时,对正在事务内处理的数据做多版本的管理。达到避免写操作的堵塞，从而引发读操作的并发问题。</p>
<p>MVCC插入逻辑流程 ：</p>
<p><img src="https://api2.mubu.com/v3/document_image/de8de1d3-76d7-4062-bbcd-82146470f0be-11197877.jpg" alt="MVCC插入逻辑流程"></p>
<p>MVCC删除逻辑流程：</p>
<p><img src="https://api2.mubu.com/v3/document_image/8e3f45d4-6284-44e3-a785-09c59fdeb861-11197877.jpg" alt="MVCC删除逻辑流程"></p>
<p>MVCC修改逻辑流程：</p>
<p><img src="https://api2.mubu.com/v3/document_image/d80ca7d4-6d88-495a-a294-2cf1e6d1d949-11197877.jpg" alt="MVCC修改逻辑流程"></p>
<p>MVCC查询逻辑流程:</p>
<p><img src="https://api2.mubu.com/v3/document_image/6bfce1c3-7ec8-4023-ad62-e14a1689f4e2-11197877.jpg" alt="MVCC查询逻辑流程"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/17/mysql-4mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/17/mysql-4mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%94%81/" class="post-title-link" itemprop="url">mysql性能优化-事务及锁</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-17 10:46:03" itemprop="dateCreated datePublished" datetime="2020-12-17T10:46:03+08:00">2020-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-17 21:31:54" itemprop="dateModified" datetime="2021-03-17T21:31:54+08:00">2021-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h4><ul>
<li>原子性(Atomicity) <strong>最小的工作单元</strong>，整个工作单元要么<strong>一起提交成功，要么全部失败回滚</strong>。  </li>
<li>一致性(Consistency) <strong>事务中操作的数据及状态改变是一致的</strong>，即写入资料的结果必须完全符合预设的规则，不会因为出现系统意外等原因导致状态的不一致。  </li>
<li>隔离性(Isolation) <strong>一个事务所操作的数据在提交之前，对其他事务的可见性设定(一般设定为不可见)。</strong>  </li>
<li>持久性(Durability) 事务所做的修改就会<strong>永久保存</strong>，不会因为系统意外导致数据的丢失。 </li>
</ul>
<h4 id="事务并发带来的的问题"><a href="#事务并发带来的的问题" class="headerlink" title="事务并发带来的的问题"></a>事务并发带来的的问题</h4><ul>
<li>脏读:<strong>在不同事务下，当前事务可以读到另外事务未提交的数据</strong>。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/1d32ed1d-7caa-4b42-9156-29eba926152b-11197877.jpg" alt="脏读"></p>
<ul>
<li>不可重复读：在<strong>一个事务内多次读取同一数据集合</strong>。<strong>在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。</strong></li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/e0c73513-4f11-4041-adfd-d9f751c73566-11197877.jpg" alt="不可重复读"></p>
<ul>
<li>幻读:本质上也属于不可重复读的情况，T1读取某个范围的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/7a4e33c7-588d-4c8e-a48c-ddbe6a23c54f-11197877.jpg" alt="幻读"></p>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul>
<li>未提交读：<strong>事务中的修改，即使没有提交，对其它事务也是可见的</strong><ul>
<li>存在脏读，不能解决并发问题</li>
</ul>
</li>
<li>Read Committed(提交读)：一个事务开始之后，只能看到自己提交的事务所做的修改。<ul>
<li>解决了脏读问题，没有解决不可重复读(nonrepeatable read) 问题</li>
</ul>
</li>
<li>Repeatable Read (可重复读)：在同一个事务中多次读取同样的数据结果是一样的。<ul>
<li>解决不可重复读问题，未定义解决幻读的问题</li>
</ul>
</li>
<li>Serializable (串行化)：解决所有问题 最高的隔离级别，通过强制事务的<strong>串行执行</strong> </li>
</ul>
<p>查看mysql的设置的事务隔离级别:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@tx_isolation; <span class="comment">--默认为REPEATABLE-READ</span></span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/69afe5ec-ba61-48fe-903e-063c2bf57fcc-11197877.jpg" alt="mysql事务隔离级别"></p>
<h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><h4 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h4><p>锁用于管理<strong>不同事务对共享资源的并发访问</strong>。</p>
<p>表锁与行锁的区别: </p>
<ul>
<li>锁定粒度:表锁 &gt; 行锁  </li>
<li>加锁效率:表锁 &gt; 行锁  </li>
<li>冲突概率:表锁 &gt; 行锁  </li>
<li>并发性能:表锁 &lt; 行锁  </li>
</ul>
<h4 id="InnoDB锁类型"><a href="#InnoDB锁类型" class="headerlink" title="InnoDB锁类型"></a>InnoDB锁类型</h4><p>InnoDB存储引擎支持行锁和表锁(另类的行锁)。</p>
<ul>
<li>共享锁(行锁):Shared Locks  <ul>
<li>又称为<strong>读锁</strong>，简称S锁，顾名思义，共享锁就是<strong>多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改</strong>； </li>
</ul>
</li>
<li>排它锁(行锁):Exclusive Locks  <ul>
<li>又称为<strong>写锁</strong>，简称X锁，<strong>排他锁不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的锁</strong>(共享锁、排他锁)，只有该获取了排他锁的事务是可以对数据行进行读取和修改，(<strong>其他事务要读取数据可来自于快照</strong>)。  </li>
</ul>
</li>
<li>意向锁共享锁(表锁):Intention Shared Locks  </li>
<li>意向锁排它锁(表锁):Intention Exclusive Locks  </li>
<li>自增锁:AUTO-INC Locks</li>
</ul>
<h5 id="表锁操作"><a href="#表锁操作" class="headerlink" title="表锁操作"></a>表锁操作</h5><p>共享锁加锁释放锁语法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;   </span><br><span class="line"><span class="keyword">commit</span>/<span class="keyword">rollback</span></span><br></pre></td></tr></table></figure>
<p>排它锁加锁释锁方式:  </p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> / <span class="keyword">update</span> / <span class="keyword">insert</span> 默认加上X锁  </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>  </span><br><span class="line"><span class="keyword">commit</span>/<span class="keyword">rollback</span></span><br></pre></td></tr></table></figure>
<p>行锁的算法：</p>
<ul>
<li>记录锁 Record Locks  </li>
<li>间隙锁 Gap Locks  </li>
<li>临键锁 Next-key Locks</li>
</ul>
<h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><ul>
<li>InnoDB的行锁是通过<strong>给索引上的索引项加锁</strong>来实现的。   </li>
<li><strong>只有通过索引条件进行数据检索，InnoDB才使用行级锁，</strong>否则，InnoDB 将使用表锁(锁住索引的所有记录)</li>
<li><p><strong>使用二级索引(辅助索引)去更新数据，会把二级索引和聚集索引都上锁</strong>。  </p>
</li>
<li><p>意向共享锁(IS)  ：表示事务<strong>准备</strong>给数据行加入共享锁，即<strong>一个数据行加共享锁前必须先取得该表的IS锁，意向共享锁之间是可以相互兼容的。</strong>  </p>
</li>
<li>意向排它锁(IX)  ：表示事务准备给数据行加入排他锁，即一个数据行加排他锁前必须先取得该表的IX锁，意向排它锁之间是可以相互兼容的。</li>
</ul>
<p>意向锁(IS、IX)是InnoDB数据操作之前<strong>自动加</strong>的，<strong>不需要用户干预</strong>。  </p>
<p>意义：当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁。 </p>
<h5 id="自增锁-AUTO-INC-Locks"><a href="#自增锁-AUTO-INC-Locks" class="headerlink" title="自增锁:AUTO-INC Locks"></a>自增锁:AUTO-INC Locks</h5><ul>
<li>针对<strong>自增列自增长</strong>的一个特殊的<strong>表级</strong>别锁  </li>
<li><code>show variables like &#39;innodb_autoinc_lock_mode&#39;;</code></li>
<li><strong>默认取值1，代表连续，事务未提交ID永久丢失</strong></li>
</ul>
<h5 id="临键锁Next-key-locks"><a href="#临键锁Next-key-locks" class="headerlink" title="临键锁Next-key locks"></a>临键锁Next-key locks</h5><p><img src="https://api2.mubu.com/v3/document_image/efa963f1-d97a-41c2-9151-53d963a0b882-11197877.jpg" alt="临键锁"></p>
<ul>
<li>锁住记录+区间(左开右闭)  </li>
<li><strong>当sql执行按照索引进行数据的检索时,查询条件为范围查找(between and、&lt;、&gt;等)并有数据命中则此时SQL语句加上的锁为Next-key locks，锁住索引的记录+区间(左开右闭)</strong> </li>
</ul>
<h5 id="间隙锁Gap-locks"><a href="#间隙锁Gap-locks" class="headerlink" title="间隙锁Gap locks"></a>间隙锁Gap locks</h5><p><img src="https://api2.mubu.com/v3/document_image/7a70a939-fb7c-4389-8bb2-ec5fb753a9d1-11197877.jpg" alt="间隙锁"></p>
<ul>
<li><strong>锁住数据不存在的区间</strong>(左开右开)  </li>
<li>当sql执行按照索引进行数据的检索时，<strong>查询条件的数据不存在，这时SQL语句加上的锁即为 Gap locks，锁住索引不存在的区间(左开右开)</strong>  </li>
</ul>
<h5 id="记录锁Record-locks"><a href="#记录锁Record-locks" class="headerlink" title="记录锁Record locks"></a>记录锁Record locks</h5><p><img src="https://api2.mubu.com/v3/document_image/bed5f5dc-376c-44a6-9022-d45a8da2b91c-11197877.jpg" alt="记录锁"></p>
<ul>
<li>锁住<strong>具体的索引项</strong>  </li>
<li>当sql执行<strong>按照唯一性(Primary key、Unique key)索引进行数据的检索</strong>时，查询条件等值匹 配且查询的数据存在，这时SQL语句加上的锁即为记录锁Record locks，<strong>锁住具体的索引项</strong>  </li>
</ul>
<h4 id="利用锁解决并发问题"><a href="#利用锁解决并发问题" class="headerlink" title="利用锁解决并发问题"></a>利用锁解决并发问题</h4><p>解决脏读 :</p>
<p><img src="https://api2.mubu.com/v3/document_image/e2cf51fb-3076-418d-a9dd-5316ed372267-11197877.jpg" alt="解决脏读"></p>
<p>解决不可重复读  :</p>
<p><img src="https://api2.mubu.com/v3/document_image/632f11ea-acd7-4adc-b2d3-819bb46c924c-11197877.jpg" alt="解决不可重复读"></p>
<p>解决幻读:</p>
<p><img src="https://api2.mubu.com/v3/document_image/cf157ef6-11cd-4f0c-befe-00c8ac992a70-11197877.jpg" alt="解决幻读"></p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul>
<li>多个并发事务(2个或者以上);  </li>
<li>每个事务都持有锁(或者是已经在等待锁);  </li>
<li>每个事务都需要再继续持有锁;  </li>
<li><strong>事务之间产生加锁的循环等待，形成死锁</strong>。</li>
</ul>
<h4 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h4><ul>
<li>类似的业务逻辑以<strong>固定的顺序访问表和行</strong>。  </li>
<li>大事务拆小。大事务更倾向于死锁，如果业务允许，<strong>将大事务拆小</strong>。  </li>
<li>在<strong>同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。</strong>  </li>
<li><strong>降低隔离级别</strong>，如果业务允许，将隔离级别调低也是较好的选择  </li>
<li>为表添加<strong>合理的索引</strong>。可以看到<strong>如果不走索引将会为表的每一行记录添 加上锁(或者说是表锁)</strong>  </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/14/mysql-3mysql%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%9C%BA%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/14/mysql-3mysql%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%9C%BA%E7%90%86/" class="post-title-link" itemprop="url">mysql性能分析-体系结构及运行机理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-14 09:38:25" itemprop="dateCreated datePublished" datetime="2020-12-14T09:38:25+08:00">2020-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-17 21:23:07" itemprop="dateModified" datetime="2021-03-17T21:23:07+08:00">2021-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Mysql体系结构"><a href="#Mysql体系结构" class="headerlink" title="Mysql体系结构"></a>Mysql体系结构</h3><p><img src="https://api2.mubu.com/v3/document_image/a1619f89-f86a-4530-ab7c-6db518222e98-11197877.jpg" alt="mysql体系结构"></p>
<ul>
<li><p>Client Connectors  </p>
<ul>
<li>接入方 支持协议很多  </li>
<li>Management Serveices &amp; Utilities 系统管理和控制工具，mysql dump、 mysql复制集群、分区管理等  </li>
</ul>
</li>
<li><p>Connection Pool  </p>
<ul>
<li>连接池:管理缓冲用户连接、用户名、<strong>密码、权限校验</strong>、线程处理等需要缓存的需求  </li>
</ul>
</li>
<li><p>SQL Interface  </p>
<ul>
<li>SQL接口:接受用户的SQL命令，并且返回用户需要查询的结果  </li>
</ul>
</li>
<li><p>Parser  </p>
<ul>
<li>解析器，SQL命令传递到解析器的时候会被<strong>解析器验证和解析</strong>。解析器是由Lex和YACC实现的  </li>
</ul>
</li>
<li><p>Optimizer  </p>
<ul>
<li>查询优化器，<strong>SQL语句在查询之前会使用查询优化器对查询进行优化</strong>  </li>
</ul>
</li>
<li><p>Cache和Buffer(高速缓存区)  </p>
<ul>
<li>查询缓存，如果<strong>查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据</strong>  </li>
</ul>
</li>
<li><p>pluggable storage Engines </p>
<ul>
<li>插件式存储引擎。<strong>存储引擎是MySql中具体的与文件打交道的子系统</strong>  </li>
</ul>
</li>
<li><p>file system  </p>
<ul>
<li>文件系统，数据、日志(redo，undo)、索引、错误日志、查询记录、慢查询等</li>
</ul>
</li>
</ul>
<h3 id="Mysql查询优化"><a href="#Mysql查询优化" class="headerlink" title="Mysql查询优化"></a>Mysql查询优化</h3><p><img src="https://api2.mubu.com/v3/document_image/38b5c5c9-ec61-4671-80ff-2eb68bbd83f1-11197877.jpg" alt="查询过程"></p>
<h4 id="client-server通信"><a href="#client-server通信" class="headerlink" title="client/server通信"></a>client/server通信</h4><p>Mysql客户端与服务端的通信方式是<strong>“半双工”;</strong>  </p>
<ul>
<li>全双工:双向通信，发送同时也可以接收(tcp握手过程)  </li>
<li>半双工:<strong>双向通信，同时只能接收或者是发送，无法同时做操作</strong>  <ul>
<li>半双工通信: 在任何一个时刻，要么是有服务器向客户端发送数据，要么是客户端向服务端发送数据，这<strong>两个动作不能同时发生</strong>。所以我们无法也无需将一个消息切成小块进行传输。  </li>
<li>特点和限制: 客户端一旦开始发送消息，另一端要接收完整个消息才能响应。  </li>
<li>客户端一旦开始接收数据没法停下来发送指令。  </li>
</ul>
</li>
<li>单工:只能单一方向传送  </li>
</ul>
<h4 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h4><p>对于一个mysql连接，或者说一个线程，时刻都有一个状态来标识这个连接正在做什么。</p>
<p>查看命令 <code>show full processlist / show processlist</code>  </p>
<p><img src="https://api2.mubu.com/v3/document_image/4e83270b-5e57-4839-8470-5e4141670dfc-11197877.jpg" alt="查询参数"></p>
<ul>
<li>Sleep:线程正在等待客户端发送数据  </li>
<li>Query:连接线程正在执行查询</li>
<li>Locked:线程正在等待表锁的释放  </li>
<li>Sorting result:线程正在对结果进行排序  </li>
<li>Sending data:向请求端返回数据</li>
</ul>
<p>可通过<code>kill {id}</code>的方式进行连接的杀掉 </p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><ul>
<li>工作原理:<ul>
<li>缓存SELECT操作的结果集和SQL语句</li>
<li>新的SELECT语句，先去查询缓存，判断是否存在可用的记录集</li>
</ul>
</li>
<li>判断标准: <ul>
<li>与缓存的SQL语句，<strong>是否完全一样</strong>，区分大小写(简单认为存储了一个key-value结构，<strong>key为sql，value为sql查询结果集</strong>)。</li>
</ul>
</li>
<li>几个关键字<ul>
<li>query_cache_type<ul>
<li>值:0 -– <strong>不启用</strong>查询缓存，<strong>默认值</strong></li>
<li>值:1 -– 启用查询缓存，<strong>只要符合查询缓存的要求，客户端的查询语句和记录集都可以缓存起来，供其他客户端使用，加上SQL_NO_CACHE将不缓存</strong></li>
<li>值:2 -– 启用查询缓存，只要<strong>查询语句中添加了参数:SQL_CACHE，且符合查询缓存的要求</strong>，客户端的查询语句和记录集，则可以缓存起来，供其他客户端使用</li>
</ul>
</li>
<li>query_cache_size  <ul>
<li>允许设置query_cache_size的值最小为40K，默认1M，推荐设置为:64M/128M</li>
</ul>
</li>
<li>query_cache_limit <ul>
<li>限制查询缓存区最大能缓存的查询记录集，默认设置为1M </li>
<li><code>show status like &#39;Qcache%&#39;</code>命令可查看缓存情况。  </li>
</ul>
</li>
</ul>
</li>
<li><p>不会缓存的情况</p>
<ul>
<li>当查询语句中有一些不确定的数据时，则不会被缓存。如包含函数NOW()，CURRENT_DATE()等类似的函数，或者用户自定义的函数，存储函数，用户变量等都不会被缓存。</li>
<li>当查询的结果大于query_cache_limit设置的值时，结果不会被缓存。</li>
<li>对于InnoDB引擎来说，<strong>当一个语句在事务中修改了某个表，那么在这个事务提交之前，所有与这个表相关的查询都无法被缓存。因此长时间执行事务，会大大降低缓存命中率。</strong>  </li>
<li>查询的表是系统表  </li>
<li>查询语句不涉及到表</li>
</ul>
</li>
<li><p>为什么mysql默认关闭了缓存开启  </p>
<ul>
<li>在查询之前必须<strong>先检查是否命中缓存,浪费计算资源。</strong></li>
<li>如果这个查询可以被缓存，那么执行完成后，MySQL发现查询缓存中没有这个查询，则会将结果存入查询缓存，这会带来额外的系统消耗。</li>
<li>针对表进行<strong>写入或更新数据时，将对应表的所有缓存都设置失效。</strong> </li>
<li>如果<strong>查询缓存很大或者碎片很多</strong>时，这个操作可能带来很大的系统消耗。</li>
</ul>
</li>
<li><p>缓存适用业务场景</p>
<ul>
<li>以<strong>读为主的业务</strong>，数据生成之后就不常改变的业务</li>
<li>比如门户类、新闻类、报表类、论坛类等  </li>
</ul>
</li>
</ul>
<h4 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h4><p>查询优化处理的三个阶段:  </p>
<ul>
<li>解析:解析sql通过lex<strong>词法分析</strong>，yacc语法分析将sql语句解析成<strong>解析树</strong>。</li>
<li>预处理阶段：根据mysql的语法的规则<strong>进一步检查解析树的合法性</strong>，如：<strong>检查数据的表和列是否存在，解析名字和别名的设置，还会进行权限的验证</strong>。</li>
<li>查询优化器 ：优化器的主要作用就是<strong>找到最优的执行计划</strong>。</li>
</ul>
<p>查询优化器如何找到最优执行计划：</p>
<ul>
<li>使用等价变化规则  <ul>
<li>数据表的关联并不总是按照查询语句的顺序进行。 </li>
<li>5=5 and a&gt;5 改写成 a&gt;5  ，a<b and a=5 改写成 b>5 and a=5  </li>
</ul>
</li>
<li>将外连接转化为内连接 <ul>
<li>并不是所有的OUTER JOIN都必须以外链接的方式进行。  </li>
</ul>
</li>
<li>优化count 、min、max等函数<ul>
<li>min函数只需找索引<strong>最左边</strong></li>
<li>max函数只需找索引最右边 </li>
<li>myisam引擎count(*)  </li>
</ul>
</li>
<li>覆盖索引扫描  </li>
<li>子查询优化</li>
<li>提前终止查询  <ul>
<li>用了<strong>limit关键字</strong>或者使用<strong>不存在的条件</strong></li>
</ul>
</li>
<li>IN的优化<ul>
<li>先进行<strong>排序</strong>，再采用<strong>二分查找</strong>的方式</li>
</ul>
</li>
</ul>
<p>Mysql的查询优化器基于<strong>成本计算</strong>的原则，会尝试各种执行计划，<strong>以数据抽样的方式进行试验(随机的读取一个4K的数据块进行分析)。</strong>可用explain来进行分析。</p>
<h4 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h4><p>调用插件式的存储引擎的原子API的功能进行执行计划的执行。 </p>
<h4 id="返回客户端"><a href="#返回客户端" class="headerlink" title="返回客户端"></a>返回客户端</h4><ul>
<li>有需要做缓存的，执行缓存操作。  </li>
<li>增量的返回结果：<strong>开始生成第一条结果时，mysql就开始往请求方逐步返回数据</strong>。  <ul>
<li>好处: mysql服务器无须保存过多的数据，浪费内存；用户体验好，马上就拿到了数据。 </li>
</ul>
</li>
</ul>
<h4 id="慢SQL"><a href="#慢SQL" class="headerlink" title="慢SQL"></a>慢SQL</h4><p>定位慢SQL:</p>
<ul>
<li>业务驱动  </li>
<li>测试驱动  </li>
<li>慢查询日志  </li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show variables like 'slow_query_log';</span><br><span class="line">set global slow_query_log = on;</span><br><span class="line">set global slow_query_log_file = '/var/lib/mysql/test-slow.log';   </span><br><span class="line">set global log_queries_not_using_indexes = on;</span><br><span class="line">set global long_query_time = 0.1;</span><br></pre></td></tr></table></figure>
<ul>
<li>慢查询日志分析</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/b4851df7-e19f-44fa-8b14-87d44517f53e-11197877.jpg" alt="慢查询日志分析"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time :日志记录的时间  </span><br><span class="line">User@Host:执行的用户及主机  </span><br><span class="line">Query_time:查询耗费时间  </span><br><span class="line">Lock_time 锁表时间  </span><br><span class="line">Rows_sent 发送给请求方的记录条数  </span><br><span class="line">Rows_examined 语句扫描的记录条数  </span><br><span class="line"><span class="keyword">SET</span> <span class="built_in">timestamp</span> 语句执行的时间点  </span><br><span class="line"><span class="keyword">select</span> .... 执行的具体语句</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -t 10 -s at /var/lib/mysql/test-slow.log</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/e937e8cb-5a7b-4587-89ba-fba600203b88-11197877.jpg" alt="慢查询工具"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShifuDong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShifuDong</p>
  <div class="site-description" itemprop="description">记录生活， 记录学习， 分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/mailto:sfd_w@foxmail.com" title="E-Mail → mailto:sfd_w@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShifuDong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  



    </div>
</body>
</html>
