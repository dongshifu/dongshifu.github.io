<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ShifuDong" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="记录生活， 记录学习， 分享知识">
<meta name="keywords" content="生活，C++, C, go, java, OS, 网络， 存储， 联邦学习， 机器学习，python">
<meta property="og:type" content="website">
<meta property="og:title" content="ShifuDong">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="ShifuDong">
<meta property="og:description" content="记录生活， 记录学习， 分享知识">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ShifuDong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShifuDong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Knowledge Sharing</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/25/os-%E7%BD%91%E7%BB%9C-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/os-%E7%BD%91%E7%BB%9C-3/" class="post-title-link" itemprop="url">TCP连接耗时</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-25 18:36:05" itemprop="dateCreated datePublished" datetime="2021-02-25T18:36:05+08:00">2021-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-01 15:02:25" itemprop="dateModified" datetime="2021-07-01T15:02:25+08:00">2021-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="TCP连接耗时"><a href="#TCP连接耗时" class="headerlink" title="TCP连接耗时"></a>TCP连接耗时</h3><p>开发过程中调用mysql, redis等组件获取数据或者执行rpc远程调用以及调用restful api的时候底层使用的是TCP协议。这是因为在传输层协议中，TCP协议具备可靠的连接，错误重传，拥塞控制等优点。</p>
<h4 id="正常的TCP连接建立过程"><a href="#正常的TCP连接建立过程" class="headerlink" title="正常的TCP连接建立过程"></a>正常的TCP连接建立过程</h4><p>在软中断中，当一个包被内核从<code>RingBuffer</code>中摘下来的时候，在内核中是用<code>struct sk_buff</code>结构体来表示的(参见内核代码<code>include/linux/skbuff.h</code>)。其中的data成员是接收到的数据，<strong>在协议栈逐层被处理的时候，通过修改指针指向data的不同位置，来找到每一层协议关心的数据。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/c89a0e92-adb3-4685-97f9-8e3ac4553a12-11197877.jpg" alt="网络包读取过程"></p>
<p>对于TCP协议包来说，它的Header中有一个重要的字段:flags,也就是<strong>标志位</strong>。</p>
<p>通过设置不同的标记为，可以将TCP包分成<code>SYNC、FIN、ACK、RST</code>等类型。客户端通过<code>connect</code>系统调用命令内核发出<code>SYNC、ACK</code>等包来实现和服务器TCP连接的建立。在服务器端，可能会接收许许多多的连接请求，内核还需要借助一些辅助数据结构-<strong>半连接队列和全连接队列</strong>。看一下整个连接过程：</p>
<p><img src="https://api2.mubu.com/v3/document_image/1b6c4373-b894-4e5d-a81f-de6e00f83d65-11197877.jpg" alt="TCP三次握手具体过程"></p>
<p>简单分析每一步的耗时：</p>
<ul>
<li>客户端发出SYNC包：客户端一般是通过<strong>connect系统调用</strong>来发出SYN的，这里牵涉到<strong>本机的系统调用和软中断的CPU耗时开销</strong></li>
<li><strong>SYN传到服务器</strong>：SYN从客户端网卡被发出，开始长途远距离的网络传输</li>
<li>服务器处理SYN包：<strong>内核通过软中断来收包，然后放到半连接队列中，然后再发出SYN/ACK响应。又是CPU耗时开销</strong></li>
<li><strong>SYC/ACK传到客户端</strong>：SYN/ACK从服务器端被发出后，同样进行一次长途网络跋涉</li>
<li>客户端处理SYN/ACK：客户端内核收包并处理SYN后，经过几us的CPU处理，接着发出ACK。同样是软中断处理开销</li>
<li><strong>ACK传到服务器</strong>：和SYN包，一样，再经过几乎同样远的路，传输一遍。 又一次长途网络跋涉</li>
<li>服务端收到ACK：<strong>服务器端内核收到并处理ACK，然后把对应的连接从半连接队列中取出来，然后放到全连接队列中。一次软中断CPU开销</strong></li>
<li>服务器端用户进程唤醒：<strong>正在被accpet系统调用阻塞的用户进程被唤醒，然后从全连接队列中取出来已经建立好的连接。一次上下文切换的CPU开销</strong></li>
</ul>
<p>以上操作主要可以分为两类：</p>
<ul>
<li>第一类是内核消耗CPU进行接收、发送或者是处理，包括系统调用、软中断和上下文切换。它们的耗时基本都是几个us左右</li>
<li>第二类是网络传输，当包被从一台机器上发出以后，中间要经过各式各样的网线、各种交换机路由器。所以<strong>网络传输的耗时相比本机的CPU处理，就要高的多了。根据网络远近一般在几ms~到几百ms不等。</strong></li>
</ul>
<p>1ms等于1000us，因此网络传输耗时比双端的CPU开销要高1000倍左右，甚至更高可能还到100000倍。所以，<strong>在正常的TCP连接的建立过程中，一般可以考虑网络延时即可</strong>。一个RTT指的是包从一台服务器到另外一台服务器的一个来回的延迟时间。所以从全局来看，TCP连接建立的网络耗时大约需要三次传输，再加上少许的双方CPU开销，总共大约比1.5倍RTT大一点点。不过从客户端视角来看，只要ACK包发出了，内核就认为连接是建立成功了。所以如果在客户端打点统计TCP连接建立耗时的话，只需要两次传输耗时-既1个RTT多一点的时间。（对于服务器端视角来看同理，从SYN包收到开始算，到收到ACK，中间也是一次RTT耗时）</p>
<h4 id="TCP连接建立时的异常情况"><a href="#TCP连接建立时的异常情况" class="headerlink" title="TCP连接建立时的异常情况"></a>TCP连接建立时的异常情况</h4><p>在正常情况下一次TCP连接总的耗时也就就大约是一次网络RTT的耗时。但在某些情况下，可能会导致连接时的网络传输耗时上涨、CPU处理开销增加、甚至是连接失败。</p>
<h5 id="客户端connect系统调用耗时失控"><a href="#客户端connect系统调用耗时失控" class="headerlink" title="客户端connect系统调用耗时失控"></a>客户端connect系统调用耗时失控</h5><p>正常一个系统调用的耗时也就是几个us（微秒）左右。但当TCP客户端TIME_WAIT有30000左右，<strong>导致可用端口不是特别充足的时候，connect系统调用的CPU开销直接上涨了100多倍，会达到毫秒级别。</strong></p>
<p>查看<strong>本机的端口内核参数配置</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysctl -a | grep ip_local_port_range</span><br><span class="line">net.ipv4.ip_local_port_range = 32768	60999</span><br></pre></td></tr></table></figure>
<p>可以看到内核分配的端口其实就3万个左右，<strong>当端口快占满的时候(TIME_WAIT过多)，端口的选择会十分耗时,且该段时间内cpu一直处于找空闲端口阶段，一直在占用CPU。</strong></p>
<p><strong>主要原因：临时端口选择过程是生成一个随机数，利用随机数在<code>ip_local_port_range</code>范围内取值，如果取到的值在<code>ip_local_reserved_ports</code>范围内 ，那就再依次取下一个值，直到不在<code>ip_local_reserved_ports</code>范围内为止。原来临时端口竟然是随机撞出来的。也就是说假如就有range里配置了5W个端口可以用，已经使用掉了49999个。那么新建立连接的时候，可能需要调用这个随机函数5W次才能撞到这个没用的端口身上。</strong></p>
<h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><ul>
<li><p><strong>保证可用临时端口的充裕，避免你的connect系统调用进入反复查找模式。正常端口充足的时候，只需要微秒几倍。但是一旦出现端口紧张，则一次系统调用耗时会上升到毫秒几倍，整整多出100倍。这个开销比正常tcp连接的建立吃掉的cpu时间（每个30usec左右）的开销要大的多。</strong></p>
<p>修改方法：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/sysctl.conf</span></span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可以考虑设置net.ipv4.tcp_tw_recycle和net.ipv4.tcp_tw_reuse这两个参数，避免端口长时间保守地等待2MSL时间。</strong></p>
</li>
<li>参考<a href="https://blog.csdn.net/enweitech/article/details/79261439" target="_blank" rel="noopener">https://blog.csdn.net/enweitech/article/details/79261439</a></li>
</ul>
<h5 id="半-全连接队列全满"><a href="#半-全连接队列全满" class="headerlink" title="半/全连接队列全满"></a>半/全连接队列全满</h5><p>如果连接建立的过程中，<strong>任意一个队列满了，那么客户端发送过来的syn或者ack就会被丢弃。客户端等待很长一段时间无果后，然后会发出TCP Retransmission重传。</strong></p>
<p>TCP<strong>握手超时重传的时间是秒级别的</strong>。也就是说一旦server端的连接队列导致连接建立不成功，那么光建立连接就至少需要秒级以上。而正常的在同机房的情况下只是不到1毫秒的事情，整整高了1000倍左右。尤其是对于给用户提供实时服务的程序来说，用户体验将会受到较大影响。如果连重传也没有握手成功的话，很可能等不及二次重试，这个用户访问直接就超时了。</p>
<p>更坏的情况是，它还有可能会影响其它的用户。假如使用的是进程/线程池这种模型提供服务，比如php-fpm。<strong>fpm进程是阻塞的，当它响应一个用户请求的时候，该进程是没有办法再响应其它请求的</strong>。假如开了100个进程/线程，而某一段时间内有50个进程/线程卡在和redis或者mysql服务器的握手连接上了（<strong>注意：这个时候服务器是TCP连接的客户端一方</strong>）。这一段时间内相当于可以用的正常工作的进程/线程只有50个了。而这个50个worker可能根本处理不过来，这时<strong>候服务可能就会产生拥堵。再持续稍微时间长一点的话，可能就产生雪崩了，整个服务都有可能会受影响。</strong></p>
<h5 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h5><p>查看服务是否有因为半/全连接队列满的情况发生。<strong>在客户端，可以抓包查看是否有SYN的TCP Retransmission。如果有偶发的TCP Retransmission，那就说明对应的服务端连接队列可能有问题了。</strong></p>
<p>在服务端的话，查看起来就更方便一些。<strong><code>netstat -s</code>可查看到当前系统半连接队列满导致的丢包统计，但该数字记录的是总丢包数。需要再借助<code>watch</code>命令动态监控。</strong>如果下面的数字在监控的过程中变了，那说明当前服务器有因为半连接队列满而产生的丢包。可能需要加大半连接队列的长度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ watch <span class="string">'netstat -s | grep LISTEN'</span></span><br></pre></td></tr></table></figure>
<p>对于全连接队列来说，查看方法也类似：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ watch <span class="string">'netstat -s  | grep overflowed'</span></span><br></pre></td></tr></table></figure>
<p><strong>如果服务因为队列满产生丢包，其中一个做法就是加大半/全连接队列的长度。 半连接队列长度Linux内核中，主要受<code>tcp_max_syn_backlog</code>影响 加大它到一个合适的值就可以。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span></span><br><span class="line">512</span><br><span class="line"><span class="comment"># echo "2048" &gt; /proc/sys/net/ipv4/tcp_max_syn_backlog</span></span><br></pre></td></tr></table></figure>
<p><strong>全连接队列长度是应用程序调用<code>listen</code>时传入的<code>backlog</code>以及内核参数<code>net.core.somaxconn</code>二者之中较小的那个。可能需要同时调整应用程序和该内核参数</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/net/core/somaxconn</span></span><br><span class="line">128</span><br><span class="line"><span class="comment"># echo "256" &gt; /proc/sys/net/core/somaxconn</span></span><br></pre></td></tr></table></figure>
<p>改完之后可以通过<code>ss</code>命令输出的<code>Send-Q</code>确认最终生效长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ss -nlt</span><br><span class="line">Recv-Q Send-Q Local Address:Port Address:Port</span><br><span class="line">0      128    *:80               *:*</span><br></pre></td></tr></table></figure>
<p><code>Recv-Q</code>告知<strong>当前该进程的全连接队列使用长度情况</strong>。<strong>如果<code>Recv-Q</code>已经逼近了<code>Send-Q</code>,那么可能不需要等到丢包也应该准备加大全连接队列。</strong></p>
<p>如果加大队列后仍然有非常偶发的队列溢出的话，可以暂且容忍。如果仍然有较长时间处理不过来怎么办？另外一个做法就是<strong>直接报错，不要让客户端超时等待。例如将Redis、Mysql等后端接口的内核参数<code>tcp_abort_on_overflow</code>为1。如果队列满了，直接发reset给client。告诉后端进程/线程不要痴情地傻等</strong>。这时候client会收到错误“connection reset by peer”。<strong>牺牲一个用户的访问请求，要比把整个站都搞崩了还是要强的。</strong></p>
<h4 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h4><p>参考<a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;mid=2247484126&amp;idx=1&amp;sn=4c35ea42477ffd5db5f05fe8bc850cdb&amp;chksm=a6e303e591948af3cc31b1db349958c8a879b9eb7100ebd138dc361aaf04ba5878f602a16365&amp;cur_album_id=1532487451997454337&amp;scene=189#rd" target="_blank" rel="noopener">张彦飞的博客</a>.可以得出的结论主要有：</p>
<p>TCP连接建立异常情况下，可能需要好几秒，一个坏处就是会影响用户体验，甚至导致当前用户访问超时都有可能。另外一个坏处是可能会诱发雪崩。所以当服务器使用短连接的方式访问数据的时候，一定要学会要监控服务器的连接建立是否有异常状态发生。如果有，学会优化掉它。当然可以采用本机内存缓存，或者使用连接池来保持长连接，通过这两种方式直接避免掉TCP握手挥手的各种开销也可以。</p>
<p>当连接队列溢出时需要特别注意：<strong>一旦发生队列满，当时撞上的那个连接请求就得需要长时间的连接建立延时。</strong></p>
<p>正常情况下，TCP建立的延时大约就是两台机器之间的一个RTT耗时，这是避免不了的。但是可以控制<strong>两台机器之间的物理距离</strong>来降低这个RTT，比如把要访问的redis尽可能地部署的离后端接口机器近一点，这样RTT也能从几十ms削减到最低可能零点几ms。</p>
<p><strong>线上部署时，理想的方案是将自己服务依赖的各种mysql、redis等服务和自己部署在同一个地区、同一个机房（再变态一点，甚至可以是甚至是同一个机架）。因为这样包括TCP链接建立啥的各种网络包传输都要快很多。要尽可能避免长途跨地区机房的调用情况出现。</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;mid=2247484126&amp;idx=1&amp;sn=4c35ea42477ffd5db5f05fe8bc850cdb&amp;chksm=a6e303e591948af3cc31b1db349958c8a879b9eb7100ebd138dc361aaf04ba5878f602a16365&amp;cur_album_id=1532487451997454337&amp;scene=189#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;mid=2247484126&amp;idx=1&amp;sn=4c35ea42477ffd5db5f05fe8bc850cdb&amp;chksm=a6e303e591948af3cc31b1db349958c8a879b9eb7100ebd138dc361aaf04ba5878f602a16365&amp;cur_album_id=1532487451997454337&amp;scene=189#rd</a></p>
<p><a href="https://mp.weixin.qq.com/s/tH8RFmjrveOmgLvk9hmrkw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/tH8RFmjrveOmgLvk9hmrkw</a></p>
<p><a href="https://blog.csdn.net/enweitech/article/details/79261439" target="_blank" rel="noopener">https://blog.csdn.net/enweitech/article/details/79261439</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/22/rabbitmq-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/22/rabbitmq-1/" class="post-title-link" itemprop="url">RabbitMQ简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-22 18:36:05" itemprop="dateCreated datePublished" datetime="2021-02-22T18:36:05+08:00">2021-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-13 09:35:41" itemprop="dateModified" datetime="2021-05-13T09:35:41+08:00">2021-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RabbitMQ/" itemprop="url" rel="index">
                    <span itemprop="name">RabbitMQ</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h3><h4 id="Message-Broker（消息代理）"><a href="#Message-Broker（消息代理）" class="headerlink" title="Message Broker（消息代理）"></a>Message Broker（消息代理）</h4><p>RabbitMQ 官网对 Message broker 的定义：Message broker <strong>接收来自发布者的消息并将其路由到消费者。</strong></p>
<p>RabbitMQ 实现了一个加  AMQP（Advanced Message Queuing Protocol）的协议，AMQP 就如互联网的 HTTP 协议，它<strong>更注重于如何传输数据，并不关心发送的数据是什么</strong>。这也就意味着<strong>需要消息的发送者和接收者来协调消息的格式。</strong></p>
<h4 id="Message-Broker的作用"><a href="#Message-Broker的作用" class="headerlink" title="Message Broker的作用"></a>Message Broker的作用</h4><p>有这样一个应用，客户端需要与服务器进行通信，传递数据。最简单的情况就是客户端通过 HTTP 类协议直接与服务器连接，并发送数据。看似非常简单，但如果服务器因为维护或其它原因发生了停机，或者想对其横向扩展，添加更多的服务器来进行响应。那么问题就来了，<strong>客户端目前是与这台服务器紧密的耦合在一起了，而随着系统的增长和进化，这种紧耦合就开始让人头疼。</strong></p>
<p>此时，如果在客户端和服务器之间放置一个Message broker则不一样：</p>
<p><img src="https://i0.hdslb.com/bfs/article/99b7a06fd5309c70c18e23d9e70b31af2d7e0e43.png@1248w_504h.png" alt="在客户端和服务器之间添加Message broker"></p>
<p><strong>客户端首先将数据发送给 Message broker。Message broker 会对数据进行检验，并将其发送给服务器。</strong>但是在这种简单的情景下，似乎没带来什么好处。然而，Message broker 可以通过简单的设置来允许多种场景，从而让<strong>后端服务器的横向扩展或停机维护</strong>等工作变得轻松，并且<strong>客户端并不会感知到任何的变化。</strong></p>
<h4 id="Exchange和Queue"><a href="#Exchange和Queue" class="headerlink" title="Exchange和Queue"></a>Exchange和Queue</h4><p>在最简单的场景下，RabbitMQ 的架构示意图大致如下：</p>
<p><img src="https://i0.hdslb.com/bfs/article/bf0f6ae284810963816540237726112522acad3b.png@1248w_396h.png" alt="Rabbitmq架构"></p>
<ul>
<li>首先某个消息从发布者那里发往 RabbitMQ</li>
<li>这个<strong>消息需要声明一个 Exchange（交换机）</strong>，并被发往这个 Exchange<ul>
<li>Exchange 有点类似<strong>“暂存区”</strong>，消息都会发往 Exchange。用个类比来说：Exchange 就像邮箱一样，写的信件首先都要放到邮箱里才能进行发送。</li>
</ul>
</li>
<li>然后，Exchange 将使用消息内的一些<strong>信息</strong>以及它自己的<strong>配置</strong>来决定<strong>一条或多条发送消息的路由。</strong></li>
<li>这些路由都通向一个 Queue（队列），<strong>消息会存储在这个 Queue 里，等待消息的接收者来进行使用。</strong></li>
<li>一个消息的接收者可以使用 Queue 中的信息。<strong>一旦确认这个消息被传递成功，那么它将从 Queue 中被删除。</strong><ul>
<li>RabbitMQ 所提供的<strong>松耦合</strong>的特性，主要是因为 <strong>Exchange 和 Queue 的分离</strong>。</li>
<li>继续使用邮箱的类比，<strong>Queue 就相当于是接收信件的邮箱。而根据邮件地址，邮件系统会选择不同的邮箱来接收邮件。</strong></li>
</ul>
</li>
</ul>
<p>RabbitMQ的4种Exchange:</p>
<ul>
<li><p>Direct Exchange。是默认的 Exchange ，<strong>会把消息发送到一个接收者。如果注册了多个接收者来监听同样的路由 Key，那么 RabbitMQ 将会向每个 Queue 轮流发送一条消息，相当于提供了一个简单的负载均衡</strong></p>
</li>
<li><p>Fanout Exchange。 把消息的<strong>副本</strong>发送到<strong>每个绑定到该 Exchange 的 Queue 上面</strong>。而这里的 <strong>Queue 没有办法对消息进行过滤，如果需要过滤，则需要在消息接收者那里实现。</strong></p>
</li>
<li><p>Topic Exchange。和 Direct Exchange 类似，但不同的是：<strong>每个消息接收者监听特定的路由 Key，它们会收到消息的副本。</strong></p>
<ul>
<li>例如聊天室就可以使用 Topic Exchange。每个聊天室的 ID 可以作为路由 Key，这样就可以<strong>保证消息只会发送给同一个聊天室的其他参与者。</strong></li>
</ul>
</li>
<li><p>Headers Exchange。<strong>这类 Exchange 会忽略路由 Key，取而代之的是，它们会查看消息的 Header，并由此来决定消息应该发往哪个 Queue。Queue 可以有一个或多个 Header 用来进行匹配。这也就开启了复杂的路由场景</strong>，例如某个 Queue 有时可以接收到某类消息而有时则不行。</p>
</li>
</ul>
<h4 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h4><p>当消息被发往 RabbitMQ 的时候，需要<strong>指明它需要发送到哪个 Exchange。而这个 Exchange 就可以被设置成为所谓的 Fanout Exchange。</strong>使用 Fanout Exchange，<strong>消息会被克隆，并被发送到所有与这个 Exchange 绑定的 Queue 上</strong>.</p>
<p><img src="https://i0.hdslb.com/bfs/article/f1d5f471ddcf9493a2a3a4f0d28ad843e01ea3c4.png@1248w_716h.png" alt="fanout exchange"></p>
<p>这里每一个 Queue 都会得到属于自己的消息的副本，这些消息副本就可以被消息的接收者所使用。</p>
<ul>
<li>在很多大规模多人游戏的场景中，经常使用这种方式来同步玩家的数据：每个玩家都订阅到一个 Fanout Exchange，游戏的实例只需要将数据发送到一个地方即可，游戏中其他的玩家就会获得更新，而游戏实例就不需要知道如何数据发往每一个玩家了。</li>
</ul>
<h4 id="基本管理命令"><a href="#基本管理命令" class="headerlink" title="基本管理命令"></a>基本管理命令</h4><p>基本安装和配置参考RabbitMQ官网。</p>
<ul>
<li>获取RabbitMQ Server状态: <code>rabbitmqctl status</code> 得到大量关于RabbitMQ运行的消息</li>
<li>获取所有Queue队列： <code>rabbitmqctl list_queues</code></li>
<li>获取当前集群的server信息： <code>rabbitmqctl cluster_status</code></li>
<li>使用<code>service rabbitmq-server start/stop/restart/status</code>也可以进行服务管理</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.bilibili.com/read/cv10512424?from=search" target="_blank" rel="noopener">https://www.bilibili.com/read/cv10512424?from=search</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/20/os-%E7%BD%91%E7%BB%9C-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/20/os-%E7%BD%91%E7%BB%9C-2/" class="post-title-link" itemprop="url">网络调优工具使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-20 18:36:05" itemprop="dateCreated datePublished" datetime="2021-02-20T18:36:05+08:00">2021-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-13 10:25:41" itemprop="dateModified" datetime="2021-05-13T10:25:41+08:00">2021-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://api2.mubu.com/v3/document_image/be5fa6e0-26bb-4ba7-8337-6a6991d28593-11197877.jpg" alt="linux内核接收网络包的过程"></p>
<p>linux内核对网络包的接收过程大致分为：硬中断处理、接收数据到RingBuffer、ksoftirqd软中断处理几个过程。在软中断处理中，将数据包从RingBuffer中获取送到协议栈进行处理，之后再送到用户进程socket的接收队列中。</p>
<h3 id="几个工具"><a href="#几个工具" class="headerlink" title="几个工具"></a>几个工具</h3><p>监控网卡的工具：</p>
<h4 id="ethtool"><a href="#ethtool" class="headerlink" title="ethtool"></a>ethtool</h4><p>该工具用来<strong>查看和设置网卡参数</strong>。这个工具其实本身只是提供几个通用接口，<strong>真正的实现是都是在网卡驱动中</strong>。几个选项：</p>
<ul>
<li><code>-i</code> 显示<strong>网卡驱动</strong>的信息，如驱动的名称、版本等</li>
<li><code>-S</code> 查看网卡<strong>收发包</strong>的统计情况</li>
<li><code>-g/-G</code> <strong>查看或者修改RingBuffer的大小</strong></li>
<li><code>-l/-L</code> 查看或者修改<strong>网卡队列</strong>数</li>
<li><code>-c/-C</code> 查看或者修改<strong>硬中断合并策略</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网卡驱动：</span></span><br><span class="line"><span class="variable">$ethtool</span> -i eno1</span><br><span class="line"></span><br><span class="line">driver: e1000e</span><br><span class="line">version: 3.2.6-k</span><br><span class="line">firmware-version: 0.13-4</span><br></pre></td></tr></table></figure>
<h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p>网络管理工具ifconfig不只是可以为网卡配置ip，启动或者禁用网卡，也包含了一<strong>些网卡的统计信息</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">eno1      Link encap:以太网  硬件地址 98:90:96:a5:4c:a7  </span><br><span class="line">          inet 地址:172.27.229.18  广播:172.27.255.255  掩码:255.255.0.0</span><br><span class="line">          inet6 地址: fe80::aea1:731a:3687:7f4a/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  跃点数:1</span><br><span class="line">          接收数据包:10938370 错误:0 丢弃:0 过载:0 帧数:0</span><br><span class="line">          发送数据包:1479049 错误:0 丢弃:0 过载:0 载波:0</span><br><span class="line">          碰撞:0 发送队列长度:1000 </span><br><span class="line">          接收字节:2793457160 (2.7 GB)  发送字节:187860463 (187.8 MB)</span><br><span class="line">          中断:20 Memory:f7d00000-f7d20000 </span><br><span class="line">          </span><br><span class="line">中英文对应：      </span><br><span class="line">    RX packets：接收的总包数</span><br><span class="line">    RX bytes：接收的字节数</span><br><span class="line">    RX errors：表示总的收包的错误数量</span><br><span class="line">    RX dropped：数据包已经进入了 Ring Buffer，但是由于其它原因导致的丢包</span><br><span class="line">    RX overruns：表示了 fifo 的 overruns，这是由于 Ring Buffer不足导致的丢包</span><br></pre></td></tr></table></figure>
<h4 id="伪文件系统-proc"><a href="#伪文件系统-proc" class="headerlink" title="伪文件系统/proc"></a>伪文件系统/proc</h4><p>Linux内核提供了<code>/proc</code>伪文件系统，通过<code>/proc</code>可以查看<strong>内核内部数据结构、改变内核设置</strong>。</p>
<p>主要内容：</p>
<ul>
<li><code>/proc/sys</code>目录可以查看或修改<strong>内核参数</strong></li>
<li><code>/proc/cpuinfo</code>可以查看CPU信息</li>
<li><code>/proc/meminfo</code>可以查看内存信息</li>
<li><code>/proc/interrupts</code>统计所有的<strong>硬中断</strong></li>
<li><code>/proc/softirqs</code>统计的所有的<strong>软中断</strong>信息</li>
<li><code>/proc/slabinfo</code>统计了内核数据结构的<strong>slab内存</strong>使用情况</li>
<li><code>/proc/net/dev</code>可以看到一些<strong>网卡</strong>统计数据</li>
</ul>
<p>关注伪文件 <code>/proc/net/dev</code>查看内核中对网卡的相关统计，包含的主要信息：</p>
<ul>
<li>bytes: 发送或接收的数据的总<strong>字节</strong>数</li>
<li>packets: 接口发送或接收的数据<strong>包</strong>总数</li>
<li>errs: 由设备驱动程序检测到的发送或接收错误的总数</li>
<li>drop: 设备驱动程序<strong>丢弃的数据包总数</strong></li>
<li>fifo: FIFO<strong>缓冲区错误</strong>的数量</li>
<li>frame: The number of packet framing errors.（分组帧错误的数量）</li>
<li>colls: 接口上检测到的冲突数</li>
</ul>
<h4 id="伪文件系统sysfs"><a href="#伪文件系统sysfs" class="headerlink" title="伪文件系统sysfs"></a>伪文件系统sysfs</h4><p><code>sysfs</code>和<code>/proc</code>类似，也是一个伪文件系统，但是比<code>proc</code>更新，结构更清晰。其中的<code>/sys/class/net/eno1/statistics/</code>也包含了网卡的统计信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd /sys/class/net/eno1/statistics/ </span></span><br><span class="line"><span class="comment"># grep . * | grep tx</span></span><br><span class="line"></span><br><span class="line">tx_aborted_errors:0</span><br><span class="line">tx_bytes:193280753</span><br><span class="line">tx_carrier_errors:0</span><br><span class="line">tx_compressed:0</span><br><span class="line">tx_dropped:0</span><br><span class="line">tx_errors:0</span><br><span class="line">tx_fifo_errors:0</span><br><span class="line">tx_heartbeat_errors:0</span><br><span class="line">tx_packets:1513872</span><br><span class="line">tx_window_errors:0</span><br></pre></td></tr></table></figure>
<h4 id="RingBuffer监控和调优"><a href="#RingBuffer监控和调优" class="headerlink" title="RingBuffer监控和调优"></a>RingBuffer监控和调优</h4><p>当网线中的数据帧到达网卡后，第一站就是RingBuffer（网卡通过DMA机制将数据帧送到RingBuffer中）。</p>
<p>使用<code>ethtool</code>查看RingBuffer:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ethtool -g eno1</span></span><br><span class="line"></span><br><span class="line">Ring parameters <span class="keyword">for</span> eno1:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:		4096</span><br><span class="line">RX Mini:	0</span><br><span class="line">RX Jumbo:	0</span><br><span class="line">TX:		4096</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:		256</span><br><span class="line">RX Mini:	0</span><br><span class="line">RX Jumbo:	0</span><br><span class="line">TX:		256</span><br></pre></td></tr></table></figure>
<p>本机器的网卡设置RingBuffer最大允许到4096,实际设置为256。</p>
<p>注意：ethtool查看到的是实际是<code>Rx bd</code>的大小。<strong><code>Rx bd</code>位于网卡中，相当于一个指针。<code>RingBuffer</code>在内存中，<code>Rx bd</code>指向<code>RingBuffer</code>。<code>Rx  bd</code>和<code>RingBuffer</code>中的元素是一一对应的关系</strong>。在网卡启动的时候，内核会为网卡的<code>Rx  bd</code>在内存中分配<code>RingBuffer</code>，并设置好对应关系。</p>
<p>在Linux的整个网络栈中，<code>RingBuffer</code>起到一个任务的收发中转站的角色。<strong>对于接收过程来讲，网卡负责往<code>RingBuffer</code>中写入收到的数据帧，<code>ksoftirqd</code>内核线程负责从中取走处理。只要<code>ksoftirqd</code>线程工作的足够快，<code>RingBuffer</code>这个中转站就不会出现问题</strong>。但是设想一下，<strong>假如某一时刻，瞬间来了特别多的包，而<code>ksoftirqd</code>处理不过来了，会发生什么？这时<code>RingBuffer</code>可能瞬间就被填满了，后面再来的包网卡直接就会丢弃，不做任何处理！</strong></p>
<p>查看机器上是否有因为RingBuffer设置导致的丢包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ethtool -S eno1</span></span><br><span class="line"></span><br><span class="line">rx_fifo_errors: 0 <span class="comment">#有的机器上不一定有</span></span><br><span class="line">tx_fifo_errors: 0</span><br></pre></td></tr></table></figure>
<p><code>rx_fifo_errors</code>如果不为0的话（在 <code>ifconfig</code>中体现为<code>overruns</code>  指标增长），就表示有包因为<code>RingBuffer</code>装不下而被丢弃了。那么怎么解决这个问题呢？很自然首先想到的是，加大<code>RingBuffer</code>这个“中转仓库”的大小。通过<code>ethtool</code>就可以修改:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ethtool -G eth1 rx 512 tx 512</span></span><br></pre></td></tr></table></figure>
<p>这样网卡会被分配更大一点的”中转站“，可以<strong>解决偶发的瞬时的丢包</strong>。不过这种方法有个<strong>小副作用，那就是排队的包过多会增加处理网络包的延时。</strong>所以另外一种解决思路更好，那就是<strong>让内核处理网络包的速度更快一些，而不是让网络包傻傻地在<code>RingBuffer</code>中排队。</strong>怎么加快内核消费RingBuffer中任务的速度?</p>
<h4 id="硬中断监控与调优"><a href="#硬中断监控与调优" class="headerlink" title="硬中断监控与调优"></a>硬中断监控与调优</h4><h5 id="监控部分"><a href="#监控部分" class="headerlink" title="监控部分"></a>监控部分</h5><p>硬中断可以通过内核提供的伪文件<code>/proc/interrupts</code>来查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/interrupts</span><br><span class="line"></span><br><span class="line">           CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7       </span><br><span class="line"> 31:          0          0          0          0          0        536          0    4507261  IR-PCI-MSI 409600-edge      eno1</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>网卡的输入队列<code>eno1</code>的中断号是31</li>
<li>31号中断由CPU5和CPU7来处理</li>
</ul>
<p>注意：</p>
<ul>
<li>为什么输入队列的中断在CPU5和CPU7上？</li>
</ul>
<p>这是因为内核的一个配置，在伪文件系统中可以查看到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat /proc/irq/31/smp_affinity</span></span><br><span class="line">80</span><br></pre></td></tr></table></figure>
<p><code>smp_affinity</code>里是CPU的亲和性的绑定，80是二进制的<code>01010000</code>,第5位和第7位都为1，代表的就是第5和第7个CPU核心CPU5和CPU7。</p>
<ul>
<li>对于收包来过程来讲，硬中断的总次数表示的是Linux收包总数吗？</li>
</ul>
<p>不是，<strong>硬件中断次数不代表总的网络包数。第一网卡可以设置中断合并，多个网络帧可以只发起一次中断。第二NAPI 运行的时候会关闭硬中断，通过poll来收包。</strong></p>
<h5 id="多队列网络调优"><a href="#多队列网络调优" class="headerlink" title="多队列网络调优"></a>多队列网络调优</h5><p>现在的主流网卡基本上都是支持多队列的，可以<strong>通过将不同的队列分给不同的CPU核心来处理，从而加快Linux内核处理网络包的速度。这是最为有用的一个优化手段</strong>。</p>
<p><strong>每一个队列都有一个中断号，可以独立向某个CPU核心发起硬中断请求，让CPU来<code>poll</code>包。通过将接收进来的包被放到不同的内存队列里，多个CPU就可以同时分别向不同的队列发起消费了。这个特性叫做RSS（Receive Side Scaling，接收端扩展）</strong>。通过<code>ethtool</code>工具可以查看网卡的队列情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ethtool -l eth0 # 本人网卡不支持该操作，参考开发内功修炼</span></span><br><span class="line">Channel parameters <span class="keyword">for</span> eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:     0</span><br><span class="line">TX:     0</span><br><span class="line">Other:      1</span><br><span class="line">Combined:   63</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:     0</span><br><span class="line">TX:     0</span><br><span class="line">Other:      1</span><br><span class="line">Combined:   8</span><br></pre></td></tr></table></figure>
<p>上述结果表示当前网卡支持的最大队列数是63，当前开启的队列数是8。对于这个配置来讲，最多同时可以有8个核心来参与网络收包。<strong>如果想提高内核收包的能力，直接简单加大队列数就可以了，这比加大RingBuffer更为有用。因为加大RingBuffer只是给个更大的空间让网络帧能继续排队，而加大队列数则能让包更早地被内核处理</strong>。<code>ethtool</code>修改队列数量方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ethtool -L eth0 combined 32</span></span><br></pre></td></tr></table></figure>
<p><strong>硬中断发生在哪一个核上，它发出的软中断就由哪个核来处理。所有通过加大网卡队列数，这样硬中断工作、软中断工作都会有更多的核心参与进来。</strong></p>
<p>每一个队列都有一个中断号，每一个中断号都是绑定在特定的CPU上。如果不满意某一个中断的CPU绑定，可以通过修改<code>/proc/irq/{中断号}/smp_affinity</code>来实现。</p>
<h5 id="硬中断合并"><a href="#硬中断合并" class="headerlink" title="硬中断合并"></a>硬中断合并</h5><p>一个实际中的例子，假如你是一位开发同学，和你对口的产品经理一天有10个小需求需要让你帮忙来处理。她对你有两种中断方式：</p>
<ul>
<li>第一种：产品经理想到一个需求，就过来找你，和你描述需求细节，然后让你帮你来改</li>
<li>第二种：产品经理想到需求后，不来打扰你，等攒够5个来找你一次，你集中处理</li>
</ul>
<p>现在不考虑及时性，<strong>只考虑工作整体效率</strong>，哪种方案下你的工作效率会高呢？或者换句话说，你更喜欢哪一种工作状态呢？很明显，只要你是一个正常的开发，都会觉得第二种方案更好。对人脑来讲，频繁的中断会打乱你的计划，你脑子里刚才刚想到一半技术方案可能也就废了。当产品经理走了以后，你再想捡起来刚被中断之的工作的时候，很可能得花点时间回忆一会儿才能继续工作。</p>
<p>对于CPU来讲也是一样，<strong>CPU要做一件新的事情之前，要加载该进程的地址空间，load进程代码，读取进程数据，各级别cache要慢慢热身。因此如果能适当降低中断的频率，多攒几个包一起发出中断，对提升CPU的工作效率是有帮助的</strong>。所以，网卡允许我们对硬中断进行合并。</p>
<p>现在看一下网卡的硬中断合并配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ethtool -c eno1</span></span><br><span class="line"></span><br><span class="line">Adaptive RX: off  TX: off</span><br><span class="line">...</span><br><span class="line">rx-usecs: 3</span><br><span class="line">rx-frames: 0</span><br><span class="line">rx-usecs-irq: 0</span><br><span class="line">rx-frames-irq: 0</span><br><span class="line">rx-usecs-low: 0</span><br><span class="line">rx-frame-low: 0</span><br><span class="line">rx-usecs-high: 0</span><br><span class="line">rx-frame-high: 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>参数的含义：</p>
<ul>
<li>Adaptive RX: <strong>自适应中断合并</strong>，网卡驱动自己判断啥时候该合并啥时候不合并</li>
<li>rx-usecs：当过这么长时间过后，一个RX interrupt就会被产生</li>
<li>rx-frames：当累计接收到这么多个帧后，一个RX interrupt就会被产生</li>
</ul>
<p>修改相关参数：接使用<code>ethtool -C</code>就可以</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ethtool -C eno1 adaptive-rx on</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<strong>减少中断数量虽然能使得Linux整体吞吐更高，不过一些包的延迟也会增大，所以用的时候得适当注意。</strong></p>
<h4 id="软中断监控和调优"><a href="#软中断监控和调优" class="headerlink" title="软中断监控和调优"></a>软中断监控和调优</h4><p><strong>软中断和它对应的硬中断是在同一个核心上处理的。因此，前面硬中断分散到多核上处理的时候，软中断的优化其实也就跟着做了，也会被多核处理。</strong>不过软中断也还有自己的可优化选项。</p>
<h5 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h5><p>软中断的信息可以从<code>/proc/softirqs</code>读取：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/softirqs</span><br><span class="line"></span><br><span class="line">                    CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7       </span><br><span class="line">          HI:          0          0    1228152        865        360          7          0          0</span><br><span class="line">       TIMER:   27307279   27853788   27665421   31261338   27720654   27228264   27604399   29304702</span><br><span class="line">      NET_TX:      10611         21      33099       1480        103      39090         43         56</span><br><span class="line">      NET_RX:     936563     934954     932782     903383     896445     940357    1111527   11896810</span><br><span class="line">       BLOCK:        293    1850485      65944        395        365        332        354        333</span><br><span class="line">    IRQ_POLL:          0          0          0          0          0          0          0          0</span><br><span class="line">     TASKLET:         18          4     104755         75         25         84        748       8691</span><br><span class="line">       SCHED:   15801149   13822836   13336518   16738535   13374504   13423444   13224695   14819090</span><br><span class="line">     HRTIMER:          0          0          0          0          0          0          0          0</span><br><span class="line">         RCU:   23189803   22923131   23217378   25381785   22908760   22872174   23143036   24117847</span><br></pre></td></tr></table></figure>
<h5 id="软中断budget调整"><a href="#软中断budget调整" class="headerlink" title="软中断budget调整"></a>软中断budget调整</h5><p>番茄工作法：大致意思就是要有一整段的不被打扰的时间，集中精力处理某一项作业。这一整段时间时长被建议是25分钟。<strong>对于Linux的处理软中断的ksoftirqd来说，它也和番茄工作法思路类似。一旦它被硬中断触发开始了工作，它会集中精力处理一波网络包（绝不只是1个），然后再去做别的事情。</strong></p>
<p>处理一波是多少呢，策略略复杂。只说其中一个比较容易理解的，那就是<code>net.core.netdev_budget</code>内核参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -a | grep core.netdev_budget </span></span><br><span class="line"></span><br><span class="line">net.core.netdev_budget = 300</span><br></pre></td></tr></table></figure>
<p>这里的意思说的是，<strong>ksoftirqd一次最多处理300个包，处理够了就会把CPU主动让出来，以便Linux上其它的任务可以得到处理</strong>。那么假如说，<strong>现在想提高内核处理网络包的效率。那就可以让ksoftirqd进程多干一会儿网络包的接收，再让出CPU。至于怎么提高，直接修改不这个参数的值就行。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.core.netdev_budget=600</span></span><br></pre></td></tr></table></figure>
<p>如果<strong>要保证重启仍然生效，需要将这个配置写到<code>/etc/sysctl.conf</code></strong></p>
<h5 id="软中断GRO合并"><a href="#软中断GRO合并" class="headerlink" title="软中断GRO合并"></a>软中断GRO合并</h5><p>GRO和硬中断合并的思想很类似，不过阶段不同。<strong>硬中断合并是在中断发起之前，而GRO已经到了软中断上下文中了。</strong></p>
<p>如果应用中是大文件的传输，大部分包都是一段数据，不用GRO的话，会每次都将一个小包传送到协议栈（IP接收函数、TCP接收）函数中进行处理。<strong>开启GRO的话，Linux就会智能进行包的合并，之后将一个大包传给协议处理函数。这样CPU的效率也是就提高了。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ethtool -k eno1 | grep generic-receive-offload</span></span><br><span class="line">generic-receive-offload: on</span><br></pre></td></tr></table></figure>
<p>如果网卡驱动没有打开GRO的话，可以通过如下方式打开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ethtool -K eno1  gro on</span><br></pre></td></tr></table></figure>
<p>GRO说的仅仅只是包的接收阶段的优化方式，对于发送来说是GSO。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;mid=2247484065&amp;idx=1&amp;sn=ab0d3e11c472b845dedf6a87dcc38b25&amp;chksm=a6e3039a91948a8c23ec7d426469ebe30d70f59c7a58437e9ea8b8aac697aa1e2e29b4c47dec&amp;scene=178&amp;cur_album_id=1532487451997454337#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;mid=2247484065&amp;idx=1&amp;sn=ab0d3e11c472b845dedf6a87dcc38b25&amp;chksm=a6e3039a91948a8c23ec7d426469ebe30d70f59c7a58437e9ea8b8aac697aa1e2e29b4c47dec&amp;scene=178&amp;cur_album_id=1532487451997454337#rd</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/10/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-3%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/10/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-3%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">元数据服务</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-10 15:03:58" itemprop="dateCreated datePublished" datetime="2021-02-10T15:03:58+08:00">2021-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 08:34:09" itemprop="dateModified" datetime="2021-05-12T08:34:09+08:00">2021-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">分布式对象存储</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="元数据服务"><a href="#元数据服务" class="headerlink" title="元数据服务"></a>元数据服务</h3><p>上一个版本的分布式对象存储实现了接口服务和数据服务的分离，对象的数据被保存在了专门的数据服务节点，而不是保存在接口服务的本地磁盘上。通过解耦后，可以往集群中添加新的接口服务结点或数据服务节点。</p>
<p>但也存在问题：</p>
<ul>
<li>如果多次PUT同一个对象，会发现该<strong>对象在所有的数据服务节点上都有一份副本</strong>。这是由于在每次PUT的时候都是随机选择一个数据服务节点，只要PUT次数足够多，那么所有的节点必然都会被选中一次，结果就是每个节点上都保存着这个对象的数据。为了解决这个问题，对象存储系统提出了一个十分重要的概念，叫作<strong>数据去重。</strong><ul>
<li>最简单的办法似乎式只需要在每次PUT之前先定位一下,确保该对象不存在之后再PUT就好了。然而问题并没有那么简单，更复杂的情况是，<strong>两个名字不同的对象有可能内容相同。这样的对象也属于需要去重的范畴</strong>。这是怎么回事呢?<strong>一个对外提供服务的对象存储系统不可能只有一个用户，而是会有很多用户一起使用，这些用户上传的对象可能存在大量的重复数据。为了节省存储空间，对象存储服务通常都会尽量让数据相同的对象共享系统中的同一份数据存储</strong>。</li>
</ul>
</li>
<li>另一个问题则是<strong>数据的不一致</strong>。假设<strong>多次PUT同一个对象，且内容不同，这个对象的不同版本会被随机保存在不同的数据服务节点上。当GET它时就会随机取得不同版本的对象，这不仅破坏了对象数据的一致性，也破坏了GET方法的幂等性( 对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的)。</strong><ul>
<li>该问题似乎可以通过每次PUT之前先进行定位，如果该对象不存在则随机选择，如果存在则选择相对应的数服务节点。这时候如果客户不要求版本控制，系统的行为表现为用最新的版本覆盖上一个版本。但如果客户希望保存某个对象的所有版本，这时候用户上传的某个对象的所有版本都需要被保存起来。比如说，当用户第一次上传一个对象时，它的初始版本为1:当用户使用PUT方法改变了该对象的内容，那么新对象的版本为2，依次递增。<strong>新的版本会覆盖旧的版本，但是旧版本的对象不会被删除。在下载对象时，用户可以指定GET对象的任意一个版本。</strong> <strong>为了实现版本控制，需要一个数据库来记录系统中所有对象的所有版本。这个数据库就是元数据服务。</strong></li>
</ul>
</li>
</ul>
<h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>元数据指的是<strong>对象的描述信息</strong>。为了和对象的数据本身区分开，赋予了元数据这个名称。对象的哪些信息可以称作元数据？举例来说，有<strong>对象的名字、版本、大小以及散列值等。这些都是系统定义的元数据，因为它们的存在对一个对象存储系统有实际意义，比如说客户端和接口服务之间根据对象的名字来引用一个对象:一个对象可以有多个版本，除了删除标记外，每个版本实际都指向数据服务节点上的一份数据存储。</strong></p>
<p>用户自定义的元数据：除了系统定义的元数据以外，用户也可以为这个对象添加自定义的元数据。这些元数据通常以<strong>键值对形式保存</strong>的任意描述信息，比如一张照片的拍摄时间和拍摄地点，一首歌的作者和演唱者等。<strong>对象存储系统不关心这些元数据，但是用户需要将它们添加到对象存储系统中，作为该对象的元数据进行保存</strong>。</p>
<h4 id="散列值和散列函数"><a href="#散列值和散列函数" class="headerlink" title="散列值和散列函数"></a>散列值和散列函数</h4><p>对象的散列值是一种非常特殊的元数据，因为<strong>对象存储通常将对象的散列值作为其全局唯一的标识符。</strong>在此前，数据服务节点上的对象都是用名字来引用的，<strong>如果两个对象名字不同，那么无法知道它们的内容是否相同</strong>。如此则无法实现针对不同对象的去重。现在，<strong>以对象的散列值作为标识符，就可以将接口服务层访问的对象和数据服务存取的对象数据解耦合</strong>。<strong>客户端和接口服务通过对象的名字来引用一个对象，而实际则是通过其散列值来引用存储在数据节点上的对象数据，只要散列值相同则可以认为对象的数据相同，这样就可以实现名字不同但数据相同的对象之间的去重。</strong></p>
<p>对象的散列值是<strong>通过散列函数计算出来</strong>，散列函数会将对象的数据进行重复多轮的数学运算，这些运算操作包括按位与、按位或、按位异或等，<strong>最后计算出来一个长度固定的数字，作为对象的散列值</strong>。一个理想的散列函数具有以下5个特征。</p>
<ul>
<li>操作具有决定性，<strong>同样的数据必定计算出同样的散列值</strong>。</li>
<li>无论计算任何数据都很快。</li>
<li><strong>无法根据散列值倒推数据,只能遍历尝试所有可能的数据。</strong></li>
<li>数据上微小的变化就会导致散列值的巨大改变，新散列值和旧散列值不具有相关性。</li>
<li>无法找到两个能产生相同散列值的不同数据。</li>
</ul>
<p>实际情况无法满足所有要求，一个散列函数hash的安全级别根据3种属性决定:</p>
<ul>
<li>抗原像攻击:给定一个散列值h，难以找到一个数据m令 h=hash(m)。这个属性称为<strong>函数的单向性</strong>。欠缺单向性的散列函数易受到原像攻击。</li>
<li>抗第二原像攻击:给定一个数据m1，难以找到第二个数据m2令hash(m1)=hash(m2)。欠缺该属性的散列函数易受到第二原像攻击。</li>
<li>抗碰撞性:难以找到两个不同的数据m1和m2令hash(m1)=hash(m2)。这样的一对数据被称为散列碰撞。</li>
</ul>
<p>本项目使用的散列函数为SHA-256,该函数使用64位的数学运算，产生一个长度为256位的二进制数字作为散列值。</p>
<h4 id="分布式对象存储加入元数据服务"><a href="#分布式对象存储加入元数据服务" class="headerlink" title="分布式对象存储加入元数据服务"></a>分布式对象存储加入元数据服务</h4><p>元数据服务就是提供对元数据的存取功能的服务。本项目中实现的元数据服务较为简单，它将<strong>只保存系统定义的元数据，也就是对象的名字、版本、大小和散列值，因为这些直接影响到存储功能</strong>。</p>
<p>和上一版本的架构对，加入元数据服务的架构其他组件不变，而多了一个ElasticSearch （以下简称ES)，也就是项目种选择的元数据服务。需要说明的是能做元数据服务的并不只有ES一种，任何一个分布式数据库都可以做元数据服务。选择ES的原因是它足够好且实现方便。和RabbitMQ一样，ES本身也支持集群，但是在本书的测试环境中只使用了一个服务节点。<br><strong>ES使用的也是REST 接口</strong>，<strong>接口服务节点作为客户端通过HTTP访问ES的索引（index)。ES 的索引就相当于一个数据库，而类型（type）则相当于数据库里的一张表。项目种会创建一个名为metadata的索引，其中有一个名为objects 的类型。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/e15401f1-6fdc-490a-9351-1131bf07b90b-11197877.jpg" alt="加入元数据服务的分布式存储架构"></p>
<h5 id="REST接口"><a href="#REST接口" class="headerlink" title="REST接口"></a>REST接口</h5><p>有了元数据服务之后，就可以给接口服务增加新的功能，首先是给对象的GET方法增加一个参数version:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /objects/&lt;object_name&gt;?version=&lt;version_id&gt;</span><br></pre></td></tr></table></figure>
<p>响应正文：</p>
<ul>
<li>对象的数据:这个参数可以<strong>告诉接口服务客户端需要的是该对象的第几个版本，默认是最新的那个</strong>。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /objects/&lt;object_name&gt;</span><br></pre></td></tr></table></figure>
<p>请求头部(Request Header)</p>
<ul>
<li>Digest: SHA-256=&lt;对象散列值的Base64编码&gt;</li>
<li>Content-Length:&lt;对象数据的长度&gt;</li>
</ul>
<p>请求正文</p>
<ul>
<li>对象的内容如下:</li>
<li><strong>PUT方法没变,但是每次客户端PUT一个对象时,必须提供一个名为Digest 的HTTP请求头部，它记录了用SHA-256散列函数计算出来的对象散列值。</strong></li>
</ul>
<p>HTTP头部分为请求头部（Request Header）和响应头部(Response Header)，它允许客户端和服务器在HTTP的请求和响应中交换额外的信息。一个头部由3个部分组成:一个大小写不敏感的名字，后面跟着一个冒号“:”，然后是该头部的值。注意头部的值不能包含回车。</p>
<p>Digest头部的名字是 Digest，后面跟着一个冒号，然后是 Digest头部的值，也就是”SHA-256=&lt;对象散列值的Base64编码&gt;”。<strong>SHA-256是要求使用的散列函数,根据RFC3230的要求，客户端需要在Digest头部提供计算散列值时使用的散列函数,如果服务器发现客户端使用的散列函数跟服务器使用的散列函数不一致则会拒绝整个请求</strong>。<strong>SHA-256计算出的散列值是一个256位的二进制数字，客户端还需要对其进行Base64编码，将数字转化成ASCII字符串格式，以确保不包含回车的二进制数字。</strong></p>
<p>Base64编码规则选定了64个不同的字符，分别代表1个6位的二进制数字。对一个256位的二进制数字进行编码，首先要将其切成11个24位的二进制数字（不足的位在最后一个数字用0补齐)，然后每个数字正好用4个Base64字符来表示。</p>
<p><strong>经过Base64编码后的散列值将作为该对象的全局唯一标识符，也是数据服务节点储存的对象名。也就是说，只要对象内容发生了变化，那么原来在数据服务节点上储存的数据不会被更新，而是会储存一个新的对象。</strong></p>
<p>除了Digest头部以外，客户端还必须提供一个名为Content-Length 的HTTP请求头部用来告诉服务端该对象数据的长度。<strong>客户端提供的对象散列值和长度会作为元数据被保存在元数据服务中。</strong></p>
<p>将数据服务层存取的对象名和接口服务层访问的对象名区分开对于去重来说至关重要。现在，<strong>无论接口服务层收到的对象名是什么，只要从数据服务层角度看到的对象名一致，就可以认为是对象的内容一致，去重就只需要简单地根据数据服务层的对象名来实现就可以</strong>。</p>
<p>PUT成功后，在元数据服务中该对象就会添加一个新的版本，版本号从1开始递增。</p>
<p>除了对象的GET 和 PUT方法发生了变化以外，还可以添加新的功能，首先是对象的DELETE方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /objects/&lt;object_name&gt;</span><br></pre></td></tr></table></figure>
<p>使用DELETE方法来删除一个对象。</p>
<p>在此之前都没有实现对象的删除功能,这是有原因的<strong>。对象存储的去重会让名字不同的对象共享同一份数据存储，而删除一个对象意味着要将该对象和数据存储之间的联系断开。在把对象的名字和对象的数据存储解耦合之前，无法做到在删除一个对象的同时保留对象的数据存储。</strong> <strong>有了元数据服务，在删除一个对象时，只需要在元数据中给对象添加一个表示删除的特殊版本,而在数据节点上保留其数据。</strong></p>
<p><strong>在GET时，如果该对象的最新版本是一个删除标记，则返回404 Not Found。除了对象的删除功能之外，还需要提供对象的列表功能，用于查询所有对象或指定对象的所有版本。</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /versions/</span><br></pre></td></tr></table></figure>
<ul>
<li>响应正文<br><strong>指定对象的所有版本:客户端GET某个指定对象的版本列表，接口服务节点返回该对象的所有版本。HTTP响应内容结构同上。</strong></li>
</ul>
<h5 id="ES接口"><a href="#ES接口" class="headerlink" title="ES接口"></a>ES接口</h5><p>元数据服务的索引使用映射(mappings)结构：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">mappings":&#123;</span><br><span class="line">    "objects":&#123;</span><br><span class="line">        "properties":&#123;</span><br><span class="line">            "name" : &#123;"type" : "string" , "index" :"not analyzed"&#125;,</span><br><span class="line">            "version" :&#123;"type": "integer"&#125;,</span><br><span class="line">            "size":&#123;"type"": ""integer"&#125;,</span><br><span class="line">            "hash" : &#123;"type : "string" &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ES的索引相当于数据库而类型相当于数据库的表，那么现在这个映射则相当于定义表结构。</strong>这个映射会在创建metadata索引时作为参数一并被引入，<strong>该索引只有一个类型就是objects，其中包括4个属性分别是 name、version、size和hash，相当于数据库表的4个列。</strong></p>
<p>name属性有个额外的要求”index”:”not_analyzed”，这是<strong>为了在搜索时能够精确匹配name</strong>。<strong>默认的 analyzed index 会对name进行分词匹配。这有可能导致不相关的匹配结果。比如我们有一个元数据的name是“little cat”，如果使用analyzed index，那么它会被分成little和cat两个词，之后任何包含little或cat的搜索都会导致“little cat”被选中。</strong></p>
<h5 id="添加对象元数据"><a href="#添加对象元数据" class="headerlink" title="添加对象元数据"></a>添加对象元数据</h5><p>当客户端PUT或DELETE对象时，都需要往元数据服务添加新版本，处理步骤如图：</p>
<p><img src="https://api2.mubu.com/v3/document_image/6dfe689e-2b45-45eb-b31d-264ddbbe97b1-11197877.jpg" alt="往元数据服务添加新版本"></p>
<p>上图显示了往元数据服务添加新版本的流程，<strong>当接口服务需要给某个对象添加一个新版本时，首先会去查询该对象当前最新版本的元数据，如果该对象不存在，则新版本从1开始:否则新版本为当前最新版本加1，然后将其添加进元数据服务。</strong></p>
<p><strong>GET对象时分两种情况，如果没有指定版本号，同样需要搜索对象最新版本的元数据;如果指定了版本号，可以根据对象的名字和版本号直接获取对象指定版本的元数据。</strong></p>
<h5 id="用到的ES-API"><a href="#用到的ES-API" class="headerlink" title="用到的ES API"></a>用到的ES API</h5><p>要想荻取对象当前最新版本的元数据需要使用ES搜索API.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /metadata/_search?q=name:&lt;object_name&gt;&amp;size=1&amp;sort=version:desc</span><br></pre></td></tr></table></figure>
<p>给对象添加一个新版本需要使用ES索引API:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /metadata/objects/&lt;object_name&gt;_&lt;version&gt;?op_type=create</span><br></pre></td></tr></table></figure>
<p>在这里，特地将<code>&lt;object_name&gt;_&lt;version&gt;</code>作为<code>_i</code>d创建。这是为了<strong>当客户端指定版本GET对象时可以直接根据对象名和版本号拼出相对应的_id来从ES中获取元数据，从而免除了搜索的步骤。</strong></p>
<p>使用<code>op_type=create</code>可以确保<strong>当多个客户端同时上传同一个对象时不至于发生数据丢失，因为只有第一个请求能成功上传给ES。其他请求会收到HTTP错误代码409 Conflict，这样接口服务节点就能知道发生了版本冲突并重新上传。</strong></p>
<p>当客户端GET对象时分两种情况，如果没有指定版本号，则使用和之前同样的ES搜索API来获取对象的最新版本。</p>
<p>如果客户端指定版本号GET对象，则使用<code>ES Get API</code>直接获取对象指定版本的元数据。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /metadata/objects/&lt;object_name&gt;_&lt;version_id&gt;/_source</span><br></pre></td></tr></table></figure>
<p>当客户端GET全体对象版本列表时，使用ES<strong>搜索API</strong>方法如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /metadata/_search?sort=name,version&amp;from=&lt;from&gt;&amp;size=&lt;size&gt;</span><br></pre></td></tr></table></figure>
<p>其中，<strong>from和 size用于分页显示。在不指定from和 size的情况下，ES 默认的分页是从0开始显示10条。</strong></p>
<p>当客户端<strong>GET指定对象版本列表时</strong>，使用ES 搜索API方法如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /metadata/_search?sort=name,versions&amp;from=&lt;from&gt;&amp;size=&lt;size&gt;&amp;q=name:&lt;object_name&gt;</span><br></pre></td></tr></table></figure>
<p>这里多了一个q参数用于指定name。</p>
<h5 id="对象PUT流程"><a href="#对象PUT流程" class="headerlink" title="对象PUT流程"></a>对象PUT流程</h5><p><img src="https://api2.mubu.com/v3/document_image/777aada2-f039-4763-b3be-9e17b1e04b08-11197877.jpg" alt="加入元数据服务的对象put流程"></p>
<p>客户端的HTTP请求提供了对象的名字、散列值和大小，接口服务以散列值作为数据服务的对象名来保存对象，然后在元数据服务中根据对象的名字搜索当前最新的元数据，使其版本号加1并添加一个新版本的元数据。</p>
<h5 id="对象GET流程"><a href="#对象GET流程" class="headerlink" title="对象GET流程"></a>对象GET流程</h5><p><img src="https://api2.mubu.com/v3/document_image/9cf5cce9-c1cc-48c5-b810-19ab62954001-11197877.jpg" alt="加入元数据服务的对象get流程"></p>
<p>客户端在HTTP请求中指定对象的名字，可在 URL的查询参数中指定版本号。如果指定版本号，则接口服务根据对象的名字和版本号获取元数据;否则根据对象的名字搜索最新元数据。<strong>然后从元数据中获得对象的散列值作为数据服务的对象名来读取对象。</strong></p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>主要关注于与上一版本有变化的部分(主要在接口服务种实现元数据的互动)进行说明。</p>
<h5 id="接口服务"><a href="#接口服务" class="headerlink" title="接口服务"></a>接口服务</h5><h6 id="接口服务的main函数"><a href="#接口服务的main函数" class="headerlink" title="接口服务的main函数"></a>接口服务的main函数</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> heartbeat.ListenHeartbeat()</span><br><span class="line">	http.HandleFunc(<span class="string">"/objects/"</span>, objects.Handler)</span><br><span class="line">	http.HandleFunc(<span class="string">"/locate/"</span>, locate.Handler)</span><br><span class="line">	http.HandleFunc(<span class="string">"/versions/"</span>, versions.Handler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(os.Getenv(<span class="string">"LISTEN_ADDRESS"</span>), <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本版本的接口服务main函数多了一个用于处理<code>/vesions/</code>的函数，名字为<code>versions.Handler</code>。</p>
<h6 id="接口服务的versions包"><a href="#接口服务的versions包" class="headerlink" title="接口服务的versions包"></a>接口服务的<code>versions</code>包</h6><p>主要工作为调用es包的函数完成相关工作：</p>
<p><code>versions.Handler</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 检查HTTP方法是否为GET</span></span><br><span class="line">	m := r.Method</span><br><span class="line">	<span class="comment">// 如果不为GET，返回405 Method Not Allowed</span></span><br><span class="line">	<span class="keyword">if</span> m != http.MethodGet &#123;</span><br><span class="line">		w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 方法为GET,获取URL中的&lt;object_name&gt;部分</span></span><br><span class="line">	from := <span class="number">0</span></span><br><span class="line">	size := <span class="number">1000</span></span><br><span class="line">	name := strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="comment">// 无限循环调用es包的SearchAllVersions函数</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 返回一个元数据的数组</span></span><br><span class="line">		metas, e := es.SearchAllVersions(name, from, size)</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(e)</span><br><span class="line">			w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历数组，将元数据一一写入HTTP响应的正文</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> metas &#123;</span><br><span class="line">			b, _ := json.Marshal(metas[i])</span><br><span class="line">			w.Write(b)</span><br><span class="line">			w.Write([]<span class="keyword">byte</span>(<span class="string">"\n"</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果返回的数组长度不等于size，说明元数据服务种没有更多的数据，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(metas) != size &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 否则把from的值增加1000进行下一轮迭代</span></span><br><span class="line">		from += size</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="接口服务的objects包"><a href="#接口服务的objects包" class="headerlink" title="接口服务的objects包"></a>接口服务的objects包</h6><p>加入元数据服务以后,接口服务的objects包与上一版本相比发生了较大的变化,除了多了一个对象的DELETE方法以外，对象的PUT和GET方法也都有所改变，它们需要和元数据服务互动。</p>
<p>obejects.Handler函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	m := r.Method</span><br><span class="line">	<span class="keyword">if</span> m == http.MethodPut &#123;</span><br><span class="line">		put(w, r)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> m == http.MethodGet &#123;</span><br><span class="line">		get(w, r)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 与上一版本多一个DELETE方法处理del函数</span></span><br><span class="line">	<span class="keyword">if</span> m == http.MethodDelete &#123;</span><br><span class="line">		del(w, r)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objects.del函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">del</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	name := strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="comment">// 以name为参数调用es.SearchLaestVersion,搜索该对象最新的版本</span></span><br><span class="line">	version, e := es.SearchLatestVersion(name)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 插入新的元数据，接受元数据的name, version, size和hash</span></span><br><span class="line">	<span class="comment">// hash 为空字符串表示这个一个删除标记</span></span><br><span class="line">	e = es.PutMetadata(name, version.Version+<span class="number">1</span>, <span class="number">0</span>, <span class="string">""</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objects.put相关函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">put</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先从HTTP请求头部获取对象的散列值</span></span><br><span class="line">	hash := utils.GetHashFromHeader(r.Header)</span><br><span class="line">	<span class="keyword">if</span> hash == <span class="string">""</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"missing object hash in digest header"</span>)</span><br><span class="line">		w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以散列值作为参数调用stroreObject</span></span><br><span class="line">	c, e := storeObject(r.Body, url.PathEscape(hash))</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(c)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c != http.StatusOK &#123;</span><br><span class="line">		w.WriteHeader(c)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从URL中获取对象的名字和对象的大小</span></span><br><span class="line">	name := strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]</span><br><span class="line">	size := utils.GetSizeFromHeader(r.Header)</span><br><span class="line">	<span class="comment">// 以对象的名字、散列值和大小为参数调用es.AddVersions给对象添加新版本</span></span><br><span class="line">	e = es.AddVersion(name, hash, size)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GetHashFromHeader函数和GetSizeFromHeader函数是utils包提供的两个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetHashFromHeader</span><span class="params">(h http.Header)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取"digest"头部</span></span><br><span class="line">	digest := h.Get(<span class="string">"digest"</span>)</span><br><span class="line">	<span class="comment">// 检查diest头部的形式是否满足"SHA-256=&lt;hash&gt;"</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(digest) &lt; <span class="number">9</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> digest[:<span class="number">8</span>] != <span class="string">"SHA-256="</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> digest[<span class="number">8</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSizeFromHeader</span><span class="params">(h http.Header)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="comment">// 得到"conten-length"头部，并调用strconv.PareseInt将字符串转换为int64输出</span></span><br><span class="line">	size, _ := strconv.ParseInt(h.Get(<span class="string">"content-length"</span>), <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objects.get函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	name := strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="comment">// 获取URL并从URL的查询参数中获取"version"参数的值</span></span><br><span class="line">	<span class="comment">// Query方法返回一个保存URL所有查询参数的map，该map的键是查询参数的名字，值是一个字符串数组</span></span><br><span class="line">	<span class="comment">// HTTP的URL查询参数允许存在多个值，以"version"为key可以得到URL中查询参数的所有值</span></span><br><span class="line">	versionId := r.URL.Query()[<span class="string">"version"</span>]</span><br><span class="line">	version := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> e error</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(versionId) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 项目中不考虑多个"version"查询参数的情况</span></span><br><span class="line">		<span class="comment">// 始终以versionId数组的第一个元素作为客户端提供的版本号</span></span><br><span class="line">		<span class="comment">// 将字符串转换为整型</span></span><br><span class="line">		version, e = strconv.Atoi(versionId[<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(e)</span><br><span class="line">			w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用es的GetMetadata函数得到对象的元数据meta</span></span><br><span class="line">	meta, e := es.GetMetadata(name, version)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// meta.Hash为对象的散列值，如果为空表示该对象版本是一个删除标记</span></span><br><span class="line">	<span class="comment">// 返回404 Not Found</span></span><br><span class="line">	<span class="keyword">if</span> meta.Hash == <span class="string">""</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusNotFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以散列值为对象名从数据服务层获取对象并输出</span></span><br><span class="line">	object := url.PathEscape(meta.Hash)</span><br><span class="line">	stream, e := getStream(object)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusNotFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	io.Copy(w, stream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="es包"><a href="#es包" class="headerlink" title="es包"></a>es包</h5><p>es包封装了以HTTP访问ES的各种API的操作。</p>
<p>es.getMetadata函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构与ES映射中定义的objects类型属性一一对应</span></span><br><span class="line"><span class="keyword">type</span> Metadata <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Version <span class="keyword">int</span></span><br><span class="line">	Size    <span class="keyword">int64</span></span><br><span class="line">	Hash    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据对象的名字和版本号来获取对象的元数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMetadata</span><span class="params">(name <span class="keyword">string</span>, versionId <span class="keyword">int</span>)</span> <span class="params">(meta Metadata, e error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ES服务器地址来自环境变量ES_SERVER,索引是metadata,类型是objects</span></span><br><span class="line">	<span class="comment">// 文档的id由对象的名字和版本号拼接而成。</span></span><br><span class="line">	url := fmt.Sprintf(<span class="string">"http://%s/metadata/objects/%s_%d/_source"</span>,</span><br><span class="line">		os.Getenv(<span class="string">"ES_SERVER"</span>), name, versionId)</span><br><span class="line">	<span class="comment">// GET到URL中的对象的元数据，免除耗时的搜索操作</span></span><br><span class="line">	r, e := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r.StatusCode != http.StatusOK &#123;</span><br><span class="line">		e = fmt.Errorf(<span class="string">"fail to get %s_%d: %d"</span>, name, versionId, r.StatusCode)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 读出数据</span></span><br><span class="line">	result, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">	<span class="comment">// ES返回的结果经过JSON解码后被es,SearchLatestVersion函数使用</span></span><br><span class="line">	json.Unmarshal(result, &amp;meta)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>es.SearchLatestVersion函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hit <span class="keyword">struct</span> &#123;</span><br><span class="line">	Source Metadata <span class="string">`json:"_source"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> searchResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	Hits <span class="keyword">struct</span> &#123;</span><br><span class="line">		Total <span class="keyword">int</span></span><br><span class="line">		Hits  []hit</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchLatestVersion</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(meta Metadata, e error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 调用ES搜索API.在URL中指定对象的名字，版本号以降序排列且只返回第一个结果。</span></span><br><span class="line">	url := fmt.Sprintf(<span class="string">"http://%s/metadata/_search?q=name:%s&amp;size=1&amp;sort=version:desc"</span>,</span><br><span class="line">		os.Getenv(<span class="string">"ES_SERVER"</span>), url.PathEscape(name))</span><br><span class="line">	fmt.Println(url)</span><br><span class="line">	r, e := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r.StatusCode != http.StatusOK &#123;</span><br><span class="line">		e = fmt.Errorf(<span class="string">"fail to search latest metadata: %d"</span>, r.StatusCode)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	result, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">	<span class="keyword">var</span> sr searchResult</span><br><span class="line">	<span class="comment">// ES返回的结果通过JSON解码到一个searchResult结构体中</span></span><br><span class="line">	<span class="comment">// searchResult和ES搜索API返回的结构体保持一致</span></span><br><span class="line">	<span class="comment">// 方便读取搜索到的元数据并赋值给meta返回。</span></span><br><span class="line">	json.Unmarshal(result, &amp;sr)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(sr.Hits.Hits) != <span class="number">0</span> &#123;</span><br><span class="line">		meta = sr.Hits.Hits[<span class="number">0</span>].Source</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ES的返回结果长度为0，说明没有搜到相对应的元数据，直接返回</span></span><br><span class="line">	<span class="comment">// 此时meta中各属性都为初始值：字符串为空，整型为0</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>es.GetMetadata函数：</p>
<p>GetMetadata函数的功能类似getMetadata，输入对象的名字和版本号返回对象，区别在于当version为0时会调用SearchLatestVersion获取当前最新的版本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMetadata</span><span class="params">(name <span class="keyword">string</span>, version <span class="keyword">int</span>)</span> <span class="params">(Metadata, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当version为0的时候，调用SearchLatestVersion获取当前最新的版本</span></span><br><span class="line">	<span class="keyword">if</span> version == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SearchLatestVersion(name)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getMetadata(name, version)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>es.PutMetadata函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于向ES服务上传一个新的元数据，输入的4个参数对应元数据的4个属性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PutMetadata</span><span class="params">(name <span class="keyword">string</span>, version <span class="keyword">int</span>, size <span class="keyword">int64</span>, hash <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 生成ES文档，一个ES的文档相当于数据库的一条记录</span></span><br><span class="line">	doc := fmt.Sprintf(<span class="string">`&#123;"name":"%s","version":%d,"size":%d,"hash":"%s"&#125;`</span>,</span><br><span class="line">		name, version, size, hash)</span><br><span class="line">	client := http.Client&#123;&#125;</span><br><span class="line">	<span class="comment">// 使用op_type=create参数，如果同时又多个客户端上传同一个数据，结果会发生冲突</span></span><br><span class="line">	<span class="comment">// 只有第一个文档被成功创建，之后的PUT请求，ES会返回409Conflict</span></span><br><span class="line">	url := fmt.Sprintf(<span class="string">"http://%s/metadata/objects/%s_%d?op_type=create"</span>,</span><br><span class="line">		os.Getenv(<span class="string">"ES_SERVER"</span>), name, version)</span><br><span class="line">	<span class="comment">// 用PUT方法将文档上传到metadata索引的objects类型</span></span><br><span class="line">	request, _ := http.NewRequest(<span class="string">"PUT"</span>, url, strings.NewReader(doc))</span><br><span class="line">	r, e := client.Do(request)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> e</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果为409Conflict，函数让版本号加1并递归调用自身继续上传</span></span><br><span class="line">	<span class="keyword">if</span> r.StatusCode == http.StatusConflict &#123;</span><br><span class="line">		<span class="keyword">return</span> PutMetadata(name, version+<span class="number">1</span>, size, hash)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r.StatusCode != http.StatusCreated &#123;</span><br><span class="line">		result, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"fail to put metadata: %d %s"</span>, r.StatusCode, <span class="keyword">string</span>(result))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>es.AddVersion函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddVersion</span><span class="params">(name, hash <span class="keyword">string</span>, size <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取对象最新的版本</span></span><br><span class="line">	version, e := SearchLatestVersion(name)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> e</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在版本号上加1调用PutMetadata</span></span><br><span class="line">	<span class="keyword">return</span> PutMetadata(name, version.Version+<span class="number">1</span>, size, hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>es.SearchAllVersion函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于搜索某个对象或所有对象的全部版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchAllVersions</span><span class="params">(name <span class="keyword">string</span>, from, size <span class="keyword">int</span>)</span> <span class="params">([]Metadata, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// name表示对象的名字，如果name不为空字符粗则搜索指定对象的所有版本</span></span><br><span class="line">	<span class="comment">// 否则搜索所有对象的全部版本</span></span><br><span class="line">	<span class="comment">// from和size指定分页的显示结果</span></span><br><span class="line">	<span class="comment">// 搜索的结果按照对象的名字和版本号排序</span></span><br><span class="line">	url := fmt.Sprintf(<span class="string">"http://%s/metadata/_search?sort=name,version&amp;from=%d&amp;size=%d"</span>,</span><br><span class="line">		os.Getenv(<span class="string">"ES_SERVER"</span>), from, size)</span><br><span class="line">	<span class="keyword">if</span> name != <span class="string">""</span> &#123;</span><br><span class="line">		url += <span class="string">"&amp;q=name:"</span> + name</span><br><span class="line">	&#125;</span><br><span class="line">	r, e := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, e</span><br><span class="line">	&#125;</span><br><span class="line">	metas := <span class="built_in">make</span>([]Metadata, <span class="number">0</span>)</span><br><span class="line">	result, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">	<span class="keyword">var</span> sr searchResult</span><br><span class="line">	json.Unmarshal(result, &amp;sr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> sr.Hits.Hits &#123;</span><br><span class="line">		metas = <span class="built_in">append</span>(metas, sr.Hits.Hits[i].Source)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> metas, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试环境与上一版本相同，具体代码见<a href="https://github.com/dongshifu/distributed_object_storage_dong/tree/main/v2" target="_blank" rel="noopener">带元数据服务的分布式对象存储</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>《分布式对象存储—原理、架构及Go语言实现》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-2%E5%8F%AF%E6%89%A9%E5%B1%95%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-2%E5%8F%AF%E6%89%A9%E5%B1%95%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">可扩展分布式系统实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-20 15:03:58" itemprop="dateCreated datePublished" datetime="2021-01-20T15:03:58+08:00">2021-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 08:32:51" itemprop="dateModified" datetime="2021-05-12T08:32:51+08:00">2021-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">分布式对象存储</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="可扩展分布式系统"><a href="#可扩展分布式系统" class="headerlink" title="可扩展分布式系统"></a>可扩展分布式系统</h3><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><p>一个分布式系统要求<strong>各节点分布在网络上，并通过消息传递来合作完成一个共同目标</strong>。</p>
<p>分布式系统的三大关键特征:</p>
<ul>
<li>节点之间<strong>并发</strong>工作</li>
<li>没有全局锁</li>
<li>某个节点上发生的错误不影响其他节点。</li>
</ul>
<p>分布式系统的好处在于<strong>可扩展性，只需要加入新的节点就可以自由扩展集群的性能。</strong></p>
<p>实现分布式系统的关键是实现接口和具体实现的解耦。</p>
<h4 id="接口服务和数据存储服务分离"><a href="#接口服务和数据存储服务分离" class="headerlink" title="接口服务和数据存储服务分离"></a>接口服务和数据存储服务分离</h4><p>如图所示，<strong>接口服务层提供了对外的REST接口</strong>，而<strong>数据服务层则提供数据的存储功能</strong>。接口服务处理客户端的请求，然后向数据服务存取对象，数据服务处理来自接口服务的请求并在本地磁盘上存取对象。</p>
<p><img src="https://api2.mubu.com/v3/document_image/fd1e34fc-3de6-44cc-a135-143050dd1ac8-11197877.jpg" alt="接口服务和数据存储服务分离"></p>
<p>接口服务和数据服务之间的两种接口：</p>
<ul>
<li>实现<strong>对象存取</strong>的接口：对象的存取使用REST 接口。也就是说数据服务本身也提供REST 接口。此时，<strong>接口服务节点作为HTTP客户端向数据服务请求对象</strong>。</li>
<li>第二种接口通过RabbitMQ消息队列进行通信，对 RabbitMQ 的使用分为两种模式。<ul>
<li>一种模式是向某个exchange进行<strong>一对多</strong>的消息<strong>群发</strong></li>
<li>另一种模式则是向某个消息队列进行<strong>一对一</strong>的消息<strong>单发</strong>。</li>
</ul>
</li>
</ul>
<p><strong>每一个数据服务节点都需要向所有的接口服务节点通知自身的存在</strong>，为此，创建一个名为apiServers 的 exchange<strong>,每一台数据服务节点都会持续向这个exchange发送心跳消息。所有的接口服务节点在启动以后都会创建一个消息队列来绑定这个exchange，任何发往这个exchange 的消息都会被转发给绑定它的所有消息队列，也就是说每一个接口服务节点都会接收到任意一台数据服务节点的心跳消息。</strong></p>
<p>接口服务需要在收到对象GET 请求时<strong>定位该对象被保存在哪个数据服务节点上</strong>，所以还需要创建一个名为dataServers的exchange。<strong>所有的数据服务节点绑定这个exchange并接收来自接口服务的定位消息。拥有该对象的数据服务节点则使用消息单发通知该接口服务节点。</strong></p>
<p>之所以必须使用REST和消息队列这两种不同类型的接口是为了满足不同的需求:<strong>对象存取的特点是数据量有可能很大，不适合将一个巨大的对象通过消息队列传输。而REST接口虽然能够处理大数据量传输，但是对于群发却显得力不从心。</strong></p>
<h5 id="REST接口"><a href="#REST接口" class="headerlink" title="REST接口"></a>REST接口</h5><ul>
<li>对于数据服务来说，它的REST接口和单机版本完全相同，也就是对象的PUT和GET方法。</li>
<li>对于接口服务来说，除了对象的PUT和GET 方法之外，还应另外提供一个<strong>用于定位的 locate接口，用来帮助验证架构。</strong><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /locate/&lt;object_name&gt;</span><br><span class="line">响应正文</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>客户端通过GET方法发起对象定位请求，<strong>接口服务节点收到该请求后通过dataServers exchange会向数据服务层群发一个定位消息，然后等待数据服务节点的反馈</strong>。<strong>如果有数据服务节点发回确认消息，则返回该数据服务节点的地址;如果超过一定时间没有任何反馈,则返回HTTP错误代码<code>404 NOT FOUND</code>.</strong></p>
<h5 id="RabbitMQ消息设计"><a href="#RabbitMQ消息设计" class="headerlink" title="RabbitMQ消息设计"></a>RabbitMQ消息设计</h5><p>数据服务需要通过RabbitMQ将自身的存在通知给所有的接口服务，这样的消息称为<strong>心跳消息。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/c2721c9a-25ea-4f7c-ae66-f47e56243975-11197877.jpg" alt="数据服务心跳消息"></p>
<p>apiServers和dataServers这两个exchange需要在RabbitMQ服务器上预先创建。<strong>每个接口服务节点在启动后都会创建自己的消息队列并绑定至 apiServers exchange。</strong> <strong>每个数据服务节点在启动后每隔5s就会发送一条消息给apiServers exchange，消息的正文就是该数据服务节点的 HTTP监听地址。接口服务节点在收到该消息后就会记录这个地址。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/3c415222-3bad-43dc-a1fe-d70b137c92c9-11197877.jpg" alt="定位流程"></p>
<p>每个数据服务节点在启动时都必须创建自己的消息队列并绑定至dataServers exchange。<strong>当接口服务需要定位时，会创建一个临时消息队列，然后发送一条消息给dataServers exchange</strong>，<strong>消息的正文是需要定位的对象，返回地址则是该临时队列的名字。定位成功的数据服务节点需要将反馈消息发送给这个临时队列，反馈消息的正文是该数据服务节点自身的监听地址</strong>。<strong>临时消息队列会在一定时间后关闭。如果在关闭前没有收到任何反馈则该对象定位失败,接口服务节点就会知道该对象不存在于数据服务层。</strong></p>
<h5 id="接口和存储分离的对象PUT流程"><a href="#接口和存储分离的对象PUT流程" class="headerlink" title="接口和存储分离的对象PUT流程"></a>接口和存储分离的对象PUT流程</h5><p><img src="https://api2.mubu.com/v3/document_image/b406ad2b-b000-4a1b-82a8-de523383823e-11197877.jpg" alt="接口和存储分离的对象PUT流程"></p>
<p>客户端向接口服务发送HTTP的PUT 请求并提供了<code>&lt;object_name&gt;</code>和<code>&lt;contentof object&gt;</code>，接口服务选出一个随机数据服务节点并向它转发这个PUT请求，数据服务节点将<code>&lt;content of object&gt;</code>写入<code>$STORAGE_ROOT/objects/&lt;object_name&gt;</code>文件。</p>
<h5 id="接口和存储分离的对象GET流程"><a href="#接口和存储分离的对象GET流程" class="headerlink" title="接口和存储分离的对象GET流程"></a>接口和存储分离的对象GET流程</h5><p><img src="https://api2.mubu.com/v3/document_image/31754790-b3b4-4498-8e1b-e84c17faa6d8-11197877.jpg" alt="接口和存储分离的对象GET流程"></p>
<p>客户端的GET 请求提供了<code>&lt;object_name&gt;</code>，接口服务在收到GET请求后会对该object进行定位，如果定位失败则返回<code>404 Not Found</code>;如果定位成功，<strong>接口服务会接收到某个数据服务的地址，就可以向该地址转发来自客户端的GET请求，由数据服务读取本地磁盘上的文件并将其内容写入HTTP响应的正文。</strong></p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="数据服务"><a href="#数据服务" class="headerlink" title="数据服务"></a>数据服务</h5><p>为支持新的功能，数据服务的在实现上扩展了单机版的相关功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> heartbeat.StartHeartbeat()</span><br><span class="line">	<span class="keyword">go</span> locate.StartLocate()</span><br><span class="line">	http.HandleFunc(<span class="string">"/objects/"</span>, objects.Handler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(os.Getenv(<span class="string">"LISTEN_ADDRESS"</span>), <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据服务的heartbeat包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每隔5s向apiServers exchange发送一条消息</span></span><br><span class="line"><span class="comment">// 将本服务节点的监听对地址发送出去</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartHeartbeat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 调用rabbitmq.New创建一个rabbitmq.RabbitMQ结构体</span></span><br><span class="line">	q := rabbitmq.New(os.Getenv(<span class="string">"RABBITMQ_SERVER"</span>))</span><br><span class="line">	<span class="keyword">defer</span> q.Close()</span><br><span class="line">	<span class="comment">// 无限循环调用Publish方法向apiServers exchange发送本节点的监听地址</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		q.Publish(<span class="string">"apiServers"</span>, os.Getenv(<span class="string">"LISTEN_ADDRESS"</span>))</span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据服务的locate包：</p>
<p>locate包有两个函数，分别是用<strong>于实际定位对象的Locate函数和用于监听定位消息的StartLocate函数</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际定位对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Locate</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// os.Stat访问磁盘上对应的文件名</span></span><br><span class="line">	_, err := os.Stat(name)</span><br><span class="line">	<span class="comment">// 判断文件名是否存在，存在返回true,失败返回false</span></span><br><span class="line">	<span class="keyword">return</span> !os.IsNotExist(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于监听定位消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartLocate</span><span class="params">()</span></span> &#123;</span><br><span class="line">	q := rabbitmq.New(os.Getenv(<span class="string">"RABBITMQ_SERVER"</span>))</span><br><span class="line">	<span class="keyword">defer</span> q.Close()</span><br><span class="line">	<span class="comment">// 绑定dataServers exchange</span></span><br><span class="line">	q.Bind(<span class="string">"dataServers"</span>)</span><br><span class="line">	<span class="comment">// 返回一个channel</span></span><br><span class="line">	c := q.Consume()</span><br><span class="line">	<span class="comment">// range遍历channel,接收消息</span></span><br><span class="line">	<span class="keyword">for</span> msg := <span class="keyword">range</span> c &#123;</span><br><span class="line">		<span class="comment">// JSON编码使得对象名字上有一对双引号，使用strconv.Unquote将输入的字符串前后的双引号去除并作为结果返回</span></span><br><span class="line">		object, e := strconv.Unquote(<span class="keyword">string</span>(msg.Body))</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(e)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> Locate(os.Getenv(<span class="string">"STORAGE_ROOT"</span>) + <span class="string">"/objects/"</span> + object) &#123;</span><br><span class="line">			<span class="comment">//文件存在，调用Send方法向消息的发送方返回本服务节点的监听地址，表示该对象存在于本服务节点上。</span></span><br><span class="line">			q.Send(msg.ReplyTo, os.Getenv(<span class="string">"LISTEN_ADDRESS"</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="接口服务"><a href="#接口服务" class="headerlink" title="接口服务"></a>接口服务</h5><p>接口服务除了<strong>提供对象的REST接口以外还需要提供locate功能</strong>，其main函数为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 提供locate功能</span></span><br><span class="line">	<span class="keyword">go</span> heartbeat.ListenHeartbeat()</span><br><span class="line">	<span class="comment">// 处理URL以/objects/开头的对象请求</span></span><br><span class="line">	http.HandleFunc(<span class="string">"/objects/"</span>, objects.Handler)</span><br><span class="line">	<span class="comment">// 处理URL以/locate/开头的定位请求</span></span><br><span class="line">	http.HandleFunc(<span class="string">"/locate/"</span>, locate.Handler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(os.Getenv(<span class="string">"LISTEN_ADDRESS"</span>), <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：接口服务层和数据服务层的objects包以及heartbeat、locate包虽然名字相同，但具体实现差距较大。</p>
<ul>
<li>数据服务的objects包负责对象在<strong>本地磁盘上的存取</strong>;而接口服务的objects包则负责将<strong>对象请求转发给数据服</strong>务。</li>
<li>数据服务的heartbeat包用于<strong>发送心跳消息</strong>;而接口服务的heartbeat包则用于<strong>接收数据服务节点的心跳消息</strong>。</li>
<li>数据服务的locate包用于<strong>接收定位消息、定位对象以及发送反馈消息</strong>；而接口服务的locate包则用于<strong>发送定位消息并处理反馈消息</strong>。</li>
</ul>
<p>接口服务的heartbeat包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map,整个包可见，用于缓存所有的数据服务节点</span></span><br><span class="line"><span class="keyword">var</span> dataServers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]time.Time)</span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenHeartbeat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建消息队列绑定apiServers exchange</span></span><br><span class="line">	q := rabbitmq.New(os.Getenv(<span class="string">"RABBITMQ_SERVER"</span>))</span><br><span class="line">	<span class="keyword">defer</span> q.Close()</span><br><span class="line">	q.Bind(<span class="string">"apiServers"</span>)</span><br><span class="line">	<span class="comment">// 通过go channel监听每个来自数据服务节点的心跳信息</span></span><br><span class="line">	c := q.Consume()</span><br><span class="line">	<span class="keyword">go</span> removeExpiredDataServer() <span class="comment">//goroutine并行处理</span></span><br><span class="line">	<span class="keyword">for</span> msg := <span class="keyword">range</span> c &#123;</span><br><span class="line">		<span class="comment">//将数据服务节点的监听地址作为map的键，收到消息的时间作为值存入map中</span></span><br><span class="line">		dataServer, e := strconv.Unquote(<span class="keyword">string</span>(msg.Body))</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(e)</span><br><span class="line">		&#125;</span><br><span class="line">		mutex.Lock()</span><br><span class="line">		dataServers[dataServer] = time.Now()</span><br><span class="line">		mutex.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每隔5s扫描一遍map,清除其中超过10s没有收到心跳消息的数据服务节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeExpiredDataServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">		mutex.Lock()</span><br><span class="line">		<span class="keyword">for</span> s, t := <span class="keyword">range</span> dataServers &#123;</span><br><span class="line">			<span class="keyword">if</span> t.Add(<span class="number">10</span> * time.Second).Before(time.Now()) &#123;</span><br><span class="line">				<span class="built_in">delete</span>(dataServers, s)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		mutex.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历map并返回当前所有的数据服务节点</span></span><br><span class="line"><span class="comment">// 为防止多个goroutine并发读写map造成错误，map读写全部需要mutex的保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDataServers</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">	ds := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> s, _ := <span class="keyword">range</span> dataServers &#123;</span><br><span class="line">		ds = <span class="built_in">append</span>(ds, s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从当前所有的数据服务节点中随机选择一个节点并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ChooseRandomDataServer</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	ds := GetDataServers()</span><br><span class="line">	n := <span class="built_in">len</span>(ds)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ds[rand.Intn(n)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口服务的locate包：主要用于<strong>向数据服务节点群发定位消息并接收反馈</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理HTTP请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	m := r.Method</span><br><span class="line">	<span class="keyword">if</span> m != http.MethodGet &#123;</span><br><span class="line">		w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将文件名作为Locate函数的参数进行定位</span></span><br><span class="line">	info := Locate(strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>])</span><br><span class="line">	<span class="comment">// 为空，说明定位失败</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(info) == <span class="number">0</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusNotFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 不为空，则拥有该对象的一个数据服务节点的地址，将地址作为HTTP响应的正文输出</span></span><br><span class="line">	b, _ := json.Marshal(info)</span><br><span class="line">	w.Write(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Locate</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建一个消息队列</span></span><br><span class="line">	q := rabbitmq.New(os.Getenv(<span class="string">"RABBITMQ_SERVER"</span>))</span><br><span class="line">	<span class="comment">// 向dataServers exchange群发对象名字的定位信息</span></span><br><span class="line">	q.Publish(<span class="string">"dataServers"</span>, name)</span><br><span class="line">	c := q.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//1s后关闭临时消息队列</span></span><br><span class="line">		<span class="comment">//设置超时机制，避免无止境的等待。</span></span><br><span class="line">		<span class="comment">//1s后没有任何反馈，消息队列关闭，收到一个长度为0的消息，返回一个空字符串</span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		q.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">//阻塞等待数据服务节点向自己发送反馈消息</span></span><br><span class="line">	<span class="comment">//若在1s内有来自数据服务节点的消息，返回该消息的正文内容，也就是该数据服务节点的监听地址</span></span><br><span class="line">	msg := &lt;-c</span><br><span class="line">	s, _ := strconv.Unquote(<span class="keyword">string</span>(msg.Body))</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查Locate结果是否为空字符串来判定对象是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Exist</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Locate(name) != <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口服务的objects包：</p>
<p>接口服务的objects包跟数据服务有很大区别，其put函数和get函数并不会访问本地磁盘上的对象，而是将HTTP请求转发给数据服务。put函数负责处理对象PUT请求，其相关函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">put</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 从URL中获取objects_name</span></span><br><span class="line">	object := strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="comment">// 将r.Body和objects作为参数调用storeObject</span></span><br><span class="line">	<span class="comment">// 第一个返回值为int类型的变量，用于表示HTTP错误码</span></span><br><span class="line">	<span class="comment">// 第二个返回值为error,如果error不为nil，出错并打印</span></span><br><span class="line">	c, e := storeObject(r.Body, object)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">	&#125;</span><br><span class="line">	w.WriteHeader(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">storeObject</span><span class="params">(r io.Reader, object <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	stream, e := putStream(object)</span><br><span class="line">	<span class="comment">// 没有找到可用的数据服务节点</span></span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> http.StatusServiceUnavailable, e</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到可用的数服务节点并得到一个objectstream.PutStream的指针</span></span><br><span class="line">	<span class="comment">// objectstream.PutStream实现了Write方法，是一个io.Write接口</span></span><br><span class="line">	<span class="comment">// 用io.Copy将HTTP请求的正文写入stream</span></span><br><span class="line">	io.Copy(stream, r)</span><br><span class="line">	e = stream.Close()</span><br><span class="line">	<span class="comment">//写入出错</span></span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> http.StatusInternalServerError, e</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//写入成功</span></span><br><span class="line">	<span class="keyword">return</span> http.StatusOK, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putStream</span><span class="params">(object <span class="keyword">string</span>)</span> <span class="params">(*objectstream.PutStream, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先获得一个随机数服务节点的地址</span></span><br><span class="line">	server := heartbeat.ChooseRandomDataServer()</span><br><span class="line">	fmt.Println(<span class="string">"data server ="</span>, server)</span><br><span class="line">	<span class="comment">// 没有可用的数据服务节点，返回objectstream.PutStream的空指针</span></span><br><span class="line">	<span class="keyword">if</span> server == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"cannot find any dataServer"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> objectstream.NewPutStream(server, object), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objectstream包：对Go中的http包的一个封装，用于将一些http函数的调用转换成写流的形式，方便处理。具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> PutStream <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// writer用于实现Write方法</span></span><br><span class="line">	writer *io.PipeWriter</span><br><span class="line">	<span class="comment">// c用于把在一个gouroutine传输数据过程中发生的错误传回主线程</span></span><br><span class="line">	c      <span class="keyword">chan</span> error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于生成一个PutStream结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPutStream</span><span class="params">(server, object <span class="keyword">string</span>)</span> *<span class="title">PutStream</span></span> &#123;</span><br><span class="line">	<span class="comment">// 用io.Pipe创建一对reader和writer,类型为*io.PipeReader和*io.PipeWriter</span></span><br><span class="line">	<span class="comment">// 管道互联，写入writer的内容可以从reader中读出</span></span><br><span class="line">	<span class="comment">// 希望以写入数据流的方法操作HTTP的PUT请求</span></span><br><span class="line">	reader, writer := io.Pipe()</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 生成put请求，需要提供一个io.Reader作为http.NewRequest的参数</span></span><br><span class="line">		request, _ := http.NewRequest(<span class="string">"PUT"</span>, <span class="string">"http://"</span>+server+<span class="string">"/objects/"</span>+object, reader)</span><br><span class="line">		<span class="comment">// http.Client负责从request中读取需要PUT的内容</span></span><br><span class="line">		client := http.Client&#123;&#125;</span><br><span class="line">		<span class="comment">// 由于管道的读写阻塞特性，在goroutine中调用client.Do方法</span></span><br><span class="line">		r, e := client.Do(request)</span><br><span class="line">		<span class="keyword">if</span> e == <span class="literal">nil</span> &amp;&amp; r.StatusCode != http.StatusOK &#123;</span><br><span class="line">			e = fmt.Errorf(<span class="string">"dataServer return http code %d"</span>, r.StatusCode)</span><br><span class="line">		&#125;</span><br><span class="line">		c &lt;- e</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> &amp;PutStream&#123;writer, c&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于写入writer,实现该方法PutStream才被认为实现了io.Write接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *PutStream)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> w.writer.Write(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭writer,为了让管道另一端的reader读到io.EOF，否则在gouroutine中运行的client.Do将始终阻塞无法返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *PutStream)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	w.writer.Close()</span><br><span class="line">	<span class="comment">// 从c中读取发送自goroutine得错误并返回</span></span><br><span class="line">	<span class="keyword">return</span> &lt;-w.c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口服务层object包用于处理GET请求具体实现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	object := strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="comment">// 调用getStream生成一个类型为io.Reader的stream</span></span><br><span class="line">	stream, e := getStream(object)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusNotFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用io.Copy将stream的内容写入HTTP响应的正文</span></span><br><span class="line">	io.Copy(w, stream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getStream</span><span class="params">(object <span class="keyword">string</span>)</span> <span class="params">(io.Reader, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定位object对象</span></span><br><span class="line">	server := locate.Locate(object)</span><br><span class="line">	<span class="keyword">if</span> server == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"object %s locate fail"</span>, object)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用objectstream.NewGetStream并返回结果</span></span><br><span class="line">	<span class="keyword">return</span> objectstream.NewGetStream(server, object)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objectstream包的GetStream相关实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetStream <span class="keyword">struct</span> &#123;</span><br><span class="line">	reader io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGetStream</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(*GetStream, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 输入的url表示用于获取数据流的HTTP服务地址</span></span><br><span class="line">	<span class="comment">// 调用http.Get发起一个GET请求，获取该地址的HTTP响应</span></span><br><span class="line">	r, e := http.Get(url) <span class="comment">//返回的r类型为*http.Response,其body是用于读取HTTP响应正文的io.Reader</span></span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, e</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r.StatusCode != http.StatusOK &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"dataServer return http code %d"</span>, r.StatusCode)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;GetStream&#123;r.Body&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装newGetStream函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGetStream</span><span class="params">(server, object <span class="keyword">string</span>)</span> <span class="params">(*GetStream, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> server == <span class="string">""</span> || object == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid server %s object %s"</span>, server, object)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 内部拼凑一个url传给newGetStream，对外隐藏url的细节</span></span><br><span class="line">	<span class="keyword">return</span> newGetStream(<span class="string">"http://"</span> + server + <span class="string">"/objects/"</span> + object)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于读取reader成员，实现该方法，则GetStream结构体实现io.Reader接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *GetStream)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.reader.Read(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rabbitmq包实现：</p>
<p>为使用RabbitMQ,需要下载RabbitMQ提供的Go语言包<code>&quot;github.com/streadway/amqp&quot;</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u <span class="string">"github.com/streadway/amqp"</span></span><br></pre></td></tr></table></figure>
<p>为方便使用，实现一个rabbitmq包，该包对<code>&quot;github.com/streadway/amqp</code>进行封装以简化接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rabbitmq</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"github.com/streadway/amqp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RabbitMQ <span class="keyword">struct</span> &#123;</span><br><span class="line">	channel  *amqp.Channel</span><br><span class="line">	conn     *amqp.Connection</span><br><span class="line">	Name     <span class="keyword">string</span></span><br><span class="line">	exchange <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的rabbitmq.RabbitMQ结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">RabbitMQ</span></span> &#123;</span><br><span class="line">	conn, e := amqp.Dial(s)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ch, e := conn.Channel()</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	q, e := ch.QueueDeclare(</span><br><span class="line">		<span class="string">""</span>,    <span class="comment">// name</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// durable</span></span><br><span class="line">		<span class="literal">true</span>,  <span class="comment">// delete when unused</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// exclusive</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// no-wait</span></span><br><span class="line">		<span class="literal">nil</span>,   <span class="comment">// arguments</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mq := <span class="built_in">new</span>(RabbitMQ)</span><br><span class="line">	mq.channel = ch</span><br><span class="line">	mq.conn = conn</span><br><span class="line">	mq.Name = q.Name</span><br><span class="line">	<span class="keyword">return</span> mq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将自己的消息队列和一个exchange绑定</span></span><br><span class="line"><span class="comment">// 所有发往该exchange的消息都能在自己的消息队列中被接收到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span> <span class="title">Bind</span><span class="params">(exchange <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	e := q.channel.QueueBind(</span><br><span class="line">		q.Name,   <span class="comment">// queue name</span></span><br><span class="line">		<span class="string">""</span>,       <span class="comment">// routing key</span></span><br><span class="line">		exchange, <span class="comment">// exchange</span></span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">	q.exchange = exchange</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往某个消息队列发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span> <span class="title">Send</span><span class="params">(queue <span class="keyword">string</span>, body <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	str, e := json.Marshal(body)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">	e = q.channel.Publish(<span class="string">""</span>,</span><br><span class="line">		queue,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			ReplyTo: q.Name,</span><br><span class="line">			Body:    []<span class="keyword">byte</span>(str),</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往某个exchange发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span> <span class="title">Publish</span><span class="params">(exchange <span class="keyword">string</span>, body <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	str, e := json.Marshal(body)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">	e = q.channel.Publish(exchange,</span><br><span class="line">		<span class="string">""</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			ReplyTo: q.Name,</span><br><span class="line">			Body:    []<span class="keyword">byte</span>(str),</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个接收消息的go channel,使客户程序可以通过Go的原生机制接收队列中的消息。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span> <span class="title">Consume</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">amqp</span>.<span class="title">Delivery</span></span> &#123;</span><br><span class="line">	c, e := q.channel.Consume(q.Name,</span><br><span class="line">		<span class="string">""</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">	q.channel.Close()</span><br><span class="line">	q.conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><p>测试环境：包括6个数据服务节点和2个接口服务节点，共8个节点。为了方便测试,8个节点其实都运行在同一台服务器上，只是绑定了8个不同的地址加以区分。<br>6个数据服务节点地址分别是<code>10.29.1.1:12346、10.29.1.2:12346、10.29.1.3:12346、10.29.1.4:12346、10.29.1.5:12346、10.29.1.6:12346</code>。2个接口服务节点地址是<code>10.29.2.1:12346,10.29.2.2:12346</code></p>
<p>在同一台服务器上绑定多个地址命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig eno1:1 10.29.1.1/16</span><br><span class="line">sudo ifconfig eno1:2 10.29.1.2/16</span><br><span class="line">sudo ifconfig eno1:3 10.29.1.3/16</span><br><span class="line">sudo ifconfig eno1:4 10.29.1.4/16</span><br><span class="line">sudo ifconfig eno1:5 10.29.1.5/16</span><br><span class="line">sudo ifconfig eno1:6 10.29.1.6/16</span><br><span class="line">sudo ifconfig eno1:7 10.29.2.1/16</span><br><span class="line">sudo ifconfig eno1:8 10.29.2.2/16</span><br></pre></td></tr></table></figure>
<p>eno1是这台机器的网络接口，可使用<code>ifconfig</code>查询得到，由于Ubuntu 16.0.4的内核支持接口别名，只需要在ifconfig 命令上使用别名接口(eno1后面加上冒号和一个数字)就可以在同一个接口上绑定多个地址。<br>为了让节点能够建立消息队列，还需要一台 RabbitMQ服务器（地址设置为本地即可)，在其上安装rabbitmq-server：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install rabbitmq-server</span><br><span class="line"><span class="comment"># 下载rabbitmqadmin管理工具</span></span><br><span class="line">sudo rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_managements </span><br><span class="line">wget localhost:15672/cli /rabbitmqadmin</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建apiServers 和 dataServers这两个exchange.</span></span><br><span class="line">$ python3 rabbitmqadmin <span class="built_in">declare</span> exchange name=apiServers <span class="built_in">type</span>=fanout</span><br><span class="line">$ python3 rabbitmqadmin <span class="built_in">declare</span> exchange name=dataServers <span class="built_in">type</span>=fanout</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加用户test，密码test。</span></span><br><span class="line">$ sudo rabbitmqctl add_user <span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment">#给test用户添加访问所有exchange的权限。</span></span><br><span class="line">$ sudo rabbitmqctl set_permissions -p / <span class="built_in">test</span> <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure>
<p>消息队列服务器就绪，现在需要同时启动8个服务程序，在启动前还要记得创建相应的<code>$STORAGE_ROOT</code>目录及其子目录<code>objects</code>,接下来的操作可使用shell脚本进行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#clean environment</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 6`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    rm -rf /tmp/<span class="variable">$i</span>/objects/*</span><br><span class="line">    rm -rf /tmp/<span class="variable">$i</span>/temp/*</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare the distributed envrionment</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 6`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    mkdir -p /tmp/<span class="variable">$i</span>/objects</span><br><span class="line">    mkdir -p /tmp/<span class="variable">$i</span>/temp</span><br><span class="line">    mkdir -p /tmp/<span class="variable">$i</span>/garbage</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rabbitmq env</span></span><br><span class="line"><span class="comment"># wget localhost:15672/cli/rabbitmqadmin #rabbitmq访问</span></span><br><span class="line">python3 rabbitmqadmin <span class="built_in">declare</span> exchange name=apiServers <span class="built_in">type</span>=fanout</span><br><span class="line">python3 rabbitmqadmin <span class="built_in">declare</span> exchange name=dataServers <span class="built_in">type</span>=fanout</span><br><span class="line"><span class="comment">#sudo rabbitmqctl add_user test test #首次运行需要创建用户和密码</span></span><br><span class="line"><span class="comment">#sudo rabbitmqctl set_permissions -p / test ".*" ".*" ".*" #修改访问权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start test env</span></span><br><span class="line"><span class="built_in">export</span> RABBITMQ_SERVER=amqp://<span class="built_in">test</span>:<span class="built_in">test</span>@localhost:5672</span><br><span class="line"><span class="built_in">export</span> ES_SERVER=localhost:9200</span><br><span class="line"></span><br><span class="line">LISTEN_ADDRESS=10.29.1.1:12346 STORAGE_ROOT=/tmp/1 go run ../dataServer/dataServer.go &amp;</span><br><span class="line">LISTEN_ADDRESS=10.29.1.2:12346 STORAGE_ROOT=/tmp/2 go run ../dataServer/dataServer.go &amp;</span><br><span class="line">LISTEN_ADDRESS=10.29.1.3:12346 STORAGE_ROOT=/tmp/3 go run ../dataServer/dataServer.go &amp;</span><br><span class="line">LISTEN_ADDRESS=10.29.1.4:12346 STORAGE_ROOT=/tmp/4 go run ../dataServer/dataServer.go &amp;</span><br><span class="line">LISTEN_ADDRESS=10.29.1.5:12346 STORAGE_ROOT=/tmp/5 go run ../dataServer/dataServer.go &amp;</span><br><span class="line">LISTEN_ADDRESS=10.29.1.6:12346 STORAGE_ROOT=/tmp/6 go run ../dataServer/dataServer.go &amp;</span><br><span class="line"></span><br><span class="line">LISTEN_ADDRESS=10.29.2.1:12346 go run ../apiServer/apiServer.go &amp;</span><br><span class="line">LISTEN_ADDRESS=10.29.2.2:12346 go run ../apiServer/apiServer.go &amp;</span><br></pre></td></tr></table></figure>
<p>使用curl测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">curl -v <span class="number">10.29</span><span class="number">.2</span><span class="number">.1</span>:<span class="number">12346</span>/objects/test2 -XPUT -d<span class="string">"this is object test2"</span></span><br><span class="line"></span><br><span class="line">curl <span class="number">10.29</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">12346</span>/locate/test2</span><br><span class="line">echo</span><br><span class="line">curl <span class="number">10.29</span><span class="number">.2</span><span class="number">.1</span>:<span class="number">12346</span>/objects/test2</span><br><span class="line">echo</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">*   Trying 10.29.2.1...</span><br><span class="line">* TCP_NODELAY <span class="built_in">set</span></span><br><span class="line">* Connected to 10.29.2.1 (10.29.2.1) port 12346 (<span class="comment">#0)</span></span><br><span class="line">&gt; PUT /objects/test2 HTTP/1.1</span><br><span class="line">&gt; Host: 10.29.2.1:12346</span><br><span class="line">&gt; User-Agent: curl/7.63.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; Content-Length: 20</span><br><span class="line">&gt; Content-Type: application/x-www-form-urlencoded</span><br><span class="line">&gt; </span><br><span class="line">* upload completely sent off: 20 out of 20 bytes</span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Sat, 10 Apr 2021 08:11:54 GMT</span><br><span class="line">&lt; Content-Length: 0</span><br><span class="line">&lt; </span><br><span class="line">* Connection <span class="comment">#0 to host 10.29.2.1 left intact</span></span><br><span class="line"><span class="string">"10.29.1.4:12346"</span></span><br><span class="line">this is object test2</span><br></pre></td></tr></table></figure>
<p>完整代码可见：<a href="https://github.com/dongshifu/distributed_object_storage_dong/tree/main/v1" target="_blank" rel="noopener">可扩展分布式系统实现</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>《分布式对象存储—原理、架构及Go语言实现》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/09/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-1/" class="post-title-link" itemprop="url">分布式对象存储介绍及单机实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-09 15:03:58" itemprop="dateCreated datePublished" datetime="2021-01-09T15:03:58+08:00">2021-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 10:08:33" itemprop="dateModified" datetime="2021-05-12T10:08:33+08:00">2021-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">分布式对象存储</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><h4 id="网络存储"><a href="#网络存储" class="headerlink" title="网络存储"></a>网络存储</h4><ul>
<li>NAS: Network Attached Storage的简称，是一个提供了<strong>存储功能</strong>和<strong>文件系统</strong>的<strong>网络服务器</strong>。客户端可以<strong>访问</strong>NAS上的文件系统，还可以<strong>上传和下载</strong>文件。NAS客户端和服务端之间使用的协议有SMB、NFS 以及AFS等<strong>网络文件系统协议</strong>。对于客户端来说，NAS就是一个网络上的文件服务器。</li>
<li>SAN： Storage Area Network 的简称。和NAS的区别是<strong>SAN只提供了块存储，而把文件系统的抽象交给客户端来管理</strong>。SAN 的客户端和服务端之间的协议有FibreChannel、iSCSI、ATA over Ethernet(AoE）和 HyperSCSI。对于客户端来说，<strong>SAN就是一块磁盘,可以对其格式化、创建文件系统并挂载。</strong></li>
</ul>
<p>现代的网络存储通常混合使用NAS和SAN，同时提供文件级别的协议和块级别的协议。</p>
<h4 id="网络文件系统、块存储与对象存储的区别"><a href="#网络文件系统、块存储与对象存储的区别" class="headerlink" title="网络文件系统、块存储与对象存储的区别"></a>网络文件系统、块存储与对象存储的区别</h4><h5 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h5><ul>
<li>网络文件系统：数据是以一个个<strong>文件的形式来管理</strong></li>
<li>块存储：数据是以<strong>数据块的形式来管理</strong>的，<strong>每个数据块有它自己的地址，但是没有额外的背景信息</strong>。</li>
<li>对象存储：以<strong>对象</strong>的方式来管理数据的，一个对象通常包含了3个部分:<strong>对象的数据、对象的元数据以及一个全局唯一的标识符（即对象的ID)</strong>。其中<ul>
<li>对象的数据就是该对象中存储的<strong>数据本身</strong>。一个对象可以用来保存大量无结构的数据(例如：音乐的具体内容)。</li>
<li>对象的元数据是对象的<strong>描述信息</strong>，为了和对象的数据本身区分开来，称其为元数据(例如：音乐的名字、大小等)。</li>
<li>对象的标识符用于引用该对象。和对象的名字不同，标识符具有<strong>全局唯一性</strong>。名字不具有这个特性。通常用<strong>对象的散列值来做其标识符</strong></li>
</ul>
</li>
</ul>
<h5 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h5><ul>
<li>网络文件系统的客户端通过NFS等<strong>网络协议</strong>访问某个远程服务器上存储的文件。</li>
<li>块存储的客户端通过<strong>数据块的地址</strong>访问SAN上的数据块。</li>
<li>对象存储则通过<strong>REST网络服务</strong>访问对象。</li>
</ul>
<p>REST为Representational State Transfer的简称。REST网络服务通过<strong>标准HTTP服务对网络资源提供一套预先定义的无状态操作</strong>。网络资源被定义为可以<strong>通过URL 访问的文档或文件</strong>。更广发的：网络上一切可以通过任何方式被标识、命名、引用或处理的东西都是一种网络资源。</p>
<p>对于对象存储来说，<strong>对象就是一种网络资源，但除了对象本身以外，还需要提供一些其他的网络资源用来访问对象存储的各种功能</strong>。客户端向 REST网络服务发起请求并接收响应，以确认网络资源发生了某种变化。HTTP预定义的请求方法(Request Method)通常包括且不限于GET、POST、PUT、DELETE等。它们分别对应不同的处理方式:GET方法在REST 标准中通常用来获取某个网络资源，PUT通常用于<strong>创建或替换</strong>某个网络资源（注意，它跟<strong>PUT的区别是POST一般不同于替换网络资源，如果该资源已经存在，POST通常会返回一个错误而不是覆盖它，POST通常用于创建某个网络资源，DELETE通常用于删除某个网络资源。</strong></p>
<h5 id="对象存储的优势"><a href="#对象存储的优势" class="headerlink" title="对象存储的优势"></a>对象存储的优势</h5><ul>
<li>扩展方便：扩展只需要添加新的存储节点就可以</li>
<li>低代价的数据冗余能力</li>
</ul>
<h3 id="单机版对象存储系统"><a href="#单机版对象存储系统" class="headerlink" title="单机版对象存储系统"></a>单机版对象存储系统</h3><p>通过在一台服务器上运行一个<strong>HTTP服务提供的REST接口</strong>，并通过接口实现本地服务器上的对象存取。</p>
<p><img src="https://api2.mubu.com/v3/document_image/d0432f98-00b4-4a53-b82d-906980f1bcd5-11197877.jpg" alt="单机版分布式存储系统"></p>
<h4 id="REST接口"><a href="#REST接口" class="headerlink" title="REST接口"></a>REST接口</h4><p>实现PUT方法和GET方法</p>
<h5 id="对象PUT"><a href="#对象PUT" class="headerlink" title="对象PUT"></a>对象PUT</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /object/&lt;object_name&gt;</span><br><span class="line">请求正文(Request Body)</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/d7a4de74-3320-4ec9-9ae7-760aedea5e94-11197877.jpg" alt="单机版put操作"></p>
<p>客户端通过PUT方法将一个对象上传至服务器，服务器则将该对象保存在本地磁盘上。<strong><code>/objects/&lt;object_name&gt;</code>是标识该对象网络资源的URL</strong>。URL是Uniform Resource Locator  的简称，也就是一个网络地址，用于引用某个网络资源在网络上的位置。</p>
<p>在对象存储中，通常使用<strong>PUT方法来上传一个对象</strong>。客户端的PUT请求提供了对象的名字<code>&lt;object_name&gt;</code>和对象的数据<code>&lt;content of object&gt;</code>,它们最终被保存在本地磁盘上的文件<code>STORAGE_ROOT/objects/&lt;object_name&gt;</code>中。<code>$STORAGE_ROOT</code>环境变量保存着在<strong>本地磁盘上的存储根目录的名字。</strong></p>
<h5 id="对象GET"><a href="#对象GET" class="headerlink" title="对象GET"></a>对象GET</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /objects/&lt;object_name&gt;</span><br><span class="line">响应正文 (Response Body)</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/8c258fbb-a251-429e-8c7d-4f64c0bb7687-11197877.jpg" alt="单机版get操作"></p>
<p>客户端通过GET方法从服务器上<strong>下载</strong>一个对象，<strong>服务器在本地磁盘上查找并读取该对象，如果该对象不存在，则服务器返回HTTP错误代码<code>404 Not Found</code>。</strong></p>
<p>在对象存储中，总是使用GET方法来下载一个对象。客户端的GET请求提供了<code>&lt;object_name&gt;</code>，服务进程从本地磁盘上的文件<code>$STORAGE_ROOT/objects/&lt;object_name&gt;</code>中<strong>读取对象并将其写入HTTP响应正文。</strong></p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>main函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//注册HTTP处理函数objects.Handler,若有客户端访问该服务器的HTTP服务且URL以"objects/"开头，</span></span><br><span class="line">	<span class="comment">//则请求将由objects.Handler负责处理。除此之外的HTTP请求会默认返回HTTP错误代码404 Not Found.</span></span><br><span class="line">	http.HandleFunc(<span class="string">"/objects/"</span>, objects.Handler)</span><br><span class="line">	<span class="comment">//监听端口</span></span><br><span class="line">	<span class="comment">//正常情况下没有返回，程序运行后开始监听端口上的请求</span></span><br><span class="line">	<span class="comment">//非正常情况下，该函数将错误返回，log.Fatal打印错误信息并退出程序</span></span><br><span class="line">	log.Fatal(http.ListenAndServe(os.Getenv(<span class="string">"LISTEN_ADDRESS"</span>), <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objects包下的<code>Handler</code>函数、<code>get、put</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> objects</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查HTTP请求方法:PUT则调用put函数，GET则调用共get函数。其余则返回405 Method Not Allowed错误代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	m := r.Method <span class="comment">//Method记录该HTTP请求的方法</span></span><br><span class="line">	<span class="keyword">if</span> m == http.MethodPut &#123;</span><br><span class="line">		put(w, r)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> m == http.MethodGet &#123;</span><br><span class="line">		get(w, r)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//写HTTP响应的代码</span></span><br><span class="line">	w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> objects</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">put</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Println(r.URL.EscapedPath())</span><br><span class="line">	<span class="comment">//r.URL.EsccapedPath得到request的路径，此处为/objects/xxx</span></span><br><span class="line">	f, e := os.Create(os.Getenv(<span class="string">"STORAGE_ROOT"</span>) + <span class="string">"/objects/"</span> +</span><br><span class="line">		strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]) <span class="comment">//得到文件名</span></span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//创建文件失败</span></span><br><span class="line">		log.Println(e)</span><br><span class="line">		<span class="comment">//写入HTTP响应的代码</span></span><br><span class="line">		w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	io.Copy(f, r.Body) <span class="comment">//将r.Body写入文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> objects</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	f, e := os.Open(os.Getenv(<span class="string">"STORAGE_ROOT"</span>) + <span class="string">"/objects/"</span> +</span><br><span class="line">		strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>])</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusNotFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	io.Copy(w, f) </span><br><span class="line">	<span class="comment">//f本身的类型是*os.File,同时实现了io.Writer和io.Reader两个接口，即实现了Write和Read方法</span></span><br><span class="line">	<span class="comment">//http.ResponseWriter也是接口，该接口实现了Write方法，也是一个io.Write接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="linux下功能测试"><a href="#linux下功能测试" class="headerlink" title="linux下功能测试"></a>linux下功能测试</h3><p>运行服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/objects</span><br><span class="line">LISTEN_ADDRESS=:12345 STORAGE_ROOT=/tmp go run server.go</span><br></pre></td></tr></table></figure>
<p>curl 进行http访问：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -v 10.29.102.172:12345/objects/<span class="built_in">test</span> <span class="comment">#默认get操作，此时没有数据，返回404 Not Found</span></span><br><span class="line"></span><br><span class="line">curl -v 10.29.102.172:12345/objects/<span class="built_in">test</span> -XPUT -d<span class="string">"this is a test object"</span> <span class="comment"># put一个对象</span></span><br><span class="line"></span><br><span class="line">curl -v 10.29.102.172:12345/objects/<span class="built_in">test</span> <span class="comment">#默认get操作，成功返回200 OK</span></span><br></pre></td></tr></table></figure>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>《分布式对象存储—原理、架构及Go语言实现》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/03/Go-channel-3channel%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/03/Go-channel-3channel%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">channel发送和接收数据的过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-03 20:03:09" itemprop="dateCreated datePublished" datetime="2021-01-03T20:03:09+08:00">2021-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 10:57:04" itemprop="dateModified" datetime="2021-04-08T10:57:04+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="channel发送和接收元素的本质"><a href="#channel发送和接收元素的本质" class="headerlink" title="channel发送和接收元素的本质"></a>channel发送和接收元素的本质</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">All transfer of value on the go channels happens with the copy of value.</span><br><span class="line">channel 的发送和接收操作本质上都是 “值的拷贝”，无论是从 sender goroutine 的栈到 chan buf，还是从 chan buf 到 receiver goroutine，或者是直接从 sender goroutine 到 receiver goroutine。</span><br></pre></td></tr></table></figure>
<p>举例分析：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = user&#123;name: <span class="string">"Ankur"</span>, age: <span class="number">25</span>&#125;</span><br><span class="line"><span class="keyword">var</span> g = &amp;u</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyUser</span><span class="params">(pu *user)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"modifyUser Received Vaule"</span>, pu)</span><br><span class="line">	pu.name = <span class="string">"Anand"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printUser</span><span class="params">(u &lt;-<span class="keyword">chan</span> *user)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"printUser goRoutine called"</span>, &lt;-u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> *user, <span class="number">5</span>)</span><br><span class="line">	c &lt;- g</span><br><span class="line">	fmt.Println(g)</span><br><span class="line">	<span class="comment">// modify g</span></span><br><span class="line">	g = &amp;user&#123;name: <span class="string">"Ankur Anand"</span>, age: <span class="number">100</span>&#125;</span><br><span class="line">	<span class="keyword">go</span> printUser(c)</span><br><span class="line">	<span class="keyword">go</span> modifyUser(g)</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Println(g)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">&amp;&#123;Ankur 25&#125;</span></span><br><span class="line"><span class="comment">modifyUser Received Vaule &amp;&#123;Ankur Anand 100&#125;</span></span><br><span class="line"><span class="comment">printUser goRoutine called &amp;&#123;Ankur 25&#125;</span></span><br><span class="line"><span class="comment">&amp;&#123;Anand 100&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>一开始构造一个结构体 u，地址是 0x56420，图中地址上方就是它的内容。接着把 <code>&amp;u</code> 赋值给指针 <code>g</code>，g 的地址是 0x565bb0，它的内容就是一个地址，指向 u。</p>
<p>main 程序里，先把 g 发送到 c，根据 <code>copy value</code> 的本质，进入到 chan buf 里的就是 <code>0x56420</code>，它是指针 g 的值（不是它指向的内容），所以打印从 channel 接收到的元素时，它就是 <code>&amp;{Ankur 25}</code>。因此，这里并不是将指针 g “发送” 到了 channel 里，只是拷贝它的值而已。</p>
<h3 id="向channel发送数据的过程"><a href="#向channel发送数据的过程" class="headerlink" title="向channel发送数据的过程"></a>向channel发送数据的过程</h3><p>发送操作最终转化为 <code>chansend</code> 函数，关注主流程(hchan源码分析见<a href="https://dongshifu.github.io/2021/01/02/Go-channel-2%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">channel底层实现原理</a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 src/runtime/chan.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果 channel 是 nil</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 不能阻塞，直接返回 false，表示未发送成功</span></span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当前 goroutine 被挂起</span></span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"chan send (nil chan)"</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略 debug 相关……</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于不阻塞的 send，快速检测失败场景</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：</span></span><br><span class="line">	<span class="comment">// 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine</span></span><br><span class="line">	<span class="comment">// 2. channel 是缓冲型的，但循环数组已经装满了元素</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">		(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 锁住 channel，并发安全</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 channel 关闭了</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="comment">// 直接 panic</span></span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果接收队列里有 goroutine，直接将要发送的数据拷贝到接收 goroutine</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于缓冲型的 channel，如果还有缓冲空间</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// qp 指向 buf 的 sendx 位置</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将数据从 ep 处拷贝到 qp</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		<span class="comment">// 发送游标值加 1</span></span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="comment">// 如果发送游标值等于容量值，游标值归 0</span></span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 缓冲区的元素数量加一</span></span><br><span class="line">		c.qcount++</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不需要阻塞，则直接返回错误</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// channel 满了，发送方会被阻塞。接下来会构造一个 sudog</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前 goroutine 的指针</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前 goroutine 进入发送等待队列</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前 goroutine 被挂起</span></span><br><span class="line">	goparkunlock(&amp;c.lock, <span class="string">"chan send"</span>, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从这里开始被唤醒了（channel 有机会可以发送了）</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 被唤醒后，channel 关闭了。坑爹啊，panic</span></span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 去掉 mysg 上绑定的 channel</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/02/Go-channel-2%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/Go-channel-2%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">channel的底层实现原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 19:06:50" itemprop="dateCreated datePublished" datetime="2021-01-02T19:06:50+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 10:56:49" itemprop="dateModified" datetime="2021-04-08T10:56:49+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>源码( go 1.9.2)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// chan 里元素数量</span></span><br><span class="line">	qcount   <span class="keyword">uint</span></span><br><span class="line">	<span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span></span><br><span class="line">	<span class="comment">// 指向底层循环数组的指针</span></span><br><span class="line">	<span class="comment">// 只针对有缓冲的 channel</span></span><br><span class="line">	buf      unsafe.Pointer</span><br><span class="line">	<span class="comment">// chan 中元素大小</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	<span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	<span class="comment">// chan 中元素类型</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	<span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	<span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	<span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	<span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保护 hchan 中所有字段</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重点字段"><a href="#重点字段" class="headerlink" title="重点字段"></a>重点字段</h4><ul>
<li><p><code>buf</code> <strong>指向底层循环数组</strong>，只有<strong>缓冲型</strong>的 channel 才有。</p>
</li>
<li><p><code>sendx</code>，<code>recvx</code> 均指向底层循环数组，表示<strong>当前可以发送和接收的元素位置索引值（相对于底层数组）</strong>。</p>
</li>
<li><p><code>sendq</code>，<code>recvq</code> 分别表示<strong>被阻塞的 goroutine</strong>，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。</p>
</li>
<li><p><code>waitq</code> 是 <code>sudog</code> 的一个<strong>双向链表</strong>，而 <code>sudog</code> 实际上是对 goroutine 的一个封装：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lock</code> 用来保证每个读 channel 或写 channel 的操作都是原子的。</li>
</ul>
<p>例如，创建一个容量为 6 的，元素为 int 型的 channel 数据结构如下 ：</p>
<p><img src="https://api2.mubu.com/v3/document_image/a8f442cb-91ec-4811-a781-42ffacce965b-11197877.jpg" alt="channel数据结构"></p>
<h3 id="channel的创建过程"><a href="#channel的创建过程" class="headerlink" title="channel的创建过程"></a>channel的创建过程</h3><p>通道有两个方向，发送和接收。理论上来说，可以创建一个只发送或只接收的通道，但是这种通道创建出来后，怎么使用呢？一个只能发的通道，怎么接收呢？同样，一个只能收的通道，如何向其发送数据呢？</p>
<p>一般而言，使用 <code>make</code> 创建一个能收能发的通道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲通道</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 有缓冲通道</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>创建 chan 的函数是 <code>makechan</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span></span><br></pre></td></tr></table></figure>
<p>从函数原型来看，<strong>创建的 chan 是一个指针。所以能在函数间直接传递 channel，而不用传递 channel 的指针。</strong></p>
<p>具体过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="keyword">uintptr</span>(-<span class="keyword">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略了检查 channel size，align 的代码</span></span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="comment">// 如果元素类型不含指针 或者 size 大小为 0（无缓冲类型）</span></span><br><span class="line">	<span class="comment">// 只进行一次内存分配</span></span><br><span class="line">	<span class="keyword">if</span> elem.kind&amp;kindNoPointers != <span class="number">0</span> || size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素</span></span><br><span class="line">		<span class="comment">// 只分配 "hchan 结构体大小 + 元素大小*个数" 的内存</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+<span class="keyword">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="comment">// 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct&#123;&#125;）</span></span><br><span class="line">		<span class="keyword">if</span> size &gt; <span class="number">0</span> &amp;&amp; elem.size != <span class="number">0</span> &#123;</span><br><span class="line">			c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// race detector uses this l是ocation for synchronization</span></span><br><span class="line">			<span class="comment">// Also prevents us from pointing beyond the allocation (see issue 9401).</span></span><br><span class="line">			<span class="comment">// 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处</span></span><br><span class="line">			<span class="comment">// 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct&#123;&#125;，也无影响</span></span><br><span class="line">			<span class="comment">// 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）</span></span><br><span class="line">			c.buf = unsafe.Pointer(c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 进行两次内存分配操作</span></span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = newarray(elem, <span class="keyword">int</span>(size))</span><br><span class="line">	&#125;</span><br><span class="line">	c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	<span class="comment">// 循环数组长度</span></span><br><span class="line">	c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 hchan 指针</span></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个 chan 后，<strong>内存在堆上分配</strong>，大概长这样：</p>
<p><img src="https://api2.mubu.com/v3/document_image/59aacc73-c65d-4b7c-a17d-d9f2144fc32d-11197877.jpg" alt="chan的内存分配情况"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/02/Go-channel_1%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/Go-channel_1%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">channel用法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 14:29:34" itemprop="dateCreated datePublished" datetime="2021-01-02T14:29:34+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 10:56:36" itemprop="dateModified" datetime="2021-04-08T10:56:36+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>Go的并发依赖CSP模型，基于channel实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Do not communicate by sharing memory; instead, share memory by communicating.</span><br><span class="line">不要通过共享内存来通信，而要通过通信来实现内存共享。</span><br></pre></td></tr></table></figure>
<p>CSP 全称是 “Communicating Sequential Processes”，用于描述两个独立的并发实体通过共享 channel（管道）进行通信的并发模型。Go语言并没有完全实现了 CSP 并发模型的所有理论，仅仅是实现了 process 和 channel 这两个概念。process 就是Go语言中的 goroutine，每个 goroutine 之间是通过 channel 通讯来实现数据共享。</p>
<p>大多数的编程语言的并发编程模型是基于线程和内存同步访问控制，Go 的并发编程的模型则用 goroutine 和 channel 来替代。Goroutine 和线程类似，channel 和 mutex (用于内存同步访问控制)类似。</p>
<p>Go 的并发原则非常优秀，目标就是<strong>简单</strong>：尽量使用 channel；把 goroutine 当作免费的资源，随便用。</p>
<h3 id="操作channel的结果"><a href="#操作channel的结果" class="headerlink" title="操作channel的结果"></a>操作channel的结果</h3><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>nil channel</th>
<th>closed channel</th>
<th>not nil, not closed channel</th>
</tr>
</thead>
<tbody>
<tr>
<td>close</td>
<td>panic</td>
<td>panic</td>
<td>正常关闭</td>
</tr>
<tr>
<td>读 &lt;- ch</td>
<td>阻塞</td>
<td><strong>读到对应类型的零值</strong></td>
<td><strong>阻塞或正常读取数据</strong>。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞</td>
</tr>
<tr>
<td>写 ch &lt;-</td>
<td>阻塞</td>
<td>panic</td>
<td>阻塞或正常写入数据。非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞</td>
</tr>
</tbody>
</table>
</div>
<p>总结一下，<strong>发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。</strong></p>
<p>读、写一个 nil channel 都会被阻塞。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/21/mysql_3%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/mysql_3%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/" class="post-title-link" itemprop="url">mysql事务</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-21 21:29:27" itemprop="dateCreated datePublished" datetime="2020-12-21T21:29:27+08:00">2020-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-20 19:53:39" itemprop="dateModified" datetime="2021-06-20T19:53:39+08:00">2021-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h3><p>转账场景：要给朋友小王转100块钱，而此时银行卡只有100块钱。转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，100块钱完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念。</p>
<p>简单来说，<strong>事务就是要保证一组数据库操作，要么全部成功，要么全部失败</strong>。在<strong>MySQL中，事务支持是在引擎层实现的</strong>。MySQL是一个支持多引擎的系统<strong>，但并不是所有的引擎都支持事务</strong>。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。</p>
<h3 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h3><p>事务的四要素:ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。本次主要学习隔离性。</p>
<p>当数据库上有多个事务同时执行的时候，就可能出现<a href="https://dongshifu.github.io/2020/12/17/mysql-4mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%94%81/" target="_blank" rel="noopener">脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</a>. 为了解决这些问题，就有了“隔离级别”的概念。</p>
<p><strong>隔离得越严实，效率就会越低</strong>。因此很多时候，我们都要在二者之间寻找一个<strong>平衡点</strong>。SQL标准的事务隔离级别包括：<strong>读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）</strong>。</p>
<ul>
<li>读未提交是指，<strong>一个事务还没提交时，它做的变更就能被别的事务看到</strong>。</li>
<li>读提交是指，一个事务<strong>提交之后，它做的变更才会被其他事务看到</strong>。</li>
<li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然<strong>在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</strong></li>
<li>串行化，顾名思义是<strong>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</strong></li>
</ul>
<p>举例说明事务的隔离性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/da798e7f-1080-480e-a530-6a73973f01dd-11197877.jpg" alt="事务的隔离性"></p>
<p>在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。</p>
<ul>
<li>若隔离级别是“读未提交”，<strong>事务B虽然还没有提交，但是结果已经被A看到</strong>了。v1 为2，v2为2，v3为2</li>
<li>若隔离级别是“读提交”，<strong>事务B的更新在提交后才能被A看到</strong>。v1为1，v2为2，v3为2</li>
<li>若隔离级别是“可重复读”，事务在执行期间看到的数据前后必须是一致的。v1为1，v2为1，v3为2</li>
<li>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</li>
</ul>
<p>在实现上，数据库里面会创建一个<strong>视图</strong>，<strong>访问的时候以视图的逻辑结果为准</strong>。在<strong>“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</strong></p>
<p>在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，一定要记得将MySQL的隔离级别设置为“读提交”。</p>
<h4 id="配置隔离级别"><a href="#配置隔离级别" class="headerlink" title="配置隔离级别"></a>配置隔离级别</h4><p>配置的方式是，将启动参数<code>transaction-isolation</code>的值设置成<code>READ-COMMITTED</code>。你可以用<code>show variables</code>来查看当前的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'transaction_isolation';</span><br><span class="line">或 <span class="keyword">select</span> @@tx_isolation;</span><br><span class="line">mysql&gt;  set global transaction_isolation=0; -- 读未提交</span><br><span class="line">mysql&gt;  set global transaction_isolation=1; -- 读提交</span><br><span class="line">mysql&gt;  set global transaction_isolation=2; -- 可重复读</span><br><span class="line">mysql&gt;  set global transaction_isolation=3; -- 串行化</span><br><span class="line"><span class="keyword">set</span> [glogal|<span class="keyword">session</span>] <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> 隔离级别名称;</span><br></pre></td></tr></table></figure>
<p><strong>需要“可重复读”的场景</strong>：假设在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响校对结果。这时候使用“可重复读”隔离级别就很方便。<strong>事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</strong></p>
<h4 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h4><p>展开说明“可重复读”事务隔离的具体实现：</p>
<p>在MySQL中，实际上每条记录在<strong>更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值</strong>。假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录：</p>
<p><img src="https://api2.mubu.com/v3/document_image/e3437af8-6bab-4bcb-aa8a-6b603f4d1596-11197877.jpg" alt="回滚记录"></p>
<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，<strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong>。对于read-view A，要得到1，就<strong>必须将当前值依次执行图中所有的回滚操作得到</strong>。另外，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p>
<p><strong>回滚日志总不能一直保留，什么时候删除</strong>呢？答案是，<strong>在不需要的时候才删除</strong>。也就是说，<strong>系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除</strong>。</p>
<p>什么时候不需要？就是<strong>当系统里没有比这个回滚日志更早的read-view的时候。</strong></p>
<h4 id="为什么建议尽量不要使用长事务"><a href="#为什么建议尽量不要使用长事务" class="headerlink" title="为什么建议尽量不要使用长事务"></a>为什么建议尽量不要使用长事务</h4><p>长事务意味着系统里面会<strong>存在很老的事务视图</strong>。由于<strong>这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</strong></p>
<p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，<strong>即使长事务最终提交，回滚段被清理，文件也不会变小。若回滚段太大，最终只好为了清理回滚段，重建整个库。</strong> <strong>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库</strong></p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>MySQL的事务启动方式有以下几种：</p>
<ul>
<li><p>显式启动事务语句， <code>begin</code> 或 <code>start transaction</code>。配套的提交语句是<code>commit</code>，回滚语句是<code>rollback</code>。</p>
</li>
<li><p><code>set autocommit=0</code>，这个命令<strong>会将这个线程的自动提交关掉。意味着如果只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到主动执行commit 或 rollback 语句，或者断开连接。</strong></p>
</li>
</ul>
<p>有些客户端连接框架会默认连接成功后先执行一个<code>set autocommit=0</code>的命令。这就<strong>导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</strong></p>
<p>因此<strong>，建议总是使用<code>set autocommit=1</code>, 通过显式语句的方式来启动事务。</strong></p>
<p>对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果也有这个顾虑，建议使用commit work and chain语法: <strong>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</strong></p>
<p>可以在information_schema库的<code>innodb_trx</code>表中<strong>查询长事务</strong>，比如下面这个语句，用于查找持续时间超过60s的事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure>
<h4 id="如何避免长事务对业务的影响？"><a href="#如何避免长事务对业务的影响？" class="headerlink" title="如何避免长事务对业务的影响？"></a>如何避免长事务对业务的影响？</h4><p>从应用开发端和数据库端来看。</p>
<p><strong>首先，从应用开发端来看：</strong></p>
<ul>
<li><p>确认是否使用了set autocommit=0。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的<strong>目标就是把它改成1。</strong></p>
</li>
<li><p>确认是否有<strong>不必要的只读事务</strong>。有些框架会习惯不管什么语句先用begin/commit框起来。我见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务可以去掉。</p>
</li>
<li><p>业务连接数据库的时候，根据业务本身的预估，通过<code>SET MAX_EXECUTION_TIME</code>命令，来<strong>控制每个语句执行的最长时间，避免单个语句意外执行太长时间</strong>。</p>
</li>
</ul>
<p><strong>其次，从数据库端来看：</strong></p>
<ul>
<li><p>监控 <code>information_schema.Innodb_trx</code>表，<strong>设置长事务阈值，超过就报警/或者kill；</strong></p>
</li>
<li><p>Percona的pt-kill这个工具不错，推荐使用；</p>
</li>
<li><p>在业务功能测试阶段要求输出所有的general_log，<strong>分析日志行为提前发现问题</strong>；</p>
</li>
<li><p>如果使用的是MySQL 5.6或者更新版本，把<code>innodb_undo_tablespaces</code>设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShifuDong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShifuDong</p>
  <div class="site-description" itemprop="description">记录生活， 记录学习， 分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/mailto:sfd_w@foxmail.com" title="E-Mail → mailto:sfd_w@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShifuDong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  



    </div>
</body>
</html>
