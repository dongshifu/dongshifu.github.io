<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ShifuDong" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="记录生活， 记录学习， 分享知识">
<meta name="keywords" content="生活，C++, C, go, java, OS, 网络， 存储， 联邦学习， 机器学习，python">
<meta property="og:type" content="website">
<meta property="og:title" content="ShifuDong">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="ShifuDong">
<meta property="og:description" content="记录生活， 记录学习， 分享知识">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ShifuDong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShifuDong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Knowledge Sharing</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dongshifu" class="github-corner" title="ShifuDong GitHub" aria-label="ShifuDong GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/09/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/09/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA/" class="post-title-link" itemprop="url">hexo搭建博客并添加评论</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-09 15:03:58 / 修改时间：16:55:32" itemprop="dateCreated datePublished" datetime="2021-03-09T15:03:58+08:00">2021-03-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="hexo搭建博客并添加评论"><a href="#hexo搭建博客并添加评论" class="headerlink" title="hexo搭建博客并添加评论"></a>hexo搭建博客并添加评论</h3><p>之前搭建博客评论功能的时候使用的是gitalk, 但使用gitalk必须创建issue来进行评论，使用起来并不是很方便。</p>
<p>经过网上查找，发现了一款好用的第三方评论工具：<a href="https://www.livere.com" target="_blank" rel="noopener">livere(来必力)</a>。这款工具只需要注册并得到一个<code>livere_uid</code>值就可以在自己的网页上添加评论功能，登录后台管理还可以对评论进行管理。白嫖可真相！！！</p>
<p>现在说下主要步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">打开 https://livere.com/ 网站进行用户注册（注册的时候是韩文，可以有道或者百度翻译对应一下内容，其实也就是邮箱，名称和密码这几项），注册完成后选择【安装】，然后点击“现在安装”。</span><br><span class="line"> </span><br><span class="line">在“现在安装”页面填写相关的信息，然后获取授权ID码(主要需要填写自己的网站链接)</span><br><span class="line"></span><br><span class="line">获取到授权ID码之后会打开主题目录下的配置文件，修改“livere_uid”的值为授权ID码</span><br></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/public/resource/b75486e024e4abe4339e8068b52ef37f/xmlnote/WEBRESOURCE2a260d1f0b15a04f9ef32732c9ae5c85/4528" alt="livere_uid获取"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在自己的博客主体目录下找到_config.yml文件(我的是~/blog/dongshifu/themes/next/_config.yml)然后找到livere_uid选项，将livere管理页面中的代码管理打开并找到data-uid，复制到livere_uid后面保存即可</span><br></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/public/resource/b75486e024e4abe4339e8068b52ef37f/xmlnote/WEBRESOURCEcda4c2d033aec89de3efdbe7afaf8ac0/4530" alt="_config.yaml配置"></p>
<p>重新部署自己的网站到github就可以看到添加的评论功能了。(授权的时候可以用QQ,微信等方式，真的是很方便了)</p>
<p><img src="http://note.youdao.com/yws/public/resource/b75486e024e4abe4339e8068b52ef37f/xmlnote/WEBRESOURCE65532c3d27bdb577b7c70ba945ae81db/4533" alt="博客评论功能添加"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/08/git-1-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/08/git-1-md/" class="post-title-link" itemprop="url">设置git的用户名和邮箱</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-08 18:51:53" itemprop="dateCreated datePublished" datetime="2021-03-08T18:51:53+08:00">2021-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-09 10:52:32" itemprop="dateModified" datetime="2021-03-09T10:52:32+08:00">2021-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="设置git的用户名和邮箱"><a href="#设置git的用户名和邮箱" class="headerlink" title="设置git的用户名和邮箱"></a>设置git的用户名和邮箱</h3><p>一直在使用自己搭建的github.io来保存博客，虽然更新比较慢，也算是记录了自己的学习过程。</p>
<p>今天在使用的时候意外发现自己在git上的contribution一直没有，鉴于自己时不时会提交博客记录，遂发现不对，难道是git出错了？？明显是不可能的，经过查看，之前的大部分提交居然都是用实验室小伙伴的git帐号提交的。估计是之前小伙伴用我的电脑登录了他的git帐号吧，发现之后赶快改了一下git的帐号设置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[~/path/to/repo]$ git config user.name "dongsihfu"</span><br><span class="line">[~/path/to/repo]$ git config user.email 自己的git邮箱</span><br><span class="line">This change will only affect future commits. Past commits will retain the username and address they were committed with.</span><br><span class="line"></span><br><span class="line">设置好以后就用 ：git config --list 命令查看。</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/02/linux-02linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/linux-02linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Linux常用命令使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-02 21:29:16" itemprop="dateCreated datePublished" datetime="2020-03-02T21:29:16+08:00">2020-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-10 09:18:50" itemprop="dateModified" datetime="2021-03-10T09:18:50+08:00">2021-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Linux终端命令格式"><a href="#Linux终端命令格式" class="headerlink" title="Linux终端命令格式"></a>Linux终端命令格式</h3><h4 id="终端命令格式"><a href="#终端命令格式" class="headerlink" title="终端命令格式"></a>终端命令格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] [parameter]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><code>command</code>：命令名，相应功能的英文单词或单词的缩写</li>
<li><code>[-options]</code>：选项，可用来对命令进行控制，也可以省略</li>
<li><code>parameter</code>：传给命令的参数，可以是 <strong>零个</strong>、<strong>一个</strong> 或者 <strong>多个</strong></li>
<li><code>[]</code> 代表可选 </li>
</ul>
<h4 id="查阅命令帮助信息"><a href="#查阅命令帮助信息" class="headerlink" title="查阅命令帮助信息"></a>查阅命令帮助信息</h4><h6 id="help"><a href="#help" class="headerlink" title="help"></a>help</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>显示 <code>command</code> 命令的帮助信息</li>
</ul>
<h6 id="man"><a href="#man" class="headerlink" title="man"></a>man</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>查阅 <code>command</code> 命令的使用手册</li>
</ul>
<p><code>man</code> 是 <strong>manual</strong> 的缩写，是 Linux 提供的一个 <strong>手册</strong>，包含了绝大部分的命令、函数的详细使用说明</p>
<p>使用 <code>man</code> 时的操作键：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>空格键</td>
<td>显示手册页的下一屏</td>
</tr>
<tr>
<td>Enter 键</td>
<td>一次滚动手册页的一行</td>
</tr>
<tr>
<td>b</td>
<td>回滚一屏</td>
</tr>
<tr>
<td>f</td>
<td>前滚一屏</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>/word</td>
<td>搜索 <strong>word</strong> 字符串</td>
</tr>
</tbody>
</table>
</div>
<h3 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h3><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ls</td>
<td>list</td>
<td>查看当前文件夹下的内容</td>
</tr>
<tr>
<td>02</td>
<td>pwd</td>
<td>print wrok directory</td>
<td>查看当前所在文件夹</td>
</tr>
<tr>
<td>03</td>
<td>cd [目录名]</td>
<td>change directory</td>
<td>切换文件夹</td>
</tr>
<tr>
<td>04</td>
<td>touch [文件名]</td>
<td>touch</td>
<td>如果文件不存在，新建文件</td>
</tr>
<tr>
<td>05</td>
<td>mkdir [目录名]</td>
<td>make directory</td>
<td>创建目录</td>
</tr>
<tr>
<td>06</td>
<td>rm [文件名]</td>
<td>remove</td>
<td>删除指定的文件名</td>
</tr>
<tr>
<td>07</td>
<td>clear</td>
<td>clear</td>
<td>清屏</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>小技巧</p>
<ul>
<li><code>ctrl + shift + =</code> <strong>放大</strong>终端窗口的字体显示</li>
<li><code>ctrl + -</code> <strong>缩小</strong>终端窗口的字体显示</li>
<li>在敲出 文件 目录 命令 <code>tab</code><ul>
<li>如果输入的没有歧义，系统会自动补全</li>
<li>如果还存在其他 <code>文件</code>／<code>目录</code>／<code>命令</code>，再按一下 <code>tab</code> 键，系统会提示可能存在的命令</li>
</ul>
</li>
<li>按 <code>上</code>／<code>下</code> 光标键可以在曾经使用过的命令之间来回切换</li>
<li>如果想要退出选择，并且不想执行当前选中的命令，可以按 <code>ctrl + c</code></li>
</ul>
</blockquote>
<h3 id="远程管理常用命令"><a href="#远程管理常用命令" class="headerlink" title="远程管理常用命令"></a>远程管理常用命令</h3><h4 id="关机-重启"><a href="#关机-重启" class="headerlink" title="关机/重启"></a>关机/重启</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>shutdown 选项 时间</td>
<td>shutdown</td>
<td>关机／重新启动</td>
</tr>
</tbody>
</table>
</div>
<h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a><code>shutdown</code></h4><ul>
<li><code>shutdown</code> 命令可以 <strong>安全</strong> <strong>关闭</strong> 或者 <strong>重新启动系统</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>重新启动</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>提示：</p>
<ul>
<li><strong>不指定选项和参数</strong>，默认表示 <strong>1 分钟</strong>之后 <strong>关闭电脑</strong></li>
<li>远程维护服务器时，最好不要关闭系统，而应该重新启动系统</li>
</ul>
</blockquote>
<ul>
<li>常用命令示例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新启动操作系统，其中 now 表示现在</span></span><br><span class="line">$ shutdown -r now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立刻关机，其中 now 表示现在</span></span><br><span class="line">$ shutdown now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统在今天的 20:25 会关机</span></span><br><span class="line">$ shutdown 20:25</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统再过十分钟后自动关机</span></span><br><span class="line">$ shutdown +10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消之前指定的关机计划</span></span><br><span class="line">$ shutdown -c</span><br></pre></td></tr></table></figure>
<h4 id="查看或配置网卡信息"><a href="#查看或配置网卡信息" class="headerlink" title="查看或配置网卡信息"></a>查看或配置网卡信息</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ifconfig</td>
<td>configure a network interface</td>
<td>查看/配置计算机当前的网卡配置信息</td>
</tr>
<tr>
<td>02</td>
<td>ping ip地址</td>
<td>ping</td>
<td>检测到目标 ip地址 的连接是否正常</td>
</tr>
</tbody>
</table>
</div>
<h4 id="网卡-和-IP-地址"><a href="#网卡-和-IP-地址" class="headerlink" title="网卡 和 IP 地址"></a>网卡 和 IP 地址</h4><h6 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h6><ul>
<li>网卡是一个专门负责网络通讯的硬件设备</li>
<li><strong>IP 地址</strong>是设置在网卡上的地址信息</li>
</ul>
<blockquote>
<p>我们可以把 <strong>电脑</strong> 比作 <strong>电话</strong>，<strong>网卡</strong> 相当于 <strong>SIM 卡</strong>，<strong>IP 地址</strong> 相当于 <strong>电话号码</strong></p>
</blockquote>
<h6 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h6><ul>
<li><strong>每台联网的电脑上</strong>都有 <strong>IP 地址</strong>，<strong>是保证电脑之间正常通讯的重要设置</strong></li>
</ul>
<blockquote>
<p>注意：每台电脑的 IP 地址不能相同，否则会出现 IP 地址冲突，并且没有办法正常通讯</p>
</blockquote>
<h6 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a><code>ifconfig</code></h6><ul>
<li><code>ifconfig</code> 可以查看／配置计算机当前的网卡配置信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网卡配置信息</span></span><br><span class="line">$ ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网卡对应的 IP 地址</span></span><br><span class="line">$ ifconfig | grep inet</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：一台计算机中有可能会有一个 <strong>物理网卡</strong> 和 <strong>多个虚拟网卡</strong>，在 Linux 中物理网卡的名字通常以 <code>ensXX</code> 表示</p>
</blockquote>
<ul>
<li><code>127.0.0.1</code> 被称为 <strong>本地回环/环回地址</strong>，一般用来测试本机网卡是否正常</li>
</ul>
<h6 id="ping"><a href="#ping" class="headerlink" title="ping"></a><code>ping</code></h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测到目标主机是否连接正常</span></span><br><span class="line">$ ping IP地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测本地网卡工作正常</span></span><br><span class="line">$ ping 127.0.0.1</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ping</code> 一般用于检测当前计算机到目标计算机之间的网络 <strong>是否通畅</strong>，<strong>数值越大，速度越慢</strong></li>
</ul>
<blockquote>
<ul>
<li><code>ping</code> 的工作原理与潜水艇的声纳相似，<code>ping</code> 这个命令就是取自 <strong>声纳的声音</strong> </li>
<li>网络管理员之间也常将 <code>ping</code> 用作动词 —— <strong>ping 一下计算机X，看他是否开着</strong></li>
</ul>
</blockquote>
<p>原理：网络上的机器都有 <strong>唯一确定的 IP 地址</strong>，我们给<strong>目标 IP 地址</strong>发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在</p>
<blockquote>
<p>提示：在 Linux 中，想要终止一个终端程序的执行，绝大多数都可以使用 <code>CTRL + C</code></p>
</blockquote>
<h4 id="远程登录和复制文件"><a href="#远程登录和复制文件" class="headerlink" title="远程登录和复制文件"></a>远程登录和复制文件</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ssh 用户名@ip</td>
<td>secure shell</td>
<td>关机／重新启动</td>
</tr>
<tr>
<td>02</td>
<td>scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径</td>
<td>secure copy</td>
<td>远程复制文件</td>
</tr>
</tbody>
</table>
</div>
<h4 id="ssh-基础"><a href="#ssh-基础" class="headerlink" title="ssh 基础"></a><code>ssh</code> 基础</h4><p>在 Linux 中 SSH 是 <strong>非常常用</strong> 的工具，通过 <strong>SSH 客户端</strong> 可以连接到运行了 <strong>SSH 服务器</strong> 的远程机器上</p>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCEadf3eb255588d4620755600d7cc36a75/4539" alt="SSH示意图">￼</p>
<ul>
<li><strong>SSH 客户端</strong>是一种使用 <code>Secure Shell（SSH）</code> 协议连接到远程计算机的软件程序</li>
<li><code>SSH</code> 是目前较可靠，<strong>专为远程登录会话和其他网络服务</strong> 提供安全性的协议<ul>
<li>利用 <code>SSH 协议</code> 可以有效<strong>防止远程管理过程中的信息泄露</strong></li>
<li>通过 <code>SSH 协议</code> 可以对所有传输的数据进行<strong>加密</strong>，也能够防止 DNS 欺骗和 IP 欺骗</li>
</ul>
</li>
<li><code>SSH</code> 的另一项优点是传输的数据可以是经过<strong>压缩</strong>的，所以可以加快传输的速度</li>
</ul>
<h4 id="域名-和-端口号"><a href="#域名-和-端口号" class="headerlink" title="域名 和 端口号"></a>域名 和 端口号</h4><h5 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h5><ul>
<li>由一串 <strong>用点分隔</strong> 的名字组成，例如：<code>www.baidu.com</code></li>
<li>是 <strong>IP 地址</strong> 的别名，方便用户记忆</li>
</ul>
<h5 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h5><ul>
<li><strong>IP 地址</strong>：通过 <strong>IP 地址</strong> 找到网络上的 <strong>计算机</strong></li>
<li><strong>端口号</strong>：通过 <strong>端口号</strong> 可以找到 <strong>计算机上运行的应用程序</strong><ul>
<li><strong>SSH 服务器</strong> 的默认端口号是 <code>22</code>，如果是默认端口号，在连接的时候，可以省略</li>
</ul>
</li>
<li>常见服务端口号列表：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>服务</th>
<th>端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>SSH 服务器</td>
<td>22</td>
</tr>
<tr>
<td>02</td>
<td>Web 服务器</td>
<td>80</td>
</tr>
<tr>
<td>03</td>
<td>HTTPS</td>
<td>443</td>
</tr>
<tr>
<td>04</td>
<td>FTP 服务器</td>
<td>21</td>
</tr>
</tbody>
</table>
</div>
<h4 id="SSH-客户端的简单使用"><a href="#SSH-客户端的简单使用" class="headerlink" title="SSH 客户端的简单使用"></a>SSH 客户端的简单使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-p port] user@remote</span><br></pre></td></tr></table></figure>
<ul>
<li><code>user</code> 是在远程机器上的用户名，如果不指定的话默认为当前用户</li>
<li><code>remote</code> 是远程机器的地址，可以是 <strong>IP</strong>／<strong>域名</strong>，或者是 <strong>后面会提到的别名</strong></li>
<li><code>port</code> 是 <strong>SSH Server 监听的端口</strong>，如果不指定，就为默认值 <code>22</code></li>
</ul>
<blockquote>
<p>提示：</p>
<ul>
<li>使用 <code>exit</code> 退出当前用户的登录</li>
</ul>
<p>注意：</p>
<ul>
<li><code>ssh</code> 这个终端命令只能在 <code>Linux</code> 或者 <code>UNIX</code> 系统下使用</li>
<li>如果在 <code>Windows</code> 系统中，可以安装 <code>PuTTY</code> 或者 <code>XShell</code> 客户端软件即可</li>
</ul>
<p>提示：</p>
<ul>
<li>在工作中，SSH 服务器的端口号很有可能<strong>不是 22</strong>，如果遇到这种情况就需要使用 <code>-p</code> 选项，指定正确的端口号，否则无法正常连接到服务器</li>
</ul>
</blockquote>
<h4 id="Windows-下-SSH-客户端的安装"><a href="#Windows-下-SSH-客户端的安装" class="headerlink" title="Windows 下 SSH 客户端的安装"></a>Windows 下 SSH 客户端的安装</h4><ul>
<li><code>Putty</code> <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="noopener">http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></li>
<li><code>XShell</code> <a href="http://xshellcn.com" target="_blank" rel="noopener">http://xshellcn.com</a></li>
</ul>
<h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a><code>scp</code></h4><ul>
<li>scp 就是 <code>secure copy</code>，是一个在 Linux 下用来进行 <strong>远程拷贝文件</strong> 的命令</li>
<li>它的<strong>地址格式与 ssh 基本相同</strong>，<strong>需要注意的是</strong>，在指定<strong>端口时用的是大写的 <code>-P</code> 而不是小写的</strong></li>
</ul>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE1986053d985427bbf0e220c8dc47c816/4541" alt="SCP示意图">￼</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py</span></span><br><span class="line"><span class="comment"># 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径</span></span><br><span class="line">scp -P port 01.py user@remote:Desktop/01.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py</span></span><br><span class="line">scp -P port user@remote:Desktop/01.py 01.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上 -r 选项可以传送文件夹</span></span><br><span class="line"><span class="comment"># 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop</span></span><br><span class="line">scp -r demo user@remote:Desktop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹</span></span><br><span class="line">scp -r user@remote:Desktop demo</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</td>
</tr>
<tr>
<td>-P</td>
<td>若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意：</p>
<ul>
<li><code>scp</code> 这个终端命令只能在 <code>Linux</code> 或者 <code>UNIX</code> 系统下使用</li>
<li>如果在 <code>Windows</code> 系统中，可以安装 <code>PuTTY</code>，使用 <code>pscp</code> 命令行工具或者安装 <code>FileZilla</code> 使用 <code>FTP</code> 进行文件传输</li>
</ul>
</blockquote>
<h4 id="FileZilla"><a href="#FileZilla" class="headerlink" title="FileZilla"></a><code>FileZilla</code></h4><ul>
<li>官方网站：<a href="https://www.filezilla.cn/download/client" target="_blank" rel="noopener">https://www.filezilla.cn/download/client</a></li>
<li><code>FileZilla</code> 在传输文件时，使用的是 <code>FTP 服务</code> 而不是 <code>SSH 服务</code>，因此端口号应该设置为 <code>21</code></li>
</ul>
<h4 id="SSH-高级"><a href="#SSH-高级" class="headerlink" title="SSH 高级"></a>SSH 高级</h4><ul>
<li>免密码登录</li>
<li>配置别名</li>
</ul>
<blockquote>
<p>提示：有关 SSH 配置信息都保存在用户家目录下的 <code>.ssh</code> 目录下</p>
</blockquote>
<h6 id="免密码登录"><a href="#免密码登录" class="headerlink" title="免密码登录"></a>免密码登录</h6><h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><ul>
<li>配置公钥 <ul>
<li>执行 <code>ssh-keygen</code> 即可生成 SSH 钥匙，一路回车即可</li>
</ul>
</li>
<li>上传公钥到服务器 <ul>
<li>执行 <code>ssh-copy-id -p port user@remote</code>，可以让远程服务器记住我们的公钥</li>
</ul>
</li>
</ul>
<h6 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h6><p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCEe2a278c2e5bd8260206e2e3ae5432b23/4543" alt="SSH 免密码示意图">￼</p>
<blockquote>
<p>非对称加密算法</p>
<ul>
<li>使用 <strong>公钥</strong> 加密的数据，需要使用 <strong>私钥</strong> 解密</li>
<li>使用 <strong>私钥</strong> 加密的数据，需要使用 <strong>公钥</strong> 解密</li>
</ul>
</blockquote>
<h6 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h6><p>每次都输入 <code>ssh -p port user@remote</code>，时间久了会觉得很麻烦，特别是当 <code>user</code>, <code>remote</code> 和 <code>port</code> 都得输入，而且还不好记忆</p>
<p>而 <strong>配置别名</strong> 可以让进一步偷懒，譬如用：<code>ssh mac</code> 来替代上面这么一长串，那么就在 <code>~/.ssh/config</code> 里面追加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host mac</span><br><span class="line">    HostName ip地址</span><br><span class="line">    User itheima</span><br><span class="line">    Port 22</span><br></pre></td></tr></table></figure>
<p><strong>保存之后，即可用 <code>ssh mac</code> 实现远程登录了，<code>scp</code> 同样可以使用</strong></p>
<h3 id="系统相关命令"><a href="#系统相关命令" class="headerlink" title="系统相关命令"></a>系统相关命令</h3><h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>date</td>
<td>查看系统时间</td>
</tr>
<tr>
<td>02</td>
<td>cal</td>
<td><code>calendar</code> 查看日历，<code>-y</code> 选项可以查看一年的日历</td>
</tr>
</tbody>
</table>
</div>
<h4 id="磁盘信息"><a href="#磁盘信息" class="headerlink" title="磁盘信息"></a>磁盘信息</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>df -h</td>
<td><code>disk free</code> 显示磁盘剩余空间</td>
</tr>
<tr>
<td>02</td>
<td>du -h [目录名]</td>
<td><code>disk usage</code> 显示目录下的文件大小</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>选项说明</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-h</td>
<td>以人性化的方式显示文件大小</td>
</tr>
</tbody>
</table>
</div>
<h4 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h4><ul>
<li>所谓 <strong>进程</strong>，通俗地说就是 <strong>当前正在执行的一个程序</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ps aux</td>
<td><code>process status</code> 查看<strong>进程的详细状况</strong></td>
</tr>
<tr>
<td>02</td>
<td>top</td>
<td><strong>动态显示运行中的进程并且排序</strong></td>
</tr>
<tr>
<td>03</td>
<td>htop</td>
<td>更方便的动态显示运行中的进程并且排序</td>
</tr>
<tr>
<td>04</td>
<td>kill [-9] 进程代号</td>
<td>终止指定代号的进程，<code>-9</code> 表示强行终止</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><code>ps</code> 默认只会显示当前用户通过终端启动的应用程序</p>
</blockquote>
<ul>
<li><code>ps</code> 选项说明功能</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>显示终端上的所有进程，包括其他用户的进程</td>
</tr>
<tr>
<td>u</td>
<td>显示进程的详细状态</td>
</tr>
<tr>
<td>x</td>
<td>显示没有控制终端的进程</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>提示：使用 <code>kill</code> 命令时，最好只终止由当前用户开启的进程，而不要终止 <code>root</code> 身份开启的进程，否则可能导致系统崩溃</p>
<ul>
<li>要退出 <code>top</code> 可以直接输入 <code>q</code></li>
</ul>
</blockquote>
<h3 id="用户权限相关命令"><a href="#用户权限相关命令" class="headerlink" title="用户权限相关命令"></a>用户权限相关命令</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><strong>用户</strong> 是 Linux 系统工作中重要的一环，用户管理包括 <strong>用户</strong> 与 <strong>组</strong> 管理</li>
<li>在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都<strong>必须拥有一个账号</strong>，并且<strong>对于不同的系统资源拥有不同的使用权限</strong></li>
<li>在 Linux 中，可以指定 <strong>每一个用户</strong> 针对 <strong>不同的文件或者目录</strong> 的 <strong>不同权限</strong></li>
<li>对 <strong>文件／目录</strong> 的权限包括：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">权限</th>
<th style="text-align:center">英文</th>
<th style="text-align:center">缩写</th>
<th style="text-align:center">数字代号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">读</td>
<td style="text-align:center">read</td>
<td style="text-align:center">r</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">02</td>
<td style="text-align:center">写</td>
<td style="text-align:center">write</td>
<td style="text-align:center">w</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">03</td>
<td style="text-align:center">执行</td>
<td style="text-align:center">excute</td>
<td style="text-align:center">x</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<h4 id="组"><a href="#组" class="headerlink" title="组"></a>组</h4><ul>
<li><p>为了方便用户管理，提出了 <strong>组</strong> 的概念</p>
</li>
<li><p>在实际应用中，可以预先针对 <strong>组</strong> 设置好权限，然后 <strong>将不同的用户添加到对应的组中</strong>，从而<strong>不用依次为每一个用户设置权限</strong></p>
</li>
</ul>
<h4 id="ls-l-扩展"><a href="#ls-l-扩展" class="headerlink" title="ls -l 扩展"></a>ls -l 扩展</h4><ul>
<li><code>ls -l</code> 可以查看文件夹下文件的详细信息，从左到右依次是：<ul>
<li><strong>权限</strong>，第 1 个字符如果是 <code>d</code> 表示目录</li>
<li><strong>硬链接数</strong>，通俗地讲，就是<strong>有多少种方式，可以访问到当前目录／文件</strong></li>
<li><strong>拥有者</strong>，家目录下 文件／目录 的拥有者通常都是当前用户</li>
<li><strong>组</strong>，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲</li>
<li><strong>大小</strong></li>
<li><strong>时间</strong></li>
<li><strong>名称</strong></li>
</ul>
</li>
</ul>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCEfcb35218f77b6bcfe80920758b9974ea/4545" alt="权限示意图">￼</p>
<h4 id="chmod-简单使用"><a href="#chmod-简单使用" class="headerlink" title="chmod 简单使用"></a><code>chmod</code> 简单使用</h4><ul>
<li><code>chmod</code> 可以修改 <strong>用户／组</strong> 对 <strong>文件／目录</strong> 的权限</li>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：以上方式会一次性修改 <code>拥有者</code> / <code>组</code> 权限</p>
</blockquote>
<h4 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h4><ul>
<li>Linux 系统中的 <code>root</code> 账号通常 <strong>用于系统的维护和管理</strong>，对操作系统的所有资源 <strong>具有所有访问权限</strong></li>
<li>在大多数版本的 Linux 中，都不推荐 <strong>直接使用 root 账号登录系统</strong></li>
<li>在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户”</li>
</ul>
<h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><ul>
<li><code>su</code> 是 <code>substitute user</code> 的缩写，表示 <strong>使用另一个用户的身份</strong></li>
<li><strong><code>sudo</code> 命令用来以其他身份来执行命令，预设的身份为 <code>root</code></strong></li>
<li>用户使用 <code>sudo</code> 时，必须先输入密码，之后有 <strong>5 分钟的有效期限</strong>，超过期限则必须重新输入密码</li>
</ul>
<blockquote>
<p>若其未经授权的用户企图使用 <code>sudo</code>，则会发出警告邮件给管理员</p>
</blockquote>
<h4 id="组管理-终端命令"><a href="#组管理-终端命令" class="headerlink" title="组管理 终端命令"></a><strong>组管理</strong> 终端命令</h4><blockquote>
<p>提示：<strong>创建组</strong> / <strong>删除组</strong> 的终端命令都需要通过 <code>sudo</code> 执行</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>groupadd 组名</td>
<td>添加组</td>
</tr>
<tr>
<td>02</td>
<td>groupdel 组名</td>
<td>删除组</td>
</tr>
<tr>
<td>03</td>
<td>cat /etc/group</td>
<td>确认组信息</td>
</tr>
<tr>
<td>04</td>
<td>chgrp -R 组名 文件/目录名</td>
<td>递归修改文件/目录的所属组</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>提示：</p>
<ul>
<li>组信息保存在 <code>/etc/group</code> 文件中</li>
<li><code>/etc</code> 目录是专门用来保存 <strong>系统配置信息</strong> 的目录￼</li>
</ul>
</blockquote>
<ul>
<li>在实际应用中，可以预先针对 <strong>组</strong> 设置好权限，然后 <strong>将不同的用户添加到对应的组中</strong>，从而<strong>不用依次为每一个用户设置权限</strong></li>
</ul>
<h4 id="用户管理-终端命令"><a href="#用户管理-终端命令" class="headerlink" title="用户管理 终端命令"></a><strong>用户管理</strong> 终端命令</h4><blockquote>
<p>提示：<strong>创建用户</strong> / <strong>删除用户</strong> / <strong>修改其他用户密码</strong> 的终端命令都需要通过 <code>sudo</code> 执行</p>
</blockquote>
<h6 id="创建用户／设置密码／删除用户"><a href="#创建用户／设置密码／删除用户" class="headerlink" title="创建用户／设置密码／删除用户"></a>创建用户／设置密码／删除用户</h6><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>useradd -m -g 组 新建用户名</td>
<td>添加新用户</td>
<td>-m 自动建立用户家目录-g 指定用户所在的组，否则会建立一个和同名的组</td>
</tr>
<tr>
<td>02</td>
<td>passwd 用户名</td>
<td>设置用户密码</td>
<td><strong>如果是普通用户，直接用 passwd 可以修改自己的账户密码</strong></td>
</tr>
<tr>
<td>03</td>
<td>userdel -r 用户名</td>
<td>删除用户</td>
<td><strong>-r 选项会自动删除用户家目录</strong></td>
</tr>
<tr>
<td>04</td>
<td>cat /etc/passwd \</td>
<td>grep 用户名</td>
<td>确认用户信息</td>
<td>新建用户后，用户信息会保存在 /etc/passwd 文件中</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>提示：</p>
<ul>
<li>创建用户时，如果忘记添加 <code>-m</code> 选项指定新用户的家目录 —— 最简单的方法就是<strong>删除用户，重新创建</strong></li>
<li>创建用户时，默认会创建一个和<strong>用户名</strong>同名的<strong>组名</strong></li>
<li>用户信息保存在 <code>/etc/passwd</code> 文件中</li>
</ul>
</blockquote>
<h6 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h6><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>id [用户名]</td>
<td>查看用户 UID 和 GID 信息</td>
</tr>
<tr>
<td>02</td>
<td>who</td>
<td>查看当前所有登录的用户列表</td>
</tr>
<tr>
<td>03</td>
<td>whoami</td>
<td>查看当前登录用户的账户名</td>
</tr>
</tbody>
</table>
</div>
<h6 id="passwd-文件"><a href="#passwd-文件" class="headerlink" title="passwd 文件"></a>passwd 文件</h6><p><code>/etc/passwd</code> 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是</p>
<ol>
<li>用户名</li>
<li>密码（x，表示加密的密码）</li>
<li>UID（用户标识）</li>
<li>GID（组标识）</li>
<li>用户全名或本地帐号</li>
<li>家目录</li>
<li>登录使用的 Shell，就是登录之后，使用的终端命令，<code>ubuntu</code> 默认用 <code>dash</code></li>
</ol>
<h6 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h6><ul>
<li><code>usermod</code> 可以用来设置 <strong>用户</strong> 的 <strong>主组</strong> ／ <strong>附加组</strong> 和 <strong>登录 Shell</strong>，命令格式如下：<ul>
<li><strong>主组</strong>：通常在新建用户时指定，在 <code>etc/passwd</code> 的第 4 列 <strong>GID 对应的组</strong></li>
<li><strong>附加组</strong>：在 <code>etc/group</code> 中最后一列表示该组的用户列表，用于指定 <strong>用户的附加权限</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>提示：设置了用户的附加组之后，需要重新登录才能生效！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改用户的主组（passwd 中的 GID）</span></span><br><span class="line">usermod -g 组 用户名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户的附加组</span></span><br><span class="line">usermod -G 组 用户名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户登录 Shell</span></span><br><span class="line">usermod -s /bin/bash 用户名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：默认使用 <code>useradd</code> 添加的用户是没有权限使用 <code>sudo</code> 以 <code>root</code> 身份执行命令的，可以使用以下命令，将用户添加到 <code>sudo</code> 附加组中</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -G sudo 用户名</span><br></pre></td></tr></table></figure>
<h6 id="which"><a href="#which" class="headerlink" title="which"></a>which</h6><blockquote>
<p>提示</p>
<ul>
<li><code>/etc/passwd</code> 是用于保存用户信息的文件</li>
<li><code>/usr/bin/passwd</code> 是用于修改用户密码的程序</li>
</ul>
</blockquote>
<ul>
<li><code>which</code> 命令可以<strong>查看执行命令所在位置</strong>，例如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># /bin/ls</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">which</span> useradd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># /usr/sbin/useradd</span></span><br></pre></td></tr></table></figure>
<h6 id="bin-和-sbin"><a href="#bin-和-sbin" class="headerlink" title="bin 和 sbin"></a><code>bin</code> 和 <code>sbin</code></h6><ul>
<li>在 <code>Linux</code> 中，绝大多数可执行文件都是保存在 <code>/bin</code>、<code>/sbin</code>、<code>/usr/bin</code>、<code>/usr/sbin</code></li>
<li><code>/bin</code>（<code>binary</code>）是二进制执行文件目录，<strong>主要用于具体应用</strong></li>
<li><code>/sbin</code>（<code>system binary</code>）是<strong>系统管理员专用</strong>的二进制代码存放目录，主要用于<strong>系统管理</strong></li>
<li><code>/usr/bin</code>（<code>user commands for applications</code>）后期安装的一些软件</li>
<li><code>/usr/sbin</code>（<code>super user commands for applications</code>）超级用户的一些管理程序</li>
</ul>
<blockquote>
<p>提示：</p>
<ul>
<li><code>cd</code> 终端命令是内置在系统内核中的，没有独立的文件，因此用 <code>which</code> 无法找到 <code>cd</code> 命令的位置</li>
</ul>
</blockquote>
<h6 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h6><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>su - 用户名</td>
<td>切换用户，并且切换目录</td>
<td>- 可以切换到用户家目录，否则保持位置不变</td>
</tr>
<tr>
<td>02</td>
<td>exit</td>
<td>退出当前登录账户</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>su</code> 不接用户名，可以切换到 <code>root</code>，但是不推荐使用，因为不安全</li>
<li><code>exit</code> 示意图如下：</li>
</ul>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCEd82838dbf01984787215cb63bfafd36e/4547" alt="su和exit示意图">￼</p>
<h6 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h6><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>chown</td>
<td>修改拥有者</td>
</tr>
<tr>
<td>02</td>
<td>chgrp</td>
<td>修改组</td>
</tr>
<tr>
<td>03</td>
<td>chmod</td>
<td>修改权限</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改文件|目录的拥有者</span></span><br><span class="line">chown 用户名 文件名|目录名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件|目录的组</span></span><br><span class="line">chgrp -R 组名 文件名|目录名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件权限</span></span><br><span class="line">chmod -R 755 文件名|目录名</span><br></pre></td></tr></table></figure>
<ul>
<li><code>chmod</code> 在设置权限时，可以简单地使用三个数字分别对应 <strong>拥有者</strong> ／ <strong>组</strong> 和 <strong>其他</strong> 用户的权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他</span></span><br><span class="line">chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure>
<p>![文件权限示意图](<a href="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE2543790c4c010efe7a9f24206b82b55e/4549￼" target="_blank" rel="noopener">http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE2543790c4c010efe7a9f24206b82b55e/4549￼</a></p>
<ul>
<li>常见数字组合有（<code>u</code>表示用户／<code>g</code>表示组／<code>o</code>表示其他）： <ul>
<li><code>777</code> ===&gt; <code>u=rwx,g=rwx,o=rwx</code> </li>
<li><code>755</code> ===&gt; <code>u=rwx,g=rx,o=rx</code></li>
<li><code>644</code> ===&gt; <code>u=rw,g=r,o=r</code></li>
</ul>
</li>
</ul>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><ul>
<li><code>find</code> 命令功能非常强大，通常用来在 <strong>特定的目录下</strong> <strong>搜索</strong> 符合条件的文件</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>find [路径] -name “*.py”</td>
<td>查找指定路径下扩展名是 <code>.py</code> 的文件，包括子目录</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>如果省略路径，表示在当前文件夹下查找</strong></li>
<li>之前学习的通配符，在使用 <code>find</code> 命令时同时可用</li>
</ul>
<h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ln -s 被链接的源文件 链接文件</td>
<td>建立文件的软链接，用通俗的方式讲<strong>类似于</strong> Windows 下的<strong>快捷方式</strong></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>注意：</li>
<li>没有 <code>-s</code> 选项建立的是一个 <strong>硬链接文件</strong><ul>
<li>两个文件占用相同大小的硬盘空间，<strong>工作中几乎不会建立文件的硬链接</strong></li>
</ul>
</li>
<li><strong>源文件要使用绝对路径</strong>，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用</li>
</ul>
<h4 id="文件软硬链接的示意图"><a href="#文件软硬链接的示意图" class="headerlink" title="文件软硬链接的示意图"></a>文件软硬链接的示意图</h4><p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE7aa2d85f00d080fb528d277537be5bbb/4551" alt="文件软硬链接示意图"></p>
<blockquote>
<p>在 Linux 中，<strong>文件名</strong> 和 <strong>文件的数据</strong> 是分开存储的</p>
</blockquote>
<ul>
<li>提示： <ul>
<li>在 Linux 中，只有文件的 <code>硬链接数 == 0</code> 才会被删除</li>
<li>使用 <code>ls -l</code> 可以查看一个文件的硬链接的数量</li>
</ul>
</li>
</ul>
<h4 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h4><ul>
<li><strong>打包压缩</strong> 是日常工作中备份文件的一种方式</li>
<li>在不同操作系统中，常用的打包压缩方式是不同的 <ul>
<li><code>Windows</code> 常用 <code>rar</code></li>
<li><code>Mac</code> 常用 <code>zip</code></li>
<li><code>Linux</code> 常用 <code>tar.gz</code></li>
</ul>
</li>
</ul>
<h4 id="打包-／-解包"><a href="#打包-／-解包" class="headerlink" title="打包 ／ 解包"></a>打包 ／ 解包</h4><ul>
<li><code>tar</code> 是 Linux 中最常用的 <strong>备份</strong>工具，此命令可以 <strong>把一系列文件</strong> 打包到 <strong>一个大文件中</strong>，也可以把一个 <strong>打包的大文件恢复成一系列文件</strong></li>
<li><code>tar</code> 的命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包文件</span></span><br><span class="line">tar -cvf 打包文件.tar 被打包的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包文件</span></span><br><span class="line">tar -xvf 打包文件.tar</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tar</code> 选项说明</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>生成档案文件，创建打包文件</td>
</tr>
<tr>
<td>x</td>
<td>解开档案文件</td>
</tr>
<tr>
<td>v</td>
<td>列出归档解档的详细过程，显示进度</td>
</tr>
<tr>
<td>f</td>
<td>指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意：<code>f</code> 选项必须放在最后，其他选项顺序可以随意</p>
</blockquote>
<h4 id="压缩／解压缩"><a href="#压缩／解压缩" class="headerlink" title="压缩／解压缩"></a>压缩／解压缩</h4><h6 id="gzip"><a href="#gzip" class="headerlink" title="`gzip"></a>`gzip</h6><p><code>tar</code> 与 <code>gzip</code> 命令结合可以使用实现文件 <strong>打包和压缩</strong></p>
<ul>
<li>打包和压缩<ul>
<li><code>tar</code> 只负责打包文件，但不压缩</li>
<li>用 <code>gzip</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.gz</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>在 <code>Linux</code> 中，最常见的压缩文件格式就是 <code>xxx.tar.gz</code></p>
</blockquote>
<ul>
<li><strong>在 <code>tar</code> 命令中有一个选项 -z 可以调用 <code>gzip</code>，从而可以方便的实现压缩和解压缩的功能</strong></li>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩文件</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩到指定路径</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz -C 目标路径</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-C</td>
<td><strong>解压缩到指定目录，注意：要解压缩的目录必须存在</strong></td>
</tr>
</tbody>
</table>
</div>
<h6 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a><code>bzip2</code></h6><ul>
<li><code>tar</code> 与 <code>bzip2</code> 命令结合可以使用实现文件 <strong>打包和压缩</strong>（用法和 <code>gzip</code> 一样）<ul>
<li><code>tar</code> 只负责打包文件，但不压缩，</li>
<li>用 <code>bzip2</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.bz2</code></li>
</ul>
</li>
<li>在 <code>tar</code> 命令中有一个选项 <strong>-j</strong> 可以调用 <code>bzip2</code>，从而可以方便的实现压缩和解压缩的功能</li>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩文件</span></span><br><span class="line">tar -jxvf 打包文件.tar.bz2</span><br></pre></td></tr></table></figure>
<h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><h6 id="通过-apt-安装／卸载软件"><a href="#通过-apt-安装／卸载软件" class="headerlink" title="通过 apt 安装／卸载软件"></a>通过 apt 安装／卸载软件</h6><ul>
<li>apt 是 <code>Advanced Packaging Tool</code>，是 Linux 下的一款安装包管理工具</li>
<li>可以在终端中方便的 <strong>安装</strong>／<strong>卸载</strong>／<strong>更新软件包</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装软件</span></span><br><span class="line">$ sudo apt install 软件包</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 卸载软件</span></span><br><span class="line">$ sudo apt remove 软件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 更新已安装的包</span></span><br><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></table></figure>
<h6 id="配置软件源"><a href="#配置软件源" class="headerlink" title="配置软件源"></a>配置软件源</h6><ul>
<li>如果希望在 <code>ubuntu</code> 中安装软件，<strong>更加快速</strong>，可以通过设置<strong>镜像源</strong>，选择一个访问网速更快的服务器，来提供软件下载／安装服务</li>
<li>提示：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了</li>
</ul>
<blockquote>
<p>所谓镜像源，就是<strong>所有服务器的内容是相同的（镜像）</strong>，但是根据所在位置不同，国内服务器通常速度会更快一些！</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/01/linux_01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/01/linux_01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/" class="post-title-link" itemprop="url">Linux 文件和目录及相关操作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-01 21:29:16" itemprop="dateCreated datePublished" datetime="2020-03-01T21:29:16+08:00">2020-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-10 20:36:57" itemprop="dateModified" datetime="2021-03-10T20:36:57+08:00">2021-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="单用户操作系统和多用户操作系统"><a href="#单用户操作系统和多用户操作系统" class="headerlink" title="单用户操作系统和多用户操作系统"></a>单用户操作系统和多用户操作系统</h3><ul>
<li><strong>单用户操作系统</strong>：指一台计算机在同一时间 <strong>只能由一个用户</strong> 使用，<strong>一个用户独自享用系统的全部硬件和软件资源</strong><ul>
<li><strong>Windows XP</strong> 之前的版本都是单用户操作系统</li>
</ul>
</li>
<li><strong>多用户操作系统</strong>：指一台计算机在同一时间可以由 <strong>多个用户</strong> 使用，多个用户共<strong>同享用系统的全部硬件和软件资源</strong><ul>
<li><strong>Unix</strong> 和 <strong>Linux</strong> 的设计初衷就是多用户操作系统</li>
</ul>
</li>
</ul>
<h3 id="linux下的文件系统"><a href="#linux下的文件系统" class="headerlink" title="linux下的文件系统"></a>linux下的文件系统</h3><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><ul>
<li><p>在 <code>Windows</code> 下，打开 “计算机”，看到的是一个个的驱动器盘符：eg: C盘，D盘…。</p>
<ul>
<li>每个驱动器都有自己的根目录结构，形成多个树并列的情形。</li>
</ul>
</li>
<li><p>在 <code>Linux</code> 下，看不到驱动器盘符，看到的是<strong>文件夹（目录）</strong></p>
<ul>
<li>linux没有盘符概念，只有一个根目录 <code>/</code>，所有文件都在它下面</li>
</ul>
</li>
</ul>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE176901b2234a4a2fcab1e598a568ca75/4537" alt="linux文件系统"></p>
<ul>
<li><p>用户目录</p>
<ul>
<li><p>位于 <code>/home/xxx</code>，称之为用户工作目录或家目录，表示方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/xx</span><br><span class="line">~</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>/：根目录，<strong>一般根目录下只存放目录</strong>，在 linux 下有且只有一个根目录，所有的东西都是从这里开始 </p>
<ul>
<li>当在终端里输入 <code>cd /home</code>，其实是在告诉电脑，先从 <code>/</code>（根目录）开始，再进入到 <code>home</code> 目录</li>
</ul>
</li>
<li><p>/bin、/usr/bin：可执行二进制文件的目录，如<strong>常用的命令 ls、tar、mv、cat</strong> 等</p>
</li>
<li><p>/boot：放置 linux <strong>系统启动</strong>时用到的一些文件，如 linux 的<strong>内核</strong>文件：<code>/boot/vmlinuz</code>，<strong>系统引导</strong>管理器：<code>/boot/grub</code></p>
</li>
<li><p>/dev：存放linux系统下的<strong>设备文件</strong>，<strong>访问该目录下某个文件，相当于访问某个设备</strong>，常用的是挂载光驱<code>mount /dev/cdrom /mnt</code></p>
</li>
<li><p>/etc：<strong>系统配置文件</strong>存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有  </p>
<ul>
<li>/etc/inittab</li>
<li>/etc/fstab</li>
<li>/etc/init.d</li>
<li>/etc/X11</li>
<li>/etc/sysconfig</li>
<li><p>/etc/xinetd.d</p>
</li>
<li><p>/etc/profile</p>
</li>
</ul>
</li>
<li><p>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下 </p>
<ul>
<li><strong><code>~</code> 表示当前用户的家目录</strong></li>
<li><code>~xxx</code> 表示用户 <code>xxx</code> 的家目录</li>
</ul>
</li>
<li><p>/lib、/usr/lib、/usr/local/lib：<strong>系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助</strong></p>
</li>
<li><p>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下</p>
</li>
<li><p>/mnt: /media：光盘默认<strong>挂载点</strong>，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载</p>
</li>
<li><p>/opt：给主机<strong>额外安装软件所摆放的目录</strong></p>
</li>
<li><p>/proc：<strong>此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间</strong>，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等</p>
</li>
<li><p>/root：<strong>系统管理员root的家目录</strong></p>
</li>
<li><p>/sbin、/usr/sbin、/usr/local/sbin：放置<strong>系统管理员使用的可执行命令</strong>，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令<strong>，一般用户只能”查看”而不能设置和使用</strong></p>
</li>
<li><p>/tmp：一般用户或正在执行的程序<strong>临时存放文件的目录</strong>，任何人都可以访问，<strong>重要数据不可放置在此目录下</strong></p>
</li>
<li><p>/srv：<strong>服务启动之后需要访问的数据目录</strong>，如 www 服务需要访问的网页数据存放在 /srv/www 内</p>
</li>
<li><p>/usr：<strong>应用程序存</strong>放目录 </p>
<ul>
<li>/usr/bin：存放应用程序</li>
<li>/usr/share：存放共享数据</li>
<li>/usr/lib：存放不能直接运行的，<strong>却是许多程序运行所必需的一些函数库文件</strong></li>
<li>/usr/local：存放<strong>软件升级包</strong></li>
<li>/usr/share/doc：系统说明文件存放目录</li>
<li>/usr/share/man：程序说明文件存放目录</li>
</ul>
</li>
<li><p>/var：放置系统执行过程中<strong>经常变化的文件</strong> </p>
<ul>
<li>/var/log：随时更改的<strong>日志</strong>文件 </li>
<li>/var/spool/mail：邮件存放的目录</li>
<li>/var/run：程序或服务启动后，其 PID 存放在该目录下</li>
</ul>
</li>
</ul>
<h4 id="文件和目录常用命令"><a href="#文件和目录常用命令" class="headerlink" title="文件和目录常用命令"></a>文件和目录常用命令</h4><ul>
<li>查看目录内容 <ul>
<li><code>ls</code></li>
</ul>
</li>
<li>切换目录 <ul>
<li><code>cd</code></li>
</ul>
</li>
<li>创建和删除操作 <ul>
<li><code>touch</code></li>
<li><code>rm</code></li>
<li><code>mkdir</code></li>
</ul>
</li>
<li>拷贝和移动文件 <ul>
<li><code>cp</code></li>
<li><code>mv</code></li>
</ul>
</li>
<li>查看文件内容 <ul>
<li><code>cat</code></li>
<li><code>more</code></li>
<li><code>grep</code></li>
</ul>
</li>
<li>其他 <ul>
<li><code>echo</code></li>
<li>重定向 <code>&gt;</code> 和 <code>&gt;&gt;</code></li>
<li>管道 <code>|</code></li>
</ul>
</li>
</ul>
<h6 id="查看目录ls-命令说明"><a href="#查看目录ls-命令说明" class="headerlink" title="查看目录ls 命令说明"></a>查看目录<code>ls</code> 命令说明</h6><ul>
<li><code>ls</code> 是英文单词 <strong>list</strong> 的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于 <strong>DOS</strong> 下的 <code>dir</code> 命令</li>
</ul>
<h6 id="Linux-下文件和目录的特点"><a href="#Linux-下文件和目录的特点" class="headerlink" title="Linux 下文件和目录的特点"></a>Linux 下文件和目录的特点</h6><ul>
<li>Linux <strong>文件</strong> 或者 <strong>目录</strong> 名称最长可以有 <code>256</code> 个字符</li>
<li>以 <code>.</code> 开头的文件为隐藏文件，需要用 -a 参数才能显示</li>
<li><strong>.</strong> 代表当前目录</li>
<li><strong>..</strong> 代表上一级目录</li>
</ul>
<h6 id="ls-常用选项"><a href="#ls-常用选项" class="headerlink" title="ls 常用选项"></a>ls 常用选项</h6><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>显示指定目录下所有子目录与文件，包括隐藏文件</td>
</tr>
<tr>
<td>-l</td>
<td>以列表方式显示文件的详细信息</td>
</tr>
<tr>
<td>-h</td>
<td>配合 -l 以人性化的方式显示文件大小</td>
</tr>
</tbody>
</table>
</div>
<h6 id="计算机中文件大小的表示方式"><a href="#计算机中文件大小的表示方式" class="headerlink" title="计算机中文件大小的表示方式"></a>计算机中文件大小的表示方式</h6><div class="table-container">
<table>
<thead>
<tr>
<th>单位</th>
<th>英文</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节</td>
<td>B（Byte）</td>
<td>在计算机中作为一个数字单元，一般为 8 位二进制数</td>
</tr>
<tr>
<td>千</td>
<td>K（Kibibyte）</td>
<td>1 KB = 1024 B，千字节 （1024 = 2 ** 10）</td>
</tr>
<tr>
<td>兆</td>
<td>M（Mebibyte）</td>
<td>1 MB = 1024 KB，百万字节</td>
</tr>
<tr>
<td>千兆</td>
<td>G（Gigabyte）</td>
<td>1 GB = 1024 MB，十亿字节，千兆字节</td>
</tr>
<tr>
<td>太</td>
<td>T（Terabyte）</td>
<td>1 TB = 1024 GB，万亿字节，太字节</td>
</tr>
<tr>
<td>拍</td>
<td>P（Petabyte）</td>
<td>1 PB = 1024 TB，千万亿字节，拍字节</td>
</tr>
<tr>
<td>艾</td>
<td>E（Exabyte）</td>
<td>1 EB = 1024 PB，百亿亿字节，艾字节</td>
</tr>
<tr>
<td>泽</td>
<td>Z（Zettabyte）</td>
<td>1 ZB = 1024 EB，十万亿亿字节，泽字节</td>
</tr>
<tr>
<td>尧</td>
<td>Y（Yottabyte）</td>
<td>1 YB = 1024 ZB，一亿亿亿字节，尧字节</td>
</tr>
</tbody>
</table>
</div>
<h6 id="ls-通配符的使用"><a href="#ls-通配符的使用" class="headerlink" title="ls 通配符的使用"></a>ls 通配符的使用</h6><div class="table-container">
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>代表任意个数个字符</td>
</tr>
<tr>
<td>?</td>
<td>代表任意一个字符，至少 1 个</td>
</tr>
<tr>
<td>[]</td>
<td>表示可以匹配字符组中的任一一个</td>
</tr>
<tr>
<td>[abc]</td>
<td>匹配 a、b、c 中的任意一个</td>
</tr>
<tr>
<td>[a-f]</td>
<td>匹配从 a 到 f 范围内的的任意一个字符</td>
</tr>
</tbody>
</table>
</div>
<h4 id="磁盘分区类型"><a href="#磁盘分区类型" class="headerlink" title="磁盘分区类型"></a>磁盘分区类型</h4><ul>
<li>主分区：最多只能有四个</li>
<li>扩展分区：最多一个，算作主分区的一种，主分区加扩展分区最多有四个。扩展分区不能存储数据和格式化，必须再划分为逻辑分区才可以使用。</li>
<li>逻辑分区：在扩展分区中划分</li>
</ul>
<p>逻辑分区的编号从5开始</p>
<h4 id="支持的文件系统"><a href="#支持的文件系统" class="headerlink" title="支持的文件系统"></a>支持的文件系统</h4><ul>
<li>ext2:ext文件系统的升级版。最大支持16TB的分区和最大2TB的文件。</li>
<li>ext3:ext2的升级，增加日志功能。</li>
<li>ext4:ext3升级版本，主流使用，功能强大</li>
</ul>
<h4 id="文件系统常用命令"><a href="#文件系统常用命令" class="headerlink" title="文件系统常用命令"></a>文件系统常用命令</h4><h4 id="df-du-fsck-dump2fs"><a href="#df-du-fsck-dump2fs" class="headerlink" title="df, du, fsck, dump2fs"></a>df, du, fsck, dump2fs</h4><h6 id="文件系统查看命令df"><a href="#文件系统查看命令df" class="headerlink" title="文件系统查看命令df"></a>文件系统查看命令df</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df \[选项][挂载点]</span><br><span class="line"></span><br><span class="line">-a 所有文件系统信息</span><br><span class="line"></span><br><span class="line">-h 使用习惯单位显示容量，如kB,MB,GB</span><br><span class="line"></span><br><span class="line">ls 只统计目录下的大小，而不会统计子目录下的数据大小。</span><br></pre></td></tr></table></figure>
<h6 id="统计目录或文件大小du"><a href="#统计目录或文件大小du" class="headerlink" title="统计目录或文件大小du"></a>统计目录或文件大小du</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a , -h , -s</span><br></pre></td></tr></table></figure>
<p>df命令从文件系统考虑，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（eg. 文件已经被删除，但程序并没有释放空间）</p>
<p><strong>du命令面向文件，只会计算文件或目录占用的空间。</strong></p>
<h6 id="文件系统修复命令fsck"><a href="#文件系统修复命令fsck" class="headerlink" title="文件系统修复命令fsck"></a>文件系统修复命令fsck</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck[选项]分区设备文件名</span><br></pre></td></tr></table></figure>
<h6 id="显示磁盘状态命令dumpe2fs"><a href="#显示磁盘状态命令dumpe2fs" class="headerlink" title="显示磁盘状态命令dumpe2fs"></a>显示磁盘状态命令dumpe2fs</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpe2fs 分区设备文件名</span><br></pre></td></tr></table></figure>
<h4 id="文件系统常用命令-挂载命令"><a href="#文件系统常用命令-挂载命令" class="headerlink" title="文件系统常用命令-挂载命令"></a>文件系统常用命令-挂载命令</h4><h6 id="查询与自动挂载"><a href="#查询与自动挂载" class="headerlink" title="查询与自动挂载"></a>查询与自动挂载</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount [-l]：查询系统中已经挂载的设备，-l会显示卷标名称</span><br><span class="line"></span><br><span class="line">mount -a 依据配置文件/etc/fastb的内容，自动挂载</span><br></pre></td></tr></table></figure>
<h6 id="挂载命令格式"><a href="#挂载命令格式" class="headerlink" title="挂载命令格式"></a>挂载命令格式</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">-t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3，ext4,iso9660等文件系统</span><br><span class="line"></span><br><span class="line">-L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载</span><br><span class="line"></span><br><span class="line">-o 特殊指令（remount ...）</span><br><span class="line"></span><br><span class="line">mount -o remount ,noexec /home</span><br></pre></td></tr></table></figure>
<h6 id="挂载光盘与U盘"><a href="#挂载光盘与U盘" class="headerlink" title="挂载光盘与U盘"></a>挂载光盘与U盘</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">挂载光盘</span></span><br><span class="line"></span><br><span class="line">mkdir /mnt/cdrom/ #建立挂载点</span><br><span class="line"></span><br><span class="line">mount -t iso9660 /dev/cdrom /mnt/cdrom #挂载光盘</span><br><span class="line"></span><br><span class="line">mount /dev/sr0 /mnt/cdrom</span><br></pre></td></tr></table></figure>
<h6 id="卸载命令"><a href="#卸载命令" class="headerlink" title="卸载命令"></a>卸载命令</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">umount 设备文件名或挂载点</span><br><span class="line"></span><br><span class="line">umount /mnt/cdrom</span><br></pre></td></tr></table></figure>
<h6 id="挂载U盘"><a href="#挂载U盘" class="headerlink" title="挂载U盘"></a>挂载U盘</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l 查看U盘设备文件名</span><br><span class="line"></span><br><span class="line">mount -t vfat /dev/sdb1 /mnt/usb/</span><br><span class="line"></span><br><span class="line">linux默认不支持NTFS文件系统</span><br></pre></td></tr></table></figure>
<h4 id="fdisk分区"><a href="#fdisk分区" class="headerlink" title="fdisk分区"></a>fdisk分区</h4><h6 id="fdisk命令分区过程"><a href="#fdisk命令分区过程" class="headerlink" title="fdisk命令分区过程"></a>fdisk命令分区过程</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.添加硬盘，虚拟机必须在关机的情况下添加</span><br><span class="line"></span><br><span class="line">2.查看新硬盘 fdisk -l</span><br><span class="line"></span><br><span class="line">3.使用fdisk命令分区</span><br><span class="line"></span><br><span class="line">fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">4.重新读取分区表信息</span><br><span class="line"></span><br><span class="line">partprobe</span><br><span class="line"></span><br><span class="line">5.格式化分区</span><br><span class="line"></span><br><span class="line">扩展分区不可以格式化</span><br><span class="line"></span><br><span class="line">mkfs -t ext4 /dev/sdb1</span><br><span class="line"></span><br><span class="line">6.建立挂载分区</span><br></pre></td></tr></table></figure>
<h6 id="分区自动挂载与fstab文件修复"><a href="#分区自动挂载与fstab文件修复" class="headerlink" title="分区自动挂载与fstab文件修复"></a>分区自动挂载与fstab文件修复</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将挂载写入/etc/fstab文件，一定要写对</span><br><span class="line"></span><br><span class="line">mount -a 依据配置文件 /etc/fstab的内容，自动挂载</span><br><span class="line"></span><br><span class="line">/etc/fstab文件修复</span><br><span class="line"></span><br><span class="line">mount -o remount,rm /</span><br></pre></td></tr></table></figure>
<h4 id="分配swap分区"><a href="#分配swap分区" class="headerlink" title="分配swap分区"></a>分配swap分区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.free命令</span><br><span class="line">查看内存与swap分区使用情况</span><br><span class="line">cached(缓存):加速数据的读取过程</span><br><span class="line">buffer(缓冲)：写入数据过程中，将分散的写入操作保存到内存中，当达到一定的程度再集中写入硬盘，加速数据的写入过程。</span><br><span class="line"></span><br><span class="line">2.新建swap分区</span><br><span class="line">fdisk /dev/sdb</span><br><span class="line">还需将分区ID改为82</span><br><span class="line"></span><br><span class="line">3.格式化</span><br><span class="line">mkswap /dev/sdb6</span><br><span class="line"></span><br><span class="line">4.加入swap分区</span><br><span class="line">swapon /dev/sdb6 加入swap分区</span><br><span class="line">swapoff /dev/sdb6 取消swap分区</span><br><span class="line"></span><br><span class="line">5.swap分区开机自动挂载</span><br><span class="line">vi /etc/fstab</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/05/Go%20%E6%8E%A5%E5%8F%A3_6%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/Go%20%E6%8E%A5%E5%8F%A3_6%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Go 接口转换原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-05 22:29:16" itemprop="dateCreated datePublished" datetime="2020-01-05T22:29:16+08:00">2020-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-09 18:24:20" itemprop="dateModified" datetime="2021-03-09T18:24:20+08:00">2021-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-%E6%8E%A5%E5%8F%A3/" itemprop="url" rel="index">
                    <span itemprop="name">Go 接口</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Go-接口转换原理"><a href="#Go-接口转换原理" class="headerlink" title="Go 接口转换原理"></a>Go 接口转换原理</h3><p>通过前面提到的 <code>iface</code> 的源码可以看到，实际上它包含接口的类型 <code>*interface type</code> 和 实体类型的类型 <code>*_type</code>，这两者都是 <code>iface</code> 的字段 <code>*itab</code> 的成员。也就是说<strong>生成一个 <code>itab</code> 同时需要接口的类型和实体的类型。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;interface 类型， 实体类型&gt; -&gt;itable</span><br></pre></td></tr></table></figure>
<p><strong>当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。</strong></p>
<p>例如某类型有 <code>m</code> 个方法，某接口有 <code>n</code> 个方法，则很容易知道这种判定的时间复杂度为 <code>O(mn)</code>，<strong>Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 <code>O(m+n)</code>。</strong></p>
<p>探索将一个接口转换给另外一个接口背后的原理，当然<strong>，能转换的原因必然是类型兼容</strong>。</p>
<p>直接来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">	code()</span><br><span class="line">	run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> runner <span class="keyword">interface</span> &#123;</span><br><span class="line">	run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">	language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c coder = Gopher&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r runner</span><br><span class="line">	r = c</span><br><span class="line">	fmt.Println(c, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释上述代码：定义了两个 <code>interface</code>: <code>coder</code> 和 <code>runner</code>。定义了一个实体类型 <code>Gopher</code>，类型 <code>Gopher</code> 实现了两个方法，分别是 <code>run()</code> 和 <code>code()</code>。<strong>main 函数里定义了一个接口变量 <code>c</code>，绑定了一个 <code>Gopher</code> 对象，之后将 <code>c</code> 赋值给另外一个接口变量 <code>r</code> 。赋值成功的原因是 <code>c</code> 中包含 <code>run()</code> 方法。这样，两个接口变量完成了转换。</strong></p>
<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S ./src/main.go</span><br></pre></td></tr></table></figure>
<p>得到 main 函数的汇编命令，可以看到： <strong><code>r = c</code> 这一行语句实际上是调用了 <code>runtime.convI2I(SB)</code>，也就是 <code>convI2I</code> 函数，从函数名来看，就是将一个 <code>interface</code> 转换成另外一个 <code>interface</code>，</strong>看下它的源代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convI2I</span><span class="params">(inter *interfacetype, i iface)</span> <span class="params">(r iface)</span></span> &#123;</span><br><span class="line">	tab := i.tab</span><br><span class="line">	<span class="keyword">if</span> tab == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tab.inter == inter &#123;</span><br><span class="line">		r.tab = tab</span><br><span class="line">		r.data = i.data</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	r.tab = getitab(inter, tab._type, <span class="literal">false</span>)</span><br><span class="line">	r.data = i.data</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，函数参数 <code>inter</code> 表示接口类型，<code>i</code> 表示绑定了实体类型的接口，<code>r</code> 则表示接口转换了之后的新的 <code>iface</code>。通过前面的分析，我们又知道， <code>iface</code> 是由 <code>tab</code> 和 <code>data</code> 两个字段组成。所以，<strong>实际上 <code>convI2I</code> 函数真正要做的事，找到新 <code>interface</code> 的 <code>tab</code> 和 <code>data</code>，就大功告成了。</strong></p>
<h4 id="convI2I函数查找tab和data"><a href="#convI2I函数查找tab和data" class="headerlink" title="convI2I函数查找tab和data"></a>convI2I函数查找tab和data</h4><p><strong><code>tab</code> 包括接口类型 <code>interfacetype</code> 和 实体类型 <code>_type</code></strong>。所以最关键的语句是 <code>r.tab = getitab(inter, tab._type, false)</code>。</p>
<p>因此，重点来看下 <code>getitab</code> 函数的源码，只看关键的地方：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getitab</span><span class="params">(inter *interfacetype, typ *_type, canfail <span class="keyword">bool</span>)</span> *<span class="title">itab</span></span> &#123;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 inter, typ 计算出 hash 值</span></span><br><span class="line">	h := itabhash(inter, typ)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// look twice - once without lock, once with.</span></span><br><span class="line">	<span class="comment">// common case will be no lock contention.</span></span><br><span class="line">	<span class="keyword">var</span> m *itab</span><br><span class="line">	<span class="keyword">var</span> locked <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> locked = <span class="number">0</span>; locked &lt; <span class="number">2</span>; locked++ &#123;</span><br><span class="line">		<span class="keyword">if</span> locked != <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;ifaceLock)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历哈希表的一个 slot</span></span><br><span class="line">		<span class="keyword">for</span> m = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h]))); m != <span class="literal">nil</span>; m = m.link &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果在 hash 表中已经找到了 itab（inter 和 typ 指针都相同）</span></span><br><span class="line">			<span class="keyword">if</span> m.inter == inter &amp;&amp; m._type == typ &#123;</span><br><span class="line">                <span class="comment">// ……</span></span><br><span class="line">                </span><br><span class="line">				<span class="keyword">if</span> locked != <span class="number">0</span> &#123;</span><br><span class="line">					unlock(&amp;ifaceLock)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> m</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 hash 表中没有找到 itab，那么新生成一个 itab</span></span><br><span class="line">	m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+<span class="keyword">uintptr</span>(<span class="built_in">len</span>(inter.mhdr)<span class="number">-1</span>)*sys.PtrSize, <span class="number">0</span>, &amp;memstats.other_sys))</span><br><span class="line">	m.inter = inter</span><br><span class="line">    m._type = typ</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到全局的 hash 表中</span></span><br><span class="line">	additab(m, <span class="literal">true</span>, canfail)</span><br><span class="line">	unlock(&amp;ifaceLock)</span><br><span class="line">	<span class="keyword">if</span> m.bad &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单总结：<strong>getitab 函数会根据 <code>interfacetype</code> 和 <code>_type</code> 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 <code>interfacetype</code> 和 <code>_type</code> 新生成一个 <code>itab</code>，并插入到 itab 哈希表，这样下一次就可以直接拿到 <code>itab</code>。</strong></p>
<h4 id="写itab"><a href="#写itab" class="headerlink" title="写itab"></a>写itab</h4><p>这里查找了两次，<strong>并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 <code>itab</code> 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁</strong>。这样，<strong>其他协程在查找相同的 <code>itab</code> 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 <code>itab</code>。</strong> </p>
<p>再来看一下 <code>additab</code> 函数的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查 _type 是否符合 interface_type 并且创建对应的 itab 结构体 将其放到 hash 表中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">additab</span><span class="params">(m *itab, locked, canfail <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	inter := m.inter</span><br><span class="line">	typ := m._type</span><br><span class="line">	x := typ.uncommon()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// both inter and typ have method sorted by name,</span></span><br><span class="line">	<span class="comment">// and interface names are unique,</span></span><br><span class="line">	<span class="comment">// so can iterate over both in lock step;</span></span><br><span class="line">    <span class="comment">// the loop is O(ni+nt) not O(ni*nt).</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// inter 和 typ 的方法都按方法名称进行了排序</span></span><br><span class="line">    <span class="comment">// 并且方法名都是唯一的。所以循环的次数是固定的</span></span><br><span class="line">    <span class="comment">// 只用循环 O(ni+nt)，而非 O(ni*nt)</span></span><br><span class="line">	ni := <span class="built_in">len</span>(inter.mhdr)</span><br><span class="line">	nt := <span class="keyword">int</span>(x.mcount)</span><br><span class="line">	xmhdr := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]method)(add(unsafe.Pointer(x), <span class="keyword">uintptr</span>(x.moff)))[:nt:nt]</span><br><span class="line">	j := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; ni; k++ &#123;</span><br><span class="line">		i := &amp;inter.mhdr[k]</span><br><span class="line">		itype := inter.typ.typeOff(i.ityp)</span><br><span class="line">		name := inter.typ.nameOff(i.name)</span><br><span class="line">		iname := name.name()</span><br><span class="line">		ipkg := name.pkgPath()</span><br><span class="line">		<span class="keyword">if</span> ipkg == <span class="string">""</span> &#123;</span><br><span class="line">			ipkg = inter.pkgpath.name()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ; j &lt; nt; j++ &#123;</span><br><span class="line">			t := &amp;xmhdr[j]</span><br><span class="line">            tname := typ.nameOff(t.name)</span><br><span class="line">            <span class="comment">// 检查方法名字是否一致</span></span><br><span class="line">			<span class="keyword">if</span> typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</span><br><span class="line">				pkgPath := tname.pkgPath()</span><br><span class="line">				<span class="keyword">if</span> pkgPath == <span class="string">""</span> &#123;</span><br><span class="line">					pkgPath = typ.nameOff(x.pkgpath).name()</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</span><br><span class="line">					<span class="keyword">if</span> m != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取函数地址，并加入到itab.fun数组中</span></span><br><span class="line">						ifn := typ.textOff(t.ifn)</span><br><span class="line">						*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[<span class="number">0</span>]), <span class="keyword">uintptr</span>(k)*sys.PtrSize)) = ifn</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">goto</span> nextimethod</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">        </span><br><span class="line">		m.bad = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	nextimethod:</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !locked &#123;</span><br><span class="line">		throw(<span class="string">"invalid itab locking"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 hash 值</span></span><br><span class="line">    h := itabhash(inter, typ)</span><br><span class="line">    <span class="comment">// 加到Hash Slot链表中</span></span><br><span class="line">	m.link = hash[h]</span><br><span class="line">	m.inhash = <span class="literal">true</span></span><br><span class="line">	atomicstorep(unsafe.Pointer(&amp;hash[h]), unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>additab</code> 会检查 <code>itab</code> 持有的 <code>interfacetype</code> 和 <code>_type</code> 是否符合，就是看 <code>_type</code> 是否完全实现了 <code>interfacetype</code> 的方法，也就是看两者的方法列表重叠的部分就是 <code>interfacetype</code> 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 <code>ni * nt</code>，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 <code>ni + nt</code> 次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。</strong></p>
<p>求 hash 值的函数比较简单：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabhash</span><span class="params">(inter *interfacetype, typ *_type)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">	h := inter.typ.hash</span><br><span class="line">	h += <span class="number">17</span> * typ.hash</span><br><span class="line">	<span class="keyword">return</span> h % hashSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hashSize</code> 的值是 1009。</p>
<p>更一般的，当把实体类型赋值给接口的时候，会调用 <code>conv</code> 系列函数，例如空接口调用 <code>convT2E</code> 系列、非空接口调用 <code>convT2I</code> 系列。这些函数比较相似：</p>
<blockquote>
<ol>
<li><strong>具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</strong></li>
<li><strong>具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</strong></li>
<li><strong>而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。</strong></li>
</ol>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【接口赋值、反射】<a href="http://wudaijun.com/2018/01/go-interface-implement/" target="_blank" rel="noopener">http://wudaijun.com/2018/01/go-interface-implement/</a></p>
<p>【itab】<a href="http://legendtkl.com/2017/07/01/golang-interface-implement/" target="_blank" rel="noopener">http://legendtkl.com/2017/07/01/golang-interface-implement/</a></p>
<p>【和 C++ 的对比】<a href="https://www.jianshu.com/p/b38b1719636e" target="_blank" rel="noopener">https://www.jianshu.com/p/b38b1719636e</a></p>
<p>【getitab源码说明】<a href="https://www.twblogs.net/a/5c245d59bd9eee16b3db561d" target="_blank" rel="noopener">https://www.twblogs.net/a/5c245d59bd9eee16b3db561d</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/05/Go%E6%8E%A5%E5%8F%A3_7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%96%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/Go%E6%8E%A5%E5%8F%A3_7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%96%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Go 类型转换和断言</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-05 22:29:16" itemprop="dateCreated datePublished" datetime="2020-01-05T22:29:16+08:00">2020-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-09 14:20:58" itemprop="dateModified" datetime="2021-03-09T14:20:58+08:00">2021-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-interface/" itemprop="url" rel="index">
                    <span itemprop="name">Go interface</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Go-类型转换和断言"><a href="#Go-类型转换和断言" class="headerlink" title="Go 类型转换和断言"></a>Go 类型转换和断言</h3><p>Go 语言中不允许隐式类型转换，<strong>也就是说 <code>=</code> 两边，不允许出现类型不相同的变量</strong>。</p>
<p>类型转换<code>、</code>类型断言本质都是把一个类型转换成另外一个类型。不同之处在于，<strong>类型断言是对接口变量进行的操作。</strong></p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>对于<code>类型转换</code>而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：</p>
<blockquote>
<p>&lt;结果类型&gt; := &lt;目标类型&gt; ( &lt;表达式&gt; )</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> f <span class="keyword">float64</span></span><br><span class="line">	f = <span class="keyword">float64</span>(i)</span><br><span class="line">	fmt.Printf(<span class="string">"%T, %v\n"</span>, f, f) <span class="comment">//float64, 9</span></span><br><span class="line"></span><br><span class="line">	f = <span class="number">10.8</span></span><br><span class="line">	a := <span class="keyword">int</span>(f)</span><br><span class="line">	fmt.Printf(<span class="string">"%T, %v\n"</span>, a, a) <span class="comment">//int, 10</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// s := []int(i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码里，定义了一个 <code>int</code> 型和 <code>float64</code> 型的变量，尝试在它们之间相互转换，结果是成功的：<code>int</code> 型和 <code>float64</code> 是相互兼容的。</p>
<p>把最后一行代码的注释去掉，编译器会报告类型不兼容的错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert i (type int) to type []int</span><br></pre></td></tr></table></figure>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>前面说过，因为<strong>空接口 <code>interface{}</code> 没有定义任何函数</strong>，因此 <strong>Go 中所有类型都实现了空接口</strong>。<strong>当一个函数的形参是 <code>interface{}</code>，那么在函数中，需要对形参进行断言，从而得到它的真实类型。</strong></p>
<p>断言的语法为：</p>
<blockquote>
<p>&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) // <strong>安全类型断言</strong><br>&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )　　//<strong>非安全类型断言</strong></p>
</blockquote>
<p>类型转换和类型断言有些相似，不同之处，在于<strong>类型断言是对接口进行的操作</strong>。</p>
<p>还是来看一个简短的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br><span class="line">	s := i.(Student)</span><br><span class="line">	</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: interface conversion: interface &#123;&#125; is *main.Student, not main.Student</span><br></pre></td></tr></table></figure>
<p>直接 <code>panic</code> 了，这是因为 <strong><code>i</code> 是 <code>*Student</code> 类型，并非 <code>Student</code> 类型，断言失败</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安全断言</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br><span class="line">	s, ok := i.(Student)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，<strong>即使断言失败也不会 <code>panic</code>。</strong></p>
<h4 id="switch语句判断接口类型"><a href="#switch语句判断接口类型" class="headerlink" title="switch语句判断接口类型"></a>switch语句判断接口类型</h4><p>断言其实还有另一种形式，就是<strong>利用 <code>switch</code> 语句判断接口的类型。每一个 <code>case</code> 会被顺序地考虑。当命中一个 <code>case</code> 时，就会执行 <code>case</code> 中的语句，因此 <code>case</code> 语句的顺序是很重要的，因为很有可能会有多个 <code>case</code> 匹配的情况。</strong></p>
<p>代码示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//var i interface&#123;&#125; = new(Student)</span></span><br><span class="line">	<span class="comment">//var i interface&#123;&#125; = (*Student)(nil)</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;i, i)</span><br><span class="line"></span><br><span class="line">	judge(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">judge</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> v := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">		fmt.Printf(<span class="string">"nil type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> Student:</span><br><span class="line">		fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">		fmt.Printf(<span class="string">"Student type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> *Student:</span><br><span class="line">		fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">		fmt.Printf(<span class="string">"*Student type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">		fmt.Printf(<span class="string">"unknow\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code> 函数里有三行不同的声明，<strong>每次运行一行，注释另外两行，得到三组运行结果：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// --- var i interface&#123;&#125; = new(Student)</span><br><span class="line">0xc000010240 &amp;&#123; 0&#125;</span><br><span class="line">0xc000010260 &amp;&#123; 0&#125;</span><br><span class="line">0xc00000e030 &amp;&#123; 0&#125;</span><br><span class="line">*Student type[*main.Student] &amp;&#123; 0&#125;</span><br><span class="line"></span><br><span class="line">// --- var i interface&#123;&#125; = (*Student)(nil)</span><br><span class="line">0xc000010240 &lt;nil&gt;</span><br><span class="line">0xc000010250 &lt;nil&gt;</span><br><span class="line">0xc00000e030 &lt;nil&gt;</span><br><span class="line">*Student type[*main.Student] &lt;nil&gt;</span><br><span class="line"></span><br><span class="line">// --- var i interface&#123;&#125;</span><br><span class="line">0xc00010a220 &lt;nil&gt;</span><br><span class="line">0xc00010a230 &lt;nil&gt;</span><br><span class="line">0xc00010a240 &lt;nil&gt;</span><br><span class="line">nil type[&lt;nil&gt;] &lt;nil&gt;</span><br></pre></td></tr></table></figure>
<p>对于第一行语句：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br></pre></td></tr></table></figure>
<p><strong><code>i</code> 是一个 <code>*Student</code> 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 <code>main</code> 函数里有一个局部变量 <code>i</code>；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 <code>v</code>，它是 <code>i</code> 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。</strong></p>
<p>对于第二行语句：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = (*Student)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这里想说明的其实是 <strong><code>i</code> 在这里动态类型是 <code>(*Student)</code>, 数据为 <code>nil</code>，它的类型并不是 <code>nil</code>，它与 <code>nil</code> 作比较的时候，得到的结果也是 <code>false</code>。</strong></p>
<p>最后一行语句：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这回 <code>i</code> 才是 <code>nil</code> 类型。</p>
<p>【引申1】<br><strong><code>fmt.Println</code> 函数的参数是 <code>interface</code>。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印。而对于自定义类型，首先确定该类型是否实现了 <code>String()</code> 方法，如果实现了，则直接打印输出 <code>String()</code> 方法的结果；否则，会通过反射来遍历对象的成员进行打印。</strong></p>
<p>再来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s = Student&#123;</span><br><span class="line">		Name: <span class="string">"qcrao"</span>,</span><br><span class="line">		Age: <span class="number">18</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>Student</code> 结构体没有实现 <code>String()</code> 方法，<strong>所以 <code>fmt.Println</code> 会利用反射挨个打印成员变量：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;qcrao 18&#125;</span><br></pre></td></tr></table></figure>
<p><strong>增加一个 <code>String()</code> 方法的实现：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"[Name: %s], [Age: %d]"</span>, s.Name, s.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Name: qcrao], [Age: 18]</span><br></pre></td></tr></table></figure>
<p>按照我们自定义的方法来打印了。</p>
<p>【引申2】<br>针对上面的例子，如果改一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"[Name: %s], [Age: %d]"</span>, s.Name, s.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意看两个函数的接受者类型不同，现在 <code>Student</code> 结构体只有一个接受者类型为 <code>指针类型</code> 的 <code>String()</code> 函数，打印结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;qcrao 18&#125;</span><br></pre></td></tr></table></figure>
<p>为什么？</p>
<blockquote>
<p><strong>类型 <code>T</code> 只有接受者是 <code>T</code> 的方法；而类型 <code>*T</code> 拥有接受者是 <code>T</code> 和 <code>*T</code> 的方法。语法上 <code>T</code> 能直接调 <code>*T</code> 的方法仅仅是 <code>Go</code> 的语法糖。</strong></p>
</blockquote>
<p>当 <strong><code>Student</code> 结构体定义了接受者类型是值类型的 <code>String()</code> 方法时</strong>，通过</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(&amp;s)</span><br></pre></td></tr></table></figure>
<p>均可以按照自定义的格式来打印。</p>
<p>如果 <code>Student</code> 结构体定义了<strong>接受者类型是指针类型的 <code>String()</code> 方法时</strong>，只有通过</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&amp;s)</span><br></pre></td></tr></table></figure>
<p>才能按照自定义的格式打印。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【类型转换和断言】<a href="https://www.cnblogs.com/zrtqsk/p/4157350.html" target="_blank" rel="noopener">https://www.cnblogs.com/zrtqsk/p/4157350.html</a></p>
<p>【断言】<a href="https://studygolang.com/articles/11419" target="_blank" rel="noopener">https://studygolang.com/articles/11419</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/Go%20%E6%8E%A5%E5%8F%A3_5%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/04/Go%20%E6%8E%A5%E5%8F%A3_5%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/" class="post-title-link" itemprop="url">Go 接口的构造过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-04 22:29:16" itemprop="dateCreated datePublished" datetime="2020-01-04T22:29:16+08:00">2020-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-09 13:35:24" itemprop="dateModified" datetime="2021-03-09T13:35:24+08:00">2021-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-interface/" itemprop="url" rel="index">
                    <span itemprop="name">Go interface</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Go-接口的构造过程"><a href="#Go-接口的构造过程" class="headerlink" title="Go 接口的构造过程"></a>Go 接口的构造过程</h3><p>博客<a href="https://dongshifu.github.io/2020/01/03/Go%20%E6%8E%A5%E5%8F%A3_3iface%20%E5%92%8C%20eface%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">Go接口的底层实现</a>源码分析可以看到 <code>iface</code> 和 <code>eface</code> 的源码，知道 <code>iface</code> 最重要的是 <code>itab</code> 和 <code>_type</code>。</p>
<p>为了研究清楚接口是如何构造的，接下来利用汇编还原背后的真相。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">	growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Student)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.age += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> qcrao = Person(Student&#123;age: <span class="number">18</span>&#125;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(qcrao)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S main.go</span><br></pre></td></tr></table></figure>
<p>得到 main 函数的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00000 (./src/main.go:30) TEXT    &quot;&quot;.main(SB), $80-0</span><br><span class="line">0x0000 00000 (./src/main.go:30) MOVQ    (TLS), CX</span><br><span class="line">0x0009 00009 (./src/main.go:30) CMPQ    SP, 16(CX)</span><br><span class="line">0x000d 00013 (./src/main.go:30) JLS     157</span><br><span class="line">0x0013 00019 (./src/main.go:30) SUBQ    $80, SP</span><br><span class="line">0x0017 00023 (./src/main.go:30) MOVQ    BP, 72(SP)</span><br><span class="line">0x001c 00028 (./src/main.go:30) LEAQ    72(SP), BP</span><br><span class="line">0x0021 00033 (./src/main.go:30) FUNCDATA$0, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">0x0021 00033 (./src/main.go:30) FUNCDATA$1, gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)</span><br><span class="line">0x0021 00033 (./src/main.go:31) MOVQ    $18, &quot;&quot;..autotmp_1+48(SP)</span><br><span class="line">0x002a 00042 (./src/main.go:31) LEAQ    go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB), AX</span><br><span class="line">0x0031 00049 (./src/main.go:31) MOVQ    AX, (SP)</span><br><span class="line">0x0035 00053 (./src/main.go:31) LEAQ    &quot;&quot;..autotmp_1+48(SP), AX</span><br><span class="line">0x003a 00058 (./src/main.go:31) MOVQ    AX, 8(SP)</span><br><span class="line">0x003f 00063 (./src/main.go:31) PCDATA  $0, $0</span><br><span class="line">0x003f 00063 (./src/main.go:31) CALL    runtime.convT2I64(SB)</span><br><span class="line">0x0044 00068 (./src/main.go:31) MOVQ    24(SP), AX</span><br><span class="line">0x0049 00073 (./src/main.go:31) MOVQ    16(SP), CX</span><br><span class="line">0x004e 00078 (./src/main.go:33) TESTQ   CX, CX</span><br><span class="line">0x0051 00081 (./src/main.go:33) JEQ     87</span><br><span class="line">0x0053 00083 (./src/main.go:33) MOVQ    8(CX), CX</span><br><span class="line">0x0057 00087 (./src/main.go:33) MOVQ    $0, &quot;&quot;..autotmp_2+56(SP)</span><br><span class="line">0x0060 00096 (./src/main.go:33) MOVQ    $0, &quot;&quot;..autotmp_2+64(SP)</span><br><span class="line">0x0069 00105 (./src/main.go:33) MOVQ    CX, &quot;&quot;..autotmp_2+56(SP)</span><br><span class="line">0x006e 00110 (./src/main.go:33) MOVQ    AX, &quot;&quot;..autotmp_2+64(SP)</span><br><span class="line">0x0073 00115 (./src/main.go:33) LEAQ    &quot;&quot;..autotmp_2+56(SP), AX</span><br><span class="line">0x0078 00120 (./src/main.go:33) MOVQ    AX, (SP)</span><br><span class="line">0x007c 00124 (./src/main.go:33) MOVQ    $1, 8(SP)</span><br><span class="line">0x0085 00133 (./src/main.go:33) MOVQ    $1, 16(SP)</span><br><span class="line">0x008e 00142 (./src/main.go:33) PCDATA  $0, $1</span><br><span class="line">0x008e 00142 (./src/main.go:33) CALL    fmt.Println(SB)</span><br><span class="line">0x0093 00147 (./src/main.go:34) MOVQ    72(SP), BP</span><br><span class="line">0x0098 00152 (./src/main.go:34) ADDQ    $80, SP</span><br><span class="line">0x009c 00156 (./src/main.go:34) RET</span><br><span class="line">0x009d 00157 (./src/main.go:34) NOP</span><br><span class="line">0x009d 00157 (./src/main.go:30) PCDATA  $0, $-1</span><br><span class="line">0x009d 00157 (./src/main.go:30) CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">0x00a2 00162 (./src/main.go:30) JMP     0</span><br></pre></td></tr></table></figure>
<p>从第 10 行开始看：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>汇编行数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>10-14</td>
<td>构造调用 <code>runtime.convT2I64(SB)</code> 的<strong>参数</strong></td>
</tr>
</tbody>
</table>
</div>
<p>函数的参数形式：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I64</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>convT2I64</code> 会构造出一个 <code>inteface</code>，也就是我们的 <code>Person</code> 接口。</strong></p>
<p><strong>第一个参数的位置是 <code>(SP)</code>，这里被赋上了 <code>go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB)</code> 的地址。</strong></p>
<p>我们从生成的汇编找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go.itab.&quot;&quot;.Student,&quot;&quot;.Person SNOPTRDATA dupok size=40</span><br><span class="line">        0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  </span><br><span class="line">        0x0010 00 00 00 00 00 00 00 00 da 9f 20 d4              </span><br><span class="line">        rel 0+8 t=1 type.&quot;&quot;.Person+0</span><br><span class="line">        rel 8+8 t=1 type.&quot;&quot;.Student+0</span><br></pre></td></tr></table></figure>
<p><code>size=40</code> 大小为40字节，回顾一下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">	inter  *interfacetype <span class="comment">// 8字节</span></span><br><span class="line">	_type  *_type <span class="comment">// 8字节</span></span><br><span class="line">	link   *itab <span class="comment">// 8字节</span></span><br><span class="line">	hash   <span class="keyword">uint32</span> <span class="comment">// 4字节</span></span><br><span class="line">	bad    <span class="keyword">bool</span>   <span class="comment">// 1字节</span></span><br><span class="line">	inhash <span class="keyword">bool</span>   <span class="comment">// 1字节</span></span><br><span class="line">	unused [<span class="number">2</span>]<span class="keyword">byte</span> <span class="comment">// 2字节</span></span><br><span class="line">	fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized // 8字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>把每个字段的大小相加，<code>itab</code> 结构体的大小就是 40 字节。上面那一串数字实际上是 <code>itab</code> 序列化后的内容</strong>，注意到大部分数字是 0，从 24 字节开始的 4 个字节 <code>da 9f 20 d4</code> 实际上是 <code>itab</code> 的 <code>hash</code> 值，这在<strong>判断两个类型是否相同的时候会用到。</strong></p>
<p>下面两行是<strong>链接指令，简单说就是将所有源文件综合起来，给每个符号赋予一个全局的位置值。这里的意思也比较明确：前8个字节最终存储的是 <code>type.&quot;&quot;.Person</code> 的地址，对应 <code>itab</code> 里的 <code>inter</code> 字段，表示接口类型；8-16 字节最终存储的是 <code>type.&quot;&quot;.Student</code> 的地址，对应 <code>itab</code> 里 <code>_type</code> 字段，表示具体类型。</strong></p>
<p>第二个参数就比较简单了，它就是数字 <code>18</code> 的地址，这也是初始化 <code>Student</code> 结构体的时候会用到。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>汇编行数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>调用 <code>runtime.convT2I64(SB)</code></td>
</tr>
</tbody>
</table>
</div>
<p>具体看下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I64</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">	t := tab._type</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> *(*<span class="keyword">uint64</span>)(elem) == <span class="number">0</span> &#123;</span><br><span class="line">		x = unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		x = mallocgc(<span class="number">8</span>, t, <span class="literal">false</span>)</span><br><span class="line">		*(*<span class="keyword">uint64</span>)(x) = *(*<span class="keyword">uint64</span>)(elem)</span><br><span class="line">	&#125;</span><br><span class="line">	i.tab = tab</span><br><span class="line">	i.data = x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块代码比较简单，<strong>把 <code>tab</code> 赋给了 <code>iface</code> 的 <code>tab</code> 字段；<code>data</code> 部分则是在堆上申请了一块内存，然后将 <code>elem</code> 指向的 <code>18</code> 拷贝过去。这样 <code>iface</code> 就组装好了。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>汇编行数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>17</td>
<td>把 <code>i.tab</code> 赋给 <code>CX</code></td>
</tr>
<tr>
<td>18</td>
<td>把 <code>i.data</code> 赋给 <code>AX</code></td>
</tr>
<tr>
<td>19-21</td>
<td><strong>检测 <code>i.tab</code> 是否是 nil，如果不是的话，把 CX 移动 8 个字节，也就是把 <code>itab</code> 的 <code>_type</code> 字段赋给了 CX，这也是接口的实体类型，最终要作为 <code>fmt.Println</code> 函数的参数</strong></td>
</tr>
</tbody>
</table>
</div>
<p>后面，就是调用 <code>fmt.Println</code> 函数及之前的参数准备工作了.</p>
<p>这样，我们就把一个 <code>interface</code> 的构造过程说完了。</p>
<p>【引申1】<br>如何打印出接口类型的 <code>Hash</code> 值？</p>
<p>这里参考一篇文章<a href="https://xargin.com/go-and-interface/#reconstructing-an-itab-from-an-executable" target="_blank" rel="noopener">Go和interface探究</a>。具体做法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">	inter <span class="keyword">uintptr</span></span><br><span class="line">	_type <span class="keyword">uintptr</span></span><br><span class="line">	link <span class="keyword">uintptr</span></span><br><span class="line">	hash  <span class="keyword">uint32</span></span><br><span class="line">	_     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">	fun   [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> qcrao = Person(Student&#123;age: <span class="number">18</span>&#125;)</span><br><span class="line"></span><br><span class="line">	iface := (*iface)(unsafe.Pointer(&amp;qcrao))</span><br><span class="line">	fmt.Printf(<span class="string">"iface.tab.hash = %#x\n"</span>, iface.tab.hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个<code>山寨版</code>的 <code>iface</code> 和 <code>itab</code>，说它<code>山寨</code>是因为 <code>itab</code> 里的一些关键数据结构都不具体展开了，比如 <code>_type</code>，对比一下正宗的定义就可以发现，但是<code>山寨版</code>依然能工作，因为 <code>_type</code> 就是一个指针而已嘛。</p>
<p>在 <code>main</code> 函数里，先构造出一个接口对象 <code>qcrao</code>，然后强制类型转换，最后读取出 <code>hash</code> 值！</p>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iface.tab.hash = 0xd4209fda</span><br></pre></td></tr></table></figure>
<p>值得一提的是，构造接口 <code>qcrao</code> 的时候，即使把 <code>age</code> 写成其他值，得到的 <code>hash</code> 值依然不变的，这应该是可以预料的，<strong><code>hash</code> 值只和他的字段、方法相关。</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://xargin.com/go-and-interface/#reconstructing-an-itab-from-an-executable" target="_blank" rel="noopener">http://xargin.com/go-and-interface/#reconstructing-an-itab-from-an-executable</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/Go%20%E6%8E%A5%E5%8F%A3_4%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/04/Go%20%E6%8E%A5%E5%8F%A3_4%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E5%80%BC/" class="post-title-link" itemprop="url">Go 接口的动态类型和动态值</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-04 21:29:16" itemprop="dateCreated datePublished" datetime="2020-01-04T21:29:16+08:00">2020-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-11 13:21:25" itemprop="dateModified" datetime="2021-03-11T13:21:25+08:00">2021-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-interface/" itemprop="url" rel="index">
                    <span itemprop="name">Go interface</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Go-接口的动态类型和动态值"><a href="#Go-接口的动态类型和动态值" class="headerlink" title="Go 接口的动态类型和动态值"></a>Go 接口的动态类型和动态值</h3><p>从上一篇博客<a href="https://dongshifu.github.io/2020/01/03/Go%20%E6%8E%A5%E5%8F%A3_3iface%20%E5%92%8C%20eface%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">Go接口的底层实现</a>源码分析里可以看到：<code>iface</code>包含两个字段：<code>tab</code> 是接口表指针，指向类型信息；<code>data</code> 是数据指针，则指向具体的数据。它们分别被称为<strong><code>动态类型</code>和<code>动态值</code></strong>。而接口值包括<code>动态类型</code>和<code>动态值</code>。</p>
<p>【引申1】接口类型和 <code>nil</code> 作比较</p>
<p><strong>接口值的零值是指<code>动态类型</code>和<code>动态值</code>都为 <code>nil</code>。当仅且当这两部分的值都为 <code>nil</code> 的情况下，这个接口值就才会被认为 <code>接口值 == nil</code>。</strong></p>
<p>来看个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coder <span class="keyword">interface</span> &#123;</span><br><span class="line">	code()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is coding\n"</span>, g.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Coder</span><br><span class="line">	fmt.Println(c == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"c: %T, %v\n"</span>, c, c)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> g *Gopher</span><br><span class="line">	fmt.Println(g == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	c = g</span><br><span class="line">	fmt.Println(c == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"c: %T, %v\n"</span>, c, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">c: &lt;nil&gt;, &lt;nil&gt;</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">c: *main.Gopher, &lt;nil&gt;</span><br></pre></td></tr></table></figure>
<p>一开始，<strong><code>c</code> 的 动态类型和动态值都为 <code>nil</code>，<code>g</code> 也为 <code>nil</code>，当把 <code>g</code> 赋值给 <code>c</code> 后，<code>c</code> 的动态类型变成了 <code>*main.Gopher</code>，仅管 <code>c</code> 的动态值仍为 <code>nil</code>，但是当 <code>c</code> 和 <code>nil</code> 作比较的时候，结果就是 <code>false</code> 了。</strong></p>
<p>【引申2】</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"MyError"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := Process()</span><br><span class="line">	fmt.Println(err)</span><br><span class="line"></span><br><span class="line">	fmt.Println(err == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Process</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err *MyError = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p><strong>这里先定义了一个 <code>MyError</code> 结构体，实现了 <code>Error</code> 函数，也就实现了 <code>error</code> 接口。<code>Process</code> 函数返回了一个 <code>error</code> 接口，这块隐含了类型转换。所以，虽然它的值是 <code>nil</code>，其实它的类型是 <code>*MyError</code>，最后和 <code>nil</code> 比较的时候，结果为 <code>false</code>。</strong></p>
<p>【引申3】如何打印出接口的动态类型和值？</p>
<p>直接看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	itab, data <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	x := <span class="number">5</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">interface</span>&#123;&#125; = (*<span class="keyword">int</span>)(&amp;x)</span><br><span class="line">	</span><br><span class="line">	ia := *(*iface)(unsafe.Pointer(&amp;a))</span><br><span class="line">	ib := *(*iface)(unsafe.Pointer(&amp;b))</span><br><span class="line">	ic := *(*iface)(unsafe.Pointer(&amp;c))</span><br><span class="line"></span><br><span class="line">	fmt.Println(ia, ib, ic)</span><br><span class="line"></span><br><span class="line">	fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(ic.data)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里直接定义了一个 <code>iface</code> 结构体，<strong>用两个指针来描述 <code>itab</code> 和 <code>data</code>，之后将 a, b, c 在内存中的内容强制解释成我们自定义的 <code>iface</code>。最后就可以打印出动态类型和动态值的地址。</strong></p>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;0 0&#125; &#123;4843168 0&#125; &#123;4843168 824634355376&#125;</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>a 的动态类型和动态值的地址均为 0，也就是 nil；<strong>b 的动态类型和 c 的动态类型一致，都是 <code>*int</code></strong>；最后，c 的动态值为 5。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/03/Go%20%E6%8E%A5%E5%8F%A3_3iface%20%E5%92%8C%20eface%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/03/Go%20%E6%8E%A5%E5%8F%A3_3iface%20%E5%92%8C%20eface%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">Go 接口的底层实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-03 21:29:16" itemprop="dateCreated datePublished" datetime="2020-01-03T21:29:16+08:00">2020-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 18:38:43" itemprop="dateModified" datetime="2021-03-08T18:38:43+08:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-interface/" itemprop="url" rel="index">
                    <span itemprop="name">Go interface</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Go-接口的底层实现"><a href="#Go-接口的底层实现" class="headerlink" title="Go 接口的底层实现"></a>Go 接口的底层实现</h3><p><code>iface</code> 和 <code>eface</code> 都是 Go 中<strong>描述接口的底层结构体</strong>，区别在于 <strong><code>iface</code> 描述的接口包含方法</strong>，<strong>而 <code>eface</code> 则是不包含任何方法的空接口：<code>interface{}</code>。</strong></p>
<p>从源码层面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">	inter  *interfacetype</span><br><span class="line">	_type  *_type</span><br><span class="line">	link   *itab</span><br><span class="line">	hash   <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">	bad    <span class="keyword">bool</span>   <span class="comment">// type does not implement interface</span></span><br><span class="line">	inhash <span class="keyword">bool</span>   <span class="comment">// has this itab been added to hash?</span></span><br><span class="line">	unused [<span class="number">2</span>]<span class="keyword">byte</span></span><br><span class="line">	fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>iface</code> 内部维护两个指针，<code>tab</code> 指向一个 <code>itab</code> 实体， 它表示接口的类型以及赋给这个接口的实体类型。<code>data</code> 则指向接口具体的值，一般而言是一个指向堆内存的指针。</strong></p>
<p>再来仔细看一下 <code>itab</code> 结构体：</p>
<ul>
<li><code>_type</code> 字段描述了<strong>实体的类型</strong>，包括内存对齐方式，大小等；</li>
<li><code>inter</code> 字段则描述了<strong>接口的类型</strong>。</li>
<li><code>fun</code> 字段<strong>放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。</strong></li>
</ul>
<p>为什么 <code>fun</code> 数组的大小为 1，要是接口定义了多个方法可怎么办？<strong>实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响</strong>。<strong>这些方法是按照函数名称的字典序进行排列的。</strong></p>
<p>再看一下 <code>interfacetype</code> 类型，它描述的是<strong>接口的类型</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ     _type</span><br><span class="line">	pkgpath name</span><br><span class="line">	mhdr    []imethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，它<strong>包装了 <code>_type</code> 类型，<code>_type</code> 实际上是描述 Go 语言中各种数据类型的结构体</strong>。这里还包含一个 <strong><code>mhdr</code> 字段，表示接口所定义的函数列表， <code>pkgpath</code> 记录定义了接口的包名。</strong></p>
<p>这里通过一张图来看下 <code>iface</code> 结构体的全貌：</p>
<p><img src="http://note.youdao.com/yws/public/resource/8941a5b166d00686542939a34ab5b824/xmlnote/WEBRESOURCE4c3c10a3a36d081c3787db1242d05528/4518" style="zoom:50%;" /></p>
<p><code>eface</code> 的源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比 <code>iface</code>，<code>eface</code> 比较简单。只维护了一个 <code>_type</code> 字段，<strong>表示空接口所承载的具体的实体类型</strong>。<code>data</code> 描述了具体的值。</p>
<p><img src="http://note.youdao.com/yws/public/resource/8941a5b166d00686542939a34ab5b824/xmlnote/WEBRESOURCEb64a739bc6eb4c7cfe6a05b71e1d6e38/4523" alt="eface 结构体" style="zoom:50%;" /></p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">200</span></span><br><span class="line">	<span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125; = x</span><br><span class="line">	fmt.Println(any)</span><br><span class="line"></span><br><span class="line">	g := Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> c coder = g</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">	code()</span><br><span class="line">	debug()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">	language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"I am coding %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">debug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"I am debuging %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行命令，打印出汇编语言：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S ./src/main.go</span><br></pre></td></tr></table></figure>
<p>可以看到，main 函数里调用了两个函数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func convT2E64(t *_type, elem unsafe.Pointer) (e eface)</span><br><span class="line">func convT2I(tab *itab, elem unsafe.Pointer) (i iface)</span><br></pre></td></tr></table></figure>
<p>上面两个函数的参数和 <code>iface</code> 及 <code>eface</code> 结构体的字段是可以联系起来的：两个函数都是将参数<code>组装</code>一下，形成最终的接口。</p>
<p>作为补充，最后再来看下 <code>_type</code> 结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 类型大小</span></span><br><span class="line">	size       <span class="keyword">uintptr</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// 类型的 hash 值</span></span><br><span class="line">    hash       <span class="keyword">uint32</span></span><br><span class="line">    <span class="comment">// 类型的 flag，和反射相关</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    <span class="comment">// 内存对齐相关</span></span><br><span class="line">    align      <span class="keyword">uint8</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span></span><br><span class="line">    <span class="comment">// 类型的编号，有bool, slice, struct 等等等等</span></span><br><span class="line">	kind       <span class="keyword">uint8</span></span><br><span class="line">	alg        *typeAlg</span><br><span class="line">	<span class="comment">// gc 相关</span></span><br><span class="line">	gcdata    *<span class="keyword">byte</span></span><br><span class="line">	str       nameOff</span><br><span class="line">	ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Go 语言各种数据类型都是在 <code>_type</code> 字段的基础上，增加一些额外的字段来进行管理的：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arraytype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ   _type</span><br><span class="line">	elem  *_type</span><br><span class="line">	slice *_type</span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  _type</span><br><span class="line">	elem *_type</span><br><span class="line">	dir  <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> slicetype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  _type</span><br><span class="line">	elem *_type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> structtype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ     _type</span><br><span class="line">	pkgPath name</span><br><span class="line">	fields  []structfield</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些数据类型的结构体定义，是反射实现的基础。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【Go Interface 源码剖析 】<a href="http://legendtkl.com/2017/07/01/golang-interface-implement/" target="_blank" rel="noopener">http://legendtkl.com/2017/07/01/golang-interface-implement/</a></p>
<p>【interface 源码解读 包含反射】<a href="http://wudaijun.com/2018/01/go-interface-implement/" target="_blank" rel="noopener">http://wudaijun.com/2018/01/go-interface-implement/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/02/Go%20%E6%8E%A5%E5%8F%A3_2Go%E8%AF%AD%E8%A8%80%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/02/Go%20%E6%8E%A5%E5%8F%A3_2Go%E8%AF%AD%E8%A8%80%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB/" class="post-title-link" itemprop="url">Go鸭子类型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-02 21:30:16" itemprop="dateCreated datePublished" datetime="2020-01-02T21:30:16+08:00">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-10 08:21:27" itemprop="dateModified" datetime="2021-03-10T08:21:27+08:00">2021-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-interface/" itemprop="url" rel="index">
                    <span itemprop="name">Go interface</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h3><p>维基百科: 如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。</p>
<ul>
<li><p><code>Duck Typing</code>，鸭子类型，是<strong>动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身</strong>。</p>
</li>
<li><p>Go 语言作为一门静态语言，它通过<strong>通过接口的方式完美支持鸭子类型</strong>。</p>
</li>
</ul>
<h3 id="动态语言实现"><a href="#动态语言实现" class="headerlink" title="动态语言实现"></a>动态语言实现</h3><p>动态语言的特点：</p>
<blockquote>
<p>变量绑定的类型是不确定的，在运行期间才能确定<br>函数和方法可以接收任何类型的参数，且调用时不检查参数类型<br>不需要实现接口</p>
</blockquote>
<p>在动态语言 python 中，定义一个这样的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">(coder)</span>:</span></span><br><span class="line">    coder.say_hello()</span><br></pre></td></tr></table></figure>
<p>当调用此函数的时候，可以传入任意类型，只要它实现了 <code>say_hello()</code> 函数就可以。如果没有实现，<strong>运行过程</strong>中会出现错误。</p>
<h3 id="静态语言实现"><a href="#静态语言实现" class="headerlink" title="静态语言实现"></a>静态语言实现</h3><p>而在静态语言如 Java, C++ 中，必须要<strong>显示地声明实现了某个接后，才能用在任何需要这个接口的地方。</strong> <strong>如果你在程序中调用 <code>hello_world</code> 函数，却传入了一个根本就没有实现 <code>say_hello()</code> 的类型，那在编译阶段就不会通过。</strong>这也是静态语言比动态语言更安全的原因。</p>
<p>动态语言和静态语言的差别在此就有所体现。<strong>静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。</strong></p>
<p>静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，eg. python 。</p>
<h3 id="Go鸭子类型实现"><a href="#Go鸭子类型实现" class="headerlink" title="Go鸭子类型实现"></a>Go鸭子类型实现</h3><p>Go 语言作为一门现代静态语言，是有后发优势的。它<strong>引入了动态语言的便利，同时又会进行静态语言的类型检查</strong>，写起来是非常高效的。</p>
<p>Go 采用了折中的做法：<strong>不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。</strong></p>
<p>例子：</p>
<p>定义一个接口，和使用此接口作为参数的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IGreeting <span class="keyword">interface</span> &#123;</span><br><span class="line">	sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(i IGreeting)</span></span> &#123;</span><br><span class="line">	i.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义两个结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Go <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Go)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hi, I am GO!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PHP <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PHP)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hi, I am PHP!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在 main 函数里调用 sayHello() 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	golang := Go&#123;&#125;</span><br><span class="line">	php := PHP&#123;&#125;</span><br><span class="line"></span><br><span class="line">	sayHello(golang)</span><br><span class="line">	sayHello(php)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi, I am GO!</span><br><span class="line">Hi, I am PHP!</span><br></pre></td></tr></table></figure>
<p><strong>在 main 函数中，调用 sayHello() 函数时，传入了 <code>golang, php</code> 对象，它们并没有显式地声明实现了 IGreeting 类型，只是实现了接口所规定的 sayHello() 函数。实际上，编译器在调用 sayHello() 函数时，会隐式地将 <code>golang, php</code> 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>鸭子类型是一种动态语言的风格，在这种风格中，<strong>一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它”当前方法和属性的集合”决定。Go 作为一种静态语言，通过接口实现了 <code>鸭子类型</code>，实际上是 Go 的编译器在其中作了隐匿的转换工作。</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【Golang 与鸭子类型，讲得比较好】<a href="https://blog.csdn.net/cszhouwei/article/details/33741731" target="_blank" rel="noopener">https://blog.csdn.net/cszhouwei/article/details/33741731</a></p>
<p>【各种面向对象的名词】<a href="https://cyent.github.io/golang/other/oo/" target="_blank" rel="noopener">https://cyent.github.io/golang/other/oo/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShifuDong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShifuDong</p>
  <div class="site-description" itemprop="description">记录生活， 记录学习， 分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShifuDong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  



    </div>
</body>
</html>
