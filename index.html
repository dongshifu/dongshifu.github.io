<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ShifuDong" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="记录生活， 记录学习， 分享知识">
<meta name="keywords" content="生活，C++, C, go, java, OS, 网络， 存储， 联邦学习， 机器学习，python">
<meta property="og:type" content="website">
<meta property="og:title" content="ShifuDong">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="ShifuDong">
<meta property="og:description" content="记录生活， 记录学习， 分享知识">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ShifuDong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShifuDong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Knowledge Sharing</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/21/http-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/21/http-1/" class="post-title-link" itemprop="url">HTTP需要注意的知识点</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-21 19:29:16" itemprop="dateCreated datePublished" datetime="2021-03-21T19:29:16+08:00">2021-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 08:27:29" itemprop="dateModified" datetime="2021-03-29T08:27:29+08:00">2021-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a><code>HTTP</code>基本概念</h3><h4 id="定义-超文本传输协议"><a href="#定义-超文本传输协议" class="headerlink" title="定义:超文本传输协议"></a>定义:超文本传输协议</h4><ul>
<li>协议：一个用在计算机中的协议。使用计算机语言确定了一种计算机之间通信的<strong>规范</strong>(两个及以上的参与者)以及相关的<strong>控制和错误处理</strong>方式。</li>
<li>传输：<strong>两点之间的双向数据通信(可以服务器到服务器)</strong>，该过程中还允许有<strong>中转或接力</strong>。（在 <code>HTTP</code> 里，需要中间人遵从 <code>HTTP</code> 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西）</li>
<li>超文本：传输的<strong>内容</strong>是超文本（是文字、图片、视频等的混合体，<strong>能从一个超文本跳转到另外一个超文本，<code>eg. html</code></strong>）</li>
</ul>
<h4 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h4><ul>
<li><code>1xx</code>:该类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</li>
<li><code>2xx</code> ：该类状态码表示服务器<strong>成功</strong>处理了客户端的请求。<ul>
<li><strong><code>200 OK</code></strong>是最常见的成功状态码，表示<strong>一切正常</strong>。如果是<strong>非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据</strong>。</li>
<li><strong><code>204 No Content</code></strong>也是常见的成功状态码，与 200 OK 基本相同，但<strong>响应头没有 body 数据</strong>。</li>
<li><strong><code>206 Partial Content</code></strong>是<strong>应用于 <code>HTTP</code>分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分</strong>，也是服务器处理成功的状态。</li>
</ul>
</li>
<li><code>3xx</code>:该 类状态码表示<strong>客户端请求的资源发生了变动</strong>，需要客户端<strong>用新的 URL 重新发送请求获取资源</strong>，也就是<strong>重定向</strong>。<ul>
<li><strong><code>301 Moved Permanentl</code></strong>表示<strong>永久重定向</strong>，说明请求的<strong>资源已经不存在了，需改用新的 URL 再次访问</strong>。</li>
<li><strong><code>302 Moved Temporarily</code></strong>表示<strong>临时重定向</strong>，说明请求的<strong>资源还在，但暂时需要用另一个 URL 来访问</strong>。</li>
<li>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</li>
<li><strong><code>304 Not Modified</code></strong>不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称<strong>缓存重定向，用于缓存控制。</strong></li>
</ul>
</li>
<li><code>4xx</code> :该类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。<ul>
<li><strong><code>400 Bad Request</code></strong>表示<strong>客户端请求的报文有错误，但只是个笼统的错误。</strong></li>
<li><strong>403 Forbidden</strong>表示<strong>服务器禁止访问资源</strong>，并不是客户端的请求出错。</li>
<li><strong>404 Not Found</strong>表示<strong>请求的资源在服务器上不存在或未找到，所以无法提供给客户端</strong>。</li>
</ul>
</li>
<li><code>5xx</code>:该 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于<strong>服务器端的错误码</strong>。<ul>
<li><strong><code>500 Internal Server Error</code></strong>与 400 类型，是个笼统通用的错误码，服务器发生了什么错误并不知道。</li>
<li><strong><code>501 Not Implemented</code></strong>表示<strong>客户端请求的功能还不支持</strong>，类似“即将开业，敬请期待”的意思。</li>
<li><strong><code>502 Bad Gateway</code></strong>通常是<strong>服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</strong></li>
<li><strong>503 Service Unavailable</strong>表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</li>
</ul>
</li>
</ul>
<h4 id="HTTP常用字段"><a href="#HTTP常用字段" class="headerlink" title="HTTP常用字段"></a><code>HTTP</code>常用字段</h4><ul>
<li><code>Host</code>：客户端发送请求时，用来指定服务器的域名<code>Host: www.A.com</code>。有了 <code>Host</code> 字段，就可以<strong>将请求发往[同一台]服务器上的不同网站。</strong></li>
<li><code>Connection</code>: 该字段最常用于<strong>客户端要求服务器使用 TCP 持久连接，以便其他请求复用</strong>。<code>HTTP/1.1</code> 版本的默认连接都是持久连接，但为了兼容老版本的 <code>HTTP</code>，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</li>
<li><code>Content-Length</code> :服务器在返回数据时，会有 <code>Content-Length</code> 字段<code>Content-Length: 1000</code>，<strong>表明本次回应的数据长度</strong>。</li>
<li><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次<strong>数据是什么格式</strong>.<code>eg.Content-Type: text/html; charset=utf-8</code>,该类型表明，发送的是网页，而且编码是<code>UTF-8</code>.<ul>
<li>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以<strong>接受哪些数据格式</strong>。<code>Accept: */*</code>表明客户端声明自己可以接受<strong>任何格式</strong>的数据。</li>
</ul>
</li>
<li><code>Content-Encoding</code> ：该字段说明<strong>数据的压缩方法</strong>。表示<strong>服务器返回的数据使用了什么压缩格式</strong>。<code>eg.Content-Encoding: gzip</code>表示服务器返回的数据采用了<code>gzip</code> 方式压缩，告知客户端需要用此方式解压。<ul>
<li>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。<code>eg.Accept-Encoding: gzip, deflate</code></li>
</ul>
</li>
</ul>
<h3 id="Get与Post"><a href="#Get与Post" class="headerlink" title="Get与Post"></a>Get与Post</h3><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><ul>
<li><code>Get</code> 方法的含义是请求<strong>从服务器获取资源</strong>，这个资源可以是静态的文本、页面、图片视频等</li>
<li>而<code>POST</code> 方法则是相反操作，它向 <code>URI</code> 指定的资源<strong>提交数据，数据就放在报文的 body 里。</strong></li>
</ul>
<h4 id="安全和幂等"><a href="#安全和幂等" class="headerlink" title="安全和幂等"></a>安全和幂等</h4><ul>
<li>在 HTTP 协议里，<strong>安全</strong>是指<strong>请求方法不会破坏服务器上的资源。</strong></li>
<li><strong>幂等意思是多次执行相同的操作，结果都是相同的</strong>。</li>
</ul>
<p>很明显 <strong>GET 方法就是安全且幂等的</strong>，因为它是<strong>只读操作，</strong>无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p>
<p><strong>POST</strong> 因为是新增或提交数据的操作，<strong>会修改服务器上的资源，所以是不安全的</strong>，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。</p>
<h3 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a><code>HTTP</code>特性</h3><h4 id="HTTP的优点"><a href="#HTTP的优点" class="headerlink" title="HTTP的优点"></a><code>HTTP</code>的优点</h4><ul>
<li>简单：基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong>，降低学习和使用的门槛。</li>
<li>灵活和易于扩展：各类请求方法、<code>URI/URL</code>、状态码、头字段等每个组成要求都没有被固定死，允许开发人员<strong>自定义和扩充</strong>。<code>HTTP</code>工作在应用层，则它<strong>下层可以随意变化</strong>。</li>
<li>应用广泛/跨平台：从台式机的浏览器到手机上的各种 <code>APP</code>，从看新闻、刷贴吧到购物、理财、游戏，<code>HTTP</code> 的应用无处不在，同时天然具有<strong>跨平台</strong>的优越性。</li>
</ul>
<h4 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h4><ul>
<li>无状态<ul>
<li>好处：服务器<strong>不会去记忆<code>HTTP</code> 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务</strong>。</li>
<li>坏处：服务器没有记忆能力，它<strong>在完成有关联性的操作时会非常麻烦</strong>。例如：网上购物过程中，登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，<strong>这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。</strong></li>
<li>解决办法：<strong><code>Cookie</code></strong> 技术。通过在请求和响应报文中写入<code>Cookie</code> 信息来<strong>控制客户端的状态</strong>。</li>
</ul>
</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/cc11fd84-388e-472d-a05e-f91386904e1e-11197877.jpg" alt="cookie"></p>
<ul>
<li>明文传输:虽然为调试等工作带来便利，但该传输方式相当于<strong>信息裸奔</strong>。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有账号密码信息，则可能出现账号被盗等情况。</li>
<li>不安全<ul>
<li>通信使用明文（不加密），内容可能会被窃听。比如，<strong>账号信息容易泄漏</strong></li>
<li>不验证通信方的身份，因此有可能遭遇伪装。比如，<strong>访问假的淘宝、拼多多。</strong></li>
<li>无法证明报文的完整性，所以有可能已遭篡改。比如，<strong>网页上植入垃圾广告</strong>。</li>
</ul>
</li>
</ul>
<h4 id="HTTP-1-1的性能"><a href="#HTTP-1-1的性能" class="headerlink" title="HTTP/1.1的性能"></a><code>HTTP/1.1</code>的性能</h4><p><code>HTTP</code> 协议基于 <strong><code>TCP/IP</code></strong>，并且使用了<strong>请求 - 应答</strong>的通信模式，所以性能的关键就在这里。</p>
<ul>
<li><p>长连接。早期 <code>HTTP/1.0</code> 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是<strong>串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。</strong>为了解决该 问题，<code>HTTP/1.1</code> 提出了<strong>长连接</strong>的通信方式，也叫<strong>持久连接</strong>。这种方式的好处在于<strong>减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载</strong>。</p>
<ul>
<li>持久连接的特点是，<strong>只要任意一端没有明确提出断开连接，则保持 TCP 连接状态</strong>。</li>
<li><img src="https://api2.mubu.com/v3/document_image/f8acb87d-85b4-463c-b2bc-a45eea496d8d-11197877.jpg" alt="长连接与短连接"></li>
</ul>
</li>
<li><p>管道网络传输：<code>HTTP/1.1</code> 采用了长连接的方式，这使得管道（<code>pipeline</code>）网络传输成为可能。即<strong>可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去</strong>，可以<strong>减少整体的响应时间。</strong>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。<strong>管道机制则是允许浏览器同时发出 A 请求和 B 请求。</strong></p>
</li>
<li>队头阻塞：但是服务器还是按照<strong>顺序</strong>，先回应 A 请求，完成后再回应 B 请求。<strong>要是前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞</strong>。</li>
</ul>
<h3 id="HTTPS与HTTP"><a href="#HTTPS与HTTP" class="headerlink" title="HTTPS与HTTP"></a><code>HTTPS</code>与<code>HTTP</code></h3><h4 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a><code>HTTP</code>与<code>HTTPS</code>的区别</h4><ul>
<li><p><code>HTTP</code> 是超文本传输协议，<strong>信息是明文传输</strong>，存在安全风险的问题。<code>HTTPS</code> 则解决 <code>HTTP</code> 不安全的缺陷，在 <code>TCP</code>和 <code>HTTP</code>网络层之间加入了<code>SSL/TLS</code> 安全协议，使得报文能够加密传输。</p>
</li>
<li><p><code>HTTP</code> 连接建立相对简单， <code>TCP</code> 三次握手之后便可进行 HTTP 的报文传输。而 <code>HTTPS</code> 在 <code>TC</code>P 三次握手之后，还需进行 <code>SSL/TLS</code> 的握手过程，才可进入加密报文传输。</p>
</li>
<li><p><code>HTTP</code> 的端口号是 80，<code>HTTPS</code> 的端口号是 443。</p>
</li>
<li><p><code>HTTPS</code> 协议需要向 <code>CA</code>（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
</li>
</ul>
<h4 id="HTTPS解决窃听、篡改、冒充采取的措施"><a href="#HTTPS解决窃听、篡改、冒充采取的措施" class="headerlink" title="HTTPS解决窃听、篡改、冒充采取的措施"></a><code>HTTPS</code>解决窃听、篡改、冒充采取的措施</h4><ul>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换会话秘钥，后续就不再使用非对称加密。（<strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，<strong>解决了密钥交换问题但速度慢</strong>）</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的会话秘钥的方式加密明文数据（<strong>对称加密</strong>只使用一个密钥，<strong>运算速度快，密钥必须保密</strong>，无法做到安全的密钥交换）</li>
</ul>
</li>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的”指纹”，<strong>指纹用于校验数据的完整性，解决了篡改的风险。</strong><ul>
<li>客户端在发送明文之前会通过摘要算法算出明文的指纹，发送的时候把指纹 + 明文一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的指纹和当前算出的指纹做比较，若指纹相同，说明数据是完整的。</li>
</ul>
</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。<ul>
<li>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</li>
<li>如何保证公钥不被篡改：需要借助第三方权威机构 <code>CA</code> （数字证书认证机构），将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</li>
<li><img src="https://api2.mubu.com/v3/document_image/fb816dbc-b6ff-4960-a516-20ebcc5f43c1-11197877.jpg" alt="CA"></li>
</ul>
</li>
</ul>
<h4 id="HTTPS建立的过程"><a href="#HTTPS建立的过程" class="headerlink" title="HTTPS建立的过程"></a><code>HTTPS</code>建立的过程</h4><ul>
<li>客户端向服务器<strong>索要并验证服务器的公钥</strong>。</li>
<li>双方协商<strong>产生会话秘钥</strong>。</li>
<li>双方采用会话秘钥进行加密通信。</li>
</ul>
<p>前两步也就是 <code>SL/TLS</code>的建立过程，也就是<strong>握手阶段</strong>。</p>
<p><img src="https://api2.mubu.com/v3/document_image/98e42ee4-6309-4ff2-9f50-9c3f3fcad5f4-11197877.jpg" alt="https握手过程"></p>
<p><code>SSL/TLS</code> 协议建立的详细流程：</p>
<p><em>1.ClientHello</em></p>
<p>首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。</p>
<p>在这一步，客户端主要向服务器发送以下信息：</p>
<ul>
<li><p>客户端支持的<code>SSL/TLS</code> 协议版本，如 TLS 1.2 版本。</p>
</li>
<li><p>客户端生产的随机数（<code>Client Random</code>），后面用于生产会话秘钥。</p>
</li>
<li><p>客户端支持的密码套件列表，如 <code>RSA</code>加密算法。</p>
</li>
</ul>
<p><em>2. SeverHello</em></p>
<p>服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code>。服务器回应的内容有如下内容：</p>
<ul>
<li><p>确认<code>SSL/ TLS</code> 协议版本，如果浏览器不支持，则关闭加密通信。</p>
</li>
<li><p>服务器生产的随机数（<code>Server Random</code>），后面用于生产会话秘钥。</p>
</li>
<li><p>确认的密码套件列表，如 <code>RSA</code> 加密算法。</p>
</li>
<li><p>服务器的数字证书。</p>
</li>
</ul>
<p><em>3.客户端回应</em></p>
<p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</p>
<ul>
<li><p>一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p>
</li>
<li><p>加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信。</p>
</li>
<li><p>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p>
</li>
</ul>
<p>上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，<strong>各自生成</strong>本次通信的会话秘钥。</p>
<p><em>4. 服务器的最后回应</em></p>
<p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的会话秘钥。然后，向客户端发生最后的信息：</p>
<ul>
<li><p>加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信。</p>
</li>
<li><p>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p>
</li>
</ul>
<p>至此，整个 <code>SSL/TLS</code> 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 <code>HTTP</code>协议，只不过用会话秘钥加密内容。</p>
<h3 id="HTTP-1-1、HTTP-2、HTTP-3演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3演变"></a><code>HTTP/1.1、HTTP/2、HTTP/3</code>演变</h3><p><code>HTTP/1.1</code> 相比 <code>HTTP/1.0</code>性能上的改进：</p>
<ul>
<li>使用 <strong><code>TCP</code> 长连接的方式改善了<code>HTTP/1.0</code> 短连接造成的性能开销。</strong></li>
<li>支持<strong>管道<code>（pipeline）</code>网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去</strong>，可以减少整体的响应时间。</li>
</ul>
<p>存在的性能瓶颈：</p>
<ul>
<li>请求 / 响应头部（Header）<strong>未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分</strong></li>
<li>发送冗长的首部。每次互相<strong>发送相同的首部造成的浪费较多</strong></li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong></li>
<li>没有请求<strong>优先级控制</strong></li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ul>
<h4 id="HTTP-2的优化"><a href="#HTTP-2的优化" class="headerlink" title="HTTP/2的优化"></a><code>HTTP/2</code>的优化</h4><p><code>HTTP/2</code>协议是基于 <code>HTTPS</code> 的，所以 <code>HTTP/2</code> 的安全性也是有保障的。</p>
<p>那 <code>HTTP/2</code> 相比 <code>HTTP/1.1</code> 性能上的改进：</p>
<p><em>1. 头部压缩</em></p>
<p><code>HTTP/2</code> 会<strong>压缩头</strong>（Header）,如果同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮助<strong>消除重复的部分</strong>。使用的是 <code>HPACK</code> 算法：<strong>在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号</strong>，这样就<strong>提高速度</strong>了。</p>
<p><em>2. 二进制格式</em></p>
<p><code>HTTP/2</code>不再像<code>HTTP/1.1</code>里的纯文本形式的报文，而是全面采用了<strong>二进制格式。</strong></p>
<p>头信息和数据体都是二进制，并且统称为<strong>帧（frame）</strong>：<strong>头信息帧和数据帧</strong>。</p>
<p>因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p>
<p><em>3. 数据流</em></p>
<p>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此<strong>，必须要对数据包做标记，指出它属于哪个回应。</strong></p>
<p>每个请求或回应的所有数据包，称为一个数据流（<code>Stream</code>）。</p>
<p><strong>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</strong></p>
<p>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p>
<p><em>4. 多路复用</em></p>
<p><code>HTTP/2</code>是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</p>
<p>移除了 <code>HTTP/1.1</code> 中的串行请求，不需要排队等待，也就不会再出现队头阻塞问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</p>
<p>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p>
<p><em>5. 服务器推送</em></p>
<p><code>HTTP/2</code>还在一定程度上改善了传统的请求 - 应答工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。</p>
<p>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 <code>JS、CSS</code> 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送（<code>Server Push，也叫 Cache Push</code>）。</p>
<h4 id="HTTP-2的缺陷"><a href="#HTTP-2的缺陷" class="headerlink" title="HTTP/2的缺陷"></a><code>HTTP/2</code>的缺陷</h4><p>多个<code>HTTP</code> 请求在复用一个 <code>TCP</code> 连接，下层的 <code>TCP</code> 协议是不知道有多少个 <code>HTTP</code> 请求的。</p>
<p>所以一旦发生了丢包现象，就会触发 <code>TCP</code> 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p>
<ul>
<li><code>HTTP/1.1</code> 中的管道（ <code>pipeline</code>）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li>
<li><code>HTTP/2</code> 多请求复用一个<code>TCP</code>连接，<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求。</strong></li>
</ul>
<p>这都是基于<code>TCP</code> 传输层的问题，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>
<p><code>UDP</code>是不可靠传输的，但基于 <code>UDP</code> 的 <strong><code>QUIC</code> 协议</strong> 可以实现类似 <code>TCP</code> 的可靠性传输。</p>
<ul>
<li><code>QUIC</code>有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li>
<li><code>TL3</code> 升级成了最新的 <code>1.3</code> 版本，头部压缩算法也升级成了 <code>QPack</code>。</li>
<li><code>HTTPS</code> 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 <code>TLS/1.3</code> 的三次握手。<code>QUIC</code> 直接把以往的 TCP 和 <code>TLS/1.3</code> 的 6 次交互<strong>合并成了 3 次，减少了交互次数</strong>。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/9232c5e0-77f8-475a-a969-7cc6e175dc53-11197877.jpg" alt="quic"></p>
<p>所以， <code>QUIC</code> 是一个在 <code>UDP</code> 之上的<strong>伪</strong> <code>TCP + TLS + HTTP/2</code> 的<strong>多路复用的协议。</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/17/%E4%BD%BF%E7%94%A8https%E8%AE%BF%E9%97%AE%E7%9A%84%E7%9A%84%E6%85%95%E5%B8%83%E6%89%98%E7%AE%A1%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/17/%E4%BD%BF%E7%94%A8https%E8%AE%BF%E9%97%AE%E7%9A%84%E7%9A%84%E6%85%95%E5%B8%83%E6%89%98%E7%AE%A1%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/" class="post-title-link" itemprop="url">使用带https访问的慕布托管博客图片</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-17 22:19:23" itemprop="dateCreated datePublished" datetime="2021-03-17T22:19:23+08:00">2021-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-21 08:59:57" itemprop="dateModified" datetime="2021-03-21T08:59:57+08:00">2021-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="使用带https访问的慕布托管博客图片"><a href="#使用带https访问的慕布托管博客图片" class="headerlink" title="使用带https访问的慕布托管博客图片"></a>使用带<code>https</code>访问的慕布托管博客图片</h3><p>之前博客 一直使用有道云笔记来保存图片，对于保存的每张图片都可以生成一个唯一的URL，但实际访问的时候提供的只是<code>http</code>的访问。浏览器的进步(Chrome为代表)使得<code>http</code>协议变得不安全，之前写的博客中的<code>http</code>访问的图片在浏览器中居然不能正常显示了(虽然火狐可以，但同步还是Chrome好用)，找了好久都没有找到合适的图片保存库。</p>
<p>今天意外发现<a href="https://mubu.com/app" target="_blank" rel="noopener">慕布</a>这款在线编辑软件可以给保存的图片一个带<code>https</code>的<code>URL</code>,从而满足了浏览器强制的<code>https</code>访问。遂将所有博客的图片更新了一下。</p>
<p>有需要的同学可根据需要注册使用<a href="https://mubu.com/app" target="_blank" rel="noopener">慕布</a>。图片保存到文件后进行共享，将共享的链接打开后右键可以获取图片的<code>https</code>地址，然后就可以在自己的博客中使用啦。(慕布还支持脑图以及markdown，其实还是挺好用的)。</p>
<p>关于<code>http</code>与<code>https</code>，后面写个博客来讲清楚吧(最近要写导师的本子，还有科研任务和找工作的事情，忙的有点混乱了)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/09/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/09/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA/" class="post-title-link" itemprop="url">使用来必力为博客添加评论</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-09 15:03:58" itemprop="dateCreated datePublished" datetime="2021-03-09T15:03:58+08:00">2021-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-17 21:46:43" itemprop="dateModified" datetime="2021-03-17T21:46:43+08:00">2021-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="使用来必力为博客添加评论"><a href="#使用来必力为博客添加评论" class="headerlink" title="使用来必力为博客添加评论"></a>使用来必力为博客添加评论</h3><p>之前搭建博客评论功能的时候使用的是gitalk, 但使用gitalk必须创建issue来进行评论，使用起来并不是很方便。</p>
<p>经过网上查找，发现了一款好用的第三方评论工具：<a href="https://www.livere.com" target="_blank" rel="noopener">livere(来必力)</a>。这款工具只需要注册并得到一个<code>livere_uid</code>值就可以在自己的网页上添加评论功能，登录后台管理还可以对评论进行管理。白嫖可真相！！！</p>
<p>现在说下主要步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">打开 https://livere.com/ 网站进行用户注册（注册的时候是韩文，可以有道或者百度翻译对应一下内容，其实也就是邮箱，名称和密码这几项），注册完成后选择【安装】，然后点击“现在安装”。</span><br><span class="line"> </span><br><span class="line">在“现在安装”页面填写相关的信息，然后获取授权ID码(主要需要填写自己的网站链接)</span><br><span class="line"></span><br><span class="line">获取到授权ID码之后会打开主题目录下的配置文件，修改“livere_uid”的值为授权ID码</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/5896a85d-afa6-4c9a-82ef-7f0483f4af72-11197877.jpg" alt="livere_uid获取"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在自己的博客主体目录下找到_config.yml文件(我的是~/blog/dongshifu/themes/next/_config.yml)然后找到livere_uid选项，将livere管理页面中的代码管理打开并找到data-uid，复制到livere_uid后面保存即可</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/2bf5527c-0f97-4ffe-a928-7571278ea275-11197877.jpg" alt="_config.yaml配置"></p>
<p>重新部署自己的网站到github就可以看到添加的评论功能了。(授权的时候可以用QQ,微信等方式，真的是很方便了)</p>
<p><img src="https://api2.mubu.com/v3/document_image/172a0a8f-3bf7-46e3-882f-29a2e8c288a3-11197877.jpg" alt="博客评论功能添加"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/08/git-1-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/08/git-1-md/" class="post-title-link" itemprop="url">设置git的用户名和邮箱</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-08 18:51:53" itemprop="dateCreated datePublished" datetime="2021-03-08T18:51:53+08:00">2021-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-09 10:52:32" itemprop="dateModified" datetime="2021-03-09T10:52:32+08:00">2021-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="设置git的用户名和邮箱"><a href="#设置git的用户名和邮箱" class="headerlink" title="设置git的用户名和邮箱"></a>设置git的用户名和邮箱</h3><p>一直在使用自己搭建的github.io来保存博客，虽然更新比较慢，也算是记录了自己的学习过程。</p>
<p>今天在使用的时候意外发现自己在git上的contribution一直没有，鉴于自己时不时会提交博客记录，遂发现不对，难道是git出错了？？明显是不可能的，经过查看，之前的大部分提交居然都是用实验室小伙伴的git帐号提交的。估计是之前小伙伴用我的电脑登录了他的git帐号吧，发现之后赶快改了一下git的帐号设置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[~/path/to/repo]$ git config user.name "dongsihfu"</span><br><span class="line">[~/path/to/repo]$ git config user.email 自己的git邮箱</span><br><span class="line">This change will only affect future commits. Past commits will retain the username and address they were committed with.</span><br><span class="line"></span><br><span class="line">设置好以后就用 ：git config --list 命令查看。</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/03/Go-channel-3channel%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/03/Go-channel-3channel%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">channel发送和接收数据的过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-03 20:03:09" itemprop="dateCreated datePublished" datetime="2021-01-03T20:03:09+08:00">2021-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 10:57:04" itemprop="dateModified" datetime="2021-04-08T10:57:04+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="channel发送和接收元素的本质"><a href="#channel发送和接收元素的本质" class="headerlink" title="channel发送和接收元素的本质"></a>channel发送和接收元素的本质</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">All transfer of value on the go channels happens with the copy of value.</span><br><span class="line">channel 的发送和接收操作本质上都是 “值的拷贝”，无论是从 sender goroutine 的栈到 chan buf，还是从 chan buf 到 receiver goroutine，或者是直接从 sender goroutine 到 receiver goroutine。</span><br></pre></td></tr></table></figure>
<p>举例分析：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = user&#123;name: <span class="string">"Ankur"</span>, age: <span class="number">25</span>&#125;</span><br><span class="line"><span class="keyword">var</span> g = &amp;u</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyUser</span><span class="params">(pu *user)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"modifyUser Received Vaule"</span>, pu)</span><br><span class="line">	pu.name = <span class="string">"Anand"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printUser</span><span class="params">(u &lt;-<span class="keyword">chan</span> *user)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"printUser goRoutine called"</span>, &lt;-u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> *user, <span class="number">5</span>)</span><br><span class="line">	c &lt;- g</span><br><span class="line">	fmt.Println(g)</span><br><span class="line">	<span class="comment">// modify g</span></span><br><span class="line">	g = &amp;user&#123;name: <span class="string">"Ankur Anand"</span>, age: <span class="number">100</span>&#125;</span><br><span class="line">	<span class="keyword">go</span> printUser(c)</span><br><span class="line">	<span class="keyword">go</span> modifyUser(g)</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Println(g)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">&amp;&#123;Ankur 25&#125;</span></span><br><span class="line"><span class="comment">modifyUser Received Vaule &amp;&#123;Ankur Anand 100&#125;</span></span><br><span class="line"><span class="comment">printUser goRoutine called &amp;&#123;Ankur 25&#125;</span></span><br><span class="line"><span class="comment">&amp;&#123;Anand 100&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>一开始构造一个结构体 u，地址是 0x56420，图中地址上方就是它的内容。接着把 <code>&amp;u</code> 赋值给指针 <code>g</code>，g 的地址是 0x565bb0，它的内容就是一个地址，指向 u。</p>
<p>main 程序里，先把 g 发送到 c，根据 <code>copy value</code> 的本质，进入到 chan buf 里的就是 <code>0x56420</code>，它是指针 g 的值（不是它指向的内容），所以打印从 channel 接收到的元素时，它就是 <code>&amp;{Ankur 25}</code>。因此，这里并不是将指针 g “发送” 到了 channel 里，只是拷贝它的值而已。</p>
<h3 id="向channel发送数据的过程"><a href="#向channel发送数据的过程" class="headerlink" title="向channel发送数据的过程"></a>向channel发送数据的过程</h3><p>发送操作最终转化为 <code>chansend</code> 函数，关注主流程(hchan源码分析见<a href="https://dongshifu.github.io/2021/01/02/Go-channel-2%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">channel底层实现原理</a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 src/runtime/chan.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果 channel 是 nil</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 不能阻塞，直接返回 false，表示未发送成功</span></span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当前 goroutine 被挂起</span></span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"chan send (nil chan)"</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略 debug 相关……</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于不阻塞的 send，快速检测失败场景</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：</span></span><br><span class="line">	<span class="comment">// 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine</span></span><br><span class="line">	<span class="comment">// 2. channel 是缓冲型的，但循环数组已经装满了元素</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">		(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 锁住 channel，并发安全</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 channel 关闭了</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="comment">// 直接 panic</span></span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果接收队列里有 goroutine，直接将要发送的数据拷贝到接收 goroutine</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于缓冲型的 channel，如果还有缓冲空间</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// qp 指向 buf 的 sendx 位置</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将数据从 ep 处拷贝到 qp</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		<span class="comment">// 发送游标值加 1</span></span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="comment">// 如果发送游标值等于容量值，游标值归 0</span></span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 缓冲区的元素数量加一</span></span><br><span class="line">		c.qcount++</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不需要阻塞，则直接返回错误</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// channel 满了，发送方会被阻塞。接下来会构造一个 sudog</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前 goroutine 的指针</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前 goroutine 进入发送等待队列</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前 goroutine 被挂起</span></span><br><span class="line">	goparkunlock(&amp;c.lock, <span class="string">"chan send"</span>, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从这里开始被唤醒了（channel 有机会可以发送了）</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 被唤醒后，channel 关闭了。坑爹啊，panic</span></span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 去掉 mysg 上绑定的 channel</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/02/Go-channel-2%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/Go-channel-2%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">channel的底层实现原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 19:06:50" itemprop="dateCreated datePublished" datetime="2021-01-02T19:06:50+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 10:56:49" itemprop="dateModified" datetime="2021-04-08T10:56:49+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>源码( go 1.9.2)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// chan 里元素数量</span></span><br><span class="line">	qcount   <span class="keyword">uint</span></span><br><span class="line">	<span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span></span><br><span class="line">	<span class="comment">// 指向底层循环数组的指针</span></span><br><span class="line">	<span class="comment">// 只针对有缓冲的 channel</span></span><br><span class="line">	buf      unsafe.Pointer</span><br><span class="line">	<span class="comment">// chan 中元素大小</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	<span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	<span class="comment">// chan 中元素类型</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	<span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	<span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	<span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	<span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保护 hchan 中所有字段</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重点字段"><a href="#重点字段" class="headerlink" title="重点字段"></a>重点字段</h4><ul>
<li><p><code>buf</code> <strong>指向底层循环数组</strong>，只有<strong>缓冲型</strong>的 channel 才有。</p>
</li>
<li><p><code>sendx</code>，<code>recvx</code> 均指向底层循环数组，表示<strong>当前可以发送和接收的元素位置索引值（相对于底层数组）</strong>。</p>
</li>
<li><p><code>sendq</code>，<code>recvq</code> 分别表示<strong>被阻塞的 goroutine</strong>，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。</p>
</li>
<li><p><code>waitq</code> 是 <code>sudog</code> 的一个<strong>双向链表</strong>，而 <code>sudog</code> 实际上是对 goroutine 的一个封装：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lock</code> 用来保证每个读 channel 或写 channel 的操作都是原子的。</li>
</ul>
<p>例如，创建一个容量为 6 的，元素为 int 型的 channel 数据结构如下 ：</p>
<p><img src="https://api2.mubu.com/v3/document_image/a8f442cb-91ec-4811-a781-42ffacce965b-11197877.jpg" alt="channel数据结构"></p>
<h3 id="channel的创建过程"><a href="#channel的创建过程" class="headerlink" title="channel的创建过程"></a>channel的创建过程</h3><p>通道有两个方向，发送和接收。理论上来说，可以创建一个只发送或只接收的通道，但是这种通道创建出来后，怎么使用呢？一个只能发的通道，怎么接收呢？同样，一个只能收的通道，如何向其发送数据呢？</p>
<p>一般而言，使用 <code>make</code> 创建一个能收能发的通道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲通道</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 有缓冲通道</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>创建 chan 的函数是 <code>makechan</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span></span><br></pre></td></tr></table></figure>
<p>从函数原型来看，<strong>创建的 chan 是一个指针。所以能在函数间直接传递 channel，而不用传递 channel 的指针。</strong></p>
<p>具体过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="keyword">uintptr</span>(-<span class="keyword">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略了检查 channel size，align 的代码</span></span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="comment">// 如果元素类型不含指针 或者 size 大小为 0（无缓冲类型）</span></span><br><span class="line">	<span class="comment">// 只进行一次内存分配</span></span><br><span class="line">	<span class="keyword">if</span> elem.kind&amp;kindNoPointers != <span class="number">0</span> || size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素</span></span><br><span class="line">		<span class="comment">// 只分配 "hchan 结构体大小 + 元素大小*个数" 的内存</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+<span class="keyword">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="comment">// 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct&#123;&#125;）</span></span><br><span class="line">		<span class="keyword">if</span> size &gt; <span class="number">0</span> &amp;&amp; elem.size != <span class="number">0</span> &#123;</span><br><span class="line">			c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// race detector uses this l是ocation for synchronization</span></span><br><span class="line">			<span class="comment">// Also prevents us from pointing beyond the allocation (see issue 9401).</span></span><br><span class="line">			<span class="comment">// 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处</span></span><br><span class="line">			<span class="comment">// 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct&#123;&#125;，也无影响</span></span><br><span class="line">			<span class="comment">// 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）</span></span><br><span class="line">			c.buf = unsafe.Pointer(c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 进行两次内存分配操作</span></span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = newarray(elem, <span class="keyword">int</span>(size))</span><br><span class="line">	&#125;</span><br><span class="line">	c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	<span class="comment">// 循环数组长度</span></span><br><span class="line">	c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 hchan 指针</span></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个 chan 后，<strong>内存在堆上分配</strong>，大概长这样：</p>
<p><img src="https://api2.mubu.com/v3/document_image/59aacc73-c65d-4b7c-a17d-d9f2144fc32d-11197877.jpg" alt="chan的内存分配情况"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/02/Go-channel_1%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/Go-channel_1%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">channel用法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 14:29:34" itemprop="dateCreated datePublished" datetime="2021-01-02T14:29:34+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-08 10:56:36" itemprop="dateModified" datetime="2021-04-08T10:56:36+08:00">2021-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>Go的并发依赖CSP模型，基于channel实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Do not communicate by sharing memory; instead, share memory by communicating.</span><br><span class="line">不要通过共享内存来通信，而要通过通信来实现内存共享。</span><br></pre></td></tr></table></figure>
<p>CSP 全称是 “Communicating Sequential Processes”，用于描述两个独立的并发实体通过共享 channel（管道）进行通信的并发模型。Go语言并没有完全实现了 CSP 并发模型的所有理论，仅仅是实现了 process 和 channel 这两个概念。process 就是Go语言中的 goroutine，每个 goroutine 之间是通过 channel 通讯来实现数据共享。</p>
<p>大多数的编程语言的并发编程模型是基于线程和内存同步访问控制，Go 的并发编程的模型则用 goroutine 和 channel 来替代。Goroutine 和线程类似，channel 和 mutex (用于内存同步访问控制)类似。</p>
<p>Go 的并发原则非常优秀，目标就是<strong>简单</strong>：尽量使用 channel；把 goroutine 当作免费的资源，随便用。</p>
<h3 id="操作channel的结果"><a href="#操作channel的结果" class="headerlink" title="操作channel的结果"></a>操作channel的结果</h3><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>nil channel</th>
<th>closed channel</th>
<th>not nil, not closed channel</th>
</tr>
</thead>
<tbody>
<tr>
<td>close</td>
<td>panic</td>
<td>panic</td>
<td>正常关闭</td>
</tr>
<tr>
<td>读 &lt;- ch</td>
<td>阻塞</td>
<td><strong>读到对应类型的零值</strong></td>
<td><strong>阻塞或正常读取数据</strong>。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞</td>
</tr>
<tr>
<td>写 ch &lt;-</td>
<td>阻塞</td>
<td>panic</td>
<td>阻塞或正常写入数据。非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞</td>
</tr>
</tbody>
</table>
</div>
<p>总结一下，<strong>发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。</strong></p>
<p>读、写一个 nil channel 都会被阻塞。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/21/mysql_2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/mysql_2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">mysql日志系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-21 21:29:27" itemprop="dateCreated datePublished" datetime="2020-12-21T21:29:27+08:00">2020-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-30 13:43:39" itemprop="dateModified" datetime="2021-03-30T13:43:39+08:00">2021-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h3><p>MySQL可以恢复到半个月内任意一秒的状态，这是怎样做到的？</p>
<p>考虑一条更新语句的执行流程？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>
<p>更新语句会与查询语句有很多相似地方(连接、缓存查询，分析等)，与查询流程不一样的是，<strong>更新流程还涉及两个重要的日志模块</strong>：<code>redo log</code>（重做日志）和 <code>binlog</code>（归档日志）。</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>在MySQL里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了WAL技术，<strong>WAL的全称是Write-Ahead Logging，它的关键点是先写日志，再写磁盘。</strong></p>
<p>具体来说，当有一条记录需要更新的时候，<strong>InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做</strong>。</p>
<p>InnoDB的<strong>redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作</strong>。<strong>从头开始写，写到末尾就又回到开头循环写，如下面这个图所示：</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/fa0cd9fa-4d34-4017-b30d-84b7b04d3c4f-11197877.jpg" alt="redo_log"></p>
<p>write pos是<strong>当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头</strong>。checkpoint是<strong>当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</strong></p>
<p>write pos和checkpoint之间的是还空着的部分（write pos后面以及checkpoint前面的部分），可以用来记录新的操作。<strong>如果write pos追上checkpoint，表示log满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下</strong>。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<p><code>innodb_flush_log_at_trx_commit</code>这个参数设置成1的时候，表示<strong>每次事务的redo log都直接持久化到磁盘</strong>。这个参数建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p><strong>redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</strong></p>
<p>会有两份日志？因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，<strong>binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</strong></p>
<p>两种日志的不同点：</p>
<ul>
<li><p>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</p>
</li>
<li><p>redo log是<strong>物理日志，记录的是“在某个数据页上做了什么修改”</strong>；binlog是<strong>逻辑日志，记录的是这个语句的原始逻辑</strong>，比如“给ID=2这一行的c字段加1 ”。</p>
</li>
<li><p>redo log是<strong>循环写</strong>的，<strong>空间固定会用完</strong>；binlog是<strong>可以追加写入</strong>的。“追加写”是指<strong>binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</strong>。</p>
</li>
</ul>
<p><code>sync_binlog</code>这个参数设置成1的时候，表示<strong>每次事务的binlog都持久化到磁盘。这个参数建议设置成1，这样可以保证MySQL异常重启之后binlog不丢失</strong>。</p>
<p>执行器和InnoDB引擎在执行一个简单的update(<code>update T set c=c+1 where ID=2</code>)语句时的内部流程：</p>
<ul>
<li><p>执行器先找引擎取ID=2这一行。ID是<strong>主键</strong>，引擎直接用<strong>树搜索</strong>找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li><p>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，<strong>得到新的一行数据，再调用引擎接口写入这行新数据。</strong></p>
</li>
<li><p>引擎将这行<strong>新数据更新到内存中，同时将这个更新操作记录到redo log里面</strong>，此时<strong>redo log处于prepare状态</strong>。然后告知执行器执行完成了，随时可以提交事务。</p>
</li>
<li><p><strong>执行器生成这个操作的binlog，并把binlog写入磁盘。</strong></p>
</li>
<li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成<strong>提交（commit）状态，更新完成。</strong></p>
</li>
</ul>
<p>将redo log的写入拆成了两个步骤：prepare和commit，这就是<strong>“两阶段提交”</strong>。</p>
<h4 id="redo-log的两阶段提交"><a href="#redo-log的两阶段提交" class="headerlink" title="redo log的两阶段提交"></a>redo log的两阶段提交</h4><p>两阶段提交的目的是<strong>为了让两份日志之间的逻辑一致</strong>。</p>
<p>反证法：</p>
<p>仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p>
<ul>
<li><p><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。前面说过，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后会发现，<strong>如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</strong></p>
</li>
<li><p><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，<strong>由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</strong></p>
</li>
</ul>
<p>可以看到，<strong>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</strong></p>
<p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，可以这么做：</p>
<ul>
<li>首先，<strong>找到最近的一次全量备份</strong>，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到<strong>临时库</strong>；</li>
<li>然后，<strong>从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</strong></li>
</ul>
<p>这样临时库就跟误删之前的线上库一样了，然后可以<strong>把表数据从临时库取出来，按需要恢复到线上库去。</strong>不只是误操作后需要用这个过程来恢复数据。当需要<strong>扩容</strong>的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用<strong>全量备份加上应用binlog来实现的</strong>，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p>
<p>简单说，<strong>redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/21/mysql_3%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/mysql_3%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/" class="post-title-link" itemprop="url">mysql事务</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-21 21:29:27" itemprop="dateCreated datePublished" datetime="2020-12-21T21:29:27+08:00">2020-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-30 13:43:38" itemprop="dateModified" datetime="2021-03-30T13:43:38+08:00">2021-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h3><p>转账场景：要给朋友小王转100块钱，而此时银行卡只有100块钱。转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，100块钱完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念。</p>
<p>简单来说，<strong>事务就是要保证一组数据库操作，要么全部成功，要么全部失败</strong>。在<strong>MySQL中，事务支持是在引擎层实现的</strong>。MySQL是一个支持多引擎的系统<strong>，但并不是所有的引擎都支持事务</strong>。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。</p>
<h3 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h3><p>事务的四要素:ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。本次主要学习隔离性。</p>
<p>当数据库上有多个事务同时执行的时候，就可能出现<a href="https://dongshifu.github.io/2020/12/17/mysql-4mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%94%81/" target="_blank" rel="noopener">脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</a>. 为了解决这些问题，就有了“隔离级别”的概念。</p>
<p><strong>隔离得越严实，效率就会越低</strong>。因此很多时候，我们都要在二者之间寻找一个<strong>平衡点</strong>。SQL标准的事务隔离级别包括：<strong>读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）</strong>。</p>
<ul>
<li>读未提交是指，<strong>一个事务还没提交时，它做的变更就能被别的事务看到</strong>。</li>
<li>读提交是指，一个事务<strong>提交之后，它做的变更才会被其他事务看到</strong>。</li>
<li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然<strong>在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</strong></li>
<li>串行化，顾名思义是<strong>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</strong></li>
</ul>
<p>举例说明事务的隔离性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://api2.mubu.com/v3/document_image/da798e7f-1080-480e-a530-6a73973f01dd-11197877.jpg" alt="事务的隔离性"></p>
<p>在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。</p>
<ul>
<li>若隔离级别是“读未提交”，<strong>事务B虽然还没有提交，但是结果已经被A看到</strong>了。v1 为2，v2为2，v3为2</li>
<li>若隔离级别是“读提交”，<strong>事务B的更新在提交后才能被A看到</strong>。v1为1，v2为2，v3为2</li>
<li>若隔离级别是“可重复读”，事务在执行期间看到的数据前后必须是一致的。v1为1，v2为1，v3为2</li>
<li>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</li>
</ul>
<p>在实现上，数据库里面会创建一个<strong>视图</strong>，<strong>访问的时候以视图的逻辑结果为准</strong>。在<strong>“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</strong></p>
<p>在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，一定要记得将MySQL的隔离级别设置为“读提交”。</p>
<h4 id="配置隔离级别"><a href="#配置隔离级别" class="headerlink" title="配置隔离级别"></a>配置隔离级别</h4><p>配置的方式是，将启动参数<code>transaction-isolation</code>的值设置成<code>READ-COMMITTED</code>。你可以用<code>show variables</code>来查看当前的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'transaction_isolation';</span><br><span class="line">或 <span class="keyword">select</span> @@tx_isolation;</span><br><span class="line">mysql&gt;  set global transaction_isolation=0; -- 读未提交</span><br><span class="line">mysql&gt;  set global transaction_isolation=1; -- 读提交</span><br><span class="line">mysql&gt;  set global transaction_isolation=2; -- 可重复读</span><br><span class="line">mysql&gt;  set global transaction_isolation=3; -- 串行化</span><br><span class="line"><span class="keyword">set</span> [glogal|<span class="keyword">session</span>] <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> 隔离级别名称;</span><br></pre></td></tr></table></figure>
<p><strong>需要“可重复读”的场景</strong>：假设在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响校对结果。这时候使用“可重复读”隔离级别就很方便。<strong>事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</strong></p>
<h4 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h4><p>展开说明“可重复读”事务隔离的具体实现：</p>
<p>在MySQL中，实际上每条记录在<strong>更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值</strong>。假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录：</p>
<p><img src="https://api2.mubu.com/v3/document_image/e3437af8-6bab-4bcb-aa8a-6b603f4d1596-11197877.jpg" alt="回滚记录"></p>
<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，<strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong>。对于read-view A，要得到1，就<strong>必须将当前值依次执行图中所有的回滚操作得到</strong>。另外，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p>
<p><strong>回滚日志总不能一直保留，什么时候删除</strong>呢？答案是，<strong>在不需要的时候才删除</strong>。也就是说，<strong>系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除</strong>。</p>
<p>什么时候不需要？就是<strong>当系统里没有比这个回滚日志更早的read-view的时候。</strong></p>
<h4 id="为什么建议尽量不要使用长事务"><a href="#为什么建议尽量不要使用长事务" class="headerlink" title="为什么建议尽量不要使用长事务"></a>为什么建议尽量不要使用长事务</h4><p>长事务意味着系统里面会<strong>存在很老的事务视图</strong>。由于<strong>这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</strong></p>
<p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，<strong>即使长事务最终提交，回滚段被清理，文件也不会变小。若回滚段太大，最终只好为了清理回滚段，重建整个库。</strong> <strong>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库</strong></p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>MySQL的事务启动方式有以下几种：</p>
<ul>
<li><p>显式启动事务语句， <code>begin</code> 或 <code>start transaction</code>。配套的提交语句是<code>commit</code>，回滚语句是<code>rollback</code>。</p>
</li>
<li><p><code>set autocommit=0</code>，这个命令<strong>会将这个线程的自动提交关掉。意味着如果只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到主动执行commit 或 rollback 语句，或者断开连接。</strong></p>
</li>
</ul>
<p>有些客户端连接框架会默认连接成功后先执行一个<code>set autocommit=0</code>的命令。这就<strong>导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</strong></p>
<p>因此<strong>，建议总是使用<code>set autocommit=1</code>, 通过显式语句的方式来启动事务。</strong></p>
<p>对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果也有这个顾虑，建议使用commit work and chain语法: <strong>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</strong></p>
<p>可以在information_schema库的<code>innodb_trx</code>表中<strong>查询长事务</strong>，比如下面这个语句，用于查找持续时间超过60s的事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure>
<h4 id="如何避免长事务对业务的影响？"><a href="#如何避免长事务对业务的影响？" class="headerlink" title="如何避免长事务对业务的影响？"></a>如何避免长事务对业务的影响？</h4><p>从应用开发端和数据库端来看。</p>
<p><strong>首先，从应用开发端来看：</strong></p>
<ul>
<li><p>确认是否使用了set autocommit=0。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的<strong>目标就是把它改成1。</strong></p>
</li>
<li><p>确认是否有<strong>不必要的只读事务</strong>。有些框架会习惯不管什么语句先用begin/commit框起来。我见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务可以去掉。</p>
</li>
<li><p>业务连接数据库的时候，根据业务本身的预估，通过<code>SET MAX_EXECUTION_TIME</code>命令，来<strong>控制每个语句执行的最长时间，避免单个语句意外执行太长时间</strong>。</p>
</li>
</ul>
<p><strong>其次，从数据库端来看：</strong></p>
<ul>
<li><p>监控 <code>information_schema.Innodb_trx</code>表，<strong>设置长事务阈值，超过就报警/或者kill；</strong></p>
</li>
<li><p>Percona的pt-kill这个工具不错，推荐使用；</p>
</li>
<li><p>在业务功能测试阶段要求输出所有的general_log，<strong>分析日志行为提前发现问题</strong>；</p>
</li>
<li><p>如果使用的是MySQL 5.6或者更新版本，把<code>innodb_undo_tablespaces</code>设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/20/mysql-5mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-mvcc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/20/mysql-5mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-mvcc/" class="post-title-link" itemprop="url">mysql性能优化-mvcc</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-20 17:02:01" itemprop="dateCreated datePublished" datetime="2020-12-20T17:02:01+08:00">2020-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-17 21:34:36" itemprop="dateModified" datetime="2021-03-17T21:34:36+08:00">2021-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>实验1:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> autocommit=<span class="keyword">off</span>;  </span><br><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> lastUpdate=<span class="keyword">now</span>() <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">--在未做commit/rollback操作之前  </span></span><br><span class="line"><span class="comment">--在其他的事务能不能进行对应数据的查询(特别是加上了X锁的数据)  </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">1</span>; </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>实验2:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> lastUpdate=<span class="keyword">now</span>() <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>两个实验从结果上来看是一致的，底层实现是一样的吗？跟MVCC有什么关系？ </p>
<h4 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC"></a>MVCC</h4><p>multiversion concurrency control （多版本并发控制）：并发访问(读或写)数据库时,对正在事务内处理的数据做多版本的管理。达到避免写操作的堵塞，从而引发读操作的并发问题。</p>
<p>MVCC插入逻辑流程 ：</p>
<p><img src="https://api2.mubu.com/v3/document_image/de8de1d3-76d7-4062-bbcd-82146470f0be-11197877.jpg" alt="MVCC插入逻辑流程"></p>
<p>MVCC删除逻辑流程：</p>
<p><img src="https://api2.mubu.com/v3/document_image/8e3f45d4-6284-44e3-a785-09c59fdeb861-11197877.jpg" alt="MVCC删除逻辑流程"></p>
<p>MVCC修改逻辑流程：</p>
<p><img src="https://api2.mubu.com/v3/document_image/d80ca7d4-6d88-495a-a294-2cf1e6d1d949-11197877.jpg" alt="MVCC修改逻辑流程"></p>
<p>MVCC查询逻辑流程:</p>
<p><img src="https://api2.mubu.com/v3/document_image/6bfce1c3-7ec8-4023-ad62-e14a1689f4e2-11197877.jpg" alt="MVCC查询逻辑流程"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShifuDong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShifuDong</p>
  <div class="site-description" itemprop="description">记录生活， 记录学习， 分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/mailto:sfd_w@foxmail.com" title="E-Mail → mailto:sfd_w@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShifuDong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  



    </div>
</body>
</html>
