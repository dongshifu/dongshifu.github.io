<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ShifuDong" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="信号基本概念及机制信号的共性:  简单 不能携带大量信息 满足特性条件才能发送  特质：A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行去处理信号，处理完毕之后再继续执行。与硬件中断类似——异步模式。但信号是软件层面上的实现的中断，早期被称为”软中断”。 信号的特质：由于信号通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟">
<meta name="keywords" content="linux">
<meta property="og:type" content="article">
<meta property="og:title" content="linux系统-信号">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;03&#x2F;28&#x2F;linux-%E7%B3%BB%E7%BB%9F-08%E4%BF%A1%E5%8F%B7&#x2F;index.html">
<meta property="og:site_name" content="ShifuDong">
<meta property="og:description" content="信号基本概念及机制信号的共性:  简单 不能携带大量信息 满足特性条件才能发送  特质：A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行去处理信号，处理完毕之后再继续执行。与硬件中断类似——异步模式。但信号是软件层面上的实现的中断，早期被称为”软中断”。 信号的特质：由于信号通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;59beec01-cbf6-47bc-b417-05caf5134bab-11197877.jpg">
<meta property="og:updated_time" content="2021-03-26T07:33:59.566Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;59beec01-cbf6-47bc-b417-05caf5134bab-11197877.jpg">

<link rel="canonical" href="http://yoursite.com/2020/03/28/linux-%E7%B3%BB%E7%BB%9F-08%E4%BF%A1%E5%8F%B7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>linux系统-信号 | ShifuDong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShifuDong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Knowledge Sharing</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/28/linux-%E7%B3%BB%E7%BB%9F-08%E4%BF%A1%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux系统-信号
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-28 16:54:01" itemprop="dateCreated datePublished" datetime="2020-03-28T16:54:01+08:00">2020-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-26 15:33:59" itemprop="dateModified" datetime="2021-03-26T15:33:59+08:00">2021-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统编程</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="基本概念及机制"><a href="#基本概念及机制" class="headerlink" title="基本概念及机制"></a>基本概念及机制</h4><p>信号的共性:</p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足特性条件才能发送</li>
</ul>
<p>特质：A给B发送信号，B收到信号之前执行自己的代码，<strong>收到信号后，不管执行到程序的什么位置，都要暂停运行去处理信号，处理完毕之后再继续执行。</strong>与硬件中断类似——异步模式。但信号是软件层面上的实现的中断，早期被称为”软中断”。</p>
<p>信号的特质：由于<strong>信号通过软件方法实现，其实现手段导致信号有很强的延时性</strong>。但对于用户来说，这个延迟时间非常短，不易察觉。</p>
<p><strong>所有信号的产生和处理, 都是由内核完成的</strong>。</p>
<h4 id="与信号相关的事件和状态"><a href="#与信号相关的事件和状态" class="headerlink" title="与信号相关的事件和状态"></a>与信号相关的事件和状态</h4><p>产生信号:</p>
<ul>
<li><p><strong>按键</strong>产生:<code>Ctrl+c, Ctrl+z, Ctrl+\</code></p>
</li>
<li><p><strong>系统调用</strong>产生:<code>kill, raise, abort</code></p>
</li>
<li><p><strong>软件条件产生</strong>:定时器<code>alarm</code></p>
</li>
<li><p><strong>硬件异常</strong>产生:非法访问内存(段错误), 除0(浮点数例外), 内存对齐错误(总线错误);</p>
</li>
<li><p><strong>命令</strong>产生:<code>kill</code>命令</p>
</li>
</ul>
<p>递达: 内核发出的信号<strong>递送并且到达</strong>进程</p>
<p>未决: 产生和递达之间的状态, 主要由于<strong>阻塞(屏蔽)导致该状态</strong></p>
<p>信号的处理方式:</p>
<ul>
<li><p>执行<strong>默认动作</strong></p>
</li>
<li><p><strong>丢弃</strong>(忽略)</p>
</li>
<li><p><strong>捕捉</strong>(调用户处理函数)</p>
</li>
</ul>
<h4 id="信号屏蔽字和未决信号集"><a href="#信号屏蔽字和未决信号集" class="headerlink" title="信号屏蔽字和未决信号集"></a>信号屏蔽字和未决信号集</h4><p>Linux内核的进程控制块PCB是一个结构体，<code>task_struct</code>除了包含进程<code>id</code>，状态，工作目录，用户<code>id</code>，组<code>id</code>，文件描述符，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。</p>
<p>阻塞态：用<strong>阻塞信号集（信号屏蔽字）</strong>来描述</p>
<p><code>PCB</code>中<strong>阻塞信号集影响未决信号集</strong></p>
<p>阻塞信号集（信号屏蔽字）<strong>：将某些信号加入集合，对他们设置屏蔽，当屏蔽<code>x</code>信号后，再收到该信号，该信号的处理将推后（解除屏蔽字后）</strong></p>
<p>未决信号集：</p>
<ul>
<li>信号产生，<strong>未决信号集中描述该信号的位立刻翻转为1,表示信号处于未决状态，当信号被处理后，对应位翻转回为0，</strong>这一时刻往往非常短暂。</li>
<li><strong>信号产生后由于某些原因（主要是阻塞）不能抵达</strong>。这类信号的集合称为未决信号集。在屏蔽解除前，信号一直处于未决状态。</li>
</ul>
<h4 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h4><ul>
<li><p>编号：信号有自己的编号，不存在为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号）。34-64为实时信号，驱动编程与硬件相关，名字上区别不大。而前32个名字各不相同。</p>
</li>
<li><p>名称</p>
</li>
<li><p>事件</p>
</li>
<li><p>默认处理动作</p>
<ul>
<li>Term：终止进程</li>
<li>Ign：<strong>忽略</strong>信号（默认即时对该种信号忽略操作）</li>
<li>Core：<strong>终止</strong>进程，生成Core文件（查验进程死亡原因，用于gdb调试）</li>
<li>Stop：停止（<strong>暂停</strong>）进程</li>
<li>Cont：<strong>继续运行</strong>进程</li>
</ul>
</li>
</ul>
<p><code>man 7 signal</code>可以查看帮助文档</p>
<p><strong>特别强调：9)SIGKILL和19)SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其其设置为阻塞。</strong></p>
<p>只有每个信号所对应的事件发生了, 该信号才会被递送(但不一定递达), 不应该乱发信号</p>
<h4 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h4><p>给指定进程发送指定信号（不一定杀死）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;<span class="comment">//成功：0， 失败：-1（ID非法，普通用户杀init进程等权级问题），设置errno</span></span><br><span class="line"><span class="comment">//sig:不推荐使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致</span></span><br><span class="line"><span class="comment">//pid &gt;0; //发送信号给指定的进程</span></span><br><span class="line"><span class="comment">//pid = 0; //发送信号给与调用kill函数进程属于同一进程组的所有进程</span></span><br><span class="line"><span class="comment">//pid &lt; 0;//取|pid|发给对应进程组:kill -9 -10698 :杀死10698进程组的所有进程;</span></span><br><span class="line"><span class="comment">//pid = -1;//发送给进程有权限发送的系统中所有进程</span></span><br></pre></td></tr></table></figure>
<p>进程组：每个进程都属于一个进程组，<strong>进程组是一个或多个进程集合，它们互相关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组<code>ID</code>与进程组长<code>ID</code>相同。</strong></p>
<p>权限保护：<strong><code>super</code>用户（<code>root</code>）可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。<code>kill -9</code> (<code>root</code>用户的<code>pid</code>)是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。只能向自己创建的进程发送信号，普通用户基本规则是：发送者实际或有效用户<code>ID == 接收者实际或有效用户ID</code>。</strong></p>
<h4 id="raise和abort函数"><a href="#raise和abort函数" class="headerlink" title="raise和abort函数"></a>raise和abort函数</h4><p><code>raise</code>函数：给当前进程发送指定信号（自己给自己发）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">raise(signo) == kill(getpid(), signo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;<span class="comment">//成功：0</span></span><br></pre></td></tr></table></figure>
<p><code>abort</code>函数：给自己发送异常终止信号。<code>SIGABRT</code>信号，终止并产生core文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//该函数无返回</span></span><br></pre></td></tr></table></figure>
<h4 id="软件条件产生信号（定时产生信号）"><a href="#软件条件产生信号（定时产生信号）" class="headerlink" title="软件条件产生信号（定时产生信号）"></a>软件条件产生信号（定时产生信号）</h4><p><code>alarm</code>函数：设置定时器（闹钟），在指定<code>seconds</code>后，内核会给当前进程发送<code>14)SIGALRM</code>信号。<strong>进程收到该信号，默认动作终止</strong>。</p>
<p><strong>每个进程都有且只有唯一个定时器。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;<span class="comment">//返回0或剩余的秒数，无失败</span></span><br></pre></td></tr></table></figure>
<p>常用：取消定时器<code>alarm(0)</code>,返回旧闹钟余下秒数</p>
<p><strong>定时，与进程无关（自然定时法）！无论进程处于何种状态（就绪、运行、挂起、终止、僵尸…)，<code>alarm</code>都计时</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试一秒钟数多少个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用time命令测试程序运行时间</span></span><br><span class="line"><span class="comment">//real    0m1.003s</span></span><br><span class="line"><span class="comment">//user    0m0.074s</span></span><br><span class="line"><span class="comment">//sys     0m0.217s</span></span><br></pre></td></tr></table></figure>
<p><code>time ./alarm</code>可以统计<code>alarm</code>的运算时间。</p>
<p>使用<code>time</code>命令查看程序执行的时间。<strong>程序运行的瓶颈在<code>IO</code>，优化程序，首先优化<code>IO</code></strong></p>
<p><strong>实际执行时间 = 系统时间+用户时间+等待时间</strong></p>
<p><code>setitimer</code>函数：<strong>设置定时器（闹钟），可以替代<code>alarm</code>函数，精度微秒<code>（us）</code>，可以实现周期定时</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getitimer</span><span class="params">(<span class="keyword">int</span> which, struct itimerval *curr_value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">const</span> struct itimerval *new_value, struct itimerval *old_value)</span></span>;</span><br><span class="line"><span class="comment">//参数which:指定定时方式。</span></span><br><span class="line"><span class="comment">//自然定时：ITIMER_REAL:14) SIGLARM 计算自然定时</span></span><br><span class="line"><span class="comment">//虚拟空间计时（用户空间，只计算进程占用CPU的时间）：ITIMER_VIRTUAL 26) SIGVIRTUAL 只计算进程占用cpu时间</span></span><br><span class="line"><span class="comment">//运行时计时（用户+内核）： ITIMER_PROF 27)SIGPROF 计算cpu及执行系统调用的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*精确到us的时间结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="keyword">time_t</span>	tv_sec;        		 <span class="comment">/* seconds */</span></span><br><span class="line">	<span class="keyword">suseconds_t</span>	tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><p><code>it_interva</code>l :用来设定<strong>两次定时任务之间间隔的时间</strong></p>
</li>
<li><p><code>it_value</code>:<strong>定时的时长</strong></p>
</li>
<li><p>两个参数都设置为0,即清0操作</p>
</li>
</ul>
<p>signal捕捉信号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*信号捕捉回调函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello signal\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*it为传入参数,进行初始化*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">    <span class="comment">//信号捕捉函数是一个回调函数</span></span><br><span class="line">    signal(SIGALRM, myfun);<span class="comment">//注册SIGALRM信号的捕捉处理函数，捕捉由内核完成</span></span><br><span class="line"></span><br><span class="line">    it.it_value.tv_sec = <span class="number">5</span>;</span><br><span class="line">    it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    it.it_interval.tv_sec = <span class="number">3</span>;</span><br><span class="line">    it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(setitimer(ITIMER_REAL,&amp;it, &amp;oldit) == <span class="number">-1</span>) <span class="comment">//自然定时</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"settimer error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*手动让程序阻塞*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h3><p>内核通过<strong>读取未决信号集来判断信号是否应该被处理，信号屏蔽字<code>mask</code>可以影响未决信集</strong>。可以在应用程序中<strong>自定义<code>set</code>来改变<code>mask</code>以达到屏蔽指定信号的目的。</strong></p>
<h4 id="操作信号集的若干步骤"><a href="#操作信号集的若干步骤" class="headerlink" title="操作信号集的若干步骤"></a>操作信号集的若干步骤</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建一个自定义信号集*/</span></span><br><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"><span class="comment">/*清空自定义信号集*/</span></span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">/*向自定义信号集添加信号*/</span></span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"><span class="comment">/*用自定义信号集操作内核信号集*/</span></span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">/*查看未决信号集*/</span></span><br><span class="line">sigpending(&amp;myset);</span><br></pre></td></tr></table></figure>
<h4 id="信号集设定"><a href="#信号集设定" class="headerlink" title="信号集设定"></a>信号集设定</h4><p><code>sigset_t</code> 类型的本质是<strong>位图</strong>。但不应该直接使用位操作，而应该使用下列函数，<strong>保证跨系统操作有效</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>; <span class="comment">//typedef unsigned long sigset_t</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//将某个信号集清0,成功0,失败-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//将某个信号集置1, 成功0,失败-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;<span class="comment">//将某个信号加入信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;<span class="comment">//将某个信号清出信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;<span class="comment">//判断某个信号是否在信号集中，返回值：在集合：1,不在集合：0</span></span><br></pre></td></tr></table></figure>
<h4 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h4><p>用来<strong>屏蔽信号、解除屏蔽</strong>也使用该函数。其<strong>本质为读取或修改进程的信号屏蔽字(<code>PCB</code>中).</strong></p>
<p>注意：<strong>屏蔽信号只是将信号处理延后执行（延至解除屏蔽），而忽略表示将信号丢弃处理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> sigset *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;<span class="comment">//成功，0,失败-1,设置errno</span></span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//how参数取值：假设当前的信号屏蔽字为mask</span></span><br><span class="line"><span class="comment">//1.SIG_BLOCK:当how设置为此值，set表示需要屏蔽的信号。相当于mask = mask|set(设置阻塞, set表示需要屏蔽的信号)</span></span><br><span class="line"><span class="comment">//2.SIG_UNBLOCK:当how设置为此值，set表示需要解除屏蔽的信号，相当于mask = mask&amp;~set(设置非阻塞, set表示需要解除屏蔽的信号;)</span></span><br><span class="line"><span class="comment">//3.SIG_SETMASK:set表示用于替代原始屏蔽集的新屏蔽集：相当于mask = set。若调用sigprocmask解除了对当前若干个信号的阻塞。则在sigprocmask返回前，至少将其中一个信号递达。(用set替换原始屏蔽集)</span></span><br><span class="line"><span class="comment">//set：传入参数，是一个位图，set中哪个位置为1,就表示当前进程屏蔽哪个信号</span></span><br><span class="line"><span class="comment">//oldset:传出参数，保留旧的信号屏蔽集</span></span><br></pre></td></tr></table></figure>
<h4 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h4><p><strong>读取当前进程的未决信号集</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(sigset *<span class="built_in">set</span>)</span> </span>;<span class="comment">//set传出参数。</span></span><br><span class="line"><span class="comment">//返回：成功:0，失败-1,设置errno</span></span><br></pre></td></tr></table></figure>
<p>打印未决信号集：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printped</span><span class="params">(<span class="keyword">sigset_t</span> *ped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;<span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sigismember(ped,i) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> myset, ped, oldset; <span class="comment">//自定义集合类型</span></span><br><span class="line">    sigemptyset(&amp;myset);	<span class="comment">/*清空自定义信号集*/</span></span><br><span class="line">    sigaddset(&amp;myset,SIGQUIT);<span class="comment">/*向自定义信号集添加信号*/</span></span><br><span class="line">    sigaddset(&amp;myset,SIGINT); <span class="comment">//程序终止信号，通常Ctrl+c</span></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;myset, &amp;oldset);<span class="comment">/*用自定义信号集操作内核信号集*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sigpending(&amp;ped);</span><br><span class="line">        printped(&amp;ped);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简易信号捕捉"><a href="#简易信号捕捉" class="headerlink" title="简易信号捕捉"></a>简易信号捕捉</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catchsigint</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------catch\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sighandler_t</span> handler;</span><br><span class="line">    handler = signal(SIGINT,catchsigint);</span><br><span class="line">    <span class="keyword">if</span>(handler == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"signal error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sigaction函数注册捕捉"><a href="#sigaction函数注册捕捉" class="headerlink" title="sigaction函数注册捕捉"></a>sigaction函数注册捕捉</h4><p><strong>sigaction函数的功能是检查或修改与指定信号相关联的处理动作（可同时两种操作）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction* act, struct sigaction* oldact)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);	<span class="comment">//不用</span></span><br><span class="line">	<span class="keyword">sigset_t</span>   sa_mask;		<span class="comment">//只工作于信号捕捉函数执行期间,相当于中断屏蔽</span></span><br><span class="line">	<span class="keyword">int</span>        sa_flags;	<span class="comment">//本信号默认屏蔽</span></span><br><span class="line">	<span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);			<span class="comment">//废弃</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">docatch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d signal is catched\n"</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = docatch;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaddset(&amp;act.sa_mask,SIGQUIT);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;<span class="comment">//默认属性，信号捕捉函数执行期间自动屏蔽本信号</span></span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGINT,&amp;act,<span class="literal">NULL</span>); <span class="comment">//程序终止信号</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a>信号捕捉特性</h4><ul>
<li><p>进程正常运行时，默认<strong>PCB中有一个信号屏蔽字</strong>，假定为<code>x</code>，它<strong>决定了进程自动屏蔽哪些信号</strong>。当注册了某个信号捕捉函数，捕捉到该信号之后，要调用该函数。而该函数有可能执行很长时间，<strong>在这期间所屏蔽的信号不能由<code>x</code>来指定。而是用<code>sa_mask</code>来指定。调用完信号处理函数，再次恢复为<code>x</code></strong>(<strong>捕捉函数执行期间, 信号屏蔽字由<code>mask</code>变为<code>sigaction</code>结构体中的<code>sa_mask</code>, 捕捉函数执行结束后, 恢复回<code>mask</code></strong>)。</p>
</li>
<li><p><code>xxx</code>信号捕捉函数执行期间，<code>xxx</code>信号自动被屏蔽(捕捉函数执行期间, 本信号自动被屏蔽(<code>sa_flags=0</code>);)</p>
</li>
<li>阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）(<strong>捕捉函数执行期间, 若被屏蔽信号多次发送, 解除屏蔽后只响应一次</strong>)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">docatch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d signal is catched\n"</span>,signo);</span><br><span class="line">    sleep(<span class="number">10</span>); <span class="comment">//模拟信号捕捉函数执行时间很长</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"finish\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = docatch;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaddset(&amp;act.sa_mask,SIGQUIT);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;<span class="comment">//默认属性，信号捕捉函数执行期间自动屏蔽本信号</span></span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGINT,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内核实现信号捕捉过程："><a href="#内核实现信号捕捉过程：" class="headerlink" title="内核实现信号捕捉过程："></a>内核实现信号捕捉过程：</h4><p><img src="https://api2.mubu.com/v3/document_image/59beec01-cbf6-47bc-b417-05caf5134bab-11197877.jpg" alt="signal_catch"></p>
<p>为什么执行完信号处理函数后要再次进入内核?<strong>因为信号处理函数是内核调用的, 函数执行完毕后要返回给调用者。</strong></p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><h4 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a>pause函数</h4><p>调用该函数可以<strong>造成进程主动挂起，等待信号唤醒</strong>。<strong>调用该系统调用的进程将处于阻塞状态（主动放弃<code>cpu</code>）直到信号递达将其唤醒。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span> </span>;<span class="comment">//返回值：-1并设置errno为EINTR</span></span><br><span class="line"><span class="comment">/*返回值：</span></span><br><span class="line"><span class="comment">如果信号的默认处理动作为终止进程，则进程终止，pause函数没有机会返回</span></span><br><span class="line"><span class="comment">如果信号的默认处理动作是忽略，进程继续处于挂起状态，pause函数不返回</span></span><br><span class="line"><span class="comment">如果信号的处理动作是捕捉，则调用完信号处理函数后，pause返回-1。errno设置为EINTR，表示信号被中断</span></span><br><span class="line"><span class="comment">pause收到的信号不能被屏蔽，如果被屏蔽，那么puase就不能被唤醒</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>使用<code>pause</code>和<code>alarm</code>来实现<code>sleep</code>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_sigalrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"catched\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    act.sa_handler = catch_sigalrm;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGALRM,&amp;act,&amp;oldact);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(seconds);</span><br><span class="line">    ret = pause();<span class="comment">//主动挂起，等待信号</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pause success\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = alarm(<span class="number">0</span>);<span class="comment">//闹钟清0</span></span><br><span class="line">    sigaction(SIGALRM,&amp;oldact,<span class="literal">NULL</span>);<span class="comment">//恢复SIGALRM信号旧有的处理方式</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mysleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----------\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时序竞态"><a href="#时序竞态" class="headerlink" title="时序竞态"></a>时序竞态</h4><p>时序问题分析：</p>
<p>借助<code>pause</code>和<code>alarm</code>实现的<code>mysleep</code>函数，设想如下时序：</p>
<ul>
<li>注册<code>SIGALRM</code>信号处理函数（<code>sigaction...</code>）</li>
<li>调用<code>alarm(1)</code>函数设定闹钟1秒</li>
<li>函数调用刚结束，开始倒计时1秒，当前进程失去cpu，内核调度优先级高的进程（多个）取代当前进程，当前进程无法获得cpu，进入<strong>就绪态等待cpu</strong></li>
<li><strong>1秒后，闹钟超时，内核向当前进程发送<code>SIGALARM</code>信号（自然定时法，与进程状态无关），高优先级进程尚未执行完，当前进程仍处于就绪态，信号无法处理(未决)</strong></li>
<li>优先级高的进程执行完，当前进程获得cpu资源，内核调度回当前进程执行。<code>SIGALRM</code>信号递达，信号设置捕捉，执行处理函数<code>catch_sigalrm</code></li>
<li><strong>信号处理函数执行结束，返回当前进程主控流程，<code>pause()</code>被调用挂起等待。（欲等待<code>alarm</code>函数发送的<code>SIGALRM</code>信号将自己唤醒）</strong></li>
<li><strong><code>SIGALRM</code>信号已经处理完毕，<code>pause</code>不会等到。</strong></li>
</ul>
<h4 id="解决时序问题"><a href="#解决时序问题" class="headerlink" title="解决时序问题"></a>解决时序问题</h4><p>可以通过设置屏蔽<code>SIGALRM</code>的方法来控制程序执行逻辑，<strong>但无论如何设置，程序都有可能在“解除信号屏蔽”与“挂起等待信号”这两个操作间隙失去cpu资源</strong>。除非将这两步骤合并成一个“<strong>原子操作</strong>”，<strong><code>sigsuspend</code>函数具备这个功能。在对时序要求严格的场合下都应该使用<code>sigsuspend</code>替换<code>pause</code>。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *mask)</span></span>; <span class="comment">//挂起等待信号</span></span><br></pre></td></tr></table></figure>
<p><strong><code>sigsuspend</code>函数调用期间，进程信号屏蔽字由其参数<code>mask</code>指定。</strong></p>
<p><strong>程序执行过程的信号屏蔽字由<code>sigaction.sa_mask</code>决定，但在执行<code>sigsuspend</code>期间由传入的<code>mask</code>决定。</strong></p>
<p><strong>可将某个信号（如<code>SIGALRM</code>）从临时屏蔽字<code>mask</code>中删除，这样在调用<code>sigsuspend</code>时将解除对该信号的屏蔽，然后挂起等待，当<code>sigsubpend</code>返回时，进程的信号屏蔽字恢复为原来的值。如果原来对该信号是屏蔽态，<code>sigsuspend</code>函数返回后仍然屏蔽该信号字。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> newmask, oldmask, suspmask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为SIGALRM设置捕捉函数，一个空函数</span></span><br><span class="line">    newact.sa_handler = catch_sigalrm;</span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGALRM,&amp;newact, &amp;oldact);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置阻塞信号集，阻塞SIGALRM信号</span></span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask, SIGALRM);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask); <span class="comment">//信号屏蔽字 mask</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时n秒，到时可以产生SIGALRM信号</span></span><br><span class="line">    alarm(seconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造一个调用sigsuspend临时有效的阻塞信号集，</span></span><br><span class="line">    <span class="comment">//在临时阻塞信号集里解除SIGALRM的阻塞</span></span><br><span class="line">    suspmask = oldmask; <span class="comment">//SIGALRM没有被屏蔽</span></span><br><span class="line">    sigdelset(&amp;suspmask, SIGALRM); <span class="comment">//原来屏蔽字中可能有屏蔽</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//sigsuspend调用期间，采用临时阻塞信号集suspmask替换原有阻塞信号集合</span></span><br><span class="line">    <span class="comment">//这个信号集中不包含SIGALRM喜好，同时挂起等待</span></span><br><span class="line">    <span class="comment">//当sigsuspend被信号唤醒返回时，恢复原来的阻塞信号集</span></span><br><span class="line">    sigsuspend(&amp;suspmask);<span class="comment">//原子操作</span></span><br><span class="line">    unslept = alarm(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复SIGALRM原有的处理动作，呼应前面注释</span></span><br><span class="line">    sigaction(SIGALRM,&amp;oldact,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解除对SIGALRM的阻塞，呼应前面注释</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (unslept);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>竞态条件跟系统负载有很紧密的的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</strong></p>
<p>不可靠由其实现原理导致。<strong>信号是通过软件方式实现的（与内核调度高度依赖，延时性强），每次系统调用结束后，或中断处理结束后，需要扫描PCB中的未决信号集来判断是否应该处理某个信号，当系统负载过重时，会出现时序混乱</strong>。</p>
<p>这种意外情况只能出现在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补，且由于该错误不具规律性，后期捕捉和重现十分困难。</p>
<h4 id="可重入函数，不可重入函数"><a href="#可重入函数，不可重入函数" class="headerlink" title="可重入函数，不可重入函数"></a>可重入函数，不可重入函数</h4><p>一个函数在被调用执行期间(尚未调用结束)，由于某种时序又被重复调用，称为“重入”,根据函数实现的方法可分为”可重入函数”和“不可重入函数”。</p>
<p>注意事项：</p>
<ul>
<li>定义可重入函数，函数内部不能含有全局变量及<code>static</code>变量，不能使用<code>malloc,free</code></li>
<li>信号捕捉函数应设计为可重入函数</li>
<li>信号处理程序可以调用的可重入函数可参阅<code>man 7 signal</code></li>
</ul>
<h3 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a><code>SIGCHLD</code>信号</h3><h4 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h4><ul>
<li><strong>子进程终止</strong>时</li>
<li>子进程<strong>收到<code>SIGSTOP</code>信号停止</strong>时</li>
<li>子进程<strong>处在停止态，接受到<code>SIGCONT</code>后唤醒</strong>时</li>
</ul>
<h4 id="借助SIGCHLD信号回收子进程"><a href="#借助SIGCHLD信号回收子进程" class="headerlink" title="借助SIGCHLD信号回收子进程"></a>借助<code>SIGCHLD</code>信号回收子进程</h4><p>子进程结束运行，其<strong>父进程会收到<code>SIGCHLD</code>信号，该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收。</strong></p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((pid = waitpid(<span class="number">0</span>, &amp;status,WNOHANG))&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) <span class="comment">//WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"--------------child %d exit %d\n"</span>,pid,WEXITSTATUS(status)); <span class="comment">//当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)退出，WEXITSTATUS(status)就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。请注意，如果进程不是正常退出的，也就是说，WIFEXITED返回0，这个值就毫无意义</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status)) <span class="comment">// WIFSIGNALED(status)为非0 表明进程异常终止</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child %d cancle signal %d\n"</span>,pid, WTERMSIG(status)); <span class="comment">//通过WTERMSIG(status)获取使得进程退出的信号编号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//阻塞SIGCHLD</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sys_err(<span class="string">"fork"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">//10个子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child ID %d\n"</span>,getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//SIGCHLD阻塞</span></span><br><span class="line">        struct sigaction act;</span><br><span class="line">        act.sa_handler = do_sig_child;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//NULL解除对SIGCHLD的阻塞</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Parent ID %d\n"</span>,getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h4><p>系统调用可以分为两种：慢速系统调用和其他系统调用。</p>
<ul>
<li>慢速系统调用：<strong>可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就会被中断，</strong>不再继续执行(早期)。也可以设定系统调用是否重启。如<code>read、write、pause、wait...</code></li>
<li>其他系统调用：<code>getpid、getppid、fork</code></li>
</ul>
<p>结合<code>pause</code>,回顾慢速系统调用：</p>
<p>慢速系统调用被中断的相关行为。实际上就是<code>pause</code>的行为，如read:</p>
<ul>
<li>想中断<code>pause</code>，信号不能被屏蔽</li>
<li>信号的处理方式必须是捕捉（默认、忽略都不可以）</li>
<li>中断后返回-1,设置<code>errno</code>为<code>EINTR</code>(表示被信号中断)</li>
</ul>
<p>可以修改<code>sa_flags</code>参数来设置被信号中断后系统调用是否重启。<code>SA_INTERRURT</code>不重启，<code>SA_RESTART</code>重启。</p>
<p><code>sa_flags</code>还有很多可选参数，适用于不同情况。如：捕捉到信号后，在执行捕捉信号期间，不希望自动阻塞该信号，可将<code>sa_flags</code>设置为<code>SA_NODEFER</code>,除非<code>sa_mask</code>中包含该信号。</p>
<h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><p><strong>所有输入输出设备总称。</strong></p>
<p>终端启动流程：<code>init-&gt;fork-&gt;exec-&gt;getty</code>-&gt;用户输入帐号-&gt;<code>login</code>-&gt;输入密码-&gt;<code>exec</code>-&gt;<code>bash</code></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"># linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/27/linux-%E7%B3%BB%E7%BB%9F-07%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" rel="prev" title="linux系统-进程间通信">
      <i class="fa fa-chevron-left"></i> linux系统-进程间通信
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/31/linux-%E7%B3%BB%E7%BB%9F-09%E4%BC%9A%E8%AF%9D%E5%8F%8A%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" rel="next" title="linux系统-会话及守护进程">
      linux系统-会话及守护进程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
            <li class="tab"><a href="#comment-livere">livere</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments" id="gitalk-container"></div>
            </div>
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments" id="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MjkwMy8yOTM4MA=="></div>
  </div>
  
            </div>
        </div>
      </div>
      <script>
        window.addEventListener('tabs:register', () => {
          let activeClass = 'gitalk';
            activeClass = localStorage.getItem('comments_active') || activeClass;
          if (activeClass) {
            let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
            if (activeTab) {
              activeTab.click();
            }
          }
        });
        window.addEventListener('tabs:click', event => {
          let commentClass = event.target.classList[1];
          localStorage.setItem('comments_active', commentClass);
        });
      </script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#信号"><span class="nav-number">1.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本概念及机制"><span class="nav-number">1.1.</span> <span class="nav-text">基本概念及机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#与信号相关的事件和状态"><span class="nav-number">1.2.</span> <span class="nav-text">与信号相关的事件和状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号屏蔽字和未决信号集"><span class="nav-number">1.3.</span> <span class="nav-text">信号屏蔽字和未决信号集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号4要素"><span class="nav-number">1.4.</span> <span class="nav-text">信号4要素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kill函数"><span class="nav-number">1.5.</span> <span class="nav-text">kill函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#raise和abort函数"><span class="nav-number">1.6.</span> <span class="nav-text">raise和abort函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#软件条件产生信号（定时产生信号）"><span class="nav-number">1.7.</span> <span class="nav-text">软件条件产生信号（定时产生信号）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号集操作函数"><span class="nav-number">2.</span> <span class="nav-text">信号集操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#操作信号集的若干步骤"><span class="nav-number">2.1.</span> <span class="nav-text">操作信号集的若干步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号集设定"><span class="nav-number">2.2.</span> <span class="nav-text">信号集设定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sigprocmask函数"><span class="nav-number">2.3.</span> <span class="nav-text">sigprocmask函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sigpending函数"><span class="nav-number">2.4.</span> <span class="nav-text">sigpending函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简易信号捕捉"><span class="nav-number">2.5.</span> <span class="nav-text">简易信号捕捉</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sigaction函数注册捕捉"><span class="nav-number">2.6.</span> <span class="nav-text">sigaction函数注册捕捉</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号捕捉特性"><span class="nav-number">2.7.</span> <span class="nav-text">信号捕捉特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内核实现信号捕捉过程："><span class="nav-number">2.8.</span> <span class="nav-text">内核实现信号捕捉过程：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#竞态条件"><span class="nav-number">3.</span> <span class="nav-text">竞态条件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pause函数"><span class="nav-number">3.1.</span> <span class="nav-text">pause函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时序竞态"><span class="nav-number">3.2.</span> <span class="nav-text">时序竞态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决时序问题"><span class="nav-number">3.3.</span> <span class="nav-text">解决时序问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">3.4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可重入函数，不可重入函数"><span class="nav-number">3.5.</span> <span class="nav-text">可重入函数，不可重入函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIGCHLD信号"><span class="nav-number">4.</span> <span class="nav-text">SIGCHLD信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#产生条件"><span class="nav-number">4.1.</span> <span class="nav-text">产生条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#借助SIGCHLD信号回收子进程"><span class="nav-number">4.2.</span> <span class="nav-text">借助SIGCHLD信号回收子进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断系统调用"><span class="nav-number">4.3.</span> <span class="nav-text">中断系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#终端"><span class="nav-number">5.</span> <span class="nav-text">终端</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShifuDong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShifuDong</p>
  <div class="site-description" itemprop="description">记录生活， 记录学习， 分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/mailto:sfd_w@foxmail.com" title="E-Mail → mailto:sfd_w@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShifuDong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'a6ee5b68c97a3db64850',
      clientSecret: '1dfa06f32032431e4af79b80f9ddf9dfd13dbda2',
      repo: 'dongshifu.github.io',
      owner: 'dongshifu',
      admin: ['dongshifu'],
      id: '02e117dd4dc4d906d54c1761f20af0eb',
        language: 'zh-CN',
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

<script>
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>

    </div>
</body>
</html>
