<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ShifuDong" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="TCP基础知识为什么需要TCPIP 层是不可靠的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。 如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。 TCP是什么TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。">
<meta name="keywords" content="TCP">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP需要注意的知识点">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;06&#x2F;03&#x2F;tcp-1&#x2F;index.html">
<meta property="og:site_name" content="ShifuDong">
<meta property="og:description" content="TCP基础知识为什么需要TCPIP 层是不可靠的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。 如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。 TCP是什么TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;eee8b186-13ee-47a9-9a36-e78bd9b561fd-11197877.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;6a228333-dec9-45fb-8c1d-76ad93064551-11197877.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;2bd8a8b8-b62c-45f2-9a78-645082d3352a-11197877.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;d0d675fa-c7be-4221-ba70-d001cd098a66-11197877.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;f6c51f91-0005-44c9-8010-64d523fe5e12-11197877.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;1b6c4373-b894-4e5d-a81f-de6e00f83d65-11197877.jpg">
<meta property="og:updated_time" content="2021-04-15T05:35:29.663Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;eee8b186-13ee-47a9-9a36-e78bd9b561fd-11197877.jpg">

<link rel="canonical" href="http://yoursite.com/2020/06/03/tcp-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>TCP需要注意的知识点 | ShifuDong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShifuDong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Knowledge Sharing</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/tcp-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TCP需要注意的知识点
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 19:29:16" itemprop="dateCreated datePublished" datetime="2020-06-03T19:29:16+08:00">2020-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-15 13:35:29" itemprop="dateModified" datetime="2021-04-15T13:35:29+08:00">2021-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="TCP基础知识"><a href="#TCP基础知识" class="headerlink" title="TCP基础知识"></a>TCP基础知识</h3><h4 id="为什么需要TCP"><a href="#为什么需要TCP" class="headerlink" title="为什么需要TCP"></a>为什么需要TCP</h4><p><code>IP</code> 层是不可靠的，它<strong>不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性</strong>。</p>
<p>如果需要<strong>保障网络数据包的可靠性</strong>，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p>
<h4 id="TCP是什么"><a href="#TCP是什么" class="headerlink" title="TCP是什么"></a>TCP是什么</h4><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<ul>
<li>面向连接：一定是<strong>一对一</strong>才能连接，不能像<code>UDP</code>协议可以一个主机同时向多个主机发送消息，也即无法做到一对多。</li>
<li>可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端。</li>
<li>字节流：消息是没有边的，所以<strong>无论消息有多大都可以进行传输</strong>。并且<strong>消息是有序的，当前一个消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对重复的报文会自动丢弃。</strong></li>
</ul>
<h4 id="TCP头部中比较重要的字段："><a href="#TCP头部中比较重要的字段：" class="headerlink" title="TCP头部中比较重要的字段："></a>TCP头部中比较重要的字段：</h4><ul>
<li><strong>序列号</strong>：在建立连接时由计算机生成的<strong>随机数</strong>作为其初始值，通过 <code>SYN</code> 包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小。<strong>用来解决网络包乱序问题。</strong></li>
<li><strong>确认应答号</strong>：指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在<strong>这个序号以前的数据都已经被正常接收</strong>。<strong>用来解决不丢包的问题。</strong></li>
<li><strong>控制位：</strong><ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，确认应答的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中<strong>出现异常必须强制断开连接</strong>。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希<strong>望建立连，并在其序列号的字段进行序列号初始值的设定。</strong></li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示<strong>今后不会再有数据发送，希望断开连接</strong>。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位置为 1 的 TCP 段。</li>
</ul>
</li>
</ul>
<h3 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h3><h4 id="什么是TCP连接"><a href="#什么是TCP连接" class="headerlink" title="什么是TCP连接"></a>什么是TCP连接</h4><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</strong></p>
<p>建立一个 TCP 连接是需要客户端与服务器端达成三个信息的共识。</p>
<ul>
<li><strong>Socket</strong>：由 <strong>IP 地址和端口号</strong>组成</li>
<li><strong>序列号</strong>：用来解决<strong>乱序</strong>问题等</li>
<li><strong>窗口大小</strong>：用来做<strong>流量控制</strong></li>
</ul>
<h4 id="如何唯一确定一个TCP连接"><a href="#如何唯一确定一个TCP连接" class="headerlink" title="如何唯一确定一个TCP连接"></a>如何唯一确定一个TCP连接</h4><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<p>源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方<strong>主机</strong>。</p>
<p>源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个<strong>进程</strong>。</p>
<h4 id="TCP-的最大连接数是多少"><a href="#TCP-的最大连接数是多少" class="headerlink" title="TCP 的最大连接数是多少"></a>TCP 的最大连接数是多少</h4><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。</p>
<p>因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:</p>
<script type="math/tex; mode=display">
最大TCP连接数 = 客户端的IP数 * 客户端的端口数</script><p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code> 次方，也就是<strong>服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方</strong>。</p>
<p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。</p>
<ul>
<li>首先主要是<strong>文件描述符限制</strong>，Socket 都是文件，所以首先要通过 <code>ulimit</code> 配置文件描述符的数目</li>
<li>另一个是<strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统是有限的。</li>
</ul>
<h4 id="TCP三次握手过程和状态变迁"><a href="#TCP三次握手过程和状态变迁" class="headerlink" title="TCP三次握手过程和状态变迁"></a>TCP三次握手过程和状态变迁</h4><ul>
<li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li>
<li><strong>第一次握手</strong>：客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的序号字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，<strong>该报文不包含应用层数据</strong>，之后客户端处于 <code>SYN-SENT</code> 状态</li>
<li><strong>第二次握手</strong>:服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的序号字段中，其次把 TCP 首部的确认应答号字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>
<li><strong>第三次握手</strong>：客户端收到服务端报文后，还要向服务端<strong>回应最后一个应答报文</strong>，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，<strong>这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</strong></li>
<li>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ul>
<h4 id="查看tcp的连接状态"><a href="#查看tcp的连接状态" class="headerlink" title="查看tcp的连接状态"></a>查看tcp的连接状态</h4><p><code>netstat -napt</code></p>
<h4 id="为什么需要三次握手，两次或者四次是否可以？"><a href="#为什么需要三次握手，两次或者四次是否可以？" class="headerlink" title="为什么需要三次握手，两次或者四次是否可以？"></a>为什么需要三次握手，两次或者四次是否可以？</h4><ul>
<li>避免历史连接：<strong>防止旧的重复连接初始化造成混乱。</strong>网络环境是错综复杂的，往往并不是如期望的一样，先发送的数据包，就先到达目标主机，可能会由于网络拥堵等乱七八糟的原因，<strong>会使得旧的数据包，先到达目标主机</strong>，那么这种情况下 TCP 三次握手是如何避免的呢？<ul>
<li>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下<ul>
<li>一个旧 SYN 报文比最新的 SYN 报文早到达了服务端</li>
<li>此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端</li>
<li>客户端收到后可以<strong>根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</strong></li>
</ul>
</li>
<li>如果是<strong>两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接</strong>：<ul>
<li>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 <code>RST</code> 报文，以此<strong>中止历史连接</strong></li>
<li>如果不是历史连接，则第三次发送的报文是 <code>ACK</code> 报文，通信双方就会成功建立连接</li>
</ul>
</li>
</ul>
</li>
<li>同步双方初始序列号。TCP 协议的通信双方， 都<strong>必须维护一个序列号</strong>， 序列号是可靠传输的一个关键因素，它的作用：<ul>
<li>接收方可以<strong>去除重复的数据</strong></li>
<li>接收方可以根据数据包的序列号<strong>按序接收</strong></li>
<li>可以<strong>标识发送出去的数据包中， 哪些是已经被对方收到的</strong></li>
<li>客户端和服务器双发使用序列号保证在来回通信过程中<strong>初始序列号能被可靠的同步。</strong></li>
</ul>
</li>
<li>避免资源浪费。如果只有「两次握手」，当客户端的 <code>SYN</code> 请求连接在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认信号，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接，这会造成重复发送多次 <code>SYN</code> 报文，那么服务器在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></li>
</ul>
<h4 id="为什么客户端和服务器端的初始序列号ISN是不相同的"><a href="#为什么客户端和服务器端的初始序列号ISN是不相同的" class="headerlink" title="为什么客户端和服务器端的初始序列号ISN是不相同的"></a>为什么客户端和服务器端的初始序列号ISN是不相同的</h4><p>网络中的报文<strong>会延迟、会复制重发、也有可能丢失</strong>，这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。</p>
<h4 id="IP层会分片，为什么TCP层还需要MSS"><a href="#IP层会分片，为什么TCP层还需要MSS" class="headerlink" title="IP层会分片，为什么TCP层还需要MSS"></a>IP层会分片，为什么TCP层还需要MSS</h4><ul>
<li><code>MTU(maximum transmission unit)</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节</li>
<li><code>MSS(maximum segment size)</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li>
</ul>
<p>如果TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常？</p>
<p>当 IP 层有一个超过 <code>MTU</code> 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，在交给上一层 TCP 传输层。</p>
<p>这看起来井然有序，但这存在隐患的，<strong>那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，不会响应 ACK 给对方，<strong>那么发送方的 TCP 在超时后，就会重发整个 TCP 报文（头部 + 数据）</strong>。因此，可以得知<strong>由 IP 层进行分片传输，是非常没有效率的</strong>。</p>
<p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，<strong>当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</strong>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，<strong>而不用重传所有的分片，大大增加了重传的效率。</strong></p>
<h4 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h4><p>TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的 SYN 接收队列（未连接队列）</strong>，使得服务器不能为正常用户服务。</p>
<h4 id="SYN攻击的避免"><a href="#SYN攻击的避免" class="headerlink" title="SYN攻击的避免"></a>SYN攻击的避免</h4><p>方式一：通过<strong>修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理</strong>。</p>
<ul>
<li>当<strong>网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值</strong>参数：<code>net.core.netdev_max_backlog</code></li>
<li><code>SYN_RCVD</code> 状态连接的最大个数：<code>net.ipv4.tcp_max_syn_backlog</code></li>
<li>超出处理能时，对新的 SYN 直接回 RST，丢弃连接：<code>net.ipv4.tcp_abort_on_overflow</code></li>
</ul>
<p>Linux <strong>内核的 <code>SYN</code> （未完成连接建立）队列与 <code>Accpet</code> （已完成连接建立）队列</strong>是如何工作的:</p>
<p><img src="https://api2.mubu.com/v3/document_image/eee8b186-13ee-47a9-9a36-e78bd9b561fd-11197877.jpg" alt="SYN_ACCPET队列工作原理"></p>
<p>正常流程：</p>
<ul>
<li>当服务端接收到客户端的 SYN 报文时，会将其加入到<strong>内核的SYN 队列</strong></li>
<li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文</li>
<li>服务端接收到 ACK 报文后，从 SYN 队列移除放入到 Accept 队列</li>
<li><strong>应用通过调用 <code>accpet()</code> socket 接口，从Accept 队列取出连接。</strong></li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/6a228333-dec9-45fb-8c1d-76ad93064551-11197877.jpg" alt="应用程序过慢"></p>
<p>如果应用程序过慢时，就会<strong>导致Accept 队列被占满。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/2bd8a8b8-b62c-45f2-9a78-645082d3352a-11197877.jpg" alt="受到SYN攻击"></p>
<ul>
<li>如果不断受到 SYN 攻击，就会导致「 SYN 队列」被占满。<code>tcp_syncookies</code> 的方式可以应对 SYN 攻击的方法：<code>net.ipv4.tcp_syncookies = 1</code></li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/d0d675fa-c7be-4221-ba70-d001cd098a66-11197877.jpg" alt="cookie启动"></p>
<ul>
<li>当 <strong>SYN 队列满之后，后续服务器收到 SYN 包，不进入SYN 队列</strong></li>
<li>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的序列号返回客户端</li>
<li>服务端接收到客户端的应答报文时，<strong>服务器会检查这个 ACK 包的合法性。如果合法，直接放入到 Accept 队列</strong>。</li>
<li>最后应用<strong>通过调用 <code>accpet()</code> socket 接口，从 Accept 队列取出的连接</strong>。</li>
</ul>
<h3 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h3><h4 id="TCP四次挥手过程及状态变迁"><a href="#TCP四次挥手过程及状态变迁" class="headerlink" title="TCP四次挥手过程及状态变迁"></a>TCP四次挥手过程及状态变迁</h4><p><strong>双方都可以主动断开连接，断开连接后主机中的资源将被释放</strong>。</p>
<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <strong><code>FIN_WAIT_1</code> 状态</strong>。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <strong><code>CLOSED_WAIT</code> 状态。</strong></li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <strong><code>FIN_WAIT_2</code> 状态</strong>。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <strong><code>LAST_ACK</code> 状态。</strong></li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <strong><code>TIME_WAIT</code> 状态</strong></li>
<li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p>
<h4 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h4><ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，<strong>仅仅表示客户端不再发送数据了但是还能接收数据。</strong></li>
<li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而<strong>服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</strong></li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p>
<h4 id="为什么需要-TIME-WAIT-状态"><a href="#为什么需要-TIME-WAIT-状态" class="headerlink" title="为什么需要 TIME_WAIT 状态"></a>为什么需要 TIME_WAIT 状态</h4><p><strong>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</strong></p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防止具有相同四元组的旧数据包被收到<ul>
<li>假设 TIME-WAIT 没有等待时间或时间过短，<strong>有相同端口的 TCP 连接可能被复用，</strong>被延迟的数据包抵达后会：有可能正常接收这个过期的报文，这就会产生<strong>数据错乱</strong>等严重的问题</li>
<li>经过 <code>2MSL</code> 时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></li>
</ul>
</li>
<li>保证<strong>被动关闭连接的一方能被正确的关闭</strong>，即<strong>保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</strong>。<ul>
<li>假设 TIME-WAIT 没有等待时间或时间过短，客户端四次挥手的最后一个 <code>ACK</code> 报文如果在网络中被丢失了，此时<strong>如果客户端 <code>TIME-WAIT</code> 过短或没有，则就直接进入了 <code>CLOSE</code> 状态了，那么服务端则会一直处在 <code>LASE-ACK</code> 状态。</strong></li>
<li>当客户端发起建立连接的 <code>SYN</code> 请求报文后，服务端会发送 <code>RST</code> 报文给客户端，连接建立的过程就会被终止。</li>
</ul>
</li>
</ul>
<h4 id="为什么-TIME-WAIT-等待的时间是-2MSL"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL"></a>为什么 TIME_WAIT 等待的时间是 2MSL</h4><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是<strong>任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</strong>因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别：MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：<strong>网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。</strong>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p>
<p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p>
<p>在 Linux 系统里 <code>2MSL</code> 默认是 <code>60</code> 秒，那么一个 <code>MSL</code> 也就是 <code>30</code> 秒。<strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p>
<p>其定义在 Linux 内核代码里的名称为 TCP_TIMEWAIT_LEN：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT state, about 60 seconds  */</span><br></pre></td></tr></table></figure>
<p><strong>如果要修改 TIME_WAIT 的时间长度，只能修改 Linux 内核代码里<code>TCP_TIMEWAIT_LEN</code>的值，并重新编译 Linux 内核。</strong></p>
<h4 id="TIME-WAIT-过多有什么危害"><a href="#TIME-WAIT-过多有什么危害" class="headerlink" title="TIME_WAIT 过多有什么危害"></a>TIME_WAIT 过多有什么危害</h4><p>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器方主动发起的断开请求。</p>
<p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li>第一是<strong>内存资源占用</strong></li>
<li>第二是对<strong>端口资源的占用</strong>，一个 TCP 连接至少消耗一个本地端口</li>
</ul>
<p>第二个危害是会造成严重的后果的，端口资源是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过如下参数设置指定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_local_port_range</span><br></pre></td></tr></table></figure>
<p><strong>如果服务端 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。</strong></p>
<h4 id="如何优化-TIME-WAIT？"><a href="#如何优化-TIME-WAIT？" class="headerlink" title="如何优化 TIME_WAIT？"></a>如何优化 TIME_WAIT？</h4><p>优化 TIME-WAIT 的几个方式，都是有利有弊：</p>
<ul>
<li><p>打开 <code>net.ipv4.tcp_tw_reuse</code> 和<code>net.ipv4.tcp_timestamps</code>选项</p>
<ul>
<li><strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong></li>
<li><code>net.ipv4.tcp_tw_reuse = 1</code>,使用前提：打开对 TCP 时间戳的支持:<code>net.ipv4.tcp_timestamps=1（默认即为 1）</code>(这个时间戳的字段是在 TCP 头部的选项里，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。由于引入了时间戳，前面提到的 <code>2MSL</code> 问题就不复存在了，因为<strong>重复的数据包会因为时间戳过期被自然丢弃</strong>)</li>
<li>注意：<strong><code>net.ipv4.tcp_tw_reuse</code>要慎用，因为使用了它就必然要打开时间戳的支持 <code>net.ipv4.tcp_timestamps</code>，当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉。</strong></li>
</ul>
</li>
<li><p><code>net.ipv4.tcp_max_tw_buckets</code></p>
<ul>
<li>这个值默认为 18000，当系统中处于 TIME_WAIT 的连接<strong>一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置。</strong>这个方法过于暴力，而且治标不治本，<strong>带来的问题远比解决的问题多</strong>。</li>
</ul>
</li>
<li><p>程序中使用 <code>SO_LINGER</code> ，应用强制使用 <code>RST</code> 关闭</p>
<ul>
<li>可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">so_linger</span>;</span></span><br><span class="line">so_linger.l_onoff = <span class="number">1</span>;</span><br><span class="line">so_linger.l_linger = <span class="number">0</span>;</span><br><span class="line">setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,<span class="keyword">sizeof</span>(so_linger));</span><br></pre></td></tr></table></figure>
<ul>
<li>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，<strong>该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</strong>但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为。</li>
</ul>
</li>
</ul>
<h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办</h4><p>TCP 有一个机制是<strong>保活机制</strong>。该机制的原理为：</p>
<p>定义一个时间段，<strong>在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡</strong>，系统内核将错误信息通知给上层应用程序。</p>
<p>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=7200</span><br><span class="line">net.ipv4.tcp_keepalive_intvl=75  </span><br><span class="line">net.ipv4.tcp_keepalive_probes=9</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tcp_keepalive_time=7200</code>：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</li>
<li><code>tcp_keepalive_intvl=75</code>：表示每次检测间隔 75 秒；</li>
<li><code>tcp_keepalive_probes=9</code>：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li>
</ul>
<p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个死亡连接。这个时间可以根据实际的需求，对以上的保活相关的参数进行设置。</p>
<p>如果开启了 TCP 保活，需要考虑以下几种情况：</p>
<ul>
<li><p>对端程序是<strong>正常工作</strong>的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p>
</li>
<li><p>对端程序<strong>崩溃并重启</strong>。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</p>
</li>
<li><p>是对端程序<strong>崩溃</strong>，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p>
</li>
</ul>
<h3 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h3><p>socket编程与TCP状态的对应图：</p>
<p><img src="https://api2.mubu.com/v3/document_image/f6c51f91-0005-44c9-8010-64d523fe5e12-11197877.jpg" alt="socket编程与通信过程的对应"></p>
<h4 id="listen-时候参数-backlog-的意义"><a href="#listen-时候参数-backlog-的意义" class="headerlink" title="listen 时候参数 backlog 的意义"></a>listen 时候参数 backlog 的意义</h4><p>Linux内核中会维护两个队列：</p>
<ul>
<li><strong>未完成连接队列（SYN 队列）</strong>：接收到一个 SYN 建立连接请求，处于<code>SYN_RCVD</code> 状态</li>
<li><strong>已完成连接队列（Accpet 队列）</strong>：已完成 TCP 三次握手过程，处于 <code>ESTABLISHED</code>状态</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/1b6c4373-b894-4e5d-a81f-de6e00f83d65-11197877.jpg" alt="backlog"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span> <span class="params">(<span class="keyword">int</span> socketfd, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 参数一 socketfd 为 socketfd 文件描述符</span></span></span><br><span class="line"><span class="function"><span class="comment">// 参数二 backlog，这参数在历史有一定的变化</span></span></span><br></pre></td></tr></table></figure>
<p>在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。</p>
<p>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列。</strong></p>
<h4 id="accept-发送在三次握手的哪一步"><a href="#accept-发送在三次握手的哪一步" class="headerlink" title="accept 发送在三次握手的哪一步"></a>accept 发送在三次握手的哪一步</h4><p>第三次握手的包到达服务器端后，<strong>服务器端协议栈使得 <code>accept</code> 阻塞调用返回</strong>，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 ESTABLISHED 状态。<strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后</strong></p>
<h4 id="客户端调用-close-了，连接是断开的流程是什么"><a href="#客户端调用-close-了，连接是断开的流程是什么" class="headerlink" title="客户端调用 close 了，连接是断开的流程是什么"></a>客户端调用 close 了，连接是断开的流程是什么</h4><ul>
<li>客户端调用 <code>close</code>，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态</li>
<li>服务端接收到了 FIN 报文，<strong>TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。这个 <code>EOF</code> 会被放在已排队等候的其他已接收的数据之后，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态</strong></li>
<li>接着，<strong>当处理完数据后，自然就会读到 <code>EOF</code>，于是也调用 <code>close</code> 关闭它的套接字，这会使得会发出一个 FIN 包，之后处于 LAST_ACK 状态</strong></li>
<li>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态</li>
<li>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态</li>
<li>客户端进过 <code>2MSL</code> 时间之后，也进入 CLOSED 状态</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/tH8RFmjrveOmgLvk9hmrkw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/tH8RFmjrveOmgLvk9hmrkw</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/TCP/" rel="tag"># TCP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/02/Go%20%E6%8E%A5%E5%8F%A3_2Go%E8%AF%AD%E8%A8%80%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB/" rel="prev" title="Go鸭子类型">
      <i class="fa fa-chevron-left"></i> Go鸭子类型
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/03/Go%20%E6%8E%A5%E5%8F%A3_3iface%20%E5%92%8C%20eface%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/" rel="next" title="Go 接口的底层实现">
      Go 接口的底层实现 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments" id="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MjkwMy8yOTM4MA=="></div>
  </div>
  
            </div>
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments" id="gitalk-container"></div>
            </div>
        </div>
      </div>
      <script>
        window.addEventListener('tabs:register', () => {
          let activeClass = 'gitalk';
            activeClass = localStorage.getItem('comments_active') || activeClass;
          if (activeClass) {
            let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
            if (activeTab) {
              activeTab.click();
            }
          }
        });
        window.addEventListener('tabs:click', event => {
          let commentClass = event.target.classList[1];
          localStorage.setItem('comments_active', commentClass);
        });
      </script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP基础知识"><span class="nav-number">1.</span> <span class="nav-text">TCP基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么需要TCP"><span class="nav-number">1.1.</span> <span class="nav-text">为什么需要TCP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP是什么"><span class="nav-number">1.2.</span> <span class="nav-text">TCP是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP头部中比较重要的字段："><span class="nav-number">1.3.</span> <span class="nav-text">TCP头部中比较重要的字段：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP建立连接"><span class="nav-number">2.</span> <span class="nav-text">TCP建立连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是TCP连接"><span class="nav-number">2.1.</span> <span class="nav-text">什么是TCP连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何唯一确定一个TCP连接"><span class="nav-number">2.2.</span> <span class="nav-text">如何唯一确定一个TCP连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-的最大连接数是多少"><span class="nav-number">2.3.</span> <span class="nav-text">TCP 的最大连接数是多少</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP三次握手过程和状态变迁"><span class="nav-number">2.4.</span> <span class="nav-text">TCP三次握手过程和状态变迁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看tcp的连接状态"><span class="nav-number">2.5.</span> <span class="nav-text">查看tcp的连接状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么需要三次握手，两次或者四次是否可以？"><span class="nav-number">2.6.</span> <span class="nav-text">为什么需要三次握手，两次或者四次是否可以？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么客户端和服务器端的初始序列号ISN是不相同的"><span class="nav-number">2.7.</span> <span class="nav-text">为什么客户端和服务器端的初始序列号ISN是不相同的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP层会分片，为什么TCP层还需要MSS"><span class="nav-number">2.8.</span> <span class="nav-text">IP层会分片，为什么TCP层还需要MSS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SYN攻击"><span class="nav-number">2.9.</span> <span class="nav-text">SYN攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SYN攻击的避免"><span class="nav-number">2.10.</span> <span class="nav-text">SYN攻击的避免</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP断开连接"><span class="nav-number">3.</span> <span class="nav-text">TCP断开连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP四次挥手过程及状态变迁"><span class="nav-number">3.1.</span> <span class="nav-text">TCP四次挥手过程及状态变迁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么需要四次挥手"><span class="nav-number">3.2.</span> <span class="nav-text">为什么需要四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么需要-TIME-WAIT-状态"><span class="nav-number">3.3.</span> <span class="nav-text">为什么需要 TIME_WAIT 状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么-TIME-WAIT-等待的时间是-2MSL"><span class="nav-number">3.4.</span> <span class="nav-text">为什么 TIME_WAIT 等待的时间是 2MSL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TIME-WAIT-过多有什么危害"><span class="nav-number">3.5.</span> <span class="nav-text">TIME_WAIT 过多有什么危害</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何优化-TIME-WAIT？"><span class="nav-number">3.6.</span> <span class="nav-text">如何优化 TIME_WAIT？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如果已经建立了连接，但是客户端突然出现故障了怎么办"><span class="nav-number">3.7.</span> <span class="nav-text">如果已经建立了连接，但是客户端突然出现故障了怎么办</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket编程"><span class="nav-number">4.</span> <span class="nav-text">socket编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#listen-时候参数-backlog-的意义"><span class="nav-number">4.1.</span> <span class="nav-text">listen 时候参数 backlog 的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#accept-发送在三次握手的哪一步"><span class="nav-number">4.2.</span> <span class="nav-text">accept 发送在三次握手的哪一步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端调用-close-了，连接是断开的流程是什么"><span class="nav-number">4.3.</span> <span class="nav-text">客户端调用 close 了，连接是断开的流程是什么</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShifuDong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShifuDong</p>
  <div class="site-description" itemprop="description">记录生活， 记录学习， 分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/mailto:sfd_w@foxmail.com" title="E-Mail → mailto:sfd_w@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShifuDong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  

<script>
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'a6ee5b68c97a3db64850',
      clientSecret: '1dfa06f32032431e4af79b80f9ddf9dfd13dbda2',
      repo: 'dongshifu.github.io',
      owner: 'dongshifu',
      admin: ['dongshifu'],
      id: '5181a87bfdc5cfdb4ba57d33dafaa7c4',
        language: 'zh-CN',
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

    </div>
</body>
</html>
