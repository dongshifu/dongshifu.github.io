<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux 文件系统</title>
    <url>/2020/01/06/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>安全方向</p>
<p>优点：执行速度快，功能强大，编程自由。代码量小：dll封装等</p>
<p>缺点：编程周期长，可移植性较差，过于自由，容易出错，对于平台库依赖较多。</p>
<p>可用部分：网站后台，程序库，游戏引擎，写语言，操作系统，微处理器</p>
<p>构成：32个关键字，9种控制语句，34种运算符（算术运算符，关系运算符，逻辑运算符，位运算符，复制运算傅符，条件运算符，逗号运算符，指针运算符，求字节数，强制类型转换，分量运算符，下标运算符）</p>
<h1 id="include-lt-gt-表示导入系统文件"><a href="#include-lt-gt-表示导入系统文件" class="headerlink" title="include &lt;&gt; 表示导入系统文件"></a>include &lt;&gt; 表示导入系统文件</h1><h1 id="include-“”表示导入自定义文件"><a href="#include-“”表示导入自定义文件" class="headerlink" title="include “”表示导入自定义文件"></a>include “”表示导入自定义文件</h1><p>%d 为一个占位符</p>
<h4 id="c编译步骤"><a href="#c编译步骤" class="headerlink" title="c编译步骤"></a>c编译步骤</h4><ul>
<li>预处理：宏文件展开、头文件展开、条件编译等，同时将代码中的注释删除，并不检查语法<ul>
<li>gcc -E hello.c -o hello.i</li>
</ul>
</li>
<li>编译：检查语法，将预处理后文件编译生成汇编文件<ul>
<li>gcc -S hello.i -o hello.s</li>
</ul>
</li>
<li>汇编：将汇编文件生成目标文件（二进制文件）<ul>
<li>gcc -c hello.s -o hello.o</li>
</ul>
</li>
<li>链接：程序依赖各种库，编译之后需要将库链接到最终的可执行程序中<ul>
<li>gcc hello.o -o hello</li>
<li>-o 表示生成一个文件</li>
</ul>
</li>
</ul>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p>编辑异常</p>
<p>编译时异常</p>
<p>运行时异常</p>
<h4 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h4><p>硬盘（外部存储设备）-&gt;内存（MEM，代码区，数据区，栈区，堆区）-&gt;CPU -&gt; </p>
<h4 id="64位与32位操作系统区别"><a href="#64位与32位操作系统区别" class="headerlink" title="64位与32位操作系统区别"></a>64位与32位操作系统区别</h4><ul>
<li>寄存器是CPU内部最基本的存储单元</li>
<li>CPU对外通过总线（地址、控制、数据）来和外部设备交互，总线的带宽是8位，同时CPU的寄存器也是8位，那个CPU就叫做8位CPU</li>
<li>如果总线是32位，寄存器也是32位的，这个CPU为32位CPU</li>
<li>所有的64位CPU兼容32位的指令，32位要兼容16位的指令，所以在64位的CPU上可以识别32位的指令</li>
<li>在64位的架构上运行64位的操作系统，那个这个系统为64位</li>
<li>64位的CPU运行32位的操作系统，这个系统为32位</li>
<li>64位的软件不能运行在32位的CPU上</li>
</ul>
<p>总线越宽，速度越快</p>
<h4 id="寄存器，缓存，内存的关系"><a href="#寄存器，缓存，内存的关系" class="headerlink" title="寄存器，缓存，内存的关系"></a>寄存器，缓存，内存的关系</h4><p>所有的运算都要放到CPU中计算，CPU直接打交道的其实是寄存器。</p>
<p>内存和寄存器进行数据读写</p>
<p>01.c //汇编+c</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>数据类型关键字：char, short, int ,long, float, double</p>
<p>unsigned, signed, struct, union, enum, <strong>void</strong></p>
<p>控制语句关键字：if ,else, switch, case,default, for ,while , break, continue,goto, return</p>
<p>存储类关键字：auto , extern, register, static, const</p>
<p>其他关键字：sizeof, typedef（ 定义函数指针，定义别名）,  volatile（防止编译器做优化）</p>
<p>数据类型的作用：编译器预算对象（变量）分配的内存空间大小</p>
<p>基址：编译过程决定</p>
<p>常量：在程序运行过程中，其值不能发生变化的量</p>
<p>const int price = 3;（不安全写法，限定在c语言中）</p>
<p>宏定义常量 #define PI 3.14159</p>
<p>变量：在程序运行过程中，其值可以发生变化的量</p>
<p>%f, 默认保留6位小数，%.2f（保留2位）</p>
<h4 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h4><p>不能使用系统关键字</p>
<p>允许字母，下划线，数字，数字不能开头</p>
<p>标识符区分大小写</p>
<p>见名知意</p>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>%d</p>
<p>%o 8进制int类型</p>
<p>%x 16进制int类型，字母以小写输出</p>
<p>%X 16进制int ,字母以大写输出</p>
<p>%u 输出10进制无符号数</p>
<p>定义八进制数据：以0开头</p>
<p>定义十六禁止数据：以0x开头</p>
<p>在计算机中不可以直接定义二进制</p>
<p>&amp;取地址符</p>
<p>sizeof()不是函数，不需要包含任何头文件，计算一个数据类型的大小，单位为字节。</p>
<h2 id="操作系统栈和堆"><a href="#操作系统栈和堆" class="headerlink" title="操作系统栈和堆"></a>操作系统栈和堆</h2><p>地址空间布局：<br><img src="https://images2018.cnblogs.com/blog/1375029/201807/1375029-20180726233237789-23027217.png" alt="-c">￼</p>
<h4 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h4><p>​    执行期间编译器自动分配，编译器用它实现函数调用，调用函数时，栈增长，函数返回时，栈收缩。局部变量、函数参数、返回数据、返回地址等放在栈中</p>
<p>栈的特点</p>
<ol>
<li>内存分配取决于编译器，用户栈在程序运行期间可以动态的扩展和收缩。</li>
<li>和数据结构中的“栈”本质上是不一样的，但是操作方式类似于栈。</li>
<li>数据从栈中的进出满足“后进先出”的规律。</li>
<li>栈向低地址方向增长，esp（栈指针）指向栈顶元素。</li>
</ol>
<h4 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h4><p>​    动态储存器分配器维护着的一个进程的虚拟存储器区域。一般由程序员分配释放（堆在操作系统对进程初始化的时候分配），若程序员不释放，程序结束时可能由OS回收，每个进程，内核都维护着一个变量brk指向堆顶。</p>
<p>堆的特点</p>
<ol>
<li>内存分配取决于程序员，C/C++可以手动释放该片内存。</li>
<li>和数据结构的”堆“完全两回事，没有半点关系，在这里堆的结构更像链表。</li>
<li>所有的对象，包括数组的对象都存在堆上。</li>
<li>堆内存被所有的线程共享。</li>
<li>引用类型总是放在堆中。</li>
<li>堆向高地址方向增长，内核都维护的变量brk指向堆顶。</li>
</ol>
<p>注意：值类型和指针总是放在他们被声明的地方（复杂）<br>当值类型的数据在方法体内被声明时，它们都应该放在栈上。<br>如果一个只类型被声明在方法体外且存在于一个引用类型中，那么它将会被堆里的引用类型所取代。</p>
<h4 id="全局区-静态区："><a href="#全局区-静态区：" class="headerlink" title="全局区/静态区："></a>全局区/静态区：</h4><p>​    全局变量、静态变量、常量的存储区域，程序终止时系统释放。</p>
<h4 id="文字常量区："><a href="#文字常量区：" class="headerlink" title="文字常量区："></a>文字常量区：</h4><p>​    存放常量字符串，程序结束后由系统释放。</p>
<h4 id="程序代码区："><a href="#程序代码区：" class="headerlink" title="程序代码区："></a>程序代码区：</h4><p>​    存放函数体（类成员函数和全局函数）的二进制代码。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;        <span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1;       <span class="comment">//全局未初始化区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b;          <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"123"</span>;  <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p2;       <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">"sdfghhj"</span>; <span class="comment">//其中，“sdfghhj\0”常量区，p3在栈区</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>; <span class="comment">//全局区</span></span><br><span class="line">    p1 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);   <span class="comment">//10个字节区域在堆区</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1,<span class="string">"sdfghhj"</span>);    <span class="comment">//"sdfghhj\0"在常量区，编译器可能会优化p1和p3指向同一块区域</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栈和堆的区别："><a href="#栈和堆的区别：" class="headerlink" title="栈和堆的区别："></a>栈和堆的区别：</h4><ol>
<li>栈内存存储的的是局部变量，堆内存存储的是实体。</li>
<li>栈内存的更新的速度会更快些（局部变量），堆内存的更新速度相对更慢。</li>
<li>栈内存的访问直接从地址读取数据到寄存器，然后放到目标地址，而堆内存的访问更麻烦，先将分配的地址放到寄存器，在读取地址的值，最后再放到目标文件中，开销更大。</li>
<li>栈内存是连续的空间，堆内存一般情况不是连续的，频繁地开辟空间，释放空间容易产生内存碎片（外碎片）。</li>
</ol>
<h4 id="栈和堆的联系："><a href="#栈和堆的联系：" class="headerlink" title="栈和堆的联系："></a>栈和堆的联系：</h4><p>​    堆中对象是直接由栈中的句柄（引用）管理者，所以堆负责产生真实对象，栈负责管理对象。</p>
<p>字符变量实际上并不是将该字符本身放到变量的内存单元，而是将该字符对应的ASCII编码放到变量的存储单元。char的本质就是一个字节大小的整型。</p>
<p>不以f结尾的常量都是double类型，以f结尾的为float类型。</p>
<p>float a = 3.14 实际为double类型转换为float类型。</p>
<p>%p 打印地址，一个变量对应的内存地址编号（无符号十六禁止整型数）</p>
<p>大小端对齐</p>
<p>科学计数：a = 3.2e3f //3.2*1000 = 3200</p>
<p>数据在计算机中主要以补码的形式存储。</p>
<p>数据传输以bit表示。</p>
<p>原码：最高位为符号位，0表示正，1表示负。当两个整数相减或不同符号数相加时，必须比较两个数哪个绝对值大才能决定谁减谁，才能确定结果为正还是负，所以原码不便于加减运算。</p>
<p>反码：正数与原码一样。负数：符号位不变，其它取反。反码运算也不方便，通常用来作为补码的中间过渡。</p>
<p>补码：<strong>计算机系统中，数值一律用补码来存储</strong>。对于正数：原码，反码，补码相同。<strong>负数：补码为它的反码加1</strong>。补码符号位不动，其他位求反,加1得到原码</p>
<p>补码原因：</p>
<ul>
<li>统一零的编码（0在计算机中的存储方式：按照原码和反码都需要区分0和-0）</li>
<li>将符号位和其他位统一处理</li>
<li>将减法运算转变为加法运算</li>
<li>两个补码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="number">10</span>; </span><br><span class="line">原码 <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line">反码 <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line">补码 <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"><span class="keyword">char</span> ch1 = <span class="number">-10</span>;</span><br><span class="line">原码 <span class="number">1000</span> <span class="number">1010</span></span><br><span class="line">反码 <span class="number">1111</span> <span class="number">0101</span></span><br><span class="line">补码 <span class="number">1111</span> <span class="number">0110</span></span><br><span class="line">    </span><br><span class="line">ch + ch1 = <span class="number">0</span></span><br><span class="line"><span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"><span class="number">1111</span> <span class="number">0110</span></span><br><span class="line"><span class="number">1</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">    </span><br><span class="line"><span class="number">76</span> - <span class="number">32</span> 转化为 <span class="number">76</span> + (<span class="number">-32</span>)</span><br><span class="line"><span class="number">76</span>原码 <span class="number">0100</span> <span class="number">1100</span></span><br><span class="line">  反码 <span class="number">0100</span> <span class="number">1100</span></span><br><span class="line">  补码 <span class="number">0100</span> <span class="number">1100</span></span><br><span class="line"><span class="number">-32</span>原码 <span class="number">1010</span> <span class="number">0000</span></span><br><span class="line">   反码 <span class="number">1101</span> <span class="number">1111</span></span><br><span class="line">   补码 <span class="number">1110</span> <span class="number">0000</span></span><br><span class="line"> 	<span class="number">1</span> <span class="number">0010</span> <span class="number">1100</span> </span><br><span class="line">    <span class="number">0010</span> <span class="number">1100</span> 得到原码为： <span class="number">0010</span> <span class="number">1100</span> 为<span class="number">44</span></span><br><span class="line"> <span class="number">76</span> - <span class="number">82</span></span><br><span class="line"> <span class="number">-82</span>原码 <span class="number">1101</span> <span class="number">0010</span></span><br><span class="line">    反码 <span class="number">1010</span> <span class="number">1101</span></span><br><span class="line">    补码 <span class="number">1010</span> <span class="number">1110</span></span><br><span class="line"> 相加：   <span class="number">1111</span> <span class="number">1010</span> 得到原码： <span class="number">1000</span> <span class="number">0110</span> 为<span class="number">-6</span></span><br></pre></td></tr></table></figure>
<p>8bit数据最大存储区间为：[-128, 127]</p>
<p>数据存储时，将-0对应的区间值设为-2^7 也就是-128</p>
<p>无符号：数据在计算机中不存在符号位</p>
<p>usigned char : 0 - 2^8 -1 : 0 - 255</p>
<h4 id="数值溢出"><a href="#数值溢出" class="headerlink" title="数值溢出"></a>数值溢出</h4><p>当超过一个数据类型能够存放最大的范围时，数值会溢出</p>
<p>有符号最高位溢出的区别：符号位溢出会导致数的正负发生变化，但最高位的溢出会导致最高位丢失。</p>
<h4 id="类型限定"><a href="#类型限定" class="headerlink" title="类型限定"></a>类型限定</h4><div class="table-container">
<table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>extern</td>
<td>声明一个变量，extern声明的变量没有建立存储空间。在定义的时候再创建存储空间</td>
</tr>
<tr>
<td>const</td>
<td>定义一个常量，常量的值不能修改</td>
</tr>
<tr>
<td>volatile</td>
<td>防止编译器优化代码</td>
</tr>
<tr>
<td>register</td>
<td>定义寄存器变量，提高效率，建议型的变量而不是命令型的指令。如果CPU有空闲寄存器，则register生效，没有空闲则无效</td>
</tr>
</tbody>
</table>
</div>
<h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><ul>
<li>字符串常量是内存中一段连续的char空间，以’\0’结尾</li>
<li>字符串常量是由双引号括起来的字符序列，如”china”///</li>
</ul>
<p>字符串常量与字符常量的不同：</p>
<p>‘a’为字符常量， 实际存储’a’</p>
<p>”a“为字符串常量 , 实际存储’a’’\0’</p>
<p>每个字符串的结尾，编译器会自动的添加一个结束标志位’\0’，即”a”包含两个字符’a’和’\0’.</p>
<p>占位符%s,表示输出一个字符串，遇到\0停止。</p>
<p>putchar()输出<strong>字符</strong>，可以是变量，字符，数字</p>
<p>getchar()从标准输入设备<strong>读取一个char</strong></p>
<p>scanf()内部参数中不能包含\n,可以用空格，逗号等。。。</p>
<h4 id="运算符号"><a href="#运算符号" class="headerlink" title="运算符号"></a>运算符号</h4><p>算术运算符</p>
<p>两个整数相除一定得到一个整数</p>
<p>取余只能对整数</p>
<p>自增，自减</p>
<p>后自增： a++ ， 先进行表达式计算，再进行++</p>
<p>前自增： ++a ，在表达式之前进行++，再进行表达式计算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = ++a * <span class="number">10</span>;<span class="comment">//  a =  11, b = 110</span></span><br><span class="line"><span class="keyword">int</span> b = a++ * <span class="number">10</span>;<span class="comment">//  a = 11, b = 100 先完成计算，再增加1</span></span><br></pre></td></tr></table></figure>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>c语言的比较运算中，”真“用数字”1”来表示，”假“用数字”0“表示</p>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>单目高于双目运算符</p>
<ol>
<li>[] () . 若同时出现，从左到右</li>
<li>- ~(按位取反) ++ — *(取值运算符) &amp;（取地址运算符） ! (类型)（强制类型转换） sizeof， 从右到左</li>
<li>/ * %</li>
<li>+ - </li>
<li>&lt;&lt; &gt;&gt; </li>
<li>>= &gt; &lt; &lt;=</li>
<li>== !=</li>
<li>&amp; （按位与）</li>
<li>^(按位异或) </li>
<li>|</li>
<li>&amp;&amp;</li>
<li>||</li>
<li>?:</li>
<li>= /= %= -= += &gt;&gt;= &lt;&lt;= &amp;= ^= |= </li>
<li>, 逗号运算符号</li>
</ol>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>不同类型数据之间进行混合运算时必然涉及到类型的转换问题</p>
<p>转换的两种方法：</p>
<ul>
<li>自动转换（隐式转换）：遵循一定的规则，由编译系统自动完成</li>
<li>强制类型转换：把表达式的运算结果强制转换成所需的数据类型</li>
</ul>
<p>类型转换的原则：占用内存字节数少（值域小）的类型向占用内存字节数多（值域大）的类型转换，以保证精度不降低。</p>
<p>强制类型转换运算符，不会四舍五入</p>
<h3 id="程序流程结构"><a href="#程序流程结构" class="headerlink" title="程序流程结构"></a>程序流程结构</h3><p>if (适合多区间，带嵌套)</p>
<p>if else 条件嵌套</p>
<p>if eles if  else</p>
<p>switch case  break default（不适合多区间，执行效率高）</p>
<p>三目运算符： ？：</p>
<p>表达式1?表达式2：表达式3     如果表达式1为真，结果为表达式2,为假则表达式结果为3</p>
<p>while </p>
<p>do while</p>
<h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><p>break 在swith条件语句和循环语句中都可以使用break语句</p>
<ul>
<li>出现在switch条件语句中时，作用是终止某个case并跳出switch结构</li>
<li>当出现在循环语句中，作用是跳出当前内循环语句，执行后面的程序</li>
<li>当出现在嵌套循环语句中，跳出最近的内循环语句，执行后面的程序</li>
</ul>
<p>continue：在循环语句中，如果希望立即终止本次循环，并执行下一次循环，此时需要使用continue语句。</p>
<p>goto语句（无条件跳转，尽量少用）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> FLAG;</span><br><span class="line">xxxx</span><br><span class="line">FLAG;</span><br></pre></td></tr></table></figure>
<h3 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h3><p>数组：把具有相同类型的若干变量按有序形式组织起来。</p>
<p><strong>数组名是一个常量，是一个地址，指向数组首地址。</strong></p>
<p><strong>数组在内存中占用的大小：sizeof(数组名) = 数组类型*数组个数</strong></p>
<p>数组的定义和初始化：{} </p>
<p>数组的个数必须是常量或常量表达式</p>
<p>数组必须预先知道大小，动态数组-&gt;开辟堆空间</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>有行有列</p>
<p><strong>数组的名为一个地址常量，二维数组的arr[0]也为地址常量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;arr[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//所有输出都相等</span></span><br></pre></td></tr></table></figure>
<p>多维数组</p>
<p>嵌套定义</p>
<h4 id="字符数组和字符串"><a href="#字符数组和字符串" class="headerlink" title="字符数组和字符串"></a>字符数组和字符串</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[<span class="number">5</span>] = &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>&#125;; <span class="comment">//字符数组</span></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">6</span>] = &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>&#125;; <span class="comment">//字符串，最后一个arr[5]自动赋值为0,相当于'\0'</span></span><br><span class="line"><span class="keyword">char</span>* arr = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> arr[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> arr[] = &#123;<span class="string">"hello"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>字符串是字符数组的一个特例</p>
<p><strong>字符串结束标志为\0,  数字0等同于\0, 但不等同于’0’</strong></p>
<h4 id="字符数组与字符串的区别"><a href="#字符数组与字符串的区别" class="headerlink" title="字符数组与字符串的区别"></a>字符数组与字符串的区别</h4><ul>
<li>C中没有字符串这种数据类型，可以通过char的数组来替代</li>
<li>字符串一定是一个char的数组，但char的数组未必是字符串</li>
<li>数字0(和字符’\0’等级)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[<span class="number">100</span>] = &#123;<span class="number">110</span>,<span class="number">111</span>,<span class="number">112</span>,<span class="number">32</span>, <span class="number">32</span>,<span class="number">43</span>&#125;;<span class="comment">//数字对应ASCII码，可以打印出字符串</span></span><br></pre></td></tr></table></figure>
<p><strong>gets() 允许输入的字符串含有空格，scanf不允许含有空格</strong></p>
<p>scanf(“%[\^\n]”,ch);//接收非\n的所有内容（通过正则表达式来做约束）</p>
<p>由于scanf和gets无法知道字符串s大小，<strong>必须遇到换行符或读到文件结尾为止才接收输入</strong>，因此容易导致字符数组越界（缓冲区溢出）的情况。</p>
<p>char<em> fgets(char </em>s, int size, FILE <em> stream):从stram指定的文件内读入字符，保存到s所指定的内存空间，直到出现换行字符，<em>*读到文件结尾或是已读了size-1个字符为止，最后会自动加上字符\0作为结束标志。</em></em></p>
<p><strong>如果是从键盘输入，stream为stdin</strong></p>
<p>puts():标准输出字符串，在输出完成后自动输出一个\n</p>
<p>fputf</p>
<p>strlen() 计算指定字符串的长度，不包含字符串结束符\0</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数分类"><a href="#函数分类" class="headerlink" title="函数分类"></a>函数分类</h4><p>系统函数和用户定义的函数</p>
<ul>
<li>系统函数，即库函数：由编译系统提供，用户中不必自己定义，可以直接使用</li>
<li>用户定义函数，用于解决用户的专门需要</li>
</ul>
<p>调用函数的要素：</p>
<ul>
<li>头文件</li>
<li>函数名字，必须和声明的名字一样</li>
<li>功能</li>
<li>参数</li>
<li>返回值</li>
</ul>
<h4 id="函数定义和使用"><a href="#函数定义和使用" class="headerlink" title="函数定义和使用"></a>函数定义和使用</h4><p>返回值类型 函数名 （参数列表）</p>
<p>{</p>
<p>​    代码体；// 函数功能实现的过程</p>
<p>​    return;</p>
<p>}</p>
<p>在不同函数中函数中的变量名可以重名，因为<strong>作用域</strong>不同。</p>
<p>在函数调用过程中传递的参数为实参（有具体的值）。</p>
<p>函数定义中参数称为形式参数。</p>
<p>在函数调用过程中，将实参传递给形参。</p>
<p><strong>在函数调用结束，函数会在内存中销毁。</strong></p>
<p>在定义函数时指定的形参，在未出现函数调用时，它们并不占用内存中的存储单元，因此称为形式参数或者形参，表示它们并不是实际存在的数据，所以，形参中的变量不能赋值。</p>
<p>如果函数返回的类型和return语句中表达式的值不一致，则以函数返回类型为准，即函数返回类型决定返回值的类型。对数值型数据，可以自动进行类型转换。</p>
<p>注意：如果函数返回的类型和return语句中表达式的值不一致，而它又无法自动进行类型转换，程序则会报错。</p>
<p>实参可以常量、变量或表达式，无论实参数是何类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。所以，这里的变量是在圆括号外面定义好的、赋好值的变量。</p>
<p>void类型不可以直接定义数据，void类型可以作为函数的返回值类型，表示没有返回值。</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><ul>
<li><p>函数声明：如果用户自己定义的函数，而该函数与调用它的函数（即主调函数）不在同一文件中，或者函数定义的位置在主调函数之后，则必须在调用此函数之前对被调用的函数做声明。</p>
<ul>
<li>所谓函数声明，就是在函数尚在未定义的情况下，事先将该函数的有关信息通知编译系统，相当于告诉编译器，函数在后面定义，以便编译器能够正常运行。</li>
<li>注意：一个函数只能被定义一次，但可以声明多次。</li>
</ul>
</li>
<li><p>函数定义</p>
</li>
<li><p>函数定义</p>
</li>
</ul>
<h4 id="声明和定义的区别"><a href="#声明和定义的区别" class="headerlink" title="声明和定义的区别"></a>声明和定义的区别</h4><ul>
<li>声明变量不需要建立存储空间，如：extern int a;</li>
<li>定义变量需要建立存储空间，如： int b;</li>
</ul>
<p>从广义的角度来说声明中包含着定义，即定义是声明的一个特例，所以并非所有的声明都是定义。</p>
<ul>
<li>int b; //即是声明，同时又是定义</li>
<li>对于extern b 来说只是声明不是定义</li>
</ul>
<p>一般情况下，把建立存储空间的声明称为“定义”， 而把不需要建立存储空间的声明称为“声明”</p>
<h4 id="主函数和exit函数"><a href="#主函数和exit函数" class="headerlink" title="主函数和exit函数"></a>主函数和exit函数</h4><p>在main函数中调用了exit和return结果是一样的，但在子函数中调用return只是代表子函数终止了，在子函数中使用exit，那么程序终止。</p>
<h4 id="多文件编程"><a href="#多文件编程" class="headerlink" title="多文件编程"></a>多文件编程</h4><p>函数功能实现放在其他.c文件中</p>
<p>函数声明放到.h文件中</p>
<p>.h文件头部 # program once //防止头文件重复包含</p>
<p>头文件一般用于</p>
<ul>
<li>全局变量的定义</li>
<li>函数的声明</li>
</ul>
<p>导入自己定义的头文件，用“xxx.h”</p>
<p>一个相同名字的头文件对应一个相同名字的源文件</p>
<p>为了避免同一个文件被include多次，c/c++中有两种方式：</p>
<ul>
<li><h1 id="ifndef-一般定义的方式为"><a href="#ifndef-一般定义的方式为" class="headerlink" title="ifndef //一般定义的方式为"></a>ifndef //一般定义的方式为</h1><ul>
<li><h1 id="ifndef-SOMEFILEH"><a href="#ifndef-SOMEFILEH" class="headerlink" title="ifndef _SOMEFILEH"></a>ifndef _<em>SOMEFILE<em>H</em></em></h1></li>
<li><h1 id="define-SOMEFILEH"><a href="#define-SOMEFILEH" class="headerlink" title="define _SOMEFILEH"></a>define _<em>SOMEFILE<em>H</em></em></h1></li>
<li><h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1></li>
</ul>
</li>
<li><h1 id="pragma-once-只能用于windows中"><a href="#pragma-once-只能用于windows中" class="headerlink" title="pragma once //只能用于windows中"></a>pragma once //只能用于windows中</h1></li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>内存是沟通CPU和硬盘的桥梁</p>
<ul>
<li>暂存放CPU中的运算数据</li>
<li>暂存与硬盘等外部存储器交换的数据</li>
</ul>
<h4 id="物理存储器和存储地址空间"><a href="#物理存储器和存储地址空间" class="headerlink" title="物理存储器和存储地址空间"></a>物理存储器和存储地址空间</h4><p>物理存储器为实际存在的具体存储器芯片。</p>
<p>存储地址空间：对存储器编码的范围。软件中常说的内存含义。</p>
<ul>
<li>编码：对每个物理存储单元（一个字节）分配一个号码</li>
<li>寻址：可以根据分配的号码找到相应的存储单元，完成数据的读写</li>
</ul>
<h4 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h4><ul>
<li>将内存抽象为一个很大的一维字符数组</li>
<li>编码就是对内存的每一个字节分配一个32位或64位的编号（与处理器的位数有关）</li>
<li>内存编号称为内存地址。内存中的每一个数据都会分配相应的地址。</li>
<li>char:占一个字节分配一个地址</li>
<li>int：占四个字节分配四个地址</li>
<li>float, struct,函数，数组等</li>
</ul>
<p>小端对齐，大端对齐</p>
<p>int*  为一个指针</p>
<p>地址也是一种特殊的数据类型，故存放地址的指针定义需要指明这一点，也就是二级指针的应用。</p>
<p>所有的指针类型存储的都是内存地址，内存地址都是一个无符号十六进制整型数</p>
<p>&amp;是取地址符号，是升维度的</p>
<p>*是取值符号，是降维度的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="number">97</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = &amp;ch; <span class="comment">//指针类型不匹配，后面通过指针访问和修改数据都将报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义指针类型的时候，一定要和变量的类型对应上。</p>
<h4 id="野指针和空指针"><a href="#野指针和空指针" class="headerlink" title="野指针和空指针"></a>野指针和空指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">100</span>;<span class="comment">//野指针，程序中允许存在野指针</span></span><br></pre></td></tr></table></figure>
<p>操作野指针对应的内存空间可能报错</p>
<p>野指针：指针变量指向一个未知的空间</p>
<p>指针变量也是变量，是变量就可以任意赋值，不要越界即可(32位为4字节，64位为8字节)，但是，任意数值赋值给指针变量没有意义，因为这样的指针就变成了野指针，此指针指向的区域是未知的（操作系统不允许操作此指针指向的内存区域）.所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。</p>
<p>但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量（空闲可用），c语言中可以把NULL赋值给此指针，这样就标志此指针为空指针，没有在任何指向。</p>
<p>操作系统将0-255的地址作为系统占用，不允许访问操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0) <span class="comment">//NULL为一个值为0的宏常量,内存地址为0的空间</span></span></span><br></pre></td></tr></table></figure>
<p>操作空指针对应的空间一定会报错</p>
<p>空指针可以用作条件判断： if (p==NULL)</p>
<h4 id="万能指针void"><a href="#万能指针void" class="headerlink" title="万能指针void *"></a>万能指针void *</h4><p>void <em>指针可以<em>*指向任意变量的内存空间</em></em></p>
<p>万能指针可以接收任意类型变量的内存地址</p>
<p>在通过万能指针修改变量的值时，需要找到变量对应的指针类型</p>
<h4 id="const修饰的指针变量"><a href="#const修饰的指针变量" class="headerlink" title="const修饰的指针变量"></a>const修饰的指针变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    *p = <span class="number">100</span>; <span class="comment">//指针间接修改常量的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a); <span class="comment">//a = 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>const修饰指针：</p>
<ul>
<li>const 修饰指针类型：const int* p （p为一个指向int的指针，）可以修改指针变量的值，不可以修改指针指向内存空间的值</li>
<li>const修饰指针变量：int * const p (p为const类型的指针，是一个常量)，可以修改指针指向内存空间的值，不可以修改指针变量的值。</li>
</ul>
<p>const int<em> const p //const修饰指针类型，修饰指针变量，<em>*只读指针</em></em></p>
<h4 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h4><p><strong>数组名是数组的首元素地址，但它是一个常量。</strong></p>
<p>指针类型变量+1,等同于内存地址 + sizeof(type)</p>
<p>两个指针相减，得到的结果是两个指针的偏移量（步长）</p>
<p>所有的指针类型相减结果都是int类型。</p>
<p><strong>数组作为函数参数会退化为指针，丢失了数组的精度</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">char</span>*ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*dest++ = *ch++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;<span class="built_in">array</span>[<span class="number">5</span>];</span><br><span class="line">p[<span class="number">-2</span>]; <span class="comment">//*(p-2),想当于 p[3]</span></span><br></pre></td></tr></table></figure>
<p>指针操作数组时下标允许是负数</p>
<p>指针可以比较大小，逻辑运算，</p>
<h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p>指针数组，是一个数组，数组的每个元素都是指针类型</p>
<p>指针数组里面元素存储的是指针</p>
<p>指针数组是一个特殊的二维数组模型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> c[] = &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指针数组是一个特殊的二维数组模型</span></span><br><span class="line">    <span class="keyword">int</span>* arr[] = &#123;a,b,c&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//arr和&amp;arr[0]是指针数组的首地址</span></span><br><span class="line">    <span class="comment">//指针数组对应二级指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;arr[<span class="number">0</span>]);<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> **p = arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h4><p>二级指针就是指向一个一级指针变量地址的指针。</p>
<p>指针数组和二级指针建立关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> c[] = &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针是一个特殊的二维数组模型</span></span><br><span class="line">    <span class="keyword">int</span> *arr[] = &#123;a,b,c&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针数组和二维指针建立关系</span></span><br><span class="line">    <span class="keyword">int</span> **p = arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, **p);</span><br><span class="line">    <span class="comment">//二级指针加偏移量，相当于跳过了一个一维数组大小</span></span><br><span class="line">    <span class="comment">//一级指针加偏移量，相当于跳过一个元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,**(p+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(*(p+<span class="number">1</span>)+<span class="number">1</span>)); <span class="comment">//arr[1][1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, p[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,*(p[i]+j));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,*(*(p+i)+j));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="值传递和地址传递"><a href="#值传递和地址传递" class="headerlink" title="值传递和地址传递"></a>值传递和地址传递</h4><p>值传递：形参不影响实参的值</p>
<p>地址传递：形参可以改变实参的值</p>
<p>数组名做函数参数，函数的形参会退化为指针。通过函数传递数组，一般都要给定数组的长度。</p>
<p>注意字符串和字符数组的区别</p>
<p>字符串去空格：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_space01</span><span class="params">(<span class="keyword">char</span>* ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> * p = str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch[i]!= <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[i] != <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str[j] = ch[i];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*ch++ = *p++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_space</span><span class="params">(<span class="keyword">char</span>* ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* ftemp = ch;<span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">char</span>* rtemp = ch; <span class="comment">//记录空格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*ftemp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*ftemp != <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *rtemp = *ftemp;</span><br><span class="line">            rtemp++;</span><br><span class="line">        &#125;</span><br><span class="line">        ftemp++; </span><br><span class="line">    &#125;</span><br><span class="line">    *rtemp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> test[] = <span class="string">"  he l  l o"</span>;</span><br><span class="line">    remove_space(test);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul>
<li>代码块作用域（{}之间的一段代码）</li>
<li>函数作用域</li>
<li>文件作用域</li>
</ul>
<p>局部变量：在函数内部定义的变量，使用auto修饰，生命周期：从创建到函数结束</p>
<p>全局变量：在<strong>函数体外定义</strong>，<strong>存放在数据区</strong>，可被<strong>本文件及其它文件中的函数所共用，若其它文件中的函数调用此变量，须用extern声明。</strong></p>
<ul>
<li>全局变量的声明周期和程序运行周期一样</li>
<li>不同文件的全局变量不可重名</li>
<li>全局变量可以和局部变量重名，使用最近的一个</li>
</ul>
<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>在没有运行程序前，也就是程序没有加载到内存之前，可执行程序内部已经分好了3段信息，分别为代码区（text），数据区（data）和未初始化数据区（bss）3个部分。</p>
<h4 id="静态-static-局部变量"><a href="#静态-static-局部变量" class="headerlink" title="静态(static)局部变量"></a>静态(static)局部变量</h4><ul>
<li>static局部变量的作用域也是在定义的函数内有效，在数据区存储</li>
<li><strong>static局部变量的生命周期和程序运行周期一样</strong>，同时static局部变量的值只初始化一次，但可以<strong>赋值多次</strong></li>
<li>static局部变量若未赋以初值，则由系统自动赋值：数值型变量自动赋初值0,字符型变量赋空字符</li>
</ul>
<h4 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h4><p>可以在<strong>本文件中使用，不可以在其他文件中使用</strong></p>
<p>生命周期：数据区保存，从程序开始到程序结束</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量类型</th>
<th>作用域</th>
<th>生命周期</th>
<th>存储位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>局部变量</td>
<td>函数内部</td>
<td>从局部变量创建到函数结束</td>
<td>栈区</td>
</tr>
<tr>
<td>全局变量</td>
<td>项目中所有文件</td>
<td>从程序创建到程序销毁</td>
<td>数据区</td>
</tr>
<tr>
<td>静态局部变量</td>
<td>函数内部</td>
<td>从程序创建到程序销毁</td>
<td>数据区</td>
</tr>
<tr>
<td>静态全局变量</td>
<td>定义所在的文件</td>
<td>从程序创建到程序销毁</td>
<td>数据区</td>
</tr>
</tbody>
</table>
</div>
<p>未初始化数据(根据编译器可能不同)：</p>
<p>局部变量未初始化，值为乱码</p>
<p>未初始化的全局变量，值为0</p>
<ul>
<li>全局初始化数据区/静态数据区（data段）<ul>
<li>该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如：字符串常量）</li>
</ul>
</li>
<li>未初始化数据区（bss区）<ul>
<li>存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为0或者空（NULL）</li>
</ul>
</li>
<li>程序在加载到内存前，<strong>代码区和全局区（data和bss）的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，系统把程序加载到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。</strong></li>
</ul>
<h4 id="全局函数和静态函数"><a href="#全局函数和静态函数" class="headerlink" title="全局函数和静态函数"></a>全局函数和静态函数</h4><p>在c中函数默认为全局的，使用关键字static可以将函数声明为静态，函数定义为static就意味着这个函数只能在定义这个函数的文件中使用，在其他文件中不能使用，即使在其他文件中声明也没用。</p>
<p>对于不同文件中的static函数名可以相同</p>
<p>全局函数的名称是作用域中唯一的（c++中可以多态）</p>
<p>函数可以调用自己，称为递归调用，但一定要有出口</p>
<p>静态函数可以和全局函数重名，但作用域需要根据具体情况定</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数类型</th>
<th>作用域</th>
<th>生命周期</th>
<th>存储位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>全局函数</td>
<td>项目中的所有文件</td>
<td>从程序创建到程序销毁</td>
<td>平时在代码区（唤醒后存在栈区）</td>
</tr>
<tr>
<td>静态函数</td>
<td>定义所在文件中</td>
<td>从程序创建到程序销毁</td>
<td>代码区</td>
</tr>
</tbody>
</table>
</div>
<p>注意：</p>
<ul>
<li>允许在不同的函数中使用相同的变量名，它们代表不同的对象，分配不同的单元，互不干扰</li>
<li>同一源文件中，允许全局变量和局部变量同名，在局部变量的作用域内，全局变量不起作用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//安全的常量，存储区域为数据区常量区</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> abc = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未初始化全局变量</span></span><br><span class="line"><span class="keyword">int</span> a1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化全局变量</span></span><br><span class="line"><span class="keyword">int</span> b1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未初始化静态全局变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> c1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态全局变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> d1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未初始化局部静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> f1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化局部静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> h1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串常量</span></span><br><span class="line">    <span class="keyword">char</span>* p = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//指针</span></span><br><span class="line">    <span class="keyword">int</span>* pp = arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"未初始化全局变量:%p\n"</span>,&amp;a1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化全局变量:%p\n"</span>,&amp;b1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"未初始化静态全局变量:%p\n"</span>,&amp;c1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化全局静态变量:%p\n"</span>,&amp;d1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"局部变量:%p\n"</span>,&amp;e1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"未初始化局部静态变量%p\n"</span>,&amp;f1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化局部静态变量%p\n"</span>,&amp;h1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"字符串常量%p\n"</span>,&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数组%p\n"</span>,arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"指针变量%p\n"</span>,pp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"指针地址%p\n"</span>,&amp;pp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">未初始化全局变量:<span class="number">0x601058</span></span><br><span class="line">初始化全局变量:<span class="number">0x601040</span></span><br><span class="line">未初始化静态全局变量:<span class="number">0x601050</span></span><br><span class="line">初始化全局静态变量:<span class="number">0x601044</span></span><br><span class="line">局部变量:<span class="number">0x7fffee32d54c</span></span><br><span class="line">未初始化局部静态变量<span class="number">0x601054</span></span><br><span class="line">初始化局部静态变量<span class="number">0x601048</span></span><br><span class="line">字符串常量<span class="number">0x7fffee32d550</span></span><br><span class="line">数组<span class="number">0x7fffee32d560</span></span><br><span class="line">指针变量<span class="number">0x7fffee32d560</span></span><br><span class="line">指针地址<span class="number">0x7fffee32d558</span></span><br></pre></td></tr></table></figure>
<p>const修饰的局部常量是不安全的，const修饰的全局常量是安全的</p>
<h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><ul>
<li>代码区：程序执行二进制码（程序指令），特点：（共享:另外的执行程序可以调用它，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。只读：防止程序意外修改了它的指令。代码区还规划了局部变量的相关信息）</li>
<li>数据区：<ul>
<li>初始化数据区(data段)：包含了在程序中明确被初始化的全局变量，已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如：字符串常量）</li>
<li>未初始化数据区(bss段)：存入全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为0或者空NULL</li>
<li>常量区</li>
</ul>
</li>
<li>栈区：系统为每一个应用程序分配一个<strong>临时的空间</strong>（局部变量，局部信息，函数参数，数组），栈区大小为:1M,在windowns中可以扩展到10M,在linux中可以扩展到16M</li>
<li>堆区：存储大数据，图片，音频文件。<ul>
<li>手动开辟 malloc</li>
<li>手动释放 free</li>
</ul>
</li>
</ul>
<p>栈区内存占用从高地址到低地址，数组的[0]从低地址开始。</p>
<p>两个连续的变量保存会存在一定的地址空缺是为了放置直接根据一个变量的地址推到下一个变量的地址。</p>
<p>栈区：先进后出，后进先出</p>
<ul>
<li>栈区（stack）：栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值，返回值，局部变量等。在程序运行过程中实时加载和释放。因此：局部变量的生存周期为申请到释放该段栈空间。</li>
<li>堆区（heap）：堆是一个大容器，其容量要远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</li>
</ul>
<h4 id="堆空间开辟和释放"><a href="#堆空间开辟和释放" class="headerlink" title="堆空间开辟和释放"></a>堆空间开辟和释放</h4><p>void* malloc(size_t size);</p>
<p>在<strong>内存的动态存储区（堆区）分配一块长度为size字节的连续区域</strong>，用来存放类型说明符指定的类型，分配的内存空间内容不确定，一般使用memset初始化。</p>
<p>int<em> p = (int</em>) malloc (sizeof(int) *1024);</p>
<p>void free(void* ptr);</p>
<p>释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址，对同一内存空间释放多次会出错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//栈区大小</span></span><br><span class="line">    <span class="comment">// int arr[820000*3] =&#123;0&#125;;//段错误，核心转移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开辟空间存储</span></span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,p);</span><br><span class="line">    <span class="comment">//使用堆空间</span></span><br><span class="line">    *p = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*p);</span><br><span class="line">    <span class="comment">//释放空间</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//p为野指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,p);</span><br><span class="line">    *p = <span class="number">456</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0x195b010</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">0x195b010</span></span><br><span class="line"><span class="number">456</span></span><br></pre></td></tr></table></figure>
<p>为了避免野指针的出现，一般将指针赋值为NULL.</p>
<p>开辟的空间使用指针或者数组的方式来进行操作</p>
<h4 id="内存处理函数"><a href="#内存处理函数" class="headerlink" title="内存处理函数"></a>内存处理函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memset</span><span class="params">(<span class="keyword">void</span>* s,<span class="keyword">int</span> c,<span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>将内存区域的前n个字节以参数c填入，返回值，s的首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置内存空间的值</span></span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="string">'c'</span>,<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span>* dest, <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>拷贝src所指的内存内容的前n个字节到dest所指的内存地址上。</p>
<p>注意：dest和src所指的内存空间不可重叠，可能会导致程序报错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>memcpy()与strcpy()的区别：</p>
<p>字符串拷贝遇到\0则自动结束，内存拷贝不会出现类似情况</p>
<p>内存拷贝：拷贝的内容和字节有关，和拷贝内容无关</p>
<p>如果拷贝的目标和源发生重叠，可能报错</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">memmove()<span class="comment">//用法和memcpy一样，区别在于：dest和src所指的内存空间重叠时，memmove（）仍然能处理，不过执行效率比memcpy低</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* st, <span class="keyword">const</span> <span class="keyword">void</span>* s2, <span class="keyword">size_t</span> n)</span></span>;<span class="comment">//比较s1和s2所指向内存区域的前n个字节 </span></span><br><span class="line"><span class="comment">//返回值：0,1,-1 等于，大于，小于</span></span><br></pre></td></tr></table></figure>
<h4 id="内存常见的问题"><a href="#内存常见的问题" class="headerlink" title="内存常见的问题"></a>内存常见的问题</h4><p>空指针允许多次释放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//传值</span></span><br><span class="line">    p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span>** p)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//传地址</span></span><br><span class="line">    *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"形参%p\n"</span>,*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//返回地址</span></span><br><span class="line">    <span class="keyword">int</span>* p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) *<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//数组下标越界</span></span><br><span class="line">    <span class="comment">// char* p = (char*)malloc(sizeof(char)*10);</span></span><br><span class="line">    <span class="comment">// strcpy(p,"hello worldS");</span></span><br><span class="line">    <span class="comment">// printf("%s\n",p);</span></span><br><span class="line">    <span class="comment">// free(p);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//野指针</span></span><br><span class="line">    <span class="comment">// int* p = (int*)malloc(0);</span></span><br><span class="line">    <span class="comment">// printf("%p\n",p);</span></span><br><span class="line">    <span class="comment">// *p = 100;</span></span><br><span class="line">    <span class="comment">// printf("%d\n",*p);</span></span><br><span class="line">    <span class="comment">// free(p); //windows下程序挂，linux似乎做了优化？</span></span><br><span class="line">    <span class="comment">// return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//多次释放空间</span></span><br><span class="line">    <span class="comment">// int* p = malloc(sizeof(int)*10);</span></span><br><span class="line">    <span class="comment">// free(p);</span></span><br><span class="line">    <span class="comment">// //解决办法</span></span><br><span class="line">    <span class="comment">// p = NULL; //空指针允许多次释放</span></span><br><span class="line">    <span class="comment">// free(p);//放弃，核心已转储</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// fun(p); //形参和实参一致，都是值传递</span></span><br><span class="line"></span><br><span class="line">    fun1(&amp;p); <span class="comment">//地址传递</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* p1 = fun2();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p1[i] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二级指针对应的堆空间"><a href="#二级指针对应的堆空间" class="headerlink" title="二级指针对应的堆空间"></a>二级指针对应的堆空间</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//开辟二级指针对应的堆空间</span></span><br><span class="line">    <span class="keyword">int</span>** p = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) *<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//开辟一级指针对应的堆空间</span></span><br><span class="line">        p[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i][j] = i+j;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//free</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。</p>
<p>有时需要<strong>将不同类型的数据组合成一个有机的整体</strong>。显然单独定义变量会比较繁琐，数据不方便管理</p>
<p>定义结构体变量的方式：</p>
<ul>
<li>先声明结构体类型再定义变量名 struct stu{成员列表}; struct stu Mike;</li>
<li>在声明类型的同时定义变量。struct stu{成员列表}Mike,Bod;</li>
<li>直接定义结构体类型变量（无类型名）.struct {成员变量} Mike,Bob;</li>
</ul>
<p>结构体类型和结构体变量关系：</p>
<ul>
<li>结构体类型：指定了一个结构体类型，相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元</li>
<li>结构体变量：系统根据结构体类型（内部成员状况）为止分配空间。</li>
</ul>
<p>结构体数组：</p>
<p>结构体成员需要<strong>偏移对齐</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">int</span> score[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>[3]=</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        &#123;<span class="string">"黄x航"</span>,<span class="number">22</span>,<span class="string">'M'</span>,<span class="number">89</span>,<span class="number">90</span>,<span class="number">89</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"码x东"</span>,<span class="number">18</span>,<span class="string">'F'</span>,<span class="number">89</span>,<span class="number">54</span>,<span class="number">65</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"司正x"</span>,<span class="number">32</span>,<span class="string">'M'</span>,<span class="number">89</span>,<span class="number">98</span>,<span class="number">98</span>&#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span><span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span><span class="number">-1</span>-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stu[j].age &gt;stu[j+<span class="number">1</span>].age)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">temp</span> = <span class="title">stu</span>[<span class="title">j</span>];</span></span><br><span class="line">                stu[j] = stu[j+<span class="number">1</span>];</span><br><span class="line">                stu[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h4><h4 id="结构体赋值"><a href="#结构体赋值" class="headerlink" title="结构体赋值"></a>结构体赋值</h4><p>用=可以进行复制</p>
<p>深拷贝和浅拷贝</p>
<h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><p>若结构体中包含有指针类型的成员数据，则在给结构体变量赋值的时候需要考虑指针赋值（是开辟新空间或是赋常量的值）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> scores[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">51</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结构体指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">ss</span> = &#123;</span><span class="string">"test"</span>,<span class="number">30</span>, <span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="string">"边境"</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span>* <span class="title">p</span> = &amp;<span class="title">ss</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,(*p).name);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p-&gt;addr);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">ss</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span>* scores;</span><br><span class="line">    <span class="keyword">char</span>* addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ss* p = (ss*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ss)*<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i].name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">21</span>);</span><br><span class="line">        p[i].scores = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">3</span>);</span><br><span class="line">        p[i].addr = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">21</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d%d%d%s"</span>,p[i].name,&amp;p[i].age,</span><br><span class="line">        &amp;p[i].scores[<span class="number">0</span>],&amp;p[i].scores[<span class="number">1</span>],&amp;p[i].scores[<span class="number">2</span>],p[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>,p[i].name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i].age);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i].scores[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,(p+i)-&gt;scores[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,(p+i)-&gt;scores[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,(p+i)-&gt;addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放存储空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p[i].name);</span><br><span class="line">        <span class="built_in">free</span>(p[i].scores);</span><br><span class="line">        <span class="built_in">free</span>(p[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a>结构体做函数参数</h4><ul>
<li><p>结构体普通变量做函数参数</p>
</li>
<li><p>结构体指针变量做函数参数</p>
</li>
<li><p>结构体数组名做函数参数</p>
</li>
<li><p>const修饰结构体指针形参变量</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">ss</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">51</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun01</span><span class="params">(ss stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(stu.name,<span class="string">"lujunyi"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,stu.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ss stu = &#123;<span class="string">"宋江"</span>,<span class="number">50</span>,<span class="number">101</span>,<span class="string">"水船"</span>&#125;;</span><br><span class="line">    fun01(stu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,stu.name); <span class="comment">//值传递，不改变</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">ss</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">21</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun02</span><span class="params">(ss* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">"公孙胜"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结构体指针作为函数参数</span></span><br><span class="line">    ss stu = &#123;<span class="string">"吴用"</span>,<span class="number">50</span>, <span class="number">101</span>,<span class="string">"水泊梁山"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    fun02(&amp;stu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,stu.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体数组做函数参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">ss</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">21</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组作为函数参数退化为指针，丢失元素精度，需要传递个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ss stu[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;len-i<span class="number">-1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stu[j].age &gt;stu[j+<span class="number">1</span>].age)</span><br><span class="line">            &#123;</span><br><span class="line">                ss temp = stu[j];</span><br><span class="line">                stu[j] = stu[j+<span class="number">1</span>];</span><br><span class="line">                stu[j+<span class="number">1</span>] = temp; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ss stu[<span class="number">3</span>] = </span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">"鲁智深"</span>,<span class="number">30</span>,<span class="number">78</span>,<span class="string">"五台山"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"呼吁"</span>,<span class="number">29</span>,<span class="number">78</span>,<span class="string">"三台山"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"呈共"</span>,<span class="number">31</span>,<span class="number">87</span>,<span class="string">"滇池"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BubbleSort(stu, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\t%d\t%d\t%s\n"</span>,stu[i].name,stu[i].age,stu[i].score,stu[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Go鸭子类似</title>
    <url>/2020/01/02/Go%20%E6%8E%A5%E5%8F%A3_2Go%E8%AF%AD%E8%A8%80%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h3><p>维基百科: 如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。</p>
<ul>
<li><p><code>Duck Typing</code>，鸭子类型，是<strong>动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身</strong>。</p>
</li>
<li><p>Go 语言作为一门静态语言，它通过<strong>通过接口的方式完美支持鸭子类型</strong>。</p>
</li>
</ul>
<h3 id="动态语言实现"><a href="#动态语言实现" class="headerlink" title="动态语言实现"></a>动态语言实现</h3><p>动态语言的特点：</p>
<blockquote>
<p>变量绑定的类型是不确定的，在运行期间才能确定<br>函数和方法可以接收任何类型的参数，且调用时不检查参数类型<br>不需要实现接口</p>
</blockquote>
<p>在动态语言 python 中，定义一个这样的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">(coder)</span>:</span></span><br><span class="line">    coder.say_hello()</span><br></pre></td></tr></table></figure>
<p>当调用此函数的时候，可以传入任意类型，只要它实现了 <code>say_hello()</code> 函数就可以。如果没有实现，<strong>运行过程</strong>中会出现错误。</p>
<h3 id="静态语言实现"><a href="#静态语言实现" class="headerlink" title="静态语言实现"></a>静态语言实现</h3><p>而在静态语言如 Java, C++ 中，必须要<strong>显示地声明实现了某个接后，才能用在任何需要这个接口的地方。</strong> <strong>如果你在程序中调用 <code>hello_world</code> 函数，却传入了一个根本就没有实现 <code>say_hello()</code> 的类型，那在编译阶段就不会通过。</strong>这也是静态语言比动态语言更安全的原因。</p>
<p>动态语言和静态语言的差别在此就有所体现。<strong>静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。</strong></p>
<p>静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，eg. python 。</p>
<h3 id="Go鸭子类型实现"><a href="#Go鸭子类型实现" class="headerlink" title="Go鸭子类型实现"></a>Go鸭子类型实现</h3><p>Go 语言作为一门现代静态语言，是有后发优势的。它<strong>引入了动态语言的便利，同时又会进行静态语言的类型检查</strong>，写起来是非常高效的。</p>
<p>Go 采用了折中的做法：<strong>不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。</strong></p>
<p>例子：</p>
<p>定义一个接口，和使用此接口作为参数的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IGreeting <span class="keyword">interface</span> &#123;</span><br><span class="line">	sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(i IGreeting)</span></span> &#123;</span><br><span class="line">	i.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义两个结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Go <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Go)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hi, I am GO!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PHP <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PHP)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hi, I am PHP!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在 main 函数里调用 sayHello() 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	golang := Go&#123;&#125;</span><br><span class="line">	php := PHP&#123;&#125;</span><br><span class="line"></span><br><span class="line">	sayHello(golang)</span><br><span class="line">	sayHello(php)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hi, I am GO!</span><br><span class="line">Hi, I am PHP!</span><br></pre></td></tr></table></figure>
<p><strong>在 main 函数中，调用 sayHello() 函数时，传入了 <code>golang, php</code> 对象，它们并没有显式地声明实现了 IGreeting 类型，只是实现了接口所规定的 sayHello() 函数。实际上，编译器在调用 sayHello() 函数时，会隐式地将 <code>golang, php</code> 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>鸭子类型是一种动态语言的风格，在这种风格中，<strong>一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它”当前方法和属性的集合”决定。Go 作为一种静态语言，通过接口实现了 <code>鸭子类型</code>，实际上是 Go 的编译器在其中作了隐匿的转换工作。</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【Golang 与鸭子类型，讲得比较好】<a href="https://blog.csdn.net/cszhouwei/article/details/33741731" target="_blank" rel="noopener">https://blog.csdn.net/cszhouwei/article/details/33741731</a></p>
<p>【各种面向对象的名词】<a href="https://cyent.github.io/golang/other/oo/" target="_blank" rel="noopener">https://cyent.github.io/golang/other/oo/</a></p>
]]></content>
      <categories>
        <category>Go接口</category>
      </categories>
      <tags>
        <tag>接口 鸭子类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Go接口与C++接口的异同</title>
    <url>/2020/01/02/Go%20%E6%8E%A5%E5%8F%A3_1Go%E4%B8%8E%20C++%20%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<h3 id="接口设计的意义"><a href="#接口设计的意义" class="headerlink" title="接口设计的意义"></a>接口设计的意义</h3><ul>
<li>泛型编程：使用 interface 可以实现泛型编程</li>
<li>隐藏具体实现：设计一个函数返回一个 interface，那么<strong>只能通过 interface 里面的方法来做一些操作，但是内部的具体实现是完全不知道的。</strong></li>
</ul>
<h3 id="golang中的接口"><a href="#golang中的接口" class="headerlink" title="golang中的接口"></a>golang中的接口</h3><p>接口定义了一种<strong>规范，描述了类的行为和功能，而不做具体实现</strong>。</p>
<p>Interface定义了一个或一组method(s)，<strong>这些method(s)只有函数签名，没有具体的实现代码</strong>.</p>
<p>若某个数据类型实现了Interface中定义的那些被称为”methods”的函数，则称这些<strong>数据类型实现（implement）了interface。</strong></p>
<h3 id="C-中的接口实现方法"><a href="#C-中的接口实现方法" class="headerlink" title="C++中的接口实现方法"></a>C++中的接口实现方法</h3><p>C++ 的接口是使用<strong>抽象类</strong>来实现的，如果类中至少有一个函数被声明为<strong>纯虚函数</strong>，则这个类就是抽象类。<strong>纯虚函数是通过在声明中使用 “= 0” 来指定的</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 纯虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="built_in">string</span> name;      <span class="comment">// 名称</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设计抽象类的目的:<strong>为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</strong></p>
<p><strong>派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数</strong>。</p>
<h3 id="golang接口与C-接口区别"><a href="#golang接口与C-接口区别" class="headerlink" title="golang接口与C++接口区别"></a>golang接口与C++接口区别</h3><ul>
<li><p>C++ 定义接口的方式称为“侵入式”</p>
</li>
<li><p>Go 采用的是 “非侵入式”，<strong>不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。</strong></p>
</li>
<li><p>底层实现不同</p>
<ul>
<li>实现方式：C++ 通过<strong>虚函数表来实现基类调用派生类的函数</strong>；而 Go 通过 <code>itab</code> 中的 <code>fun</code> 字段来实现接口变量调用实体类型的函数。</li>
<li>编译生成过程：C++ 中的<strong>虚函数表是在编译期生成</strong>的；而 Go 的 <code>itab</code> 中的 <code>fun</code> 字段是在<strong>运行期间动态生成</strong>的。原因在于，<strong>Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 <code>itab</code></strong>， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Go接口</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言条件编译</title>
    <url>/2019/12/27/c_%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>要开发一个C语言程序，让它输出红色的文字，并且要求跨平台，在 Windows 和 Linux 下都能运行，怎么办呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> _WIN32</span></span><br><span class="line">        system(<span class="string">"color 0c"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"xxxxtest1\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">elif</span> __linux__</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\033[22;31mxxxtest2m"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"xxxxtest3n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#if、#elif、#else 和 #endif 都是预处理命令，整段代码的意思是：如果宏 <em>WIN32 的值为真，就保留第 4、5  行代码，删除第 7、9 行代码；如果宏 <em>_linux</em></em> 的值为真，就保留第 7 行代码；如果所有的宏都为假，就保留第 9 行代码。</p>
<p> <strong>这些操作都是在预处理阶段完成的，多余的代码以及所有的宏都不会参与编译，不仅保证了代码的正确性，还减小了编译后文件的体积。</strong></p>
<p> 这种能够<strong>根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。条件编译是预处理程序的功能，不是编译器的功能。</strong></p>
<h4 id="if用法"><a href="#if用法" class="headerlink" title="#if用法"></a>#if用法</h4><p>#if 用法的一般格式为：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">if</span> 整型常量表达式1</span></span><br><span class="line">  程序段<span class="number">1</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">elif</span> 整型常量表达式2</span></span><br><span class="line">  程序段<span class="number">2</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">elif</span> 整型常量表达式3</span></span><br><span class="line">  程序段<span class="number">3</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  程序段<span class="number">4</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>它的意思是：如常“表达式1”的值为真（非0），就对“程序段1”进行编译，否则就计算“表达式2”，结果为真的话就对“程序段2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 #else。这一点和 if else 非常类似。</p>
<p>#elif 和 #else 也可以省略，如下所示： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> _WIN32</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is Windows!\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Unknown platform!\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> __linux__</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is Linux!\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ifdef用法"><a href="#ifdef用法" class="headerlink" title="#ifdef用法"></a>#ifdef用法</h4><p>#ifdef 用法的一般格式为： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  宏名</span></span><br><span class="line">    程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>它的意思是，如果当前的宏已被定义过，则对“程序段1”进行编译，否则对“程序段2”进行编译。</p>
<p>也可以省略 #else： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  宏名</span></span><br><span class="line">    程序段</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>VS/VC 有两种编译模式，Debug 和 Release。在学习过程中，我们通常使用 Debug 模式，这样便于程序的调试；而最终发布的程序，要使用 Release 模式，这样编译器会进行很多优化，提高程序运行效率，删除冗余信息。</p>
<p>为了能够清楚地看到当前程序的编译模式，我们不妨在程序中增加提示，请看下面的代码： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"正在使用 Debug 模式编译程序...\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"正在使用 Release 模式编译程序...\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当以 Debug 模式编译程序时，宏 _DEBUG 会被定义，预处器会保留第 5 行代码，删除第 7 行代码。反之会删除第 5 行，保留第 7 行。</p>
<h4 id="ifndef-的用法"><a href="#ifndef-的用法" class="headerlink" title="#ifndef 的用法"></a>#ifndef 的用法</h4><p>#ifndef 用法的一般格式为： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> 宏名</span></span><br><span class="line">    程序段<span class="number">1</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">    程序段<span class="number">2</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>与 #ifdef 相比，仅仅是将 #ifdef 改为了 #ifndef。它的意思是，如果当前的宏未被定义，则对“程序段1”进行编译，否则对“程序段2”进行编译，这与 #ifdef 的功能正好相反。</p>
<h4 id="区别与注意"><a href="#区别与注意" class="headerlink" title="区别与注意"></a>区别与注意</h4><p>#if 后面跟的是“整型常量表达式”，而 #ifdef 和 #ifndef 后面跟的只能是一个宏名，不能是其他的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> NUM == 10 || NUM == 20</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NUM: %d\n"</span>, NUM);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NUM Error\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再如，两个宏都存在时编译代码A，否则编译代码B： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM1 10</span></span><br><span class="line"><span class="comment">// #define NUM2 20</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> (defined NUM1 &amp;&amp; defined NUM2)</span></span><br><span class="line">        <span class="comment">//代码A</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NUM1: %d, NUM2: %d\n"</span>, NUM1, NUM2);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">//代码B</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ifdef-可以认为是-if-defined-的缩写"><a href="#ifdef-可以认为是-if-defined-的缩写" class="headerlink" title="ifdef 可以认为是 #if defined 的缩写"></a>ifdef 可以认为是 #if defined 的缩写</h1>]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c语言条件编译</tag>
      </tags>
  </entry>
  <entry>
    <title>linux相关操作笔记</title>
    <url>/2019/12/26/linux%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>linux只是操作系统的内核。</p>
<ul>
<li><p>Redhat系列：企业版：redhat，centos</p>
</li>
<li><p>Debian系列：debian，ubuntu</p>
</li>
</ul>
<p>Ubuntu:</p>
<ul>
<li>命名规则：前两位数字：发行时的年份的最后两位数字，</li>
<li>后两位：发行的月份，04表示4月份发行的稳定版;10表示10月份发行的测试版。</li>
</ul>
<p>版本：</p>
<ul>
<li>桌面版：至少三年的技术支持</li>
<li><p>服务器版：至少五年的技术支持</p>
</li>
<li><p>发布频率：一年两次</p>
<ul>
<li>单数年，段期支持</li>
<li>双数年，长期支持，LTS</li>
</ul>
</li>
</ul>
<h2 id="Linux快捷键"><a href="#Linux快捷键" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h2><h3 id="命令解析器"><a href="#命令解析器" class="headerlink" title="命令解析器"></a>命令解析器</h3><p>shell — unix操作系统</p>
<p>bash — linux操作系统 Bone重新写了shell</p>
<p>本质：<strong>根据命令的名字，调用对应的可执行程序，命令解析器调用</strong></p>
<h3 id="Linux快捷键-1"><a href="#Linux快捷键-1" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h3><p>ctrl  + p  历史命令向上</p>
<p>ctrl + n 历史命令向下</p>
<p>ctrl + b 命令光标向前</p>
<p>ctrl + f 命令光标向后</p>
<p>ctrl + a 光标到行首</p>
<p>ctrl + e 行尾部</p>
<p>字符删除：</p>
<p>删除前面的：ctrl + h</p>
<p>删除后面的：ctrl + d</p>
<p>删除一部分：</p>
<p>前面： crtl + u</p>
<p>Tab键智能提示，自动补充命令，路径</p>
<h3 id="Linux下的目录结构"><a href="#Linux下的目录结构" class="headerlink" title="Linux下的目录结构"></a>Linux下的目录结构</h3><p>/ 根目录 ls /</p>
<p>/bin  Binary 缩写，<strong>该目录存放经常使用的命令</strong>。自动配置了环境变量，执行过程自动加载目录</p>
<p>/boot <strong>存放开机启动项文件</strong>，包括一些连接文件以及镜像文件</p>
<p>/dev Device的缩写，该目录下存放Linux的外部设备，在Linux中访问设备的方式和访问文件相同。</p>
<p>/etc <strong>存放所有系统管理所需要的配置文件和子目录</strong>。</p>
<p>/home <strong>用户的主目录，在linux中，每个用户都有一个自己的目录，一般该目录名是以用户的帐号命名的。</strong></p>
<p>/lib <strong>该目录存放系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件，几乎所有的应用程序都需要这些共享库。</strong></p>
<p>/lost+found 一般情况下都是空，当系统非法关机后，这里存放一些文件碎片。</p>
<p>/media linux系统自动识别一些设备，例如U盘，光驱等。<strong>当识别后，linux会将识别的设备挂载到这个目录。</strong></p>
<p>/mnt <strong>为了让用户临时挂载别的文件系统，可以将光驱挂载在/mnt上</strong>，然后进入该目录就可以查看光驱里的内容。</p>
<p>/opt 给主机额外安装软件所摆放的目录</p>
<p>/root <strong>系统管理员，也称为超级权限者的用户主目录</strong></p>
<p><strong>/sbin S为Super User的意思，存放的是系统管理者使用的系统管理程序。</strong></p>
<p>/usr <strong>user software resource，用户的很多应用程序和文件都在这个目录下，类似windows下的program files目录</strong></p>
<p>/var 存放不断扩充的东西，习惯将经常修改的目录放在这个目录下，包括各种日志文件</p>
<h3 id="用户目录"><a href="#用户目录" class="headerlink" title="用户目录"></a>用户目录</h3><p>绝对路径:  知道如何写，从根目录开始写</p>
<p>相对路径： </p>
<ul>
<li>. 当前目录</li>
<li>.. 上一级目录</li>
<li>- 邻近的两个目录间切换</li>
</ul>
<p>dongshifu@dong:~$</p>
<ul>
<li>dongshifu:当前登录的用户</li>
<li>@ 在 dong这台主机下</li>
<li>~:用户的家目录（宿主目录）</li>
<li>$: 当前用户的普通用户。若为# 则表示超级用户</li>
</ul>
<h3 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h3><p>查看目录：</p>
<ul>
<li>tree ，一般情况下文件和目录的颜色。白色，红色，绿色，蓝色，黄色</li>
<li>ls</li>
</ul>
<p>目录切换</p>
<ul>
<li>cd +目录</li>
<li>pwd 查看当前位置</li>
</ul>
<p>创建目录</p>
<ul>
<li>mkdir dirname</li>
<li>创建复合目录（多级目录） mkdir -p </li>
</ul>
<p>删除目录</p>
<ul>
<li>rmdir 删除空目录</li>
<li>rm -rf (r表示递归，-i会提示)  -f 强制删除</li>
</ul>
<p>在目录中创建文件</p>
<ul>
<li>touch 若文件不存在，创建文件，若文件存在，修改文件的时间</li>
</ul>
<p>文件的拷贝</p>
<ul>
<li>cp eg. cp hello.c tmp（文件不存在则创建文件，文件存在则覆盖文件）</li>
</ul>
<p><strong>目录的拷贝</strong></p>
<ul>
<li><strong>cp 要拷贝目录  newdir -r</strong></li>
</ul>
<p>查看文件具体信息</p>
<ul>
<li>ls -al</li>
<li>cat 文件名 适合内容少的文件</li>
<li>more 空格翻页，q退出</li>
<li>less </li>
<li>head 文件的前多少行 - number</li>
<li>tail 文件的后多少行</li>
</ul>
<p>mv命令</p>
<ul>
<li>mv</li>
<li>移动文件 mv</li>
</ul>
<p>软链接相当于快捷方式</p>
<ul>
<li>创建软链接，源文件要使用绝对路径</li>
<li>软链接大小：源文件+路径的总字节数</li>
<li>目录可以创建软链接</li>
</ul>
<p>eg. ln -s /home/a.txt（源文件名+绝对路径） a.test(软链接的名字)</p>
<p>硬链接：映射到inode，不占用磁盘空间。 ln hello.c hello.hard</p>
<ul>
<li>以文件副本的形式存在。但不占用实际空间</li>
<li>不允许给目录创建硬链接</li>
<li>硬链接只有在同一个文件系统中才能创建</li>
</ul>
<p>硬链接能够同步更新：</p>
<ul>
<li>linux下每一个文件都对应一个Inode，创建硬链接后，两个文件的Inode是相同的</li>
<li>查看文件的Inode: stat a.txt</li>
<li>文件创建硬链接后，硬链接计数+1, 删除一个硬链接，硬链接计数-1</li>
</ul>
<p><strong>linux文件系统的存储单位是块。inode — i结点(相当于索引)，保存了一些文件信息，通过inode找到对应的文件。硬链接映射的都是文件的inode（可以理解为某一个位置）。</strong></p>
<p>软链接需要指定绝对地址。</p>
<h4 id="文件或目录属性"><a href="#文件或目录属性" class="headerlink" title="文件或目录属性"></a>文件或目录属性</h4><ul>
<li>wc 获取<strong>文本文件</strong>的基本信息（行数，单词个数[空格区分]，字节数，文件名）</li>
<li>od -t （指定数据的显示格式） 二进制文件查看 </li>
<li>du 查看当前目录的大小 du -h (human)</li>
<li>df 磁盘的使用情况 df -h</li>
</ul>
<p>which  命令：查看使用的命令（只能查看外部的命令，内建命令难以查询）所在的目录</p>
<h4 id="文件权限，用户，用户组"><a href="#文件权限，用户，用户组" class="headerlink" title="文件权限，用户，用户组"></a>文件权限，用户，用户组</h4><p>查看当前登录的用户： whoami</p>
<p>修改文件权限：</p>
<ul>
<li>文字设定法：chmod [who] [+]-[=] [mode]<ul>
<li>who: 文件所有者 u, 文件所属组：g, 其他人: o， 所有的人：a</li>
<li>+/ 增加权限 - 减少权限， = 覆盖原来的权限</li>
<li>mode ： r读，w写，x执行</li>
<li>eg： chmod o+w temp</li>
<li>chmod a=w temp</li>
</ul>
</li>
<li>数字设定法<ul>
<li>- 表示没有</li>
<li>r  4</li>
<li>w 2</li>
<li>x 1</li>
<li>765 —-rwx—-文件所有者 —-rw—-文件所属组 —-r-x—-其他人</li>
<li>chmod -001 </li>
</ul>
</li>
</ul>
<h4 id="修改文件所有者和所属组"><a href="#修改文件所有者和所属组" class="headerlink" title="修改文件所有者和所属组"></a>修改文件所有者和所属组</h4><p>chown 用户名 文件/目录名</p>
<p>chown 所有者:所属组 文件/目录名</p>
<p>chgrp ABC temp 修改temp所属组为ABC</p>
<h4 id="目录必须有的权限"><a href="#目录必须有的权限" class="headerlink" title="目录必须有的权限"></a>目录必须有的权限</h4><p>必须有执行权限，否则无法进入</p>
<p>chmod a-x mytest # mytest的用户、组以及其他用户都减执行权限</p>
<h4 id="文件的查找"><a href="#文件的查找" class="headerlink" title="文件的查找"></a>文件的查找</h4><p>查找某个目录下是否有某个文件：</p>
<p>按文件属性查找：</p>
<ul>
<li>按照文件名字查找： find + 查找的目录 + -name  +“文件的名字”</li>
<li>按照文件大小查找： find  + 查找的目录 + -size  + 大小(+表示大小， -表示小于)。 find /home -size +10K -size -100M</li>
<li>按照文件类型查找：find + 查找目录 + -type +d/f/c/s/p/l</li>
</ul>
<p>按文件内容查找：</p>
<ul>
<li>grep -r(递归查找) “查找的内容” + 查找的路径</li>
</ul>
<p>通配符： * 所有， ？一个字符</p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p><img src="./figure/install.png" alt=""></p>
<p>软件列表：存放软件的名字和下载地址</p>
<h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>磁盘设备种类：</p>
<ul>
<li>sd :SCSI Device</li>
<li>hd : Hard Disk硬盘</li>
<li>fd : Floppy Disk 软盘</li>
</ul>
<p>硬盘1:sda </p>
<ul>
<li>主分区：最多有四个<ul>
<li>主分区1：sda1</li>
<li>主分区2:  sda2</li>
<li>主分区3:  sda3</li>
<li>主分区4: sda4</li>
</ul>
</li>
<li>扩展分区：第一个逻辑分区从sda5开始：<ul>
<li>逻辑分区1:sda5</li>
<li>逻辑分区2: sda6</li>
</ul>
</li>
</ul>
<p>mount 命令会临时覆盖挂载目录，umount后则恢复。</p>
<h4 id="压缩包管理"><a href="#压缩包管理" class="headerlink" title="压缩包管理"></a>压缩包管理</h4><p>扩展版：</p>
<ul>
<li>gzip：.gz格式的压缩包<ul>
<li>不会保留原文件，默认不会打包压缩</li>
<li>gunzip 解压</li>
<li>不能压缩目录</li>
</ul>
</li>
<li>bzip: .bz2格式的压缩包<ul>
<li>不会保留原文件，默认不会打包压缩  -k选项可以保留原文件</li>
<li>bunzip 解压</li>
<li>不能压缩目录</li>
</ul>
</li>
</ul>
<p>好用版：</p>
<ul>
<li>tar<ul>
<li>参数<ul>
<li>c —创建：压缩</li>
<li>x —解压缩，释放</li>
<li>v — 显示提示信息</li>
<li>f —指定压缩文件的名字</li>
<li>z —使用gzip的方式压缩文件， 后缀为.gz</li>
<li>j —使用bzip2的方式压缩文件， —bz2</li>
</ul>
</li>
<li>压缩<ul>
<li>tar zcvf 生成压缩包的名字(xxx.tar.gz)  要压缩的文件或目录</li>
<li>tar jcvf 生成压缩包的名字(xxx.tar.bz2) 要压缩的文件或目录</li>
</ul>
</li>
<li>解压缩<ul>
<li>tar jxvf 压缩包的名字(解压到当前目录)</li>
<li>-C 指定解压目录</li>
</ul>
</li>
</ul>
</li>
<li>rar<ul>
<li>参数<ul>
<li>压缩： a</li>
<li>解压缩 : x</li>
</ul>
</li>
<li>压缩<ul>
<li>rar a 生成文件 要压缩的文件</li>
</ul>
</li>
<li>解压缩<ul>
<li>rar x 要解压的文件 解压目录</li>
</ul>
</li>
</ul>
</li>
<li>zip<ul>
<li>参数</li>
<li>压缩<ul>
<li>zip 要生成压缩包名字 压缩的文件或目录</li>
</ul>
</li>
<li>解压缩<ul>
<li>unzip 压缩包的名字</li>
<li>unzip 压缩包的名字 -d 目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="PS命令使用"><a href="#PS命令使用" class="headerlink" title="PS命令使用"></a>PS命令使用</h4><p>who 命令：查看当前终端登录情况</p>
<p>ps a :查看当前操作系统所有用户</p>
<p>ps au:  查看用户的信息</p>
<p>ps aux: 查看没有终端的应用程序(不能与用户进行交互的进程[输入、输出])，TTY为?的进程</p>
<p><strong>管道 |：指令1 | 指令2 ：指令1的输出作为指令2的输入，指令2处理完毕，将信息输出到屏幕</strong></p>
<h4 id="env和top"><a href="#env和top" class="headerlink" title="env和top"></a>env和top</h4><p>Linux下的环境变量的格式: key - value</p>
<p>key=value:value:value</p>
<h4 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h4><p>ifconfig /ipconfig</p>
<p>nslookup :查看域名对应的ip</p>
<h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p>创建用户:</p>
<ul>
<li>sudo adduser +用户名  </li>
<li>sudo useradd -s /bin/bash -g shifudong -d /home/shifudong -m shifudong <ul>
<li>-s 指定新用户登录时shell类型</li>
<li>-g 指定所属组，该组必须已经存在</li>
<li>-d 用户家目录</li>
<li>-m 用户家目录不存在时，自动创建该目录</li>
</ul>
</li>
</ul>
<p>设置用户组：</p>
<ul>
<li>sudo groupadd itcast</li>
</ul>
<p>切换用户：</p>
<ul>
<li>su + 用户名</li>
</ul>
<p>修改密码：</p>
<ul>
<li>sudo passwd +用户名</li>
</ul>
<p>删除用户：</p>
<ul>
<li>sudo deluser + 用户名</li>
<li>sudo userdel -r itcast （选项-r是把用户的主目录也一起删除）</li>
</ul>
<h4 id="ftp服务器：vsftp"><a href="#ftp服务器：vsftp" class="headerlink" title="ftp服务器：vsftp"></a>ftp服务器：vsftp</h4><p>作用：负责文件的上传和下载</p>
<p>put/get file</p>
<p>不允许操作目录，如果想操作目录，打包</p>
<p>lftp：客户端工具</p>
<h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><p>使用格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r 目标用户名@目标主机IP地址:/目标文件的绝对路径 /保存到本机的绝对（相对）路径</span><br></pre></td></tr></table></figure>
<p>拷贝目录需要加参数 -r</p>
<h4 id="man-和echo"><a href="#man-和echo" class="headerlink" title="man 和echo"></a>man 和echo</h4><p>alias 查看命令是否被封装（设置或查看别名）</p>
<ul>
<li>查看 alias</li>
<li>设置: alias pag=’ps aux | grep’（需要长久有效需要设置配置文件: .bashrc）</li>
</ul>
<h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><p>工作模式</p>
<ul>
<li><p>命令模式：打开文件之后，默认进入命令模式</p>
<ul>
<li>光标的移动：H J K L（前，下，上，后），0到行首，$到行尾。gg到文件首，G到文件尾部，500G到第五百行</li>
</ul>
</li>
<li>删除操作：X删除光标前面的，x删除光标后面的，dw删除一个单词，u撤回删除操作，d0删除当前词行之前的， d$删除后面的。D删除光标后面的。dd删除一行 。5D删除(剪切)5行=5dd<ul>
<li>粘贴：p不换行，P换行</li>
</ul>
</li>
<li><p>复制：yy复制行，<strong>可视模式下y复制，d删除</strong></p>
<ul>
<li><p>查找：</p>
<ul>
<li><p>/stdio:从光标位置，向下，最下边之后返回到头部。</p>
</li>
<li><p>?stdio:从光标位置，向上查找，顶部之后，返回到尾部。</p>
</li>
</ul>
</li>
<li>找到相应的要查找字符串，按#键盘可查找<ul>
<li>缩进：&lt;&lt;, &gt;&gt;</li>
</ul>
</li>
<li>shift+k进入man文档， 3+shift+k进入man 文档第三章</li>
</ul>
</li>
<li><p>编辑模式</p>
</li>
<li><p>末行模式：在末行模式下可以输入一些指令</p>
</li>
</ul>
<p>可视模式：命令模式下 v进入</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="C库函数"><a href="#C库函数" class="headerlink" title="C库函数"></a>C库函数</h3><p>fopen, fclose, fread, fwrite, fgets,fputs, fscanf,fprintf,fseek, fgetc, fputc, ftell, feof, flush…</p>
<p>硬盘为什么慢：大部分硬盘都是机械硬盘，读取寻道时间和写入寻道时间都是毫秒级。内存是纳秒级别。</p>
<p>通过文件描述符可以索引到文件对应的磁盘文件。</p>
<p>文件读写指针位置：读写文件过程中指针的实际位置。</p>
<p>I/O缓冲区（内存地址）：通过寻址找到对应的内存块。</p>
<p>为什么需要I/O缓冲区：减少对硬盘的访问，读的放到缓冲区，当缓冲区满之后再放入到硬盘中。</p>
<p>把缓存中的数据存到硬盘上：</p>
<ul>
<li>刷新缓冲区：fflush</li>
<li>缓冲区已满</li>
<li>正常关闭文件<ul>
<li>fclose</li>
<li>return（main函数）</li>
<li>exit（main函数）</li>
</ul>
</li>
</ul>
<p>对于32位系统，linux为每一个运行的程序（进程）分配一个0-4G的地址空间（虚拟地址空间）</p>
<p>内核空间：受保护，用户不能对该空间进行读写操作，否则会出现段错误。</p>
<p>linux内核中有PCB进程控制块：文件描述符表(数组)：存储文件描述符，每打开一个新文件则占用一个文件描述符，而且使用的是空闲的最小的一个文件描述符。默认文件描述符的0,1,2是打开的，分别对应：标准输入(STDIN_FILENO)，标准输出(STDOUT_FILENO，标准错误。</p>
<p>用户空间：</p>
<p>linux下可执行文件格式：ELF</p>
<ul>
<li>ELF区中包含的区域：.bss(未初始化全局变量)，.data(已初始化全局变量)，.txt(代码段，二进制机器指令)，其他的只读数据段，符号段等</li>
<li>受保护的地址(0-4K)， 例如：#define NULL(void *) 0</li>
<li>栈空间（小）：局部变量存储</li>
<li>堆空间（大）：用户申请内存</li>
<li>共享库：动态库，生成与位置无关的代码，相对地址</li>
<li>命令行参数</li>
<li>环境变量(env)</li>
</ul>
<p>cpu为什么需要使用虚拟地址空间与物理地址空间映射？</p>
<ul>
<li>方便编译器和操作系统安排程序的地址分离：程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区</li>
<li>方便进程之间的隔离：不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程使用的物理内存</li>
<li>方便OS使用较少的内存。程序可以使用一序列虚拟地址来访问大于可用物理内存的内容缓冲区。当物理内存供应量变小时。内存管理器会将物理内存页（通常为4KB)保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘间移动。</li>
</ul>
<h3 id="C库函数与系统函数的关系"><a href="#C库函数与系统函数的关系" class="headerlink" title="C库函数与系统函数的关系"></a>C库函数与系统函数的关系</h3><p>linux<strong>系统的API分为三层：应用层，系统调用，内核层。层层调用。</strong></p>
<p>man 2 + 函数可以查找系统调用的帮助手册</p>
<h4 id="open函数："><a href="#open函数：" class="headerlink" title="open函数："></a>open函数：</h4><p>打开方式：</p>
<p>​    必选项：</p>
<p>​        O_RDONLY</p>
<p>​        O_WRONLY</p>
<p>​        O_EDWR</p>
<p>​    可选项：</p>
<p>​        O_CREATE 文件权限：本地有一个掩码（unmask可以显示,也可以修改: unmask 0002），</p>
<p>​        文件的实际权限：给定的权限 与本地掩码取反进行按位&amp;操作 111111111&amp; 111111101 得到775</p>
<p>​        O_EXCL</p>
<p>​        O_TRUNC  文件截断为0，类似清空</p>
<p>​        O_APPEND                </p>
<p>直接看man 2 open</p>
<p>errno: 文件出错的时候的返回值，定义在errno.h中的全局变量，错误宏定义位置</p>
<p>void perror(const char  *s)，头文件 stdio.h.用来将上一个函数发生错误的原因输出到标准设备(stderr) 。参数s所指的字符串会先打印，后面再加上错误原因字符串。此错误原因依照全局变量errno的值来决定要输出的字符串。</p>
<p><strong>shift +k + 数字可以跳转到对应的帮助文档</strong></p>
<h4 id="read-write-lseek"><a href="#read-write-lseek" class="headerlink" title="read,write,lseek"></a>read,write,lseek</h4><p>read(int fd, void *buf, size_t count);</p>
<p>返回值：</p>
<p>​    -1 读文件失败</p>
<p>​    0 文件读完</p>
<p>​    >0 读取的字节数</p>
<p>write(int fd, const void *buf, size_t count);</p>
<p>off_t lseek(int fd, off_t offset, int whence); //移动文件指针，获取文件的长度</p>
<h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><p>gdb 命令</p>
<ol>
<li><p>前提条件，可执行文件必须包含调试信息 gcc -g</p>
</li>
<li><p>gdb + 文件名 启动dgb调试</p>
</li>
<li>查看代码的命令<ol>
<li>当前文件： list +行号（或函数的名字）</li>
<li>指定文件：文件名:行号（函数名）</li>
</ol>
</li>
<li>设置断点<ol>
<li>当前文件： b + 行号（函数名）</li>
<li>指定文件: b+ 行号（函数名）</li>
<li>设置条件断点： b + 行号 if value == 3</li>
<li>查看断点信息： info</li>
<li>删除断点： d + 断点编号</li>
</ol>
</li>
<li>开始调试<ol>
<li>只执行一行代码： start ,继续执行停在断点处：continue — c</li>
<li>直接停在断点处：run — r</li>
</ol>
</li>
<li>单步调试<ol>
<li>进入到函数体： step — s<ol>
<li>跳出函数体： finish(如果在循环处有断点，需要删除断点)</li>
</ol>
</li>
<li>不进入函数体： next — n</li>
</ol>
</li>
<li>追踪变量<ol>
<li>自动打印变量的值：display 变量名</li>
<li>取消变量的追踪： undisplay 编号<ol>
<li>获取编号： info display</li>
</ol>
</li>
<li>手动打印变量的值： print - p</li>
<li>获取变量对应的类型: ptype</li>
</ol>
</li>
<li>跳出当前循环： u</li>
<li>退出gdb :quit</li>
</ol>
<p>Makefile</p>
<ol>
<li><p>一个规则</p>
<ol>
<li><p>三要素：目标，依赖，命令</p>
<p>目标: 依赖</p>
<p>​    命令</p>
</li>
<li><p>第一条规则是用来生成终极目标的规则</p>
<ol>
<li>如果规则中的依赖不存在，向下查找其他的规则</li>
<li>更新机制：比较的是目标文件和依赖文件的时间</li>
</ol>
</li>
</ol>
</li>
<li><p>两个函数</p>
<ol>
<li>查找指定目录下，知道类型的文件 src = $(vildcard ~/aa/*.c)取到所有的.c文件名</li>
<li>匹配替换函数 obj = $(partsubs %.c %.o $(src))  obj得到所有.o文件</li>
</ol>
</li>
<li><p>三个自动变量</p>
<ol>
<li>$&lt; 规则中的第一个依赖</li>
<li>$” 规则中的所有依赖</li>
<li>$@ 规则中的目标</li>
<li>三个自动变量只能在规则命令中使用</li>
</ol>
</li>
<li><p>模式规则</p>
<ol>
<li>%.o:%.c    gcc -c $&lt; -o $@</li>
</ol>
</li>
</ol>
<p>Linux 系统IO函数</p>
<ol>
<li><p>文件描述符</p>
<ol>
<li>int 类型</li>
<li>一个进程最多可以打开1024个文件</li>
</ol>
</li>
<li><p>PCB ：进程控制块</p>
<ol>
<li>在其中有一个文件描述符号表 数组[1024]</li>
</ol>
</li>
<li><p>虚拟地址空间</p>
<ol>
<li>用户区，内核区</li>
<li>代码段</li>
<li>已经初始化的全局变量</li>
<li>未被初始化的全局变量</li>
<li>堆：从下往上增长</li>
<li>共享库</li>
<li>栈：从下往上</li>
<li>环境变量</li>
<li>内核区</li>
</ol>
</li>
<li>读大文件然后写入另外一个文件<ol>
<li>read write 每次读一个byte</li>
<li>getc putc 每次读一个byte 效率更高，标准c库函数内部有一个缓冲区</li>
<li>两种方式，哪个效率高</li>
</ol>
</li>
</ol>
<h4 id="read-write函数读写文件"><a href="#read-write函数读写文件" class="headerlink" title="read write函数读写文件"></a>read write函数读写文件</h4><p>read_write.c</p>
<h4 id="lseek-函数"><a href="#lseek-函数" class="headerlink" title="lseek 函数"></a>lseek 函数</h4><ol>
<li>获取文件大小</li>
<li>移动文件指针</li>
<li>文件拓展</li>
</ol>
<h4 id="Linux文件操作相关函数"><a href="#Linux文件操作相关函数" class="headerlink" title="Linux文件操作相关函数"></a>Linux文件操作相关函数</h4><ol>
<li>stat函数 对应stat命令<ol>
<li>穿透函数 — 相对软链接而言, 操作：vi</li>
</ol>
</li>
<li>lstat函数<ol>
<li>不穿透，不追踪</li>
<li>不追踪链接的操作：ls -al ,rm </li>
</ol>
</li>
<li>access函数：测试文件是否拥有某种权限</li>
<li>chmod函数</li>
<li>chown函数</li>
<li>truncate函数：文化扩展函数<ol>
<li>文件长度为100,第二个参数指定为20,20以后的被覆盖，第二个参数为300,文件拓展。</li>
</ol>
</li>
<li>链接<ol>
<li>link</li>
<li>symlink</li>
<li>readlink</li>
<li>unlink:删除一个文件的目录项并减少对它的链接数。如果是符号链接，删除符号链接。如果是硬连接，硬链接数减1,当减少为0时，释放数据块和inode。如果文件硬链接数为0,但有进程已经打开这个文件，并持有文件的描述符，则等该进程关闭该文件时，kernel才真正删除该文件。利用该特性创建临时文件（例如：缓存文件），先open,create，然后unlink,接着还可以操作文件。</li>
</ol>
</li>
<li>rename</li>
<li>chdir</li>
<li>getcwd</li>
<li>mkdir</li>
<li>rmdir</li>
<li>opendir<ol>
<li>man 3 opendir</li>
</ol>
</li>
<li>readdir</li>
<li>closedir</li>
</ol>
<p>递归获取目录个数：myFileNum.c</p>
<ol>
<li>dup 和dup2<ol>
<li>用于复制文件描述符</li>
<li>dup返回的是文件描述表中没被占用的最小的文件描述符</li>
<li>dup2(old, new)<ol>
<li>old-&gt;new 如果new是一个被打开的文件描述符，在拷贝前先关掉new</li>
<li>old和new是同一个文件描述符，new不会被关掉，直接返回old</li>
</ol>
</li>
</ol>
</li>
<li>fcntl函数：改变已经打开的文件的属性：获得/设置文件描述标记符，获得/设置文件状态标记，获得/设置异步I/O所有权，获得/设置记录锁<ol>
<li>打开文件的时候：只读</li>
<li>要向文件中添加内容，需要修改文件的属性</li>
</ol>
</li>
</ol>
<p>索引结点inode:保存的其实是实际的数据的一些信息，这些信息称为“元数据”（也就是对文件属性的描述）。例如：文件大小，设备标识符，用户组标识符，文件模式，扩展属性，文件读取或修改的时间戳，链接数量，指向存储该内容的磁盘区块的指针，文件分类等。</p>
<p>注意：数据分为：元数据+数据本身</p>
<p>注意inode号：inode号是惟一的，表示不同的文件。其实在linux内部的时候，访问文件都是通过inode号来进行的，所谓文件名仅仅是给用户容易使用的。当我们打开一个文件的时候。首先，系统找到这个文件名对应的inode号;然后通过inode号得到inode信息。最后，又inode找到文件数据所在的block，这样就可以处理文件数据了。</p>
<p>inode和文件的关系：当创建一个文件的时候，就给文件分配了一个inode。一个inode只对应一个实际文件，一个文件也只会有一个inode。inode最大数量就是文件的最大数量。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux操作</tag>
      </tags>
  </entry>
  <entry>
    <title>linux环境变量设置</title>
    <url>/2019/12/26/linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="Ubuntu环境变量的添加和删除"><a href="#Ubuntu环境变量的添加和删除" class="headerlink" title="Ubuntu环境变量的添加和删除"></a>Ubuntu环境变量的添加和删除</h3><h4 id="添加环境变量的位置"><a href="#添加环境变量的位置" class="headerlink" title="添加环境变量的位置"></a>添加环境变量的位置</h4><ul>
<li>/etc/profile 该文件为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行，并从/etc/profile.d目录的配置文件中搜集shell的设置。</li>
<li>/etc/environment 登录操作系统使用的第二个文件，系统在读取自己的profile之前，设置环境文件的环境变量</li>
<li>/etc/bashrc 为每一个运行bash shell的用户执行该文件。当bash shell被打开时，该文件被读取</li>
<li>~/.profile 每个用户都可以使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次。默认情况下设置一些环境变量，执行用户的.bashrc文件</li>
<li>~/.bashrc 该文件包含专用的bash shell的bash信息，当登录以及每次打开新的shell时，该文件被读取。</li>
</ul>
<h4 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h4><ul>
<li>方法一：直接修改/etc/enviroment文件，这种方法的作用域是<strong>全局的，永久性</strong>的。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打开/etc/environment文件，其内容如下：</span></span><br><span class="line">PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games" </span><br><span class="line"><span class="meta">#</span><span class="bash">在环境变量PATH中添加你要添加的路径即可。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：修改/etc/profile文件，这种方法的作用域是<strong>全局的，永久性</strong>的。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">这个文件不是保存环境变量信息的文件，在登录时，系统只是根据它的内容对环境变量进行设置。</span></span><br><span class="line">export PATH=$PATH:[your path1]:[your path2]:[...]  </span><br><span class="line">export PATH=[your path1]:[your path2]:[...]:$PATH #其中，各个PATH之间用冒号分隔，$PATH指代添加your path前的环境变量。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法三：修改/etc/bashrc或者~/.bashrc文件，这两个文件<strong>不是为了保存环境变量，只是在使用bash shell时进行设置而已，所以设置方法和二中一样。对于/etc/bashrc文件，修改的作用于所有用户，但对于~/.bashrc文件，修改的仅仅作用于当前用户。这种修改的作用也是永久性的。</strong></p>
</li>
<li><p>方法四：<strong>修改~/.profile文件，作用仅限于当前用户，但同样也是永久性的。这种方法和修改/etc/profile本质上是一样的，这种之不过是仅仅修改了当前用户自己的配置文件。所以作用仅限于当前用户，但同样也是永久性的。</strong></p>
</li>
<li><p>方法五：在Terminal中使用shell命令，只在当前Terminal中起作用，关闭了当前Terminal就无效了。对其他Terminal也无效</p>
</li>
</ul>
<h4 id="显示环境变量"><a href="#显示环境变量" class="headerlink" title="显示环境变量"></a>显示环境变量</h4><ul>
<li>显示所有环境变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env #打印所有的环境变量</span><br></pre></td></tr></table></figure>
<ul>
<li>显示指定环境变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $PATH #打印PATH环境变量</span><br></pre></td></tr></table></figure>
<h4 id="让修改生效"><a href="#让修改生效" class="headerlink" title="让修改生效"></a>让修改生效</h4><p>使用source命令也可以让修改立即生效。使用方法为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source [file name]  # file name 指的是上面修改过的文件的file name</span><br></pre></td></tr></table></figure>
<h4 id="删除对环境变量的修改"><a href="#删除对环境变量的修改" class="headerlink" title="删除对环境变量的修改"></a>删除对环境变量的修改</h4><p>将以上方法中对配置文件的修改还原回去即可。另外，由于第五种方法由于是临时性质的且局部的，只需要关闭这个Terminal就好了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件系统</title>
    <url>/2019/11/27/file/</url>
    <content><![CDATA[<h2 id="1-分区类型"><a href="#1-分区类型" class="headerlink" title="1.分区类型"></a>1.分区类型</h2><ul>
<li>主分区：最多只能有四个</li>
<li>扩展分区：最多一个，算作主分区的一种，主分区加扩展分区最多有四个。扩展分区不能存储数据和格式化，必须再划分为逻辑分区才可以使用。</li>
<li>逻辑分区：在扩展分区中划分</li>
</ul>
<p>逻辑分区的编号从5开始</p>
<h2 id="2-文件系统"><a href="#2-文件系统" class="headerlink" title="2.文件系统"></a>2.文件系统</h2><ul>
<li>ext2:ext文件系统的升级版。最大支持16TB的分区和最大2TB的文件。</li>
<li>ext3:ext2的升级，增加日志功能。</li>
<li>ext4:ext3升级版本，主流使用，功能强大</li>
</ul>
<h3 id="2-1常用命令"><a href="#2-1常用命令" class="headerlink" title="2.1常用命令"></a>2.1常用命令</h3><h4 id="df-du-fsck-dump2fs"><a href="#df-du-fsck-dump2fs" class="headerlink" title="df, du, fsck, dump2fs"></a>df, du, fsck, dump2fs</h4><h4 id="1-文件系统查看命令df"><a href="#1-文件系统查看命令df" class="headerlink" title="1.文件系统查看命令df"></a>1.文件系统查看命令df</h4><p>df [选项][挂载点]</p>
<p>-a 所有文件系统信息</p>
<p>-h 使用习惯单位显示容量，如kB,MB,GB</p>
<p>ls 只统计目录下的大小，而不会统计子目录下的数据大小。</p>
<h4 id="2-统计目录或文件大小"><a href="#2-统计目录或文件大小" class="headerlink" title="2.统计目录或文件大小"></a>2.统计目录或文件大小</h4><p>-a</p>
<p>-h </p>
<p>-s</p>
<p>df命令从文件系统考虑，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（eg. 文件已经被删除，但程序并没有释放空间）</p>
<p>du命令面向文件，只会计算文件或目录占用的空间。</p>
<h4 id="3-文件系统修复命令fsck"><a href="#3-文件系统修复命令fsck" class="headerlink" title="3.文件系统修复命令fsck"></a>3.文件系统修复命令fsck</h4><p>fsck[选项]分区设备文件名</p>
<h4 id="4-显示磁盘状态命令dumpe2fs"><a href="#4-显示磁盘状态命令dumpe2fs" class="headerlink" title="4.显示磁盘状态命令dumpe2fs"></a>4.显示磁盘状态命令dumpe2fs</h4><p>dumpe2fs 分区设备文件名</p>
<h3 id="2-2-文件系统常用命令-挂载命令"><a href="#2-2-文件系统常用命令-挂载命令" class="headerlink" title="2.2 文件系统常用命令-挂载命令"></a>2.2 文件系统常用命令-挂载命令</h3><h4 id="1-查询与自动挂载"><a href="#1-查询与自动挂载" class="headerlink" title="1.查询与自动挂载"></a>1.查询与自动挂载</h4><p>mount [-l]：查询系统中已经挂载的设备，-l会显示卷标名称</p>
<p>mount -a 依据配置文件/etc/fastb的内容，自动挂载</p>
<h4 id="2-挂载命令格式"><a href="#2-挂载命令格式" class="headerlink" title="2.挂载命令格式"></a>2.挂载命令格式</h4><p>mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</p>
<p>选项：</p>
<p>-t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3，ext4,iso9660等文件系统</p>
<p>-L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载</p>
<p>-o 特殊指令（remount …）</p>
<p>mount -o remount ,noexec /home</p>
<h4 id="3-挂载光盘与U盘"><a href="#3-挂载光盘与U盘" class="headerlink" title="3 挂载光盘与U盘"></a>3 挂载光盘与U盘</h4><p>1.挂载光盘</p>
<p>mkdir /mnt/cdrom/ 建立挂载点</p>
<p>mount -t iso9660 /dev/cdrom /mnt/cdrom 挂载光盘</p>
<p>mount /dev/sr0 /mnt/cdrom</p>
<p> 2.卸载命令</p>
<p>umount 设备文件名或挂载点</p>
<p>umount /mnt/cdrom</p>
<p>3.挂载U盘</p>
<p>fdisk -l 查看U盘设备文件名</p>
<p>mount -t vfat /dev/sdb1 /mnt/usb/</p>
<p>linux默认不支持NTFS文件系统</p>
<h4 id="4支持NTFS文件系统"><a href="#4支持NTFS文件系统" class="headerlink" title="4支持NTFS文件系统"></a>4支持NTFS文件系统</h4><p>重新编译内核</p>
<p>第三方软件</p>
<p>NTFS-3G插件</p>
<h3 id="2-3-fdisk分区"><a href="#2-3-fdisk分区" class="headerlink" title="2.3 fdisk分区"></a>2.3 fdisk分区</h3><h4 id="fdisk命令分区过程"><a href="#fdisk命令分区过程" class="headerlink" title="fdisk命令分区过程"></a>fdisk命令分区过程</h4><p>1.添加硬盘，虚拟机必须在关机的情况下添加</p>
<p>2.查看新硬盘 fdisk -l</p>
<p>3.使用fdisk命令分区</p>
<p>fdisk /dev/sdb</p>
<p> 4.重新读取分区表信息</p>
<p>partprobe</p>
<p>5.格式化分区</p>
<p>扩展分区不可以格式化</p>
<p>mkfs -t ext4 /dev/sdb1</p>
<p>6.建立挂载分区</p>
<h4 id="分区自动挂载与fstab文件修复"><a href="#分区自动挂载与fstab文件修复" class="headerlink" title="分区自动挂载与fstab文件修复"></a>分区自动挂载与fstab文件修复</h4><p>将挂载写入/etc/fstab文件，一定要写对</p>
<p>mount -a 依据配置文件 /etc/fstab的内容，自动挂载</p>
<p>/etc/fstab文件修复</p>
<p>mount -o remount,rm /</p>
<h3 id="2-4-分配swap分区"><a href="#2-4-分配swap分区" class="headerlink" title="2.4 分配swap分区"></a>2.4 分配swap分区</h3><p>1.free命令</p>
<p>查看内存与swap分区使用情况</p>
<p>cached(缓存):加速数据的读取过程</p>
<p>buffer(缓冲)：写入数据过程中，将分散的写入操作保存到内存中，当达到一定的程度再集中写入硬盘，加速数据的写入过程。</p>
<p>2.新建swap分区</p>
<p>fdisk /dev/sdb</p>
<p>还需将分区ID改为82</p>
<p>3.格式化</p>
<p>mkswap /dev/sdb6</p>
<p>4.加入swap分区</p>
<p>swapon /dev/sdb6 加入swap分区</p>
<p>swapoff /dev/sdb6 取消swap分区</p>
<p>5.swap分区开机自动挂载</p>
<p>vi /etc/fstab</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux 文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务管理</title>
    <url>/2019/11/27/server/</url>
    <content><![CDATA[<h2 id="Linux服务管理"><a href="#Linux服务管理" class="headerlink" title="Linux服务管理"></a>Linux服务管理</h2><h3 id="服务分类"><a href="#服务分类" class="headerlink" title="服务分类"></a>服务分类</h3><p>Linux服务</p>
<ul>
<li><p>RPM包默认安装的服务</p>
<p>— 独立的服务</p>
<p>— 基于xinetd服务</p>
</li>
<li><p>源码包安装的服务</p>
</li>
</ul>
<p>启动与自启动</p>
<ul>
<li>服务启动：在当前系统中让服务运行，并提供功能</li>
<li>服务自启动：服务在系统开机或重启之后，随着系统的启动而自动启动服务</li>
</ul>
<p>RPM安装服务和源码安装服务区别就在于安装位置的不同。</p>
<p>service不可以启动RPM安装的软件</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux 服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统管理</title>
    <url>/2019/11/27/system/</url>
    <content><![CDATA[<h2 id="Linux系统管理"><a href="#Linux系统管理" class="headerlink" title="Linux系统管理"></a>Linux系统管理</h2><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h4><p>作用：判断服务器健康状态，查看系统中所有进程，杀死进程</p>
<p>查看系统中所有进程：</p>
<ul>
<li>ps aux :使用系统中所有进程，使用BSD操作系统格式</li>
<li>ps -le 查看系统中所有进程，使用Linux标准命令格式</li>
</ul>
<p>查看系统健康状态：</p>
<ul>
<li>top[选项]</li>
</ul>
<p>查看进程树：</p>
<ul>
<li>pstree</li>
</ul>
<h4 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h4><p>1.kill命令</p>
<p>kill -l 查看可用的进程信号</p>
<p>kill -1 进程id 重启进程</p>
<p>kill -9 进程id 强制杀死进程</p>
<p>2.killall命令</p>
<p>killall -9 进程名</p>
<p>3.pkill </p>
<p>按照终端号踢出用户</p>
<p>w 使用w命令查询本机已经登录的用户</p>
<p>pkill -t -9 pts/1 强制杀死从pts/1虚拟终端登录的进程</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux 系统管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux shell学习</title>
    <url>/2019/11/27/shell/</url>
    <content><![CDATA[<h3 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><ul>
<li>一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。</li>
<li><p>Shell 既是一种<strong>命令语言</strong>，又是一种<strong>程序设计语言</strong>。</p>
</li>
<li><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，<strong>用户通过这个界面访问操作系统内核的服务</strong>。</p>
</li>
</ul>
<p>真正能够控制计算机硬件（CPU、内存、显示器等）的只有操作系统内核（Kernel），图形界面和<strong>命令行只是架设在用户和内核之间的一座桥梁</strong>。由于安全、复杂、繁琐等原因，用户不能直接接触内核（也没有必要），需要另外再开发一个程序，让用户直接使用这个程序；<strong>该程序的作用就是接收用户的操作（点击图标、输入命令），并进行简单的处理，然后再传递给内核</strong>。如此一来，用户和内核之间就多了一层“代理”，这层“代理”既简化了用户的操作，也保护了内核。用户界面和命令行就是这个另外开发的程序，就是这层“代理”。在Linux下，这个命令行程序叫做 <strong>Shell</strong>。</p>
<h4 id="shell的作用"><a href="#shell的作用" class="headerlink" title="shell的作用"></a>shell的作用</h4><ul>
<li>调用其他程序，给其他程序传递数据或参数，并获取程序的处理结果；</li>
<li>在多个程序之间传递数据，把一个程序的输出作为另一个程序的输入；</li>
<li>Shell 本身也可以被其他程序调用。</li>
</ul>
<p>Shell 本身支持的命令并不多，但是它可以<strong>调用其他的程序</strong>，每个程序就是一个命令，这使得 Shell 命令的数量可以无限扩展，其结果就是  Shell 的功能非常强大，完全能够胜任 Linux  的日常管理工作，如文本或字符串检索、文件的查找或创建、大规模软件的自动部署、更改系统设置、监控服务器性能、发送报警邮件、抓取网页内容、压缩文件等。</p>
<p>Shell 主要用来开发一些实用的、自动化的小工具，而不是用来开发具有复杂业务逻辑的中大型软件，例如检测计算机的硬件参数、一键搭建Web开发环境、日志分析等。</p>
<h4 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h4><p>任何代码最终都要被“翻译”成二进制的形式才能在计算机中执行。</p>
<ul>
<li><p>编译型语言：</p>
<ul>
<li>如 C/C++、Pascal、Go语言、汇编等，必须在程序运行之前将所有代码都翻译成二进制形式，也就是生成可执行文件，用户拿到的是最终生成的可执行文件，看不到源码。</li>
<li>这个过程叫做编译（Compile），这样的编程语言叫做编译型语言，完成编译过程的软件叫做<strong>编译器</strong>（Compiler）。</li>
<li>编译型语言的优点是执行速度快、对硬件要求低、保密性好，适合开发操作系统、大型应用程序、数据库等。</li>
</ul>
</li>
<li><p>解释型语言或者脚本语言（Script）</p>
<ul>
<li>如 Shell、JavaScript、Python、PHP等，需要<strong>一边执行一边翻译，不会生成任何可执行文件，用户必须拿到源码才能运行程序。程序运行后会即时翻译，翻译完一部分执行一部分，不用等到所有代码都翻译完。</strong></li>
<li>这个过程叫做解释，这样的编程语言叫做解释型语言或者脚本语言（Script），完成解释过程的软件叫做<strong>解释器</strong>。</li>
<li>脚本语言的优点是使用灵活、部署容易、跨平台性好，非常适合Web开发以及小工具的制作。</li>
<li>Shell 就是一种脚本语言，我们编写完源码后不用编译，直接运行源码即可。</li>
</ul>
</li>
</ul>
<p>Shell 脚本很适合处理纯文本类型的数据，而 Linux 中几乎所有的配置文件、日志文件（如 NFS、Rsync、Httpd、Nginx、MySQL 等），以及绝大多数的启动文件都是纯文本类型的文件。</p>
<p>Shell 脚本是实现 Linux 系统自动管理以及自动化运维所必备的工具，Linux 的底层以及基础应用软件的核心大都涉及 Shell 脚本的内容。</p>
<p>Shell 脚本的优势在于处理偏操作系统底层的业务，例如，Linux 内部的很多应用（有的是应用的一部分）都是使用 Shell 脚本开发的，因为有 1000 多个 Linux 系统命令为它作支撑。</p>
<h3 id="常见的shell：sh-bash-csh-tcsh-ash"><a href="#常见的shell：sh-bash-csh-tcsh-ash" class="headerlink" title="常见的shell：sh, bash, csh, tcsh, ash"></a>常见的shell：sh, bash, csh, tcsh, ash</h3><p>Linux由多个组织机构开发，<strong>不同的组织机构为了发展自己的 Linux 分支可能会开发出功能类似的软件，它们各有优缺点，用户可以自由选择</strong>。Shell  就是这样的一款软件，不同的组织机构开发了不同的 Shell，它们各有所长，有的占用资源少，有的支持高级编程功能，有的兼容性好，有的重视用户体验。 </p>
<p><strong>Shell 既是一种脚本编程语言，也是一个连接内核和用户的软件。</strong></p>
<p>常见的 Shell 有 sh、bash、csh、tcsh、ash 等。</p>
<h4 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h4><p>sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名。</p>
<p>sh 是 UNIX 上的标准 shell，很多 UNIX 版本都配有 sh。sh 是第一个流行的 Shell。</p>
<h4 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h4><p>sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy (Bill Joy 是一个风云人物，他创立了 BSD 操作系统，开发了 vi 编辑器，还是 Sun 公司的创始人之一)。设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p>
<p><strong>BSD 是 UNIX 的一个重要分支</strong>，后人在此基础上发展出了很多现代的操作系统，最著名的有 FreeBSD、OpenBSD 和 NetBSD，就连 Mac OS X 在很大程度上也基于BSD。</p>
<h4 id="tcsh"><a href="#tcsh" class="headerlink" title="tcsh"></a>tcsh</h4><p>tcsh 是 csh 的增强版，加入了命令补全功能，提供了更加强大的语法支持。</p>
<h4 id="ash"><a href="#ash" class="headerlink" title="ash"></a>ash</h4><p>一个简单的轻量级的 Shell，<strong>占用资源少，适合运行于低内存环境</strong>，但是与下面讲到的 bash shell 完全兼容。</p>
<h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h4><p><strong>bash shell 是 Linux 的默认 shell</strong>. bash 兼容 sh ：<strong>针对 sh 编写的 Shell 代码可以不加修改地在 bash 中运行</strong>。</p>
<p>bash 和 sh 的一些不同之处： </p>
<ul>
<li>bash 扩展了一些命令和参数；</li>
<li>bash 并不完全和 sh 兼容，它们有些行为并不一致，但在大多数企业运维的情况下区别不大，特殊场景可以使用 bash 代替 sh。</li>
</ul>
<h4 id="shell查看"><a href="#shell查看" class="headerlink" title="shell查看"></a>shell查看</h4><p>Shell 是一个程序，一般都是放在<code>/bin</code>或者<code>/user/bin</code>目录下，当前 Linux 系统可用的 Shell 都记录在<code>/etc/shells</code>文件中。<code>/etc/shells</code>是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令（cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上）查看。</p>
<p>通过 cat 命令来查看当前 Linux 系统的可用 Shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cat /etc/shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/rbash</span><br></pre></td></tr></table></figure>
<p>在现代的 Linux 上，sh 已经被 bash 代替，<code>/bin/sh</code>往往是指向<code>/bin/bash</code>的符号链接。</p>
<p>如果希望查看当前 Linux 的默认 Shell，那么可以输出 SHELL 环境变量： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$SHELL</span></span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<p>输出结果表明默认的 Shell 是 bash。</p>
<p><code>echo</code>是一个 Shell 命令，用来输出变量的值，<code>SHELL</code>是 Linux 系统中的<strong>环境变量</strong>，它<strong>指明了当前使用的 Shell 程序的位置，也就是使用的哪个 Shell。</strong></p>
<h3 id="终端使用shell"><a href="#终端使用shell" class="headerlink" title="终端使用shell"></a>终端使用shell</h3><p>一种进入 Shell 的方法是让 Linux 系统退出图形界面模式，进入控制台模式，这样一来，显示器上只有一个简单的带着白色文字的“黑屏”，就像图形界面出现之前的样子。这种模式称为 Linux 控制台（Console）。</p>
<p>现代 Linux 系统在启动时会自动创建几个虚拟控制台（Virtual Console），其中一个供图形桌面程序使用，其他的保留原生控制台的样子。虚拟控制台其实就是 Linux 系统内存中运行的虚拟终端（Virtual Terminal）。</p>
<p>从图形界面模式进入控制台模式也很简单，往往按下<code>Ctrl + Alt + Fn(n=1,2,3,4,5...)</code>快捷键就能够来回切换。</p>
<p>例如，CentOS 在启动时会创建 6 个虚拟控制台，按下快捷键<code>Ctrl + Alt + Fn(n=2,3,4,5,6)</code>可以从图形界面模式切换到控制台模式，按下<code>Ctrl + Alt + F1</code>可以从控制台模式再切换回图形界面模式。可以发现，1号控制台被图形桌面程序占用了。</p>
<p>Ubuntu中<code>Ctrl + Alt + F7</code>对应图形界面。</p>
<p>输入用户名和密码，登录成功后就可以进入 Shell 了。<code>$</code>是命令提示符，我们可以在它后面输入 Shell 命令。 </p>
<blockquote>
<p> 在图形界面模式下，输入密码时往往会显示为<em>，密码有几个字符就显示几个</em>；而在控制台模式下，输入密码什么都不会显示，好像按键无效一样，但只要输入的密码正确就能够登录。</p>
</blockquote>
<p>图形界面也是一个程序，会占用CPU时间和内存空间，当 Linux 作为服务器系统时，安装调试完毕后，应该让 Linux 运行在控制台模式下，以节省服务器资源。正是由于这个原因，很多服务器甚至不安装图形界面程序，管理员只能使用命令来完成各项操作。</p>
<p>在Ubuntu中也可以用快捷键<code>Ctrl + Alt + t</code>快速启动一个终端。打开终端后即可输入Shell命令。</p>
<h4 id="shell提示符"><a href="#shell提示符" class="headerlink" title="shell提示符"></a>shell提示符</h4><p>启动终端模拟包或者从 Linux 控制台登录后，便可以看到 Shell 提示符。</p>
<p>对于<strong>普通用户</strong>，Base shell 默认的提示符是美元符号<code>$</code>；对于<strong>超级用户</strong>（root 用户），Bash Shell 默认的提示符是井号<code>#</code>（可使用<code>sudo su</code>切换到超级用户）。该符号表示 Shell 等待输入命令。</p>
<p>同的 Linux 发行版使用的提示符格式不同。例如在 Ubuntu中，默认的提示符格式为：<code>dongshifu@dong:~$</code></p>
<p> 这种格式包含了以下三个方面的信息： </p>
<ul>
<li>启动 Shell 的用户名，也即 dongshifu；</li>
<li>本地主机名称，也即dong；</li>
<li>当前目录，波浪号<code>~</code>是主目录的简写表示法。</li>
</ul>
<h4 id="shell脚本编辑与运行"><a href="#shell脚本编辑与运行" class="headerlink" title="shell脚本编辑与运行"></a>shell脚本编辑与运行</h4><p>打开文本编辑器，新建文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意即可。</p>
<p>输入shell代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "Hello World !"</span><br></pre></td></tr></table></figure>
<p>“#!” <strong>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。</strong>echo命令用于向窗口输出文本。</p>
<p>运行shell脚本的方法：</p>
<ul>
<li>作为可执行程序</li>
</ul>
<p>将上面的代码保存为test.sh，并 cd 到相应目录： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure>
<p>注意，<strong>一定要写成./test.sh，而不是test.sh。运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin,  /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</strong></p>
<p> 通过这种方式运行bash脚本，第一行一定要写对，好让shell查找到正确的解释器。</p>
<ul>
<li>作为解释器参数</li>
</ul>
<p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/bash test.sh</span><br></pre></td></tr></table></figure>
<p>这种方式运行的脚本<strong>，不需要在第一行指定解释器信息</strong>，写了也没用。</p>
<p>例子：用read命令从stdin获取输入并赋值给PERSON变量，最后在stdout输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "what is your name?"</span><br><span class="line">read PERSON</span><br><span class="line">echo "Hello, $PERSON"</span><br></pre></td></tr></table></figure>
<h3 id="shell变量：shell变量的定义、删除变量、只读变量、变量类型"><a href="#shell变量：shell变量的定义、删除变量、只读变量、变量类型" class="headerlink" title="shell变量：shell变量的定义、删除变量、只读变量、变量类型"></a>shell变量：shell变量的定义、删除变量、只读变量、变量类型</h3><p>脚本语言在定义变量时通常<strong>不需要指明类型，直接赋值就可以</strong>，Shell 变量也遵循这个规则。</p>
<p>在 Bash shell 中，<strong>每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储</strong>。这意味着，<strong>Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串</strong>，这一点和大部分的编程语言不同。 </p>
<p>如果有必要，你也可以<strong>使用 declare 关键字显式定义变量的类型</strong>，但在一般情况下没有这个需求。</p>
<h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><p>三种定义变量方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">variable=value</span><br><span class="line">variable='value'</span><br><span class="line">variable="value"</span><br></pre></td></tr></table></figure>
<p>variable 是<strong>变量名，value 是赋给变量的值</strong>。如<strong>果 value 不包含任何空白符（例如空格、Tab缩进等），那么可以不使用引号；如果 value 包含了空白符，那么就必须使用引号包围起来</strong>。使用单引号和使用双引号有区别。</p>
<p><strong>注意，赋值号的周围不能有空格</strong></p>
<p>Shell 变量的命名规范和大部分编程语言都一样： </p>
<ul>
<li>变量名由数字、字母、下划线组成；</li>
<li>必须以字母或者下划线开头；</li>
<li>不能使用 Shell 里的关键字（通过 help 命令可以查看保留关键字）。</li>
</ul>
<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p>使用一个定义过的变量，只要在变量名前面加美元符号<code>$</code>即可，如： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">skill="Java"</span><br><span class="line">echo "I am good at $&#123;skill&#125;Script"</span><br></pre></td></tr></table></figure>
<p>变量名外面的花括号<code>{ }</code>是可选的，加不加都行，<strong>加花括号是为了帮助解释器识别变量的边界</strong>，如果不给 skill 变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code>，解释器就会把 $skillScript 当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>
<h4 id="修改变量的值"><a href="#修改变量的值" class="headerlink" title="修改变量的值"></a>修改变量的值</h4><p>已定义的变量，可以被重新赋值，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lang=shell</span><br><span class="line">echo $&#123;lang&#125;</span><br><span class="line">lang=python</span><br><span class="line">echo $&#123;lang&#125;</span><br></pre></td></tr></table></figure>
<p>第二次对变量赋值时不能在变量名前加<script type="math/tex">`，只有在使用变量时才能加`</script>。 </p>
<h4 id="单引号与双引号的区别"><a href="#单引号与双引号的区别" class="headerlink" title="单引号与双引号的区别"></a>单引号与双引号的区别</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">test="you are so cute"</span><br><span class="line">chare='hi,$&#123;test&#125;'</span><br><span class="line">chare2="hi,$&#123;test&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">hi,<span class="variable">$&#123;test&#125;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">hi,you are so cute</span></span><br></pre></td></tr></table></figure>
<p><strong>以单引号<code>&#39; &#39;</code>包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出</strong>。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</p>
<p><strong>以双引号” “包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。</strong>这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</p>
<p>如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。</p>
<h4 id="将命令的结果赋值给变量"><a href="#将命令的结果赋值给变量" class="headerlink" title="将命令的结果赋值给变量"></a>将命令的结果赋值给变量</h4><p>shell支持将命令的执行结果赋值给变量，常见的方式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">variable=`command`</span><br><span class="line">variable=$(command)</span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test=$(ls -al)</span><br><span class="line">echo $test</span><br></pre></td></tr></table></figure>
<h4 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h4><p>使用 <strong>readonly</strong> 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test="you are so cute"</span><br><span class="line">readonly test</span><br><span class="line">test="you"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">bash: <span class="built_in">test</span>: 只读变量</span></span><br></pre></td></tr></table></figure>
<h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>使用 <strong>unset</strong>命令可以删除变量。语法： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unset variable_name</span><br></pre></td></tr></table></figure>
<p> 变量被删除后不能再次使用；unset 命令不能删除只读变量。</p>
<h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p> 运行shell时，会同时存在三种变量：</p>
<h6 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1) 局部变量"></a>1) 局部变量</h6><p>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 </p>
<h6 id="2-环境变量"><a href="#2-环境变量" class="headerlink" title="2) 环境变量"></a>2) 环境变量</h6><p><strong>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</strong> </p>
<h6 id="3-shell变量"><a href="#3-shell变量" class="headerlink" title="3) shell变量"></a>3) shell变量</h6><p>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</p>
<h4 id="shell特殊变量：Shell-0-​-和命令行参数"><a href="#shell特殊变量：Shell-0-​-和命令行参数" class="headerlink" title="shell特殊变量：Shell $0, $#, $​*, $@, $?, $$和命令行参数"></a>shell特殊变量：Shell $0, $#, $​*, $@, $?, $$和命令行参数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td>当前脚本的文件名</td>
</tr>
<tr>
<td>$n</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数。</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或函数的返回值。</td>
</tr>
<tr>
<td>$$</td>
<td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p>运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 $n$ 表示，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo "file name: $0"</span><br><span class="line">echo "First parameter: $1"</span><br><span class="line">echo "Second parameter: $2"</span><br><span class="line">echo "Quoted values: $@"</span><br><span class="line">echo "Quoted values: $*"</span><br><span class="line">echo "Total number of parameters: $#"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行结果</span></span><br><span class="line">./test1.sh shifu dong</span><br><span class="line">file name: ./test1.sh</span><br><span class="line">First parameter: shifu</span><br><span class="line">Second parameter: dong</span><br><span class="line">Quoted values: shifu dong</span><br><span class="line">Quoted values: shifu dong</span><br><span class="line">Total number of parameters: 2</span><br></pre></td></tr></table></figure>
<h4 id="的区别"><a href="#的区别" class="headerlink" title="$* ,$@的区别"></a>$* ,$@的区别</h4><p>$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。</p>
<p>但是当它们被双引号(“ “)包含时，”$*” 会将所有的参数作为一个整体，以”$1 $2 … ​$n”的形式输出所有参数；”​$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "\$*=" $*</span><br><span class="line">echo "\"\$*\"=" "$*"</span><br><span class="line"></span><br><span class="line">echo "\$@=" $@</span><br><span class="line">echo "\"\$@\"=" "$@"</span><br><span class="line"></span><br><span class="line">echo "print each param from \$*"</span><br><span class="line">for var in $*</span><br><span class="line">do </span><br><span class="line">    echo "$var"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "print each parm from \$@"</span><br><span class="line">for var in $@</span><br><span class="line">do </span><br><span class="line">    echo $var</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "print each parm form \"\$*\""</span><br><span class="line">for var in "$*"</span><br><span class="line">do </span><br><span class="line">    echo $var</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "print each parm from \"\$@\""</span><br><span class="line">for var in "$@"</span><br><span class="line">do </span><br><span class="line">    echo $var</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">./test2.sh "A" "B"</span><br><span class="line"><span class="meta">$</span><span class="bash">*= A B</span></span><br><span class="line">"$*"= A B</span><br><span class="line"><span class="meta">$</span><span class="bash">@= A B</span></span><br><span class="line">"$@"= A B</span><br><span class="line">print each param from $*</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">print each parm from $@</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">print each parm form "$*"</span><br><span class="line">A B</span><br><span class="line">print each parm from "$@"</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux shell</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo基本操作</title>
    <url>/2019/11/26/hexo-operate/</url>
    <content><![CDATA[<h2 id="hexo-文章管理"><a href="#hexo-文章管理" class="headerlink" title="hexo 文章管理"></a>hexo 文章管理</h2><h3 id="1-增加文章"><a href="#1-增加文章" class="headerlink" title="1.增加文章"></a>1.增加文章</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new xx</span><br></pre></td></tr></table></figure>
<p>创建的文件自动保存在source/_post文件夹下，为MarkDown格式</p>
<p>可以在文件中开头通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标题 # 自动创建，如 hello-world</span><br><span class="line">date: 日期 # 自动创建，如 2019-09-22 01:47:21</span><br><span class="line">tags: </span><br><span class="line">- 标签1</span><br><span class="line">- 标签2</span><br><span class="line">- 标签3</span><br><span class="line">categories:</span><br><span class="line">- 分类1</span><br><span class="line">- 分类2</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>来添加文章的必要信息。</p>
<h3 id="2-标签页添加"><a href="#2-标签页添加" class="headerlink" title="2.标签页添加"></a>2.标签页添加</h3><p>在项目的根目录下执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>执行命令后自动生成一个source/tags/index.md文件，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-09-26 16:44:17</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>可以为其增加type字段指定页面的类型:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: tags</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<p>在使用的主题_config.yml文件将页面的链接加到主菜单中，修改menu字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>
<p>本地服务重启，可以观察到页面状态变化(左侧导航出现标签，点击之后会显示标签的列表)。</p>
<h3 id="3-分类页"><a href="#3-分类页" class="headerlink" title="3.分类页"></a>3.分类页</h3><p>对文章进行归类，一个文章可以对应某个或多个分类，可以通过以下命令创建分类页：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>生成一个/source/categories/index.md文件。</p>
<p>在其中增加type字段来指定页面的类型：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type: categories </span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<p>然后在使用的主题_config.yml文件中将页面链接加入到主菜单中，修改menu字段：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line"><span class="meta">  #</span><span class="bash">about: /about/ || user</span></span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line"><span class="meta">  #</span><span class="bash">schedule: /schedule/ || calendar</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
<h4 id="4-添加搜索页"><a href="#4-添加搜索页" class="headerlink" title="4.添加搜索页"></a>4.添加搜索页</h4><p>需要搜索全站的内容，所以一个搜索功能的支持也是很有必要的，要添加搜索的支持，需要先安装一个插件，叫做 hexo-generator-searchdb，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>然后在<strong>项目</strong>的_config.yml中添加搜索设置如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p>然后在主题的 _config.yml 里面修改如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Local search</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Dependencies: https://github.com/wzpan/hexo-generator-search</span></span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line"><span class="meta">  #</span><span class="bash"> If auto, trigger search by changing input.</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  trigger: auto</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  top_n_per_article: 5</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Unescape html strings to the readable one.</span></span><br><span class="line">  unescape: false</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Preload the search data when the page loads.</span></span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure>
<h3 id="5-404页面添加"><a href="#5-404页面添加" class="headerlink" title="5.404页面添加"></a>5.404页面添加</h3><p>若需要添加一个 404 页面，直接在根目录 source 文件夹新建一个 404.md 文件，内容可以仿照如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 404 Not Found</span><br><span class="line">date: 2019-11-27 10:41:27</span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">&lt;center&gt;</span><br><span class="line">对不起，您所访问的页面不存在或者已删除。</span><br><span class="line">您可以&lt;a href="https://dongshifu.github.io&gt;"&gt;点击此处&lt;/a&gt;返回首页。</span><br><span class="line">或访问&lt;a href="https://blog.csdn.net/dongshifo"&gt;查看更多内容。</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"> </span><br><span class="line">&lt;blockquote class="blockquote-center"&gt;</span><br><span class="line">    Dongshifu</span><br><span class="line">&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo 基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title>http</title>
    <url>/2019/11/26/http/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>hexo 测试</title>
    <url>/2019/11/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
