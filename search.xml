<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo搭建博客并添加评论</title>
    <url>/2021/03/09/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="hexo搭建博客并添加评论"><a href="#hexo搭建博客并添加评论" class="headerlink" title="hexo搭建博客并添加评论"></a>hexo搭建博客并添加评论</h3><p>之前搭建博客评论功能的时候使用的是gitalk, 但使用gitalk必须创建issue来进行评论，使用起来并不是很方便。</p>
<p>经过网上查找，发现了一款好用的第三方评论工具：<a href="https://www.livere.com" target="_blank" rel="noopener">livere(来必力)</a>。这款工具只需要注册并得到一个<code>livere_uid</code>值就可以在自己的网页上添加评论功能，登录后台管理还可以对评论进行管理。白嫖可真相！！！</p>
<p>现在说下主要步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打开 https://livere.com/ 网站进行用户注册（注册的时候是韩文，可以有道或者百度翻译对应一下内容，其实也就是邮箱，名称和密码这几项），注册完成后选择【安装】，然后点击“现在安装”。</span><br><span class="line"> </span><br><span class="line">在“现在安装”页面填写相关的信息，然后获取授权ID码(主要需要填写自己的网站链接)</span><br><span class="line"></span><br><span class="line">获取到授权ID码之后会打开主题目录下的配置文件，修改“livere_uid”的值为授权ID码</span><br></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/public/resource/b75486e024e4abe4339e8068b52ef37f/xmlnote/WEBRESOURCE2a260d1f0b15a04f9ef32732c9ae5c85/4528" alt="livere_uid获取"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在自己的博客主体目录下找到_config.yml文件(我的是~/blog/dongshifu/themes/next/_config.yml)然后找到livere_uid选项，将livere管理页面中的代码管理打开并找到data-uid，复制到livere_uid后面保存即可</span><br></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/public/resource/b75486e024e4abe4339e8068b52ef37f/xmlnote/WEBRESOURCEcda4c2d033aec89de3efdbe7afaf8ac0/4530" alt="_config.yaml配置"></p>
<p>重新部署自己的网站到github就可以看到添加的评论功能了。(授权的时候可以用QQ,微信等方式，真的是很方便了)</p>
<p><img src="http://note.youdao.com/yws/public/resource/b75486e024e4abe4339e8068b52ef37f/xmlnote/WEBRESOURCE65532c3d27bdb577b7c70ba945ae81db/4533" alt="博客评论功能添加"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>设置git的用户名和邮箱</title>
    <url>/2021/03/08/git-1-md/</url>
    <content><![CDATA[<h3 id="设置git的用户名和邮箱"><a href="#设置git的用户名和邮箱" class="headerlink" title="设置git的用户名和邮箱"></a>设置git的用户名和邮箱</h3><p>一直在使用自己搭建的github.io来保存博客，虽然更新比较慢，也算是记录了自己的学习过程。</p>
<p>今天在使用的时候意外发现自己在git上的contribution一直没有，鉴于自己时不时会提交博客记录，遂发现不对，难道是git出错了？？明显是不可能的，经过查看，之前的大部分提交居然都是用实验室小伙伴的git帐号提交的。估计是之前小伙伴用我的电脑登录了他的git帐号吧，发现之后赶快改了一下git的帐号设置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[~/path/to/repo]$ git config user.name "dongsihfu"</span><br><span class="line">[~/path/to/repo]$ git config user.email 自己的git邮箱</span><br><span class="line">This change will only affect future commits. Past commits will retain the username and address they were committed with.</span><br><span class="line"></span><br><span class="line">设置好以后就用 ：git config --list 命令查看。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令使用</title>
    <url>/2020/03/02/linux-02linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Linux终端命令格式"><a href="#Linux终端命令格式" class="headerlink" title="Linux终端命令格式"></a>Linux终端命令格式</h3><h4 id="终端命令格式"><a href="#终端命令格式" class="headerlink" title="终端命令格式"></a>终端命令格式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] [parameter]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><code>command</code>：命令名，相应功能的英文单词或单词的缩写</li>
<li><code>[-options]</code>：选项，可用来对命令进行控制，也可以省略</li>
<li><code>parameter</code>：传给命令的参数，可以是 <strong>零个</strong>、<strong>一个</strong> 或者 <strong>多个</strong></li>
<li><code>[]</code> 代表可选 </li>
</ul>
<h4 id="查阅命令帮助信息"><a href="#查阅命令帮助信息" class="headerlink" title="查阅命令帮助信息"></a>查阅命令帮助信息</h4><h6 id="help"><a href="#help" class="headerlink" title="help"></a>help</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>显示 <code>command</code> 命令的帮助信息</li>
</ul>
<h6 id="man"><a href="#man" class="headerlink" title="man"></a>man</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>查阅 <code>command</code> 命令的使用手册</li>
</ul>
<p><code>man</code> 是 <strong>manual</strong> 的缩写，是 Linux 提供的一个 <strong>手册</strong>，包含了绝大部分的命令、函数的详细使用说明</p>
<p>使用 <code>man</code> 时的操作键：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>空格键</td>
<td>显示手册页的下一屏</td>
</tr>
<tr>
<td>Enter 键</td>
<td>一次滚动手册页的一行</td>
</tr>
<tr>
<td>b</td>
<td>回滚一屏</td>
</tr>
<tr>
<td>f</td>
<td>前滚一屏</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>/word</td>
<td>搜索 <strong>word</strong> 字符串</td>
</tr>
</tbody>
</table>
</div>
<h3 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h3><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ls</td>
<td>list</td>
<td>查看当前文件夹下的内容</td>
</tr>
<tr>
<td>02</td>
<td>pwd</td>
<td>print wrok directory</td>
<td>查看当前所在文件夹</td>
</tr>
<tr>
<td>03</td>
<td>cd [目录名]</td>
<td>change directory</td>
<td>切换文件夹</td>
</tr>
<tr>
<td>04</td>
<td>touch [文件名]</td>
<td>touch</td>
<td>如果文件不存在，新建文件</td>
</tr>
<tr>
<td>05</td>
<td>mkdir [目录名]</td>
<td>make directory</td>
<td>创建目录</td>
</tr>
<tr>
<td>06</td>
<td>rm [文件名]</td>
<td>remove</td>
<td>删除指定的文件名</td>
</tr>
<tr>
<td>07</td>
<td>clear</td>
<td>clear</td>
<td>清屏</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>小技巧</p>
<ul>
<li><code>ctrl + shift + =</code> <strong>放大</strong>终端窗口的字体显示</li>
<li><code>ctrl + -</code> <strong>缩小</strong>终端窗口的字体显示</li>
<li>在敲出 文件 目录 命令 <code>tab</code><ul>
<li>如果输入的没有歧义，系统会自动补全</li>
<li>如果还存在其他 <code>文件</code>／<code>目录</code>／<code>命令</code>，再按一下 <code>tab</code> 键，系统会提示可能存在的命令</li>
</ul>
</li>
<li>按 <code>上</code>／<code>下</code> 光标键可以在曾经使用过的命令之间来回切换</li>
<li>如果想要退出选择，并且不想执行当前选中的命令，可以按 <code>ctrl + c</code></li>
</ul>
</blockquote>
<h3 id="远程管理常用命令"><a href="#远程管理常用命令" class="headerlink" title="远程管理常用命令"></a>远程管理常用命令</h3><h4 id="关机-重启"><a href="#关机-重启" class="headerlink" title="关机/重启"></a>关机/重启</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>shutdown 选项 时间</td>
<td>shutdown</td>
<td>关机／重新启动</td>
</tr>
</tbody>
</table>
</div>
<h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a><code>shutdown</code></h4><ul>
<li><code>shutdown</code> 命令可以 <strong>安全</strong> <strong>关闭</strong> 或者 <strong>重新启动系统</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>重新启动</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>提示：</p>
<ul>
<li><strong>不指定选项和参数</strong>，默认表示 <strong>1 分钟</strong>之后 <strong>关闭电脑</strong></li>
<li>远程维护服务器时，最好不要关闭系统，而应该重新启动系统</li>
</ul>
</blockquote>
<ul>
<li>常用命令示例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新启动操作系统，其中 now 表示现在</span></span><br><span class="line">$ shutdown -r now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立刻关机，其中 now 表示现在</span></span><br><span class="line">$ shutdown now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统在今天的 20:25 会关机</span></span><br><span class="line">$ shutdown 20:25</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统再过十分钟后自动关机</span></span><br><span class="line">$ shutdown +10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消之前指定的关机计划</span></span><br><span class="line">$ shutdown -c</span><br></pre></td></tr></table></figure>
<h4 id="查看或配置网卡信息"><a href="#查看或配置网卡信息" class="headerlink" title="查看或配置网卡信息"></a>查看或配置网卡信息</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ifconfig</td>
<td>configure a network interface</td>
<td>查看/配置计算机当前的网卡配置信息</td>
</tr>
<tr>
<td>02</td>
<td>ping ip地址</td>
<td>ping</td>
<td>检测到目标 ip地址 的连接是否正常</td>
</tr>
</tbody>
</table>
</div>
<h4 id="网卡-和-IP-地址"><a href="#网卡-和-IP-地址" class="headerlink" title="网卡 和 IP 地址"></a>网卡 和 IP 地址</h4><h6 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h6><ul>
<li>网卡是一个专门负责网络通讯的硬件设备</li>
<li><strong>IP 地址</strong>是设置在网卡上的地址信息</li>
</ul>
<blockquote>
<p>我们可以把 <strong>电脑</strong> 比作 <strong>电话</strong>，<strong>网卡</strong> 相当于 <strong>SIM 卡</strong>，<strong>IP 地址</strong> 相当于 <strong>电话号码</strong></p>
</blockquote>
<h6 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h6><ul>
<li><strong>每台联网的电脑上</strong>都有 <strong>IP 地址</strong>，<strong>是保证电脑之间正常通讯的重要设置</strong></li>
</ul>
<blockquote>
<p>注意：每台电脑的 IP 地址不能相同，否则会出现 IP 地址冲突，并且没有办法正常通讯</p>
</blockquote>
<h6 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a><code>ifconfig</code></h6><ul>
<li><code>ifconfig</code> 可以查看／配置计算机当前的网卡配置信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看网卡配置信息</span></span><br><span class="line">$ ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网卡对应的 IP 地址</span></span><br><span class="line">$ ifconfig | grep inet</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：一台计算机中有可能会有一个 <strong>物理网卡</strong> 和 <strong>多个虚拟网卡</strong>，在 Linux 中物理网卡的名字通常以 <code>ensXX</code> 表示</p>
</blockquote>
<ul>
<li><code>127.0.0.1</code> 被称为 <strong>本地回环/环回地址</strong>，一般用来测试本机网卡是否正常</li>
</ul>
<h6 id="ping"><a href="#ping" class="headerlink" title="ping"></a><code>ping</code></h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检测到目标主机是否连接正常</span></span><br><span class="line">$ ping IP地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测本地网卡工作正常</span></span><br><span class="line">$ ping 127.0.0.1</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ping</code> 一般用于检测当前计算机到目标计算机之间的网络 <strong>是否通畅</strong>，<strong>数值越大，速度越慢</strong></li>
</ul>
<blockquote>
<ul>
<li><code>ping</code> 的工作原理与潜水艇的声纳相似，<code>ping</code> 这个命令就是取自 <strong>声纳的声音</strong> </li>
<li>网络管理员之间也常将 <code>ping</code> 用作动词 —— <strong>ping 一下计算机X，看他是否开着</strong></li>
</ul>
</blockquote>
<p>原理：网络上的机器都有 <strong>唯一确定的 IP 地址</strong>，我们给<strong>目标 IP 地址</strong>发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在</p>
<blockquote>
<p>提示：在 Linux 中，想要终止一个终端程序的执行，绝大多数都可以使用 <code>CTRL + C</code></p>
</blockquote>
<h4 id="远程登录和复制文件"><a href="#远程登录和复制文件" class="headerlink" title="远程登录和复制文件"></a>远程登录和复制文件</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ssh 用户名@ip</td>
<td>secure shell</td>
<td>关机／重新启动</td>
</tr>
<tr>
<td>02</td>
<td>scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径</td>
<td>secure copy</td>
<td>远程复制文件</td>
</tr>
</tbody>
</table>
</div>
<h4 id="ssh-基础"><a href="#ssh-基础" class="headerlink" title="ssh 基础"></a><code>ssh</code> 基础</h4><p>在 Linux 中 SSH 是 <strong>非常常用</strong> 的工具，通过 <strong>SSH 客户端</strong> 可以连接到运行了 <strong>SSH 服务器</strong> 的远程机器上</p>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCEadf3eb255588d4620755600d7cc36a75/4539" alt="SSH示意图">￼</p>
<ul>
<li><strong>SSH 客户端</strong>是一种使用 <code>Secure Shell（SSH）</code> 协议连接到远程计算机的软件程序</li>
<li><code>SSH</code> 是目前较可靠，<strong>专为远程登录会话和其他网络服务</strong> 提供安全性的协议<ul>
<li>利用 <code>SSH 协议</code> 可以有效<strong>防止远程管理过程中的信息泄露</strong></li>
<li>通过 <code>SSH 协议</code> 可以对所有传输的数据进行<strong>加密</strong>，也能够防止 DNS 欺骗和 IP 欺骗</li>
</ul>
</li>
<li><code>SSH</code> 的另一项优点是传输的数据可以是经过<strong>压缩</strong>的，所以可以加快传输的速度</li>
</ul>
<h4 id="域名-和-端口号"><a href="#域名-和-端口号" class="headerlink" title="域名 和 端口号"></a>域名 和 端口号</h4><h5 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h5><ul>
<li>由一串 <strong>用点分隔</strong> 的名字组成，例如：<code>www.baidu.com</code></li>
<li>是 <strong>IP 地址</strong> 的别名，方便用户记忆</li>
</ul>
<h5 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h5><ul>
<li><strong>IP 地址</strong>：通过 <strong>IP 地址</strong> 找到网络上的 <strong>计算机</strong></li>
<li><strong>端口号</strong>：通过 <strong>端口号</strong> 可以找到 <strong>计算机上运行的应用程序</strong><ul>
<li><strong>SSH 服务器</strong> 的默认端口号是 <code>22</code>，如果是默认端口号，在连接的时候，可以省略</li>
</ul>
</li>
<li>常见服务端口号列表：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>服务</th>
<th>端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>SSH 服务器</td>
<td>22</td>
</tr>
<tr>
<td>02</td>
<td>Web 服务器</td>
<td>80</td>
</tr>
<tr>
<td>03</td>
<td>HTTPS</td>
<td>443</td>
</tr>
<tr>
<td>04</td>
<td>FTP 服务器</td>
<td>21</td>
</tr>
</tbody>
</table>
</div>
<h4 id="SSH-客户端的简单使用"><a href="#SSH-客户端的简单使用" class="headerlink" title="SSH 客户端的简单使用"></a>SSH 客户端的简单使用</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh [-p port] user@remote</span><br></pre></td></tr></table></figure>
<ul>
<li><code>user</code> 是在远程机器上的用户名，如果不指定的话默认为当前用户</li>
<li><code>remote</code> 是远程机器的地址，可以是 <strong>IP</strong>／<strong>域名</strong>，或者是 <strong>后面会提到的别名</strong></li>
<li><code>port</code> 是 <strong>SSH Server 监听的端口</strong>，如果不指定，就为默认值 <code>22</code></li>
</ul>
<blockquote>
<p>提示：</p>
<ul>
<li>使用 <code>exit</code> 退出当前用户的登录</li>
</ul>
<p>注意：</p>
<ul>
<li><code>ssh</code> 这个终端命令只能在 <code>Linux</code> 或者 <code>UNIX</code> 系统下使用</li>
<li>如果在 <code>Windows</code> 系统中，可以安装 <code>PuTTY</code> 或者 <code>XShell</code> 客户端软件即可</li>
</ul>
<p>提示：</p>
<ul>
<li>在工作中，SSH 服务器的端口号很有可能<strong>不是 22</strong>，如果遇到这种情况就需要使用 <code>-p</code> 选项，指定正确的端口号，否则无法正常连接到服务器</li>
</ul>
</blockquote>
<h4 id="Windows-下-SSH-客户端的安装"><a href="#Windows-下-SSH-客户端的安装" class="headerlink" title="Windows 下 SSH 客户端的安装"></a>Windows 下 SSH 客户端的安装</h4><ul>
<li><code>Putty</code> <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="noopener">http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></li>
<li><code>XShell</code> <a href="http://xshellcn.com" target="_blank" rel="noopener">http://xshellcn.com</a></li>
</ul>
<h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a><code>scp</code></h4><ul>
<li>scp 就是 <code>secure copy</code>，是一个在 Linux 下用来进行 <strong>远程拷贝文件</strong> 的命令</li>
<li>它的<strong>地址格式与 ssh 基本相同</strong>，<strong>需要注意的是</strong>，在指定<strong>端口时用的是大写的 <code>-P</code> 而不是小写的</strong></li>
</ul>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE1986053d985427bbf0e220c8dc47c816/4541" alt="SCP示意图">￼</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py</span></span><br><span class="line"><span class="comment"># 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径</span></span><br><span class="line">scp -P port 01.py user@remote:Desktop/01.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py</span></span><br><span class="line">scp -P port user@remote:Desktop/01.py 01.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上 -r 选项可以传送文件夹</span></span><br><span class="line"><span class="comment"># 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop</span></span><br><span class="line">scp -r demo user@remote:Desktop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹</span></span><br><span class="line">scp -r user@remote:Desktop demo</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</td>
</tr>
<tr>
<td>-P</td>
<td>若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意：</p>
<ul>
<li><code>scp</code> 这个终端命令只能在 <code>Linux</code> 或者 <code>UNIX</code> 系统下使用</li>
<li>如果在 <code>Windows</code> 系统中，可以安装 <code>PuTTY</code>，使用 <code>pscp</code> 命令行工具或者安装 <code>FileZilla</code> 使用 <code>FTP</code> 进行文件传输</li>
</ul>
</blockquote>
<h4 id="FileZilla"><a href="#FileZilla" class="headerlink" title="FileZilla"></a><code>FileZilla</code></h4><ul>
<li>官方网站：<a href="https://www.filezilla.cn/download/client" target="_blank" rel="noopener">https://www.filezilla.cn/download/client</a></li>
<li><code>FileZilla</code> 在传输文件时，使用的是 <code>FTP 服务</code> 而不是 <code>SSH 服务</code>，因此端口号应该设置为 <code>21</code></li>
</ul>
<h4 id="SSH-高级"><a href="#SSH-高级" class="headerlink" title="SSH 高级"></a>SSH 高级</h4><ul>
<li>免密码登录</li>
<li>配置别名</li>
</ul>
<blockquote>
<p>提示：有关 SSH 配置信息都保存在用户家目录下的 <code>.ssh</code> 目录下</p>
</blockquote>
<h6 id="免密码登录"><a href="#免密码登录" class="headerlink" title="免密码登录"></a>免密码登录</h6><h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><ul>
<li>配置公钥 <ul>
<li>执行 <code>ssh-keygen</code> 即可生成 SSH 钥匙，一路回车即可</li>
</ul>
</li>
<li>上传公钥到服务器 <ul>
<li>执行 <code>ssh-copy-id -p port user@remote</code>，可以让远程服务器记住我们的公钥</li>
</ul>
</li>
</ul>
<h6 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h6><p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCEe2a278c2e5bd8260206e2e3ae5432b23/4543" alt="SSH 免密码示意图">￼</p>
<blockquote>
<p>非对称加密算法</p>
<ul>
<li>使用 <strong>公钥</strong> 加密的数据，需要使用 <strong>私钥</strong> 解密</li>
<li>使用 <strong>私钥</strong> 加密的数据，需要使用 <strong>公钥</strong> 解密</li>
</ul>
</blockquote>
<h6 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h6><p>每次都输入 <code>ssh -p port user@remote</code>，时间久了会觉得很麻烦，特别是当 <code>user</code>, <code>remote</code> 和 <code>port</code> 都得输入，而且还不好记忆</p>
<p>而 <strong>配置别名</strong> 可以让进一步偷懒，譬如用：<code>ssh mac</code> 来替代上面这么一长串，那么就在 <code>~/.ssh/config</code> 里面追加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host mac</span><br><span class="line">    HostName ip地址</span><br><span class="line">    User itheima</span><br><span class="line">    Port 22</span><br></pre></td></tr></table></figure>
<p><strong>保存之后，即可用 <code>ssh mac</code> 实现远程登录了，<code>scp</code> 同样可以使用</strong></p>
<h3 id="系统相关命令"><a href="#系统相关命令" class="headerlink" title="系统相关命令"></a>系统相关命令</h3><h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>date</td>
<td>查看系统时间</td>
</tr>
<tr>
<td>02</td>
<td>cal</td>
<td><code>calendar</code> 查看日历，<code>-y</code> 选项可以查看一年的日历</td>
</tr>
</tbody>
</table>
</div>
<h4 id="磁盘信息"><a href="#磁盘信息" class="headerlink" title="磁盘信息"></a>磁盘信息</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>df -h</td>
<td><code>disk free</code> 显示磁盘剩余空间</td>
</tr>
<tr>
<td>02</td>
<td>du -h [目录名]</td>
<td><code>disk usage</code> 显示目录下的文件大小</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>选项说明</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-h</td>
<td>以人性化的方式显示文件大小</td>
</tr>
</tbody>
</table>
</div>
<h4 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h4><ul>
<li>所谓 <strong>进程</strong>，通俗地说就是 <strong>当前正在执行的一个程序</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ps aux</td>
<td><code>process status</code> 查看<strong>进程的详细状况</strong></td>
</tr>
<tr>
<td>02</td>
<td>top</td>
<td><strong>动态显示运行中的进程并且排序</strong></td>
</tr>
<tr>
<td>03</td>
<td>htop</td>
<td>更方便的动态显示运行中的进程并且排序</td>
</tr>
<tr>
<td>04</td>
<td>kill [-9] 进程代号</td>
<td>终止指定代号的进程，<code>-9</code> 表示强行终止</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><code>ps</code> 默认只会显示当前用户通过终端启动的应用程序</p>
</blockquote>
<ul>
<li><code>ps</code> 选项说明功能</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>显示终端上的所有进程，包括其他用户的进程</td>
</tr>
<tr>
<td>u</td>
<td>显示进程的详细状态</td>
</tr>
<tr>
<td>x</td>
<td>显示没有控制终端的进程</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>提示：使用 <code>kill</code> 命令时，最好只终止由当前用户开启的进程，而不要终止 <code>root</code> 身份开启的进程，否则可能导致系统崩溃</p>
<ul>
<li>要退出 <code>top</code> 可以直接输入 <code>q</code></li>
</ul>
</blockquote>
<h3 id="用户权限相关命令"><a href="#用户权限相关命令" class="headerlink" title="用户权限相关命令"></a>用户权限相关命令</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><strong>用户</strong> 是 Linux 系统工作中重要的一环，用户管理包括 <strong>用户</strong> 与 <strong>组</strong> 管理</li>
<li>在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都<strong>必须拥有一个账号</strong>，并且<strong>对于不同的系统资源拥有不同的使用权限</strong></li>
<li>在 Linux 中，可以指定 <strong>每一个用户</strong> 针对 <strong>不同的文件或者目录</strong> 的 <strong>不同权限</strong></li>
<li>对 <strong>文件／目录</strong> 的权限包括：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">权限</th>
<th style="text-align:center">英文</th>
<th style="text-align:center">缩写</th>
<th style="text-align:center">数字代号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">读</td>
<td style="text-align:center">read</td>
<td style="text-align:center">r</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">02</td>
<td style="text-align:center">写</td>
<td style="text-align:center">write</td>
<td style="text-align:center">w</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">03</td>
<td style="text-align:center">执行</td>
<td style="text-align:center">excute</td>
<td style="text-align:center">x</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<h4 id="组"><a href="#组" class="headerlink" title="组"></a>组</h4><ul>
<li><p>为了方便用户管理，提出了 <strong>组</strong> 的概念</p>
</li>
<li><p>在实际应用中，可以预先针对 <strong>组</strong> 设置好权限，然后 <strong>将不同的用户添加到对应的组中</strong>，从而<strong>不用依次为每一个用户设置权限</strong></p>
</li>
</ul>
<h4 id="ls-l-扩展"><a href="#ls-l-扩展" class="headerlink" title="ls -l 扩展"></a>ls -l 扩展</h4><ul>
<li><code>ls -l</code> 可以查看文件夹下文件的详细信息，从左到右依次是：<ul>
<li><strong>权限</strong>，第 1 个字符如果是 <code>d</code> 表示目录</li>
<li><strong>硬链接数</strong>，通俗地讲，就是<strong>有多少种方式，可以访问到当前目录／文件</strong></li>
<li><strong>拥有者</strong>，家目录下 文件／目录 的拥有者通常都是当前用户</li>
<li><strong>组</strong>，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲</li>
<li><strong>大小</strong></li>
<li><strong>时间</strong></li>
<li><strong>名称</strong></li>
</ul>
</li>
</ul>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCEfcb35218f77b6bcfe80920758b9974ea/4545" alt="权限示意图">￼</p>
<h4 id="chmod-简单使用"><a href="#chmod-简单使用" class="headerlink" title="chmod 简单使用"></a><code>chmod</code> 简单使用</h4><ul>
<li><code>chmod</code> 可以修改 <strong>用户／组</strong> 对 <strong>文件／目录</strong> 的权限</li>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：以上方式会一次性修改 <code>拥有者</code> / <code>组</code> 权限</p>
</blockquote>
<h4 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h4><ul>
<li>Linux 系统中的 <code>root</code> 账号通常 <strong>用于系统的维护和管理</strong>，对操作系统的所有资源 <strong>具有所有访问权限</strong></li>
<li>在大多数版本的 Linux 中，都不推荐 <strong>直接使用 root 账号登录系统</strong></li>
<li>在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户”</li>
</ul>
<h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><ul>
<li><code>su</code> 是 <code>substitute user</code> 的缩写，表示 <strong>使用另一个用户的身份</strong></li>
<li><strong><code>sudo</code> 命令用来以其他身份来执行命令，预设的身份为 <code>root</code></strong></li>
<li>用户使用 <code>sudo</code> 时，必须先输入密码，之后有 <strong>5 分钟的有效期限</strong>，超过期限则必须重新输入密码</li>
</ul>
<blockquote>
<p>若其未经授权的用户企图使用 <code>sudo</code>，则会发出警告邮件给管理员</p>
</blockquote>
<h4 id="组管理-终端命令"><a href="#组管理-终端命令" class="headerlink" title="组管理 终端命令"></a><strong>组管理</strong> 终端命令</h4><blockquote>
<p>提示：<strong>创建组</strong> / <strong>删除组</strong> 的终端命令都需要通过 <code>sudo</code> 执行</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>groupadd 组名</td>
<td>添加组</td>
</tr>
<tr>
<td>02</td>
<td>groupdel 组名</td>
<td>删除组</td>
</tr>
<tr>
<td>03</td>
<td>cat /etc/group</td>
<td>确认组信息</td>
</tr>
<tr>
<td>04</td>
<td>chgrp -R 组名 文件/目录名</td>
<td>递归修改文件/目录的所属组</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>提示：</p>
<ul>
<li>组信息保存在 <code>/etc/group</code> 文件中</li>
<li><code>/etc</code> 目录是专门用来保存 <strong>系统配置信息</strong> 的目录￼</li>
</ul>
</blockquote>
<ul>
<li>在实际应用中，可以预先针对 <strong>组</strong> 设置好权限，然后 <strong>将不同的用户添加到对应的组中</strong>，从而<strong>不用依次为每一个用户设置权限</strong></li>
</ul>
<h4 id="用户管理-终端命令"><a href="#用户管理-终端命令" class="headerlink" title="用户管理 终端命令"></a><strong>用户管理</strong> 终端命令</h4><blockquote>
<p>提示：<strong>创建用户</strong> / <strong>删除用户</strong> / <strong>修改其他用户密码</strong> 的终端命令都需要通过 <code>sudo</code> 执行</p>
</blockquote>
<h6 id="创建用户／设置密码／删除用户"><a href="#创建用户／设置密码／删除用户" class="headerlink" title="创建用户／设置密码／删除用户"></a>创建用户／设置密码／删除用户</h6><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>useradd -m -g 组 新建用户名</td>
<td>添加新用户</td>
<td>-m 自动建立用户家目录-g 指定用户所在的组，否则会建立一个和同名的组</td>
</tr>
<tr>
<td>02</td>
<td>passwd 用户名</td>
<td>设置用户密码</td>
<td><strong>如果是普通用户，直接用 passwd 可以修改自己的账户密码</strong></td>
</tr>
<tr>
<td>03</td>
<td>userdel -r 用户名</td>
<td>删除用户</td>
<td><strong>-r 选项会自动删除用户家目录</strong></td>
</tr>
<tr>
<td>04</td>
<td>cat /etc/passwd \</td>
<td>grep 用户名</td>
<td>确认用户信息</td>
<td>新建用户后，用户信息会保存在 /etc/passwd 文件中</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>提示：</p>
<ul>
<li>创建用户时，如果忘记添加 <code>-m</code> 选项指定新用户的家目录 —— 最简单的方法就是<strong>删除用户，重新创建</strong></li>
<li>创建用户时，默认会创建一个和<strong>用户名</strong>同名的<strong>组名</strong></li>
<li>用户信息保存在 <code>/etc/passwd</code> 文件中</li>
</ul>
</blockquote>
<h6 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h6><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>id [用户名]</td>
<td>查看用户 UID 和 GID 信息</td>
</tr>
<tr>
<td>02</td>
<td>who</td>
<td>查看当前所有登录的用户列表</td>
</tr>
<tr>
<td>03</td>
<td>whoami</td>
<td>查看当前登录用户的账户名</td>
</tr>
</tbody>
</table>
</div>
<h6 id="passwd-文件"><a href="#passwd-文件" class="headerlink" title="passwd 文件"></a>passwd 文件</h6><p><code>/etc/passwd</code> 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是</p>
<ol>
<li>用户名</li>
<li>密码（x，表示加密的密码）</li>
<li>UID（用户标识）</li>
<li>GID（组标识）</li>
<li>用户全名或本地帐号</li>
<li>家目录</li>
<li>登录使用的 Shell，就是登录之后，使用的终端命令，<code>ubuntu</code> 默认用 <code>dash</code></li>
</ol>
<h6 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h6><ul>
<li><code>usermod</code> 可以用来设置 <strong>用户</strong> 的 <strong>主组</strong> ／ <strong>附加组</strong> 和 <strong>登录 Shell</strong>，命令格式如下：<ul>
<li><strong>主组</strong>：通常在新建用户时指定，在 <code>etc/passwd</code> 的第 4 列 <strong>GID 对应的组</strong></li>
<li><strong>附加组</strong>：在 <code>etc/group</code> 中最后一列表示该组的用户列表，用于指定 <strong>用户的附加权限</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>提示：设置了用户的附加组之后，需要重新登录才能生效！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改用户的主组（passwd 中的 GID）</span></span><br><span class="line">usermod -g 组 用户名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户的附加组</span></span><br><span class="line">usermod -G 组 用户名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户登录 Shell</span></span><br><span class="line">usermod -s /bin/bash 用户名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：默认使用 <code>useradd</code> 添加的用户是没有权限使用 <code>sudo</code> 以 <code>root</code> 身份执行命令的，可以使用以下命令，将用户添加到 <code>sudo</code> 附加组中</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -G sudo 用户名</span><br></pre></td></tr></table></figure>
<h6 id="which"><a href="#which" class="headerlink" title="which"></a>which</h6><blockquote>
<p>提示</p>
<ul>
<li><code>/etc/passwd</code> 是用于保存用户信息的文件</li>
<li><code>/usr/bin/passwd</code> 是用于修改用户密码的程序</li>
</ul>
</blockquote>
<ul>
<li><code>which</code> 命令可以<strong>查看执行命令所在位置</strong>，例如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># /bin/ls</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">which</span> useradd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># /usr/sbin/useradd</span></span><br></pre></td></tr></table></figure>
<h6 id="bin-和-sbin"><a href="#bin-和-sbin" class="headerlink" title="bin 和 sbin"></a><code>bin</code> 和 <code>sbin</code></h6><ul>
<li>在 <code>Linux</code> 中，绝大多数可执行文件都是保存在 <code>/bin</code>、<code>/sbin</code>、<code>/usr/bin</code>、<code>/usr/sbin</code></li>
<li><code>/bin</code>（<code>binary</code>）是二进制执行文件目录，<strong>主要用于具体应用</strong></li>
<li><code>/sbin</code>（<code>system binary</code>）是<strong>系统管理员专用</strong>的二进制代码存放目录，主要用于<strong>系统管理</strong></li>
<li><code>/usr/bin</code>（<code>user commands for applications</code>）后期安装的一些软件</li>
<li><code>/usr/sbin</code>（<code>super user commands for applications</code>）超级用户的一些管理程序</li>
</ul>
<blockquote>
<p>提示：</p>
<ul>
<li><code>cd</code> 终端命令是内置在系统内核中的，没有独立的文件，因此用 <code>which</code> 无法找到 <code>cd</code> 命令的位置</li>
</ul>
</blockquote>
<h6 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h6><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>su - 用户名</td>
<td>切换用户，并且切换目录</td>
<td>- 可以切换到用户家目录，否则保持位置不变</td>
</tr>
<tr>
<td>02</td>
<td>exit</td>
<td>退出当前登录账户</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>su</code> 不接用户名，可以切换到 <code>root</code>，但是不推荐使用，因为不安全</li>
<li><code>exit</code> 示意图如下：</li>
</ul>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCEd82838dbf01984787215cb63bfafd36e/4547" alt="su和exit示意图">￼</p>
<h6 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h6><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>chown</td>
<td>修改拥有者</td>
</tr>
<tr>
<td>02</td>
<td>chgrp</td>
<td>修改组</td>
</tr>
<tr>
<td>03</td>
<td>chmod</td>
<td>修改权限</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改文件|目录的拥有者</span></span><br><span class="line">chown 用户名 文件名|目录名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件|目录的组</span></span><br><span class="line">chgrp -R 组名 文件名|目录名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件权限</span></span><br><span class="line">chmod -R 755 文件名|目录名</span><br></pre></td></tr></table></figure>
<ul>
<li><code>chmod</code> 在设置权限时，可以简单地使用三个数字分别对应 <strong>拥有者</strong> ／ <strong>组</strong> 和 <strong>其他</strong> 用户的权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他</span></span><br><span class="line">chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure>
<p>![文件权限示意图](<a href="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE2543790c4c010efe7a9f24206b82b55e/4549￼" target="_blank" rel="noopener">http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE2543790c4c010efe7a9f24206b82b55e/4549￼</a></p>
<ul>
<li>常见数字组合有（<code>u</code>表示用户／<code>g</code>表示组／<code>o</code>表示其他）： <ul>
<li><code>777</code> ===&gt; <code>u=rwx,g=rwx,o=rwx</code> </li>
<li><code>755</code> ===&gt; <code>u=rwx,g=rx,o=rx</code></li>
<li><code>644</code> ===&gt; <code>u=rw,g=r,o=r</code></li>
</ul>
</li>
</ul>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><ul>
<li><code>find</code> 命令功能非常强大，通常用来在 <strong>特定的目录下</strong> <strong>搜索</strong> 符合条件的文件</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>find [路径] -name “*.py”</td>
<td>查找指定路径下扩展名是 <code>.py</code> 的文件，包括子目录</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>如果省略路径，表示在当前文件夹下查找</strong></li>
<li>之前学习的通配符，在使用 <code>find</code> 命令时同时可用</li>
</ul>
<h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>ln -s 被链接的源文件 链接文件</td>
<td>建立文件的软链接，用通俗的方式讲<strong>类似于</strong> Windows 下的<strong>快捷方式</strong></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>注意：</li>
<li>没有 <code>-s</code> 选项建立的是一个 <strong>硬链接文件</strong><ul>
<li>两个文件占用相同大小的硬盘空间，<strong>工作中几乎不会建立文件的硬链接</strong></li>
</ul>
</li>
<li><strong>源文件要使用绝对路径</strong>，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用</li>
</ul>
<h4 id="文件软硬链接的示意图"><a href="#文件软硬链接的示意图" class="headerlink" title="文件软硬链接的示意图"></a>文件软硬链接的示意图</h4><p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE7aa2d85f00d080fb528d277537be5bbb/4551" alt="文件软硬链接示意图"></p>
<blockquote>
<p>在 Linux 中，<strong>文件名</strong> 和 <strong>文件的数据</strong> 是分开存储的</p>
</blockquote>
<ul>
<li>提示： <ul>
<li>在 Linux 中，只有文件的 <code>硬链接数 == 0</code> 才会被删除</li>
<li>使用 <code>ls -l</code> 可以查看一个文件的硬链接的数量</li>
</ul>
</li>
</ul>
<h4 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h4><ul>
<li><strong>打包压缩</strong> 是日常工作中备份文件的一种方式</li>
<li>在不同操作系统中，常用的打包压缩方式是不同的 <ul>
<li><code>Windows</code> 常用 <code>rar</code></li>
<li><code>Mac</code> 常用 <code>zip</code></li>
<li><code>Linux</code> 常用 <code>tar.gz</code></li>
</ul>
</li>
</ul>
<h4 id="打包-／-解包"><a href="#打包-／-解包" class="headerlink" title="打包 ／ 解包"></a>打包 ／ 解包</h4><ul>
<li><code>tar</code> 是 Linux 中最常用的 <strong>备份</strong>工具，此命令可以 <strong>把一系列文件</strong> 打包到 <strong>一个大文件中</strong>，也可以把一个 <strong>打包的大文件恢复成一系列文件</strong></li>
<li><code>tar</code> 的命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打包文件</span></span><br><span class="line">tar -cvf 打包文件.tar 被打包的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包文件</span></span><br><span class="line">tar -xvf 打包文件.tar</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tar</code> 选项说明</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>生成档案文件，创建打包文件</td>
</tr>
<tr>
<td>x</td>
<td>解开档案文件</td>
</tr>
<tr>
<td>v</td>
<td>列出归档解档的详细过程，显示进度</td>
</tr>
<tr>
<td>f</td>
<td>指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意：<code>f</code> 选项必须放在最后，其他选项顺序可以随意</p>
</blockquote>
<h4 id="压缩／解压缩"><a href="#压缩／解压缩" class="headerlink" title="压缩／解压缩"></a>压缩／解压缩</h4><h6 id="gzip"><a href="#gzip" class="headerlink" title="`gzip"></a>`gzip</h6><p><code>tar</code> 与 <code>gzip</code> 命令结合可以使用实现文件 <strong>打包和压缩</strong></p>
<ul>
<li>打包和压缩<ul>
<li><code>tar</code> 只负责打包文件，但不压缩</li>
<li>用 <code>gzip</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.gz</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>在 <code>Linux</code> 中，最常见的压缩文件格式就是 <code>xxx.tar.gz</code></p>
</blockquote>
<ul>
<li><strong>在 <code>tar</code> 命令中有一个选项 -z 可以调用 <code>gzip</code>，从而可以方便的实现压缩和解压缩的功能</strong></li>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩文件</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩到指定路径</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz -C 目标路径</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-C</td>
<td><strong>解压缩到指定目录，注意：要解压缩的目录必须存在</strong></td>
</tr>
</tbody>
</table>
</div>
<h6 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a><code>bzip2</code></h6><ul>
<li><code>tar</code> 与 <code>bzip2</code> 命令结合可以使用实现文件 <strong>打包和压缩</strong>（用法和 <code>gzip</code> 一样）<ul>
<li><code>tar</code> 只负责打包文件，但不压缩，</li>
<li>用 <code>bzip2</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.bz2</code></li>
</ul>
</li>
<li>在 <code>tar</code> 命令中有一个选项 <strong>-j</strong> 可以调用 <code>bzip2</code>，从而可以方便的实现压缩和解压缩的功能</li>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩文件</span></span><br><span class="line">tar -jxvf 打包文件.tar.bz2</span><br></pre></td></tr></table></figure>
<h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><h6 id="通过-apt-安装／卸载软件"><a href="#通过-apt-安装／卸载软件" class="headerlink" title="通过 apt 安装／卸载软件"></a>通过 apt 安装／卸载软件</h6><ul>
<li>apt 是 <code>Advanced Packaging Tool</code>，是 Linux 下的一款安装包管理工具</li>
<li>可以在终端中方便的 <strong>安装</strong>／<strong>卸载</strong>／<strong>更新软件包</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 安装软件</span></span><br><span class="line">$ sudo apt install 软件包</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 卸载软件</span></span><br><span class="line">$ sudo apt remove 软件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 更新已安装的包</span></span><br><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></table></figure>
<h6 id="配置软件源"><a href="#配置软件源" class="headerlink" title="配置软件源"></a>配置软件源</h6><ul>
<li>如果希望在 <code>ubuntu</code> 中安装软件，<strong>更加快速</strong>，可以通过设置<strong>镜像源</strong>，选择一个访问网速更快的服务器，来提供软件下载／安装服务</li>
<li>提示：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了</li>
</ul>
<blockquote>
<p>所谓镜像源，就是<strong>所有服务器的内容是相同的（镜像）</strong>，但是根据所在位置不同，国内服务器通常速度会更快一些！</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件和目录及相关操作</title>
    <url>/2020/03/01/linux_01%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h3 id="单用户操作系统和多用户操作系统"><a href="#单用户操作系统和多用户操作系统" class="headerlink" title="单用户操作系统和多用户操作系统"></a>单用户操作系统和多用户操作系统</h3><ul>
<li><strong>单用户操作系统</strong>：指一台计算机在同一时间 <strong>只能由一个用户</strong> 使用，<strong>一个用户独自享用系统的全部硬件和软件资源</strong><ul>
<li><strong>Windows XP</strong> 之前的版本都是单用户操作系统</li>
</ul>
</li>
<li><strong>多用户操作系统</strong>：指一台计算机在同一时间可以由 <strong>多个用户</strong> 使用，多个用户共<strong>同享用系统的全部硬件和软件资源</strong><ul>
<li><strong>Unix</strong> 和 <strong>Linux</strong> 的设计初衷就是多用户操作系统</li>
</ul>
</li>
</ul>
<h3 id="linux下的文件系统"><a href="#linux下的文件系统" class="headerlink" title="linux下的文件系统"></a>linux下的文件系统</h3><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><ul>
<li><p>在 <code>Windows</code> 下，打开 “计算机”，看到的是一个个的驱动器盘符：eg: C盘，D盘…。</p>
<ul>
<li>每个驱动器都有自己的根目录结构，形成多个树并列的情形。</li>
</ul>
</li>
<li><p>在 <code>Linux</code> 下，看不到驱动器盘符，看到的是<strong>文件夹（目录）</strong></p>
<ul>
<li>linux没有盘符概念，只有一个根目录 <code>/</code>，所有文件都在它下面</li>
</ul>
</li>
</ul>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE176901b2234a4a2fcab1e598a568ca75/4537" alt="linux文件系统"></p>
<ul>
<li><p>用户目录</p>
<ul>
<li><p>位于 <code>/home/xxx</code>，称之为用户工作目录或家目录，表示方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/xx</span><br><span class="line">~</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>/：根目录，<strong>一般根目录下只存放目录</strong>，在 linux 下有且只有一个根目录，所有的东西都是从这里开始 </p>
<ul>
<li>当在终端里输入 <code>cd /home</code>，其实是在告诉电脑，先从 <code>/</code>（根目录）开始，再进入到 <code>home</code> 目录</li>
</ul>
</li>
<li><p>/bin、/usr/bin：可执行二进制文件的目录，如<strong>常用的命令 ls、tar、mv、cat</strong> 等</p>
</li>
<li><p>/boot：放置 linux <strong>系统启动</strong>时用到的一些文件，如 linux 的<strong>内核</strong>文件：<code>/boot/vmlinuz</code>，<strong>系统引导</strong>管理器：<code>/boot/grub</code></p>
</li>
<li><p>/dev：存放linux系统下的<strong>设备文件</strong>，<strong>访问该目录下某个文件，相当于访问某个设备</strong>，常用的是挂载光驱<code>mount /dev/cdrom /mnt</code></p>
</li>
<li><p>/etc：<strong>系统配置文件</strong>存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有  </p>
<ul>
<li>/etc/inittab</li>
<li>/etc/fstab</li>
<li>/etc/init.d</li>
<li>/etc/X11</li>
<li>/etc/sysconfig</li>
<li><p>/etc/xinetd.d</p>
</li>
<li><p>/etc/profile</p>
</li>
</ul>
</li>
<li><p>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下 </p>
<ul>
<li><strong><code>~</code> 表示当前用户的家目录</strong></li>
<li><code>~xxx</code> 表示用户 <code>xxx</code> 的家目录</li>
</ul>
</li>
<li><p>/lib、/usr/lib、/usr/local/lib：<strong>系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助</strong></p>
</li>
<li><p>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下</p>
</li>
<li><p>/mnt: /media：光盘默认<strong>挂载点</strong>，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载</p>
</li>
<li><p>/opt：给主机<strong>额外安装软件所摆放的目录</strong></p>
</li>
<li><p>/proc：<strong>此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间</strong>，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等</p>
</li>
<li><p>/root：<strong>系统管理员root的家目录</strong></p>
</li>
<li><p>/sbin、/usr/sbin、/usr/local/sbin：放置<strong>系统管理员使用的可执行命令</strong>，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令<strong>，一般用户只能”查看”而不能设置和使用</strong></p>
</li>
<li><p>/tmp：一般用户或正在执行的程序<strong>临时存放文件的目录</strong>，任何人都可以访问，<strong>重要数据不可放置在此目录下</strong></p>
</li>
<li><p>/srv：<strong>服务启动之后需要访问的数据目录</strong>，如 www 服务需要访问的网页数据存放在 /srv/www 内</p>
</li>
<li><p>/usr：<strong>应用程序存</strong>放目录 </p>
<ul>
<li>/usr/bin：存放应用程序</li>
<li>/usr/share：存放共享数据</li>
<li>/usr/lib：存放不能直接运行的，<strong>却是许多程序运行所必需的一些函数库文件</strong></li>
<li>/usr/local：存放<strong>软件升级包</strong></li>
<li>/usr/share/doc：系统说明文件存放目录</li>
<li>/usr/share/man：程序说明文件存放目录</li>
</ul>
</li>
<li><p>/var：放置系统执行过程中<strong>经常变化的文件</strong> </p>
<ul>
<li>/var/log：随时更改的<strong>日志</strong>文件 </li>
<li>/var/spool/mail：邮件存放的目录</li>
<li>/var/run：程序或服务启动后，其 PID 存放在该目录下</li>
</ul>
</li>
</ul>
<h4 id="文件和目录常用命令"><a href="#文件和目录常用命令" class="headerlink" title="文件和目录常用命令"></a>文件和目录常用命令</h4><ul>
<li>查看目录内容 <ul>
<li><code>ls</code></li>
</ul>
</li>
<li>切换目录 <ul>
<li><code>cd</code></li>
</ul>
</li>
<li>创建和删除操作 <ul>
<li><code>touch</code></li>
<li><code>rm</code></li>
<li><code>mkdir</code></li>
</ul>
</li>
<li>拷贝和移动文件 <ul>
<li><code>cp</code></li>
<li><code>mv</code></li>
</ul>
</li>
<li>查看文件内容 <ul>
<li><code>cat</code></li>
<li><code>more</code></li>
<li><code>grep</code></li>
</ul>
</li>
<li>其他 <ul>
<li><code>echo</code></li>
<li>重定向 <code>&gt;</code> 和 <code>&gt;&gt;</code></li>
<li>管道 <code>|</code></li>
</ul>
</li>
</ul>
<h6 id="查看目录ls-命令说明"><a href="#查看目录ls-命令说明" class="headerlink" title="查看目录ls 命令说明"></a>查看目录<code>ls</code> 命令说明</h6><ul>
<li><code>ls</code> 是英文单词 <strong>list</strong> 的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于 <strong>DOS</strong> 下的 <code>dir</code> 命令</li>
</ul>
<h6 id="Linux-下文件和目录的特点"><a href="#Linux-下文件和目录的特点" class="headerlink" title="Linux 下文件和目录的特点"></a>Linux 下文件和目录的特点</h6><ul>
<li>Linux <strong>文件</strong> 或者 <strong>目录</strong> 名称最长可以有 <code>256</code> 个字符</li>
<li>以 <code>.</code> 开头的文件为隐藏文件，需要用 -a 参数才能显示</li>
<li><strong>.</strong> 代表当前目录</li>
<li><strong>..</strong> 代表上一级目录</li>
</ul>
<h6 id="ls-常用选项"><a href="#ls-常用选项" class="headerlink" title="ls 常用选项"></a>ls 常用选项</h6><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>显示指定目录下所有子目录与文件，包括隐藏文件</td>
</tr>
<tr>
<td>-l</td>
<td>以列表方式显示文件的详细信息</td>
</tr>
<tr>
<td>-h</td>
<td>配合 -l 以人性化的方式显示文件大小</td>
</tr>
</tbody>
</table>
</div>
<h6 id="计算机中文件大小的表示方式"><a href="#计算机中文件大小的表示方式" class="headerlink" title="计算机中文件大小的表示方式"></a>计算机中文件大小的表示方式</h6><div class="table-container">
<table>
<thead>
<tr>
<th>单位</th>
<th>英文</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节</td>
<td>B（Byte）</td>
<td>在计算机中作为一个数字单元，一般为 8 位二进制数</td>
</tr>
<tr>
<td>千</td>
<td>K（Kibibyte）</td>
<td>1 KB = 1024 B，千字节 （1024 = 2 ** 10）</td>
</tr>
<tr>
<td>兆</td>
<td>M（Mebibyte）</td>
<td>1 MB = 1024 KB，百万字节</td>
</tr>
<tr>
<td>千兆</td>
<td>G（Gigabyte）</td>
<td>1 GB = 1024 MB，十亿字节，千兆字节</td>
</tr>
<tr>
<td>太</td>
<td>T（Terabyte）</td>
<td>1 TB = 1024 GB，万亿字节，太字节</td>
</tr>
<tr>
<td>拍</td>
<td>P（Petabyte）</td>
<td>1 PB = 1024 TB，千万亿字节，拍字节</td>
</tr>
<tr>
<td>艾</td>
<td>E（Exabyte）</td>
<td>1 EB = 1024 PB，百亿亿字节，艾字节</td>
</tr>
<tr>
<td>泽</td>
<td>Z（Zettabyte）</td>
<td>1 ZB = 1024 EB，十万亿亿字节，泽字节</td>
</tr>
<tr>
<td>尧</td>
<td>Y（Yottabyte）</td>
<td>1 YB = 1024 ZB，一亿亿亿字节，尧字节</td>
</tr>
</tbody>
</table>
</div>
<h6 id="ls-通配符的使用"><a href="#ls-通配符的使用" class="headerlink" title="ls 通配符的使用"></a>ls 通配符的使用</h6><div class="table-container">
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>代表任意个数个字符</td>
</tr>
<tr>
<td>?</td>
<td>代表任意一个字符，至少 1 个</td>
</tr>
<tr>
<td>[]</td>
<td>表示可以匹配字符组中的任一一个</td>
</tr>
<tr>
<td>[abc]</td>
<td>匹配 a、b、c 中的任意一个</td>
</tr>
<tr>
<td>[a-f]</td>
<td>匹配从 a 到 f 范围内的的任意一个字符</td>
</tr>
</tbody>
</table>
</div>
<h4 id="磁盘分区类型"><a href="#磁盘分区类型" class="headerlink" title="磁盘分区类型"></a>磁盘分区类型</h4><ul>
<li>主分区：最多只能有四个</li>
<li>扩展分区：最多一个，算作主分区的一种，主分区加扩展分区最多有四个。扩展分区不能存储数据和格式化，必须再划分为逻辑分区才可以使用。</li>
<li>逻辑分区：在扩展分区中划分</li>
</ul>
<p>逻辑分区的编号从5开始</p>
<h4 id="支持的文件系统"><a href="#支持的文件系统" class="headerlink" title="支持的文件系统"></a>支持的文件系统</h4><ul>
<li>ext2:ext文件系统的升级版。最大支持16TB的分区和最大2TB的文件。</li>
<li>ext3:ext2的升级，增加日志功能。</li>
<li>ext4:ext3升级版本，主流使用，功能强大</li>
</ul>
<h4 id="文件系统常用命令"><a href="#文件系统常用命令" class="headerlink" title="文件系统常用命令"></a>文件系统常用命令</h4><h4 id="df-du-fsck-dump2fs"><a href="#df-du-fsck-dump2fs" class="headerlink" title="df, du, fsck, dump2fs"></a>df, du, fsck, dump2fs</h4><h6 id="文件系统查看命令df"><a href="#文件系统查看命令df" class="headerlink" title="文件系统查看命令df"></a>文件系统查看命令df</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df \[选项][挂载点]</span><br><span class="line"></span><br><span class="line">-a 所有文件系统信息</span><br><span class="line"></span><br><span class="line">-h 使用习惯单位显示容量，如kB,MB,GB</span><br><span class="line"></span><br><span class="line">ls 只统计目录下的大小，而不会统计子目录下的数据大小。</span><br></pre></td></tr></table></figure>
<h6 id="统计目录或文件大小du"><a href="#统计目录或文件大小du" class="headerlink" title="统计目录或文件大小du"></a>统计目录或文件大小du</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a , -h , -s</span><br></pre></td></tr></table></figure>
<p>df命令从文件系统考虑，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（eg. 文件已经被删除，但程序并没有释放空间）</p>
<p><strong>du命令面向文件，只会计算文件或目录占用的空间。</strong></p>
<h6 id="文件系统修复命令fsck"><a href="#文件系统修复命令fsck" class="headerlink" title="文件系统修复命令fsck"></a>文件系统修复命令fsck</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fsck[选项]分区设备文件名</span><br></pre></td></tr></table></figure>
<h6 id="显示磁盘状态命令dumpe2fs"><a href="#显示磁盘状态命令dumpe2fs" class="headerlink" title="显示磁盘状态命令dumpe2fs"></a>显示磁盘状态命令dumpe2fs</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dumpe2fs 分区设备文件名</span><br></pre></td></tr></table></figure>
<h4 id="文件系统常用命令-挂载命令"><a href="#文件系统常用命令-挂载命令" class="headerlink" title="文件系统常用命令-挂载命令"></a>文件系统常用命令-挂载命令</h4><h6 id="查询与自动挂载"><a href="#查询与自动挂载" class="headerlink" title="查询与自动挂载"></a>查询与自动挂载</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount [-l]：查询系统中已经挂载的设备，-l会显示卷标名称</span><br><span class="line"></span><br><span class="line">mount -a 依据配置文件/etc/fastb的内容，自动挂载</span><br></pre></td></tr></table></figure>
<h6 id="挂载命令格式"><a href="#挂载命令格式" class="headerlink" title="挂载命令格式"></a>挂载命令格式</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">-t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3，ext4,iso9660等文件系统</span><br><span class="line"></span><br><span class="line">-L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载</span><br><span class="line"></span><br><span class="line">-o 特殊指令（remount ...）</span><br><span class="line"></span><br><span class="line">mount -o remount ,noexec /home</span><br></pre></td></tr></table></figure>
<h6 id="挂载光盘与U盘"><a href="#挂载光盘与U盘" class="headerlink" title="挂载光盘与U盘"></a>挂载光盘与U盘</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">挂载光盘</span></span><br><span class="line"></span><br><span class="line">mkdir /mnt/cdrom/ #建立挂载点</span><br><span class="line"></span><br><span class="line">mount -t iso9660 /dev/cdrom /mnt/cdrom #挂载光盘</span><br><span class="line"></span><br><span class="line">mount /dev/sr0 /mnt/cdrom</span><br></pre></td></tr></table></figure>
<h6 id="卸载命令"><a href="#卸载命令" class="headerlink" title="卸载命令"></a>卸载命令</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umount 设备文件名或挂载点</span><br><span class="line"></span><br><span class="line">umount /mnt/cdrom</span><br></pre></td></tr></table></figure>
<h6 id="挂载U盘"><a href="#挂载U盘" class="headerlink" title="挂载U盘"></a>挂载U盘</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fdisk -l 查看U盘设备文件名</span><br><span class="line"></span><br><span class="line">mount -t vfat /dev/sdb1 /mnt/usb/</span><br><span class="line"></span><br><span class="line">linux默认不支持NTFS文件系统</span><br></pre></td></tr></table></figure>
<h4 id="fdisk分区"><a href="#fdisk分区" class="headerlink" title="fdisk分区"></a>fdisk分区</h4><h6 id="fdisk命令分区过程"><a href="#fdisk命令分区过程" class="headerlink" title="fdisk命令分区过程"></a>fdisk命令分区过程</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.添加硬盘，虚拟机必须在关机的情况下添加</span><br><span class="line"></span><br><span class="line">2.查看新硬盘 fdisk -l</span><br><span class="line"></span><br><span class="line">3.使用fdisk命令分区</span><br><span class="line"></span><br><span class="line">fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">4.重新读取分区表信息</span><br><span class="line"></span><br><span class="line">partprobe</span><br><span class="line"></span><br><span class="line">5.格式化分区</span><br><span class="line"></span><br><span class="line">扩展分区不可以格式化</span><br><span class="line"></span><br><span class="line">mkfs -t ext4 /dev/sdb1</span><br><span class="line"></span><br><span class="line">6.建立挂载分区</span><br></pre></td></tr></table></figure>
<h6 id="分区自动挂载与fstab文件修复"><a href="#分区自动挂载与fstab文件修复" class="headerlink" title="分区自动挂载与fstab文件修复"></a>分区自动挂载与fstab文件修复</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">将挂载写入/etc/fstab文件，一定要写对</span><br><span class="line"></span><br><span class="line">mount -a 依据配置文件 /etc/fstab的内容，自动挂载</span><br><span class="line"></span><br><span class="line">/etc/fstab文件修复</span><br><span class="line"></span><br><span class="line">mount -o remount,rm /</span><br></pre></td></tr></table></figure>
<h4 id="分配swap分区"><a href="#分配swap分区" class="headerlink" title="分配swap分区"></a>分配swap分区</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.free命令</span><br><span class="line">查看内存与swap分区使用情况</span><br><span class="line">cached(缓存):加速数据的读取过程</span><br><span class="line">buffer(缓冲)：写入数据过程中，将分散的写入操作保存到内存中，当达到一定的程度再集中写入硬盘，加速数据的写入过程。</span><br><span class="line"></span><br><span class="line">2.新建swap分区</span><br><span class="line">fdisk /dev/sdb</span><br><span class="line">还需将分区ID改为82</span><br><span class="line"></span><br><span class="line">3.格式化</span><br><span class="line">mkswap /dev/sdb6</span><br><span class="line"></span><br><span class="line">4.加入swap分区</span><br><span class="line">swapon /dev/sdb6 加入swap分区</span><br><span class="line">swapoff /dev/sdb6 取消swap分区</span><br><span class="line"></span><br><span class="line">5.swap分区开机自动挂载</span><br><span class="line">vi /etc/fstab</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C基础</title>
    <url>/2020/01/06/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>优点：执行速度快，功能强大，编程自由。代码量小：dll封装等</p>
<p>缺点：编程周期长，可移植性较差，过于自由，容易出错，对于平台库依赖较多。</p>
<p>可用部分：网站后台，程序库，游戏引擎，写语言，操作系统，微处理器</p>
<p>构成：32个关键字，9种控制语句，34种运算符（算术运算符，关系运算符，逻辑运算符，位运算符，复制运算傅符，条件运算符，逗号运算符，指针运算符，求字节数，强制类型转换，分量运算符，下标运算符）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xxx&gt;  //表示导入系统文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"xxx"</span> <span class="comment">//表示导入自定义文件</span></span></span><br></pre></td></tr></table></figure>
<h4 id="c编译步骤"><a href="#c编译步骤" class="headerlink" title="c编译步骤"></a>c编译步骤</h4><ul>
<li>预处理：宏文件展开、头文件展开、条件编译等，同时将代码中的注释删除，并不检查语法<ul>
<li>gcc -E hello.c -o hello.i</li>
</ul>
</li>
<li>编译：检查语法，将预处理后文件编译生成汇编文件<ul>
<li>gcc -S hello.i -o hello.s</li>
</ul>
</li>
<li>汇编：将汇编文件生成目标文件（二进制文件）<ul>
<li>gcc -c hello.s -o hello.o</li>
</ul>
</li>
<li>链接：程序依赖各种库，编译之后需要将库链接到最终的可执行程序中<ul>
<li>gcc hello.o -o hello</li>
<li>-o 表示生成一个文件</li>
</ul>
</li>
</ul>
<h4 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h4><p>硬盘（外部存储设备）-&gt;内存（MEM，代码区，数据区，栈区，堆区）-&gt;CPU </p>
<h4 id="64位与32位操作系统区别"><a href="#64位与32位操作系统区别" class="headerlink" title="64位与32位操作系统区别"></a>64位与32位操作系统区别</h4><ul>
<li>寄存器是CPU内部最基本的存储单元</li>
<li>CPU对外通过总线（地址、控制、数据）来和外部设备交互，总线的带宽是8位，同时CPU的寄存器也是8位，那个CPU就叫做8位CPU</li>
<li>如果总线是32位，寄存器也是32位的，这个CPU为32位CPU</li>
<li>所有的64位CPU兼容32位的指令，32位要兼容16位的指令，所以在64位的CPU上可以识别32位的指令</li>
<li>在64位的架构上运行64位的操作系统，那个这个系统为64位</li>
<li>64位的CPU运行32位的操作系统，这个系统为32位</li>
<li>64位的软件不能运行在32位的CPU上</li>
</ul>
<p>总线越宽，速度越快</p>
<h4 id="寄存器，缓存，内存的关系"><a href="#寄存器，缓存，内存的关系" class="headerlink" title="寄存器，缓存，内存的关系"></a>寄存器，缓存，内存的关系</h4><p>所有的运算都要放到CPU中计算，<strong>CPU直接打交道的其实是寄存器</strong>。</p>
<p>内存和寄存器进行数据读写</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>数据类型关键字：<code>char, short, int ,long, float, double</code></p>
<p><code>unsigned, signed, struct, union, enum, void</code></p>
<p>控制语句关键字：<code>if ,else, switch, case,default, for ,while , break, continue,goto, return</code></p>
<p>存储类关键字：<code>auto , extern, register, static, const</code></p>
<p>其他关键字：<code>sizeof, typedef（ 定义函数指针，定义别名）,  volatile（防止编译器做优化）</code></p>
<p><strong>数据类型的作用：编译器预算对象（变量）分配的内存空间大小</strong></p>
<p>基址：在编译过程中决定</p>
<p>常量：在程序<strong>运行过程中，其值不能发生变化的量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> price = <span class="number">3</span>; <span class="comment">//（不安全写法，限定在c语言中）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159 <span class="comment">//宏定义常量</span></span></span><br></pre></td></tr></table></figure>
<p>变量：在程序运行过程中，其值可以发生变化的量</p>
<h4 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h4><ul>
<li><p>不能使用系统关键字</p>
</li>
<li><p>允许字母，下划线，数字，数字不能开头</p>
</li>
<li><p>标识符区分大小写</p>
</li>
<li><p>见名知意</p>
</li>
</ul>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%d</span><br><span class="line"></span><br><span class="line">%o <span class="number">8</span>进制<span class="keyword">int</span>类型</span><br><span class="line"></span><br><span class="line">%x <span class="number">16</span>进制<span class="keyword">int</span>类型，字母以小写输出</span><br><span class="line"></span><br><span class="line">%X <span class="number">16</span>进制<span class="keyword">int</span> ,字母以大写输出</span><br><span class="line"></span><br><span class="line">%u 输出<span class="number">10</span>进制无符号数</span><br><span class="line">    </span><br><span class="line">定义八进制数据：以<span class="number">0</span>开头</span><br><span class="line"></span><br><span class="line">定义十六进制数据：以<span class="number">0</span>x开头</span><br><span class="line"></span><br><span class="line">在计算机中不可以直接定义二进制</span><br><span class="line"></span><br><span class="line">&amp;取地址符</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>()不是函数，不需要包含任何头文件，计算一个数据类型的大小，单位为字节。</span><br></pre></td></tr></table></figure>
<h3 id="操作系统栈和堆"><a href="#操作系统栈和堆" class="headerlink" title="操作系统栈和堆"></a>操作系统栈和堆</h3><p>地址空间布局：<br><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE7eb3c2e043e8d12a3988f4ca2123164e/4553" alt="操作系统地址空间布局">￼</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p><strong>执行期间编译器自动分配，编译器用它实现函数调用</strong>，调用函数时，栈增长，函数返回时，栈收缩。<strong>局部变量、函数参数、返回数据、返回地址等放在栈中</strong>。</p>
<p>栈的特点</p>
<ol>
<li>内存分配取决于编译器，用户栈在程序运行期间可以<strong>动态的扩展和收缩</strong>。</li>
<li>和数据结构中的“栈”本质上是不一样的，但是操作方式类似于栈。</li>
<li>数据从栈中的进出满足“后进先出”的规律。</li>
<li>栈向低地址方向增长，<strong>esp（栈指针）指向栈顶元素。</strong></li>
</ol>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>动态储存器分配器维护着的一个<strong>进程的虚拟存储器区域</strong>。一般由<strong>程序员分配释放（堆在操作系统对进程初始化的时候分配），若程序员不释放，程序结束时可能由OS回收，每个进程，内核都维护着一个变量brk指向堆顶。</strong></p>
<p>堆的特点</p>
<ol>
<li>内存分配取决于程序员，C/C++可以<strong>手动释放</strong>该片内存。</li>
<li>和数据结构的”堆“完全两回事，没有半点关系，在这里<strong>堆的结构更像链表</strong>。</li>
<li><strong>所有的对象，包括数组的对象都存在堆上</strong>。</li>
<li><strong>堆内存被所有的线程共享</strong>。</li>
<li><strong>引用类型总是放在堆中。</strong></li>
<li>堆向高地址方向增长，内核维护的变量brk指向堆顶。</li>
</ol>
<p>注意：值类型和指针总是放在他们被声明的地方<br><strong>当值类型的数据在方法体内被声明时，它们都应该放在栈上。</strong><br>如果一个值类型被声明在方法体外且存在于一个引用类型中，那么它将会被堆里的引用类型所取代。</p>
<h4 id="全局区-静态区："><a href="#全局区-静态区：" class="headerlink" title="全局区/静态区："></a>全局区/静态区：</h4><p>全局变量、静态变量、常量的存储区域，程序终止时系统释放。</p>
<h4 id="文字常量区："><a href="#文字常量区：" class="headerlink" title="文字常量区："></a>文字常量区：</h4><p>存放常量字符串，程序结束后由系统释放。</p>
<h4 id="程序代码区："><a href="#程序代码区：" class="headerlink" title="程序代码区："></a>程序代码区：</h4><p>存放函数体（类成员函数和全局函数）的二进制代码。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;        <span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1;       <span class="comment">//全局未初始化区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b;          <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"123"</span>;  <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p2;       <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">"sdfghhj"</span>; <span class="comment">//其中，“sdfghhj\0”常量区，p3在栈区</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>; <span class="comment">//全局区</span></span><br><span class="line">    p1 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);   <span class="comment">//10个字节区域在堆区</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1,<span class="string">"sdfghhj"</span>);    <span class="comment">//"sdfghhj\0"在常量区，编译器可能会优化p1和p3指向同一块区域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栈和堆的区别："><a href="#栈和堆的区别：" class="headerlink" title="栈和堆的区别："></a>栈和堆的区别：</h4><ol>
<li><strong>栈内存存储的的是局部变量，堆内存存储的是实体。</strong></li>
<li>栈内存的更新的速度会更快些（局部变量），堆内存的更新速度相对更慢。</li>
<li>栈内存的访问<strong>直接从地址读取数据到寄存器，然后放到目标地址</strong>，而堆内存的访问更麻烦，<strong>先将分配的地址放到寄存器，在读取地址的值，最后再放到目标文件中，</strong>开销更大。</li>
<li>栈内存是<strong>连续</strong>的空间，堆内存一般情况<strong>不是连续的，频繁地开辟空间，释放空间容易产生内存碎片（外碎片）。</strong></li>
</ol>
<h4 id="栈和堆的联系："><a href="#栈和堆的联系：" class="headerlink" title="栈和堆的联系："></a>栈和堆的联系：</h4><p>堆中对象是直接由栈中的句柄（引用）管理者，所以<strong>堆负责产生真实对象，栈负责管理对象。</strong></p>
<h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>字符变量实际上并不是将该字符本身放到变量的内存单元，而是将该字符对应的ASCII编码放到变量的存储单元。char的本质就是一个字节大小的整型。</p>
<p><strong>不以f结尾的常量都是double类型，以f结尾的为float类型。</strong></p>
<p>float a = 3.14 实际为double类型转换为float类型。</p>
<p>%p 打印地址，一个变量对应的内存地址编号（无符号十六禁止整型数）</p>
<p>科学计数：a = 3.2e3f //3.2*1000 = 3200</p>
<h4 id="整型和字符型数据存储"><a href="#整型和字符型数据存储" class="headerlink" title="整型和字符型数据存储"></a>整型和字符型数据存储</h4><p>数据在计算机中主要以<strong>补码</strong>的形式存储。</p>
<p>数据<strong>传输以bit</strong>表示。</p>
<p>原码：最高位为符号位，0表示正，1表示负。当两个整数相减或不同符号数相加时，必须比较两个数哪个绝对值大才能决定谁减谁，才能确定结果为正还是负，所以<strong>原码不便于加减运算</strong>。</p>
<p>反码：<strong>正数与原码一样。负数：符号位不变，其它取反</strong>。反码运算也不方便，通常用来作为补码的中间过渡。</p>
<p>补码：<strong>计算机系统中，数值一律用补码来存储</strong>。对于正数：原码，反码，补码相同。<strong>负数：补码为它的反码加1</strong>。<strong>补码符号位不动，其他位求反,加1得到原码</strong></p>
<p>补码原因：</p>
<ul>
<li>统一零的编码（0在计算机中的存储方式：按照原码和反码都需要区分0和-0）</li>
<li>将符号位和其他位统一处理</li>
<li>将减法运算转变为加法运算</li>
<li>两个补码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="number">10</span>; </span><br><span class="line">原码 <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line">反码 <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line">补码 <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"><span class="keyword">char</span> ch1 = <span class="number">-10</span>;</span><br><span class="line">原码 <span class="number">1000</span> <span class="number">1010</span></span><br><span class="line">反码 <span class="number">1111</span> <span class="number">0101</span></span><br><span class="line">补码 <span class="number">1111</span> <span class="number">0110</span></span><br><span class="line">    </span><br><span class="line">ch + ch1 = <span class="number">0</span></span><br><span class="line"><span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"><span class="number">1111</span> <span class="number">0110</span></span><br><span class="line"><span class="number">1</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">    </span><br><span class="line"><span class="number">76</span> - <span class="number">32</span> 转化为 <span class="number">76</span> + (<span class="number">-32</span>)</span><br><span class="line"><span class="number">76</span>原码 <span class="number">0100</span> <span class="number">1100</span></span><br><span class="line">  反码 <span class="number">0100</span> <span class="number">1100</span></span><br><span class="line">  补码 <span class="number">0100</span> <span class="number">1100</span></span><br><span class="line"><span class="number">-32</span>原码 <span class="number">1010</span> <span class="number">0000</span></span><br><span class="line">   反码 <span class="number">1101</span> <span class="number">1111</span></span><br><span class="line">   补码 <span class="number">1110</span> <span class="number">0000</span></span><br><span class="line"> 	<span class="number">1</span> <span class="number">0010</span> <span class="number">1100</span> </span><br><span class="line">    <span class="number">0010</span> <span class="number">1100</span> 得到原码为： <span class="number">0010</span> <span class="number">1100</span> 为<span class="number">44</span></span><br><span class="line"> <span class="number">76</span> - <span class="number">82</span></span><br><span class="line"> <span class="number">-82</span>原码 <span class="number">1101</span> <span class="number">0010</span></span><br><span class="line">    反码 <span class="number">1010</span> <span class="number">1101</span></span><br><span class="line">    补码 <span class="number">1010</span> <span class="number">1110</span></span><br><span class="line"> 相加：   <span class="number">1111</span> <span class="number">1010</span> 得到原码： <span class="number">1000</span> <span class="number">0110</span> 为<span class="number">-6</span></span><br></pre></td></tr></table></figure>
<p>8bit数据最大存储区间为：[-128, 127]</p>
<p>数据存储时，将-0对应的区间值设为-2^7 也就是-128</p>
<p>无符号：数据在计算机中不存在符号位</p>
<p>usigned char : 0 - 2^8 -1 : 0 - 255</p>
<h4 id="数值溢出"><a href="#数值溢出" class="headerlink" title="数值溢出"></a>数值溢出</h4><p>当超过一个数据类型能够存放最大的范围时，数值会溢出</p>
<p>有符号最高位溢出的区别：<strong>符号位溢出会导致数的正负发生变化，但最高位的溢出会导致最高位丢失。</strong></p>
<h4 id="类型限定"><a href="#类型限定" class="headerlink" title="类型限定"></a>类型限定</h4><div class="table-container">
<table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>extern</td>
<td>声明一个变量，<strong>extern声明的变量没有建立存储空间。在定义的时候再创建存储空间。</strong></td>
</tr>
<tr>
<td>const</td>
<td>定义一个常量，常量的值不能修改</td>
</tr>
<tr>
<td>volatile</td>
<td>防止编译器优化代码</td>
</tr>
<tr>
<td>register</td>
<td>定义寄存器变量，提高效率，建议型的变量而不是命令型的指令。如果CPU有空闲寄存器，则register生效，没有空闲则无效</td>
</tr>
</tbody>
</table>
</div>
<h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><ul>
<li>字符串常量是<strong>内存中一段连续的char空间，以’\0’结尾</strong></li>
<li>字符串常量是由<strong>双引号</strong>括起来的字符序列，如”china”</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">字符串常量与字符常量的不同：</span><br><span class="line"><span class="string">'a'</span>为字符常量， 实际存储<span class="string">'a'</span></span><br><span class="line">”a“为字符串常量 , 实际存储<span class="string">'a'</span> <span class="string">'\0'</span></span><br><span class="line">每个字符串的结尾，编译器会自动的添加一个结束标志位<span class="string">'\0'</span>，即<span class="string">"a"</span>包含两个字符<span class="string">'a'</span>和<span class="string">'\0'</span>.</span><br><span class="line"></span><br><span class="line">占位符%s,表示输出一个字符串，遇到\<span class="number">0</span>停止。</span><br><span class="line"><span class="built_in">putchar</span>() <span class="comment">//输出字符，可以是变量，字符，数字</span></span><br><span class="line">getchar() <span class="comment">//从标准输入设备读取一个char</span></span><br><span class="line"><span class="built_in">scanf</span>() <span class="comment">//内部参数中不能包含\n,可以用空格，逗号等。。。</span></span><br></pre></td></tr></table></figure>
<h4 id="运算符号"><a href="#运算符号" class="headerlink" title="运算符号"></a>运算符号</h4><p>算术运算符</p>
<ul>
<li><p>两个整数相除一定得到一个整数</p>
</li>
<li><p>取余只能对整数</p>
</li>
<li><p>自增，自减</p>
</li>
<li><p>后自增： a++ ， 先进行表达式计算，再进行++</p>
</li>
<li><p>前自增： ++a ，在表达式之前进行++，再进行表达式计算</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = ++a * <span class="number">10</span>;<span class="comment">//  a =  11, b = 110</span></span><br><span class="line"><span class="keyword">int</span> b = a++ * <span class="number">10</span>;<span class="comment">//  a = 11, b = 100 先完成计算，再增加1</span></span><br></pre></td></tr></table></figure>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p><strong>c语言的比较运算中，”真“用数字”1”来表示，”假“用数字”0“表示</strong></p>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>单目高于双目运算符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> [] () . 若同时出现，从左到右</span><br><span class="line"><span class="number">2.</span> \- ~(按位取反) ++ -- *(取值运算符) &amp;（取地址运算符） ! (类型)（强制类型转换） <span class="keyword">sizeof</span>， 从右到左</span><br><span class="line"><span class="number">3.</span> / * %</span><br><span class="line"><span class="number">4.</span> \+ - </span><br><span class="line"><span class="number">5.</span> &lt;&lt; &gt;&gt; </span><br><span class="line"><span class="number">6.</span> \&gt;= &gt; &lt; &lt;=</span><br><span class="line"><span class="number">7.</span> == !=</span><br><span class="line"><span class="number">8.</span> &amp; （按位与）</span><br><span class="line"><span class="number">9.</span> ^(按位异或) </span><br><span class="line"><span class="number">10.</span> |</span><br><span class="line"><span class="number">11.</span> &amp;&amp;</span><br><span class="line"><span class="number">12.</span> ||</span><br><span class="line"><span class="number">13.</span> ?:</span><br><span class="line"><span class="number">14.</span> = /= %= -= += &gt;&gt;= &lt;&lt;= &amp;= ^= |= </span><br><span class="line"><span class="number">15.</span> , 逗号运算符号</span><br></pre></td></tr></table></figure>
<h4 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h4><p>数组：把具有相同类型的若干变量按有序形式组织起来。</p>
<p><strong>数组名是一个常量，是一个地址，指向数组首地址。</strong></p>
<p><strong>数组在内存中占用的大小：sizeof(数组名) = 数组类型*数组个数</strong></p>
<p>数组的定义和初始化：{} </p>
<p>数组的个数必须是常量或常量表达式</p>
<p><strong>数组必须预先知道大小，动态数组-&gt;开辟堆空间</strong></p>
<h6 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h6><p>有行有列</p>
<p><strong>数组的名为一个地址常量，二维数组的arr[0]也为地址常量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;arr[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//所有输出都相等</span></span><br></pre></td></tr></table></figure>
<p>多维数组: 嵌套定义</p>
<h6 id="字符数组和字符串"><a href="#字符数组和字符串" class="headerlink" title="字符数组和字符串"></a>字符数组和字符串</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[<span class="number">5</span>] = &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>&#125;; <span class="comment">//字符数组</span></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">6</span>] = &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>&#125;; <span class="comment">//字符串，最后一个arr[5]自动赋值为0,相当于'\0'</span></span><br><span class="line"><span class="keyword">char</span>* arr = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> arr[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> arr[] = &#123;<span class="string">"hello"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>字符串是字符数组的一个特例</p>
<p><strong>字符串结束标志为\0,  数字0等同于\0, 但不等同于’0’</strong></p>
<h6 id="字符数组与字符串的区别"><a href="#字符数组与字符串的区别" class="headerlink" title="字符数组与字符串的区别"></a>字符数组与字符串的区别</h6><ul>
<li><strong>C中没有字符串这种数据类型，可以通过char的数组来替代</strong></li>
<li><strong>字符串一定是一个char的数组，但char的数组未必是字符串</strong></li>
<li><strong>数字0(和字符’\0’等级)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[<span class="number">100</span>] = &#123;<span class="number">110</span>,<span class="number">111</span>,<span class="number">112</span>,<span class="number">32</span>, <span class="number">32</span>,<span class="number">43</span>&#125;;<span class="comment">//数字对应ASCII码，可以打印出字符串</span></span><br></pre></td></tr></table></figure>
<p><strong>gets() 允许输入的字符串含有空格，scanf不允许含有空格</strong></p>
<p>scanf(“%[\^\n]”,ch);//接收非\n的所有内容（通过正则表达式来做约束）</p>
<p>由于scanf和gets无法知道字符串s大小，<strong>必须遇到换行符或读到文件结尾为止才接收输入</strong>，因此容易导致字符数组越界（缓冲区溢出）的情况。</p>
<p>char<em> fgets(char </em>s, int size, FILE <em> stream):从stram指定的文件内读入字符，保存到s所指定的内存空间，直到出现换行字符，<em>*读到文件结尾或是已读了size-1个字符为止，最后会自动加上字符\0作为结束标志。</em></em></p>
<p><strong>如果是从键盘输入，stream为stdin</strong></p>
<p>puts():标准输出字符串，在输出完成后自动输出一个\n</p>
<p>fputf</p>
<p>strlen() 计算指定字符串的长度，不包含字符串结束符\0</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>不同类型数据之间进行混合运算时必然涉及到类型的转换问题</p>
<p>转换的两种方法：</p>
<ul>
<li>自动转换（隐式转换）：遵循一定的规则，由编译系统自动完成</li>
<li>强制类型转换：把表达式的运算结果强制转换成所需的数据类型</li>
</ul>
<p>类型转换的原则：占用内存字节数少（值域小）的类型向占用内存字节数多（值域大）的类型转换，以保证精度不降低。</p>
<p>强制类型转换运算符，不会四舍五入</p>
<h3 id="程序流程结构"><a href="#程序流程结构" class="headerlink" title="程序流程结构"></a>程序流程结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (适合多区间，带嵌套)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">else</span> 条件嵌套</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> eles <span class="keyword">if</span>  <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">case</span>  <span class="keyword">break</span> <span class="keyword">default</span>（不适合多区间，执行效率高）</span><br><span class="line"></span><br><span class="line">三目运算符： ？：</span><br><span class="line"></span><br><span class="line">表达式<span class="number">1</span>?表达式<span class="number">2</span>：表达式<span class="number">3</span> 	如果表达式<span class="number">1</span>为真，结果为表达式<span class="number">2</span>,为假则表达式结果为<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span></span><br></pre></td></tr></table></figure>
<h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><p>break 在switch条件语句和循环语句中都可以使用break语句</p>
<ul>
<li>出现在switch条件语句中时，<strong>作用是终止某个case并跳出switch结构</strong></li>
<li>当出现在循环语句中，作用是<strong>跳出当前内循环语句，执行后面的程序</strong></li>
<li>当出现在嵌套循环语句中，跳出最近的内循环语句，执行后面的程序</li>
</ul>
<p>continue：在循环语句中，如果希望<strong>立即终止本次循环，并执行下一次循环</strong>，此时需要使用continue语句。</p>
<p>goto语句（无条件跳转，尽量少用）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> FLAG;</span><br><span class="line">xxxx</span><br><span class="line">FLAG;</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数分类"><a href="#函数分类" class="headerlink" title="函数分类"></a>函数分类</h4><p>系统函数和用户定义的函数</p>
<ul>
<li>系统函数，即库函数：由编译系统提供，用户中不必自己定义，可以直接使用</li>
<li>用户定义函数，用于解决用户的专门需要</li>
</ul>
<p>调用函数的要素：</p>
<ul>
<li>头文件</li>
<li>函数名字，必须和声明的名字一样</li>
<li>功能</li>
<li>参数</li>
<li>返回值</li>
</ul>
<h4 id="函数定义和使用"><a href="#函数定义和使用" class="headerlink" title="函数定义和使用"></a>函数定义和使用</h4><p>返回值类型 函数名 （参数列表）</p>
<p>{</p>
<p>​    代码体；// 函数功能实现的过程</p>
<p>​    return;</p>
<p>}</p>
<p>在不同函数中函数中的变量名可以重名，因为<strong>作用域</strong>不同。</p>
<p>在函数调用过程中传递的参数为实参（有具体的值）。</p>
<p>函数定义中参数称为形式参数。</p>
<p>在函数调用过程中，将实参传递给形参。</p>
<p><strong>在函数调用结束，函数会在内存中销毁。</strong></p>
<p>在定义函数时指定的形参，在未出现函数调用时，它们并不占用内存中的存储单元，因此称为形式参数或者形参，表示它们并不是实际存在的数据，所以，形参中的变量不能赋值。</p>
<p>如果函数返回的类型和return语句中表达式的值不一致，则以函数返回类型为准，即函数返回类型决定返回值的类型。对数值型数据，可以自动进行类型转换。</p>
<p>注意：如果函数返回的类型和return语句中表达式的值不一致，而它又无法自动进行类型转换，程序则会报错。</p>
<p>实参可以常量、变量或表达式，无论实参数是何类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。所以，这里的变量是在圆括号外面定义好的、赋好值的变量。</p>
<p>void类型不可以直接定义数据，void类型可以作为函数的返回值类型，表示没有返回值。</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><ul>
<li><p>函数声明：如果用户自己定义的函数，而该函数与调用它的函数（即主调函数）不在同一文件中，或者函数定义的位置在主调函数之后，则必须在调用此函数之前对被调用的函数做声明。</p>
<ul>
<li>所谓函数声明，就是在函数尚在未定义的情况下，事先将该函数的有关信息通知编译系统，相当于告诉编译器，函数在后面定义，以便编译器能够正常运行。</li>
<li>注意：一个函数只能被定义一次，但可以声明多次。</li>
</ul>
</li>
<li><p>函数定义</p>
</li>
<li><p>函数定义</p>
</li>
</ul>
<h4 id="声明和定义的区别"><a href="#声明和定义的区别" class="headerlink" title="声明和定义的区别"></a>声明和定义的区别</h4><ul>
<li>声明变量不需要建立存储空间，如：extern int a;</li>
<li>定义变量需要建立存储空间，如： int b;</li>
</ul>
<p>从广义的角度来说声明中包含着定义，即定义是声明的一个特例，所以并非所有的声明都是定义。</p>
<ul>
<li>int b; //即是声明，同时又是定义</li>
<li>对于extern b 来说只是声明不是定义</li>
</ul>
<p>一般情况下，把建立存储空间的声明称为“定义”， 而把不需要建立存储空间的声明称为“声明”</p>
<h4 id="主函数和exit函数"><a href="#主函数和exit函数" class="headerlink" title="主函数和exit函数"></a>主函数和exit函数</h4><p>在main函数中调用了exit和return结果是一样的，但在子函数中调用return只是代表子函数终止了，在子函数中使用exit，那么程序终止。</p>
<h4 id="多文件编程"><a href="#多文件编程" class="headerlink" title="多文件编程"></a>多文件编程</h4><p>函数功能实现放在其他.c文件中</p>
<p>函数声明放到.h文件中</p>
<p>.h文件头部 # program once //防止头文件重复包含</p>
<p>头文件一般用于</p>
<ul>
<li>全局变量的定义</li>
<li>函数的声明</li>
</ul>
<p>导入自己定义的头文件，用“xxx.h”</p>
<p>一个相同名字的头文件对应一个相同名字的源文件</p>
<p>为了避免同一个文件被include多次，c/c++中有两种方式：</p>
<ul>
<li><h1 id="ifndef-一般定义的方式为"><a href="#ifndef-一般定义的方式为" class="headerlink" title="ifndef //一般定义的方式为"></a>ifndef //一般定义的方式为</h1><ul>
<li><h1 id="ifndef-SOMEFILEH"><a href="#ifndef-SOMEFILEH" class="headerlink" title="ifndef _SOMEFILEH"></a>ifndef _<em>SOMEFILE<em>H</em></em></h1></li>
<li><h1 id="define-SOMEFILEH"><a href="#define-SOMEFILEH" class="headerlink" title="define _SOMEFILEH"></a>define _<em>SOMEFILE<em>H</em></em></h1></li>
<li><h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1></li>
</ul>
</li>
<li><h1 id="pragma-once-只能用于windows中"><a href="#pragma-once-只能用于windows中" class="headerlink" title="pragma once //只能用于windows中"></a>pragma once //只能用于windows中</h1></li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>内存是沟通CPU和硬盘的桥梁</p>
<ul>
<li>暂存放CPU中的运算数据</li>
<li>暂存与硬盘等外部存储器交换的数据</li>
</ul>
<h4 id="物理存储器和存储地址空间"><a href="#物理存储器和存储地址空间" class="headerlink" title="物理存储器和存储地址空间"></a>物理存储器和存储地址空间</h4><p>物理存储器为实际存在的具体存储器芯片。</p>
<p>存储地址空间：对存储器编码的范围。软件中常说的内存含义。</p>
<ul>
<li>编码：对每个物理存储单元（一个字节）分配一个号码</li>
<li>寻址：可以根据分配的号码找到相应的存储单元，完成数据的读写</li>
</ul>
<h4 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h4><ul>
<li>将内存抽象为一个很大的一维字符数组</li>
<li>编码就是对内存的每一个字节分配一个32位或64位的编号（与处理器的位数有关）</li>
<li>内存编号称为内存地址。内存中的每一个数据都会分配相应的地址。</li>
<li>char:占一个字节分配一个地址</li>
<li>int：占四个字节分配四个地址</li>
<li>float, struct,函数，数组等</li>
</ul>
<p>小端对齐，大端对齐</p>
<p>int*  为一个指针</p>
<p>地址也是一种特殊的数据类型，故存放地址的指针定义需要指明这一点，也就是二级指针的应用。</p>
<p>所有的指针类型存储的都是内存地址，内存地址都是一个无符号十六进制整型数</p>
<p>&amp;是取地址符号，是升维度的</p>
<p>*是取值符号，是降维度的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="number">97</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = &amp;ch; <span class="comment">//指针类型不匹配，后面通过指针访问和修改数据都将报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义指针类型的时候，一定要和变量的类型对应上。</p>
<h4 id="野指针和空指针"><a href="#野指针和空指针" class="headerlink" title="野指针和空指针"></a>野指针和空指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">100</span>;<span class="comment">//野指针，程序中允许存在野指针</span></span><br></pre></td></tr></table></figure>
<p>操作野指针对应的内存空间可能报错</p>
<p>野指针：指针变量指向一个未知的空间</p>
<p>指针变量也是变量，是变量就可以任意赋值，不要越界即可(32位为4字节，64位为8字节)，但是，任意数值赋值给指针变量没有意义，因为这样的指针就变成了野指针，此指针指向的区域是未知的（操作系统不允许操作此指针指向的内存区域）.所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。</p>
<p>但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量（空闲可用），c语言中可以把NULL赋值给此指针，这样就标志此指针为空指针，没有在任何指向。</p>
<p>操作系统将0-255的地址作为系统占用，不允许访问操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0) <span class="comment">//NULL为一个值为0的宏常量,内存地址为0的空间</span></span></span><br></pre></td></tr></table></figure>
<p>操作空指针对应的空间一定会报错</p>
<p>空指针可以用作条件判断： if (p==NULL)</p>
<h4 id="万能指针void"><a href="#万能指针void" class="headerlink" title="万能指针void *"></a>万能指针void *</h4><p>void <em>指针可以<em>*指向任意变量的内存空间</em></em></p>
<p>万能指针可以接收任意类型变量的内存地址</p>
<p>在通过万能指针修改变量的值时，需要找到变量对应的指针类型</p>
<h4 id="const修饰的指针变量"><a href="#const修饰的指针变量" class="headerlink" title="const修饰的指针变量"></a>const修饰的指针变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    *p = <span class="number">100</span>; <span class="comment">//指针间接修改常量的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a); <span class="comment">//a = 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>const修饰指针：</p>
<ul>
<li>const 修饰指针类型：const int* p （p为一个指向int的指针，）可以修改指针变量的值，不可以修改指针指向内存空间的值</li>
<li>const修饰指针变量：int * const p (p为const类型的指针，是一个常量)，可以修改指针指向内存空间的值，不可以修改指针变量的值。</li>
</ul>
<p>const int<em> const p //const修饰指针类型，修饰指针变量，<em>*只读指针</em></em></p>
<h4 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h4><p><strong>数组名是数组的首元素地址，但它是一个常量。</strong></p>
<p>指针类型变量+1,等同于内存地址 + sizeof(type)</p>
<p>两个指针相减，得到的结果是两个指针的偏移量（步长）</p>
<p>所有的指针类型相减结果都是int类型。</p>
<p><strong>数组作为函数参数会退化为指针，丢失了数组的精度</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">char</span>*ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*dest++ = *ch++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;<span class="built_in">array</span>[<span class="number">5</span>];</span><br><span class="line">p[<span class="number">-2</span>]; <span class="comment">//*(p-2),想当于 p[3]</span></span><br></pre></td></tr></table></figure>
<p>指针操作数组时下标允许是负数</p>
<p>指针可以比较大小，逻辑运算，</p>
<h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p>指针数组，是一个数组，数组的每个元素都是指针类型</p>
<p>指针数组里面元素存储的是指针</p>
<p>指针数组是一个特殊的二维数组模型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> c[] = &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指针数组是一个特殊的二维数组模型</span></span><br><span class="line">    <span class="keyword">int</span>* arr[] = &#123;a,b,c&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//arr和&amp;arr[0]是指针数组的首地址</span></span><br><span class="line">    <span class="comment">//指针数组对应二级指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;arr[<span class="number">0</span>]);<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> **p = arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h4><p>二级指针就是指向一个一级指针变量地址的指针。</p>
<p>指针数组和二级指针建立关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> c[] = &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针是一个特殊的二维数组模型</span></span><br><span class="line">    <span class="keyword">int</span> *arr[] = &#123;a,b,c&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针数组和二维指针建立关系</span></span><br><span class="line">    <span class="keyword">int</span> **p = arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, **p);</span><br><span class="line">    <span class="comment">//二级指针加偏移量，相当于跳过了一个一维数组大小</span></span><br><span class="line">    <span class="comment">//一级指针加偏移量，相当于跳过一个元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,**(p+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(*(p+<span class="number">1</span>)+<span class="number">1</span>)); <span class="comment">//arr[1][1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, p[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,*(p[i]+j));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,*(*(p+i)+j));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="值传递和地址传递"><a href="#值传递和地址传递" class="headerlink" title="值传递和地址传递"></a>值传递和地址传递</h4><p>值传递：形参不影响实参的值</p>
<p>地址传递：形参可以改变实参的值</p>
<p>数组名做函数参数，函数的形参会退化为指针。通过函数传递数组，一般都要给定数组的长度。</p>
<p>注意字符串和字符数组的区别</p>
<p>字符串去空格：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_space01</span><span class="params">(<span class="keyword">char</span>* ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> * p = str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch[i]!= <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[i] != <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str[j] = ch[i];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*ch++ = *p++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_space</span><span class="params">(<span class="keyword">char</span>* ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* ftemp = ch;<span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">char</span>* rtemp = ch; <span class="comment">//记录空格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*ftemp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*ftemp != <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *rtemp = *ftemp;</span><br><span class="line">            rtemp++;</span><br><span class="line">        &#125;</span><br><span class="line">        ftemp++; </span><br><span class="line">    &#125;</span><br><span class="line">    *rtemp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> test[] = <span class="string">"  he l  l o"</span>;</span><br><span class="line">    remove_space(test);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul>
<li>代码块作用域（{}之间的一段代码）</li>
<li>函数作用域</li>
<li>文件作用域</li>
</ul>
<p>局部变量：在函数内部定义的变量，使用auto修饰，生命周期：从创建到函数结束</p>
<p>全局变量：在<strong>函数体外定义</strong>，<strong>存放在数据区</strong>，可被<strong>本文件及其它文件中的函数所共用，若其它文件中的函数调用此变量，须用extern声明。</strong></p>
<ul>
<li>全局变量的声明周期和程序运行周期一样</li>
<li>不同文件的全局变量不可重名</li>
<li>全局变量可以和局部变量重名，使用最近的一个</li>
</ul>
<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>在没有运行程序前，也就是程序没有加载到内存之前，可执行程序内部已经分好了3段信息，分别为代码区（text），数据区（data）和未初始化数据区（bss）3个部分。</p>
<h4 id="静态-static-局部变量"><a href="#静态-static-局部变量" class="headerlink" title="静态(static)局部变量"></a>静态(static)局部变量</h4><ul>
<li>static局部变量的作用域也是在定义的函数内有效，在数据区存储</li>
<li><strong>static局部变量的生命周期和程序运行周期一样</strong>，同时static局部变量的值只初始化一次，但可以<strong>赋值多次</strong></li>
<li>static局部变量若未赋以初值，则由系统自动赋值：数值型变量自动赋初值0,字符型变量赋空字符</li>
</ul>
<h4 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h4><p>可以在<strong>本文件中使用，不可以在其他文件中使用</strong></p>
<p>生命周期：数据区保存，从程序开始到程序结束</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量类型</th>
<th>作用域</th>
<th>生命周期</th>
<th>存储位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>局部变量</td>
<td>函数内部</td>
<td>从局部变量创建到函数结束</td>
<td>栈区</td>
</tr>
<tr>
<td>全局变量</td>
<td>项目中所有文件</td>
<td>从程序创建到程序销毁</td>
<td>数据区</td>
</tr>
<tr>
<td>静态局部变量</td>
<td>函数内部</td>
<td>从程序创建到程序销毁</td>
<td>数据区</td>
</tr>
<tr>
<td>静态全局变量</td>
<td>定义所在的文件</td>
<td>从程序创建到程序销毁</td>
<td>数据区</td>
</tr>
</tbody>
</table>
</div>
<p>未初始化数据(根据编译器可能不同)：</p>
<p>局部变量未初始化，值为乱码</p>
<p>未初始化的全局变量，值为0</p>
<ul>
<li>全局初始化数据区/静态数据区（data段）<ul>
<li>该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如：字符串常量）</li>
</ul>
</li>
<li>未初始化数据区（bss区）<ul>
<li>存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为0或者空（NULL）</li>
</ul>
</li>
<li>程序在加载到内存前，<strong>代码区和全局区（data和bss）的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，系统把程序加载到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。</strong></li>
</ul>
<h4 id="全局函数和静态函数"><a href="#全局函数和静态函数" class="headerlink" title="全局函数和静态函数"></a>全局函数和静态函数</h4><p>在c中函数默认为全局的，使用关键字static可以将函数声明为静态，函数定义为static就意味着这个函数只能在定义这个函数的文件中使用，在其他文件中不能使用，即使在其他文件中声明也没用。</p>
<p>对于不同文件中的static函数名可以相同</p>
<p>全局函数的名称是作用域中唯一的（c++中可以多态）</p>
<p>函数可以调用自己，称为递归调用，但一定要有出口</p>
<p>静态函数可以和全局函数重名，但作用域需要根据具体情况定</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数类型</th>
<th>作用域</th>
<th>生命周期</th>
<th>存储位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>全局函数</td>
<td>项目中的所有文件</td>
<td>从程序创建到程序销毁</td>
<td>平时在代码区（唤醒后存在栈区）</td>
</tr>
<tr>
<td>静态函数</td>
<td>定义所在文件中</td>
<td>从程序创建到程序销毁</td>
<td>代码区</td>
</tr>
</tbody>
</table>
</div>
<p>注意：</p>
<ul>
<li>允许在不同的函数中使用相同的变量名，它们代表不同的对象，分配不同的单元，互不干扰</li>
<li>同一源文件中，允许全局变量和局部变量同名，在局部变量的作用域内，全局变量不起作用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//安全的常量，存储区域为数据区常量区</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> abc = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未初始化全局变量</span></span><br><span class="line"><span class="keyword">int</span> a1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化全局变量</span></span><br><span class="line"><span class="keyword">int</span> b1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未初始化静态全局变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> c1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态全局变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> d1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未初始化局部静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> f1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化局部静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> h1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串常量</span></span><br><span class="line">    <span class="keyword">char</span>* p = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//指针</span></span><br><span class="line">    <span class="keyword">int</span>* pp = arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"未初始化全局变量:%p\n"</span>,&amp;a1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化全局变量:%p\n"</span>,&amp;b1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"未初始化静态全局变量:%p\n"</span>,&amp;c1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化全局静态变量:%p\n"</span>,&amp;d1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"局部变量:%p\n"</span>,&amp;e1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"未初始化局部静态变量%p\n"</span>,&amp;f1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化局部静态变量%p\n"</span>,&amp;h1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"字符串常量%p\n"</span>,&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数组%p\n"</span>,arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"指针变量%p\n"</span>,pp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"指针地址%p\n"</span>,&amp;pp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">未初始化全局变量:<span class="number">0x601058</span></span><br><span class="line">初始化全局变量:<span class="number">0x601040</span></span><br><span class="line">未初始化静态全局变量:<span class="number">0x601050</span></span><br><span class="line">初始化全局静态变量:<span class="number">0x601044</span></span><br><span class="line">局部变量:<span class="number">0x7fffee32d54c</span></span><br><span class="line">未初始化局部静态变量<span class="number">0x601054</span></span><br><span class="line">初始化局部静态变量<span class="number">0x601048</span></span><br><span class="line">字符串常量<span class="number">0x7fffee32d550</span></span><br><span class="line">数组<span class="number">0x7fffee32d560</span></span><br><span class="line">指针变量<span class="number">0x7fffee32d560</span></span><br><span class="line">指针地址<span class="number">0x7fffee32d558</span></span><br></pre></td></tr></table></figure>
<p>const修饰的局部常量是不安全的，const修饰的全局常量是安全的</p>
<h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><ul>
<li>代码区：程序执行二进制码（程序指令），特点：（共享:另外的执行程序可以调用它，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。只读：防止程序意外修改了它的指令。代码区还规划了局部变量的相关信息）</li>
<li>数据区：<ul>
<li>初始化数据区(data段)：包含了在程序中明确被初始化的全局变量，已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如：字符串常量）</li>
<li>未初始化数据区(bss段)：存入全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为0或者空NULL</li>
<li>常量区</li>
</ul>
</li>
<li>栈区：系统为每一个应用程序分配一个<strong>临时的空间</strong>（局部变量，局部信息，函数参数，数组），栈区大小为:1M,在windowns中可以扩展到10M,在linux中可以扩展到16M</li>
<li>堆区：存储大数据，图片，音频文件。<ul>
<li>手动开辟 malloc</li>
<li>手动释放 free</li>
</ul>
</li>
</ul>
<p>栈区内存占用从高地址到低地址，数组的[0]从低地址开始。</p>
<p>两个连续的变量保存会存在一定的地址空缺是为了放置直接根据一个变量的地址推到下一个变量的地址。</p>
<p>栈区：先进后出，后进先出</p>
<ul>
<li>栈区（stack）：栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值，返回值，局部变量等。在程序运行过程中实时加载和释放。因此：局部变量的生存周期为申请到释放该段栈空间。</li>
<li>堆区（heap）：堆是一个大容器，其容量要远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</li>
</ul>
<h4 id="堆空间开辟和释放"><a href="#堆空间开辟和释放" class="headerlink" title="堆空间开辟和释放"></a>堆空间开辟和释放</h4><p>void* malloc(size_t size);</p>
<p>在<strong>内存的动态存储区（堆区）分配一块长度为size字节的连续区域</strong>，用来存放类型说明符指定的类型，分配的内存空间内容不确定，一般使用memset初始化。</p>
<p>int<em> p = (int</em>) malloc (sizeof(int) *1024);</p>
<p>void free(void* ptr);</p>
<p>释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址，对同一内存空间释放多次会出错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//栈区大小</span></span><br><span class="line">    <span class="comment">// int arr[820000*3] =&#123;0&#125;;//段错误，核心转移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开辟空间存储</span></span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,p);</span><br><span class="line">    <span class="comment">//使用堆空间</span></span><br><span class="line">    *p = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*p);</span><br><span class="line">    <span class="comment">//释放空间</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//p为野指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,p);</span><br><span class="line">    *p = <span class="number">456</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0x195b010</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">0x195b010</span></span><br><span class="line"><span class="number">456</span></span><br></pre></td></tr></table></figure>
<p>为了避免野指针的出现，一般将指针赋值为NULL.</p>
<p>开辟的空间使用指针或者数组的方式来进行操作</p>
<h4 id="内存处理函数"><a href="#内存处理函数" class="headerlink" title="内存处理函数"></a>内存处理函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memset</span><span class="params">(<span class="keyword">void</span>* s,<span class="keyword">int</span> c,<span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>将内存区域的前n个字节以参数c填入，返回值，s的首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置内存空间的值</span></span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="string">'c'</span>,<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span>* dest, <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>拷贝src所指的内存内容的前n个字节到dest所指的内存地址上。</p>
<p>注意：dest和src所指的内存空间不可重叠，可能会导致程序报错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>memcpy()与strcpy()的区别：</p>
<p>字符串拷贝遇到\0则自动结束，内存拷贝不会出现类似情况</p>
<p>内存拷贝：拷贝的内容和字节有关，和拷贝内容无关</p>
<p>如果拷贝的目标和源发生重叠，可能报错</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">memmove()<span class="comment">//用法和memcpy一样，区别在于：dest和src所指的内存空间重叠时，memmove（）仍然能处理，不过执行效率比memcpy低</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* st, <span class="keyword">const</span> <span class="keyword">void</span>* s2, <span class="keyword">size_t</span> n)</span></span>;<span class="comment">//比较s1和s2所指向内存区域的前n个字节 </span></span><br><span class="line"><span class="comment">//返回值：0,1,-1 等于，大于，小于</span></span><br></pre></td></tr></table></figure>
<h4 id="内存常见的问题"><a href="#内存常见的问题" class="headerlink" title="内存常见的问题"></a>内存常见的问题</h4><p>空指针允许多次释放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//传值</span></span><br><span class="line">    p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span>** p)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//传地址</span></span><br><span class="line">    *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"形参%p\n"</span>,*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//返回地址</span></span><br><span class="line">    <span class="keyword">int</span>* p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) *<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//数组下标越界</span></span><br><span class="line">    <span class="comment">// char* p = (char*)malloc(sizeof(char)*10);</span></span><br><span class="line">    <span class="comment">// strcpy(p,"hello worldS");</span></span><br><span class="line">    <span class="comment">// printf("%s\n",p);</span></span><br><span class="line">    <span class="comment">// free(p);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//野指针</span></span><br><span class="line">    <span class="comment">// int* p = (int*)malloc(0);</span></span><br><span class="line">    <span class="comment">// printf("%p\n",p);</span></span><br><span class="line">    <span class="comment">// *p = 100;</span></span><br><span class="line">    <span class="comment">// printf("%d\n",*p);</span></span><br><span class="line">    <span class="comment">// free(p); //windows下程序挂，linux似乎做了优化？</span></span><br><span class="line">    <span class="comment">// return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//多次释放空间</span></span><br><span class="line">    <span class="comment">// int* p = malloc(sizeof(int)*10);</span></span><br><span class="line">    <span class="comment">// free(p);</span></span><br><span class="line">    <span class="comment">// //解决办法</span></span><br><span class="line">    <span class="comment">// p = NULL; //空指针允许多次释放</span></span><br><span class="line">    <span class="comment">// free(p);//放弃，核心已转储</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// fun(p); //形参和实参一致，都是值传递</span></span><br><span class="line"></span><br><span class="line">    fun1(&amp;p); <span class="comment">//地址传递</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* p1 = fun2();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p1[i] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二级指针对应的堆空间"><a href="#二级指针对应的堆空间" class="headerlink" title="二级指针对应的堆空间"></a>二级指针对应的堆空间</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//开辟二级指针对应的堆空间</span></span><br><span class="line">    <span class="keyword">int</span>** p = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) *<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//开辟一级指针对应的堆空间</span></span><br><span class="line">        p[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i][j] = i+j;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//free</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。</p>
<p>有时需要<strong>将不同类型的数据组合成一个有机的整体</strong>。显然单独定义变量会比较繁琐，数据不方便管理</p>
<p>定义结构体变量的方式：</p>
<ul>
<li>先声明结构体类型再定义变量名 struct stu{成员列表}; struct stu Mike;</li>
<li>在声明类型的同时定义变量。struct stu{成员列表}Mike,Bod;</li>
<li>直接定义结构体类型变量（无类型名）.struct {成员变量} Mike,Bob;</li>
</ul>
<p>结构体类型和结构体变量关系：</p>
<ul>
<li>结构体类型：指定了一个结构体类型，相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元</li>
<li>结构体变量：系统根据结构体类型（内部成员状况）为止分配空间。</li>
</ul>
<p>结构体数组：</p>
<p>结构体成员需要<strong>偏移对齐</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">int</span> score[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>[3]=</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        &#123;<span class="string">"黄x航"</span>,<span class="number">22</span>,<span class="string">'M'</span>,<span class="number">89</span>,<span class="number">90</span>,<span class="number">89</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"码x东"</span>,<span class="number">18</span>,<span class="string">'F'</span>,<span class="number">89</span>,<span class="number">54</span>,<span class="number">65</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"司正x"</span>,<span class="number">32</span>,<span class="string">'M'</span>,<span class="number">89</span>,<span class="number">98</span>,<span class="number">98</span>&#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span><span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span><span class="number">-1</span>-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stu[j].age &gt;stu[j+<span class="number">1</span>].age)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">temp</span> = <span class="title">stu</span>[<span class="title">j</span>];</span></span><br><span class="line">                stu[j] = stu[j+<span class="number">1</span>];</span><br><span class="line">                stu[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h4><h4 id="结构体赋值"><a href="#结构体赋值" class="headerlink" title="结构体赋值"></a>结构体赋值</h4><p>用=可以进行复制</p>
<p>深拷贝和浅拷贝</p>
<h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><p>若结构体中包含有指针类型的成员数据，则在给结构体变量赋值的时候需要考虑指针赋值（是开辟新空间或是赋常量的值）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> scores[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">51</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结构体指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">ss</span> = &#123;</span><span class="string">"test"</span>,<span class="number">30</span>, <span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="string">"边境"</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span>* <span class="title">p</span> = &amp;<span class="title">ss</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,(*p).name);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p-&gt;addr);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">ss</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span>* scores;</span><br><span class="line">    <span class="keyword">char</span>* addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ss* p = (ss*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ss)*<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i].name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">21</span>);</span><br><span class="line">        p[i].scores = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">3</span>);</span><br><span class="line">        p[i].addr = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">21</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d%d%d%s"</span>,p[i].name,&amp;p[i].age,</span><br><span class="line">        &amp;p[i].scores[<span class="number">0</span>],&amp;p[i].scores[<span class="number">1</span>],&amp;p[i].scores[<span class="number">2</span>],p[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>,p[i].name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i].age);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i].scores[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,(p+i)-&gt;scores[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,(p+i)-&gt;scores[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,(p+i)-&gt;addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放存储空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p[i].name);</span><br><span class="line">        <span class="built_in">free</span>(p[i].scores);</span><br><span class="line">        <span class="built_in">free</span>(p[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a>结构体做函数参数</h4><ul>
<li><p>结构体普通变量做函数参数</p>
</li>
<li><p>结构体指针变量做函数参数</p>
</li>
<li><p>结构体数组名做函数参数</p>
</li>
<li><p>const修饰结构体指针形参变量</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">ss</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">51</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun01</span><span class="params">(ss stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(stu.name,<span class="string">"lujunyi"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,stu.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ss stu = &#123;<span class="string">"宋江"</span>,<span class="number">50</span>,<span class="number">101</span>,<span class="string">"水船"</span>&#125;;</span><br><span class="line">    fun01(stu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,stu.name); <span class="comment">//值传递，不改变</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">ss</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">21</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun02</span><span class="params">(ss* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">"公孙胜"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结构体指针作为函数参数</span></span><br><span class="line">    ss stu = &#123;<span class="string">"吴用"</span>,<span class="number">50</span>, <span class="number">101</span>,<span class="string">"水泊梁山"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    fun02(&amp;stu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,stu.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体数组做函数参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">ss</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">21</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组作为函数参数退化为指针，丢失元素精度，需要传递个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ss stu[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;len-i<span class="number">-1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stu[j].age &gt;stu[j+<span class="number">1</span>].age)</span><br><span class="line">            &#123;</span><br><span class="line">                ss temp = stu[j];</span><br><span class="line">                stu[j] = stu[j+<span class="number">1</span>];</span><br><span class="line">                stu[j+<span class="number">1</span>] = temp; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ss stu[<span class="number">3</span>] = </span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">"鲁智深"</span>,<span class="number">30</span>,<span class="number">78</span>,<span class="string">"五台山"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"呼吁"</span>,<span class="number">29</span>,<span class="number">78</span>,<span class="string">"三台山"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"呈共"</span>,<span class="number">31</span>,<span class="number">87</span>,<span class="string">"滇池"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BubbleSort(stu, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\t%d\t%d\t%s\n"</span>,stu[i].name,stu[i].age,stu[i].score,stu[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 接口转换原理</title>
    <url>/2020/01/05/Go%20%E6%8E%A5%E5%8F%A3_6%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="Go-接口转换原理"><a href="#Go-接口转换原理" class="headerlink" title="Go 接口转换原理"></a>Go 接口转换原理</h3><p>通过前面提到的 <code>iface</code> 的源码可以看到，实际上它包含接口的类型 <code>*interface type</code> 和 实体类型的类型 <code>*_type</code>，这两者都是 <code>iface</code> 的字段 <code>*itab</code> 的成员。也就是说<strong>生成一个 <code>itab</code> 同时需要接口的类型和实体的类型。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;interface 类型， 实体类型&gt; -&gt;itable</span><br></pre></td></tr></table></figure>
<p><strong>当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。</strong></p>
<p>例如某类型有 <code>m</code> 个方法，某接口有 <code>n</code> 个方法，则很容易知道这种判定的时间复杂度为 <code>O(mn)</code>，<strong>Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 <code>O(m+n)</code>。</strong></p>
<p>探索将一个接口转换给另外一个接口背后的原理，当然<strong>，能转换的原因必然是类型兼容</strong>。</p>
<p>直接来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">	code()</span><br><span class="line">	run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> runner <span class="keyword">interface</span> &#123;</span><br><span class="line">	run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">	language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c coder = Gopher&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r runner</span><br><span class="line">	r = c</span><br><span class="line">	fmt.Println(c, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释上述代码：定义了两个 <code>interface</code>: <code>coder</code> 和 <code>runner</code>。定义了一个实体类型 <code>Gopher</code>，类型 <code>Gopher</code> 实现了两个方法，分别是 <code>run()</code> 和 <code>code()</code>。<strong>main 函数里定义了一个接口变量 <code>c</code>，绑定了一个 <code>Gopher</code> 对象，之后将 <code>c</code> 赋值给另外一个接口变量 <code>r</code> 。赋值成功的原因是 <code>c</code> 中包含 <code>run()</code> 方法。这样，两个接口变量完成了转换。</strong></p>
<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go tool compile -S ./src/main.go</span><br></pre></td></tr></table></figure>
<p>得到 main 函数的汇编命令，可以看到： <strong><code>r = c</code> 这一行语句实际上是调用了 <code>runtime.convI2I(SB)</code>，也就是 <code>convI2I</code> 函数，从函数名来看，就是将一个 <code>interface</code> 转换成另外一个 <code>interface</code>，</strong>看下它的源代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convI2I</span><span class="params">(inter *interfacetype, i iface)</span> <span class="params">(r iface)</span></span> &#123;</span><br><span class="line">	tab := i.tab</span><br><span class="line">	<span class="keyword">if</span> tab == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tab.inter == inter &#123;</span><br><span class="line">		r.tab = tab</span><br><span class="line">		r.data = i.data</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	r.tab = getitab(inter, tab._type, <span class="literal">false</span>)</span><br><span class="line">	r.data = i.data</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，函数参数 <code>inter</code> 表示接口类型，<code>i</code> 表示绑定了实体类型的接口，<code>r</code> 则表示接口转换了之后的新的 <code>iface</code>。通过前面的分析，我们又知道， <code>iface</code> 是由 <code>tab</code> 和 <code>data</code> 两个字段组成。所以，<strong>实际上 <code>convI2I</code> 函数真正要做的事，找到新 <code>interface</code> 的 <code>tab</code> 和 <code>data</code>，就大功告成了。</strong></p>
<h4 id="convI2I函数查找tab和data"><a href="#convI2I函数查找tab和data" class="headerlink" title="convI2I函数查找tab和data"></a>convI2I函数查找tab和data</h4><p><strong><code>tab</code> 包括接口类型 <code>interfacetype</code> 和 实体类型 <code>_type</code></strong>。所以最关键的语句是 <code>r.tab = getitab(inter, tab._type, false)</code>。</p>
<p>因此，重点来看下 <code>getitab</code> 函数的源码，只看关键的地方：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getitab</span><span class="params">(inter *interfacetype, typ *_type, canfail <span class="keyword">bool</span>)</span> *<span class="title">itab</span></span> &#123;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 inter, typ 计算出 hash 值</span></span><br><span class="line">	h := itabhash(inter, typ)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// look twice - once without lock, once with.</span></span><br><span class="line">	<span class="comment">// common case will be no lock contention.</span></span><br><span class="line">	<span class="keyword">var</span> m *itab</span><br><span class="line">	<span class="keyword">var</span> locked <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> locked = <span class="number">0</span>; locked &lt; <span class="number">2</span>; locked++ &#123;</span><br><span class="line">		<span class="keyword">if</span> locked != <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;ifaceLock)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历哈希表的一个 slot</span></span><br><span class="line">		<span class="keyword">for</span> m = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h]))); m != <span class="literal">nil</span>; m = m.link &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果在 hash 表中已经找到了 itab（inter 和 typ 指针都相同）</span></span><br><span class="line">			<span class="keyword">if</span> m.inter == inter &amp;&amp; m._type == typ &#123;</span><br><span class="line">                <span class="comment">// ……</span></span><br><span class="line">                </span><br><span class="line">				<span class="keyword">if</span> locked != <span class="number">0</span> &#123;</span><br><span class="line">					unlock(&amp;ifaceLock)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> m</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 hash 表中没有找到 itab，那么新生成一个 itab</span></span><br><span class="line">	m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+<span class="keyword">uintptr</span>(<span class="built_in">len</span>(inter.mhdr)<span class="number">-1</span>)*sys.PtrSize, <span class="number">0</span>, &amp;memstats.other_sys))</span><br><span class="line">	m.inter = inter</span><br><span class="line">    m._type = typ</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到全局的 hash 表中</span></span><br><span class="line">	additab(m, <span class="literal">true</span>, canfail)</span><br><span class="line">	unlock(&amp;ifaceLock)</span><br><span class="line">	<span class="keyword">if</span> m.bad &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单总结：<strong>getitab 函数会根据 <code>interfacetype</code> 和 <code>_type</code> 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 <code>interfacetype</code> 和 <code>_type</code> 新生成一个 <code>itab</code>，并插入到 itab 哈希表，这样下一次就可以直接拿到 <code>itab</code>。</strong></p>
<h4 id="写itab"><a href="#写itab" class="headerlink" title="写itab"></a>写itab</h4><p>这里查找了两次，<strong>并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 <code>itab</code> 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁</strong>。这样，<strong>其他协程在查找相同的 <code>itab</code> 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 <code>itab</code>。</strong> </p>
<p>再来看一下 <code>additab</code> 函数的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查 _type 是否符合 interface_type 并且创建对应的 itab 结构体 将其放到 hash 表中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">additab</span><span class="params">(m *itab, locked, canfail <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	inter := m.inter</span><br><span class="line">	typ := m._type</span><br><span class="line">	x := typ.uncommon()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// both inter and typ have method sorted by name,</span></span><br><span class="line">	<span class="comment">// and interface names are unique,</span></span><br><span class="line">	<span class="comment">// so can iterate over both in lock step;</span></span><br><span class="line">    <span class="comment">// the loop is O(ni+nt) not O(ni*nt).</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// inter 和 typ 的方法都按方法名称进行了排序</span></span><br><span class="line">    <span class="comment">// 并且方法名都是唯一的。所以循环的次数是固定的</span></span><br><span class="line">    <span class="comment">// 只用循环 O(ni+nt)，而非 O(ni*nt)</span></span><br><span class="line">	ni := <span class="built_in">len</span>(inter.mhdr)</span><br><span class="line">	nt := <span class="keyword">int</span>(x.mcount)</span><br><span class="line">	xmhdr := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]method)(add(unsafe.Pointer(x), <span class="keyword">uintptr</span>(x.moff)))[:nt:nt]</span><br><span class="line">	j := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; ni; k++ &#123;</span><br><span class="line">		i := &amp;inter.mhdr[k]</span><br><span class="line">		itype := inter.typ.typeOff(i.ityp)</span><br><span class="line">		name := inter.typ.nameOff(i.name)</span><br><span class="line">		iname := name.name()</span><br><span class="line">		ipkg := name.pkgPath()</span><br><span class="line">		<span class="keyword">if</span> ipkg == <span class="string">""</span> &#123;</span><br><span class="line">			ipkg = inter.pkgpath.name()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ; j &lt; nt; j++ &#123;</span><br><span class="line">			t := &amp;xmhdr[j]</span><br><span class="line">            tname := typ.nameOff(t.name)</span><br><span class="line">            <span class="comment">// 检查方法名字是否一致</span></span><br><span class="line">			<span class="keyword">if</span> typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</span><br><span class="line">				pkgPath := tname.pkgPath()</span><br><span class="line">				<span class="keyword">if</span> pkgPath == <span class="string">""</span> &#123;</span><br><span class="line">					pkgPath = typ.nameOff(x.pkgpath).name()</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</span><br><span class="line">					<span class="keyword">if</span> m != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取函数地址，并加入到itab.fun数组中</span></span><br><span class="line">						ifn := typ.textOff(t.ifn)</span><br><span class="line">						*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[<span class="number">0</span>]), <span class="keyword">uintptr</span>(k)*sys.PtrSize)) = ifn</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">goto</span> nextimethod</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">        </span><br><span class="line">		m.bad = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	nextimethod:</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !locked &#123;</span><br><span class="line">		throw(<span class="string">"invalid itab locking"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 hash 值</span></span><br><span class="line">    h := itabhash(inter, typ)</span><br><span class="line">    <span class="comment">// 加到Hash Slot链表中</span></span><br><span class="line">	m.link = hash[h]</span><br><span class="line">	m.inhash = <span class="literal">true</span></span><br><span class="line">	atomicstorep(unsafe.Pointer(&amp;hash[h]), unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>additab</code> 会检查 <code>itab</code> 持有的 <code>interfacetype</code> 和 <code>_type</code> 是否符合，就是看 <code>_type</code> 是否完全实现了 <code>interfacetype</code> 的方法，也就是看两者的方法列表重叠的部分就是 <code>interfacetype</code> 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 <code>ni * nt</code>，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 <code>ni + nt</code> 次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。</strong></p>
<p>求 hash 值的函数比较简单：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabhash</span><span class="params">(inter *interfacetype, typ *_type)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">	h := inter.typ.hash</span><br><span class="line">	h += <span class="number">17</span> * typ.hash</span><br><span class="line">	<span class="keyword">return</span> h % hashSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hashSize</code> 的值是 1009。</p>
<p>更一般的，当把实体类型赋值给接口的时候，会调用 <code>conv</code> 系列函数，例如空接口调用 <code>convT2E</code> 系列、非空接口调用 <code>convT2I</code> 系列。这些函数比较相似：</p>
<blockquote>
<ol>
<li><strong>具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</strong></li>
<li><strong>具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</strong></li>
<li><strong>而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。</strong></li>
</ol>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【接口赋值、反射】<a href="http://wudaijun.com/2018/01/go-interface-implement/" target="_blank" rel="noopener">http://wudaijun.com/2018/01/go-interface-implement/</a></p>
<p>【itab】<a href="http://legendtkl.com/2017/07/01/golang-interface-implement/" target="_blank" rel="noopener">http://legendtkl.com/2017/07/01/golang-interface-implement/</a></p>
<p>【和 C++ 的对比】<a href="https://www.jianshu.com/p/b38b1719636e" target="_blank" rel="noopener">https://www.jianshu.com/p/b38b1719636e</a></p>
<p>【getitab源码说明】<a href="https://www.twblogs.net/a/5c245d59bd9eee16b3db561d" target="_blank" rel="noopener">https://www.twblogs.net/a/5c245d59bd9eee16b3db561d</a></p>
]]></content>
      <categories>
        <category>Go 接口</category>
      </categories>
      <tags>
        <tag>Go 接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 类型转换和断言</title>
    <url>/2020/01/05/Go%E6%8E%A5%E5%8F%A3_7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%96%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="Go-类型转换和断言"><a href="#Go-类型转换和断言" class="headerlink" title="Go 类型转换和断言"></a>Go 类型转换和断言</h3><p>Go 语言中不允许隐式类型转换，<strong>也就是说 <code>=</code> 两边，不允许出现类型不相同的变量</strong>。</p>
<p>类型转换<code>、</code>类型断言本质都是把一个类型转换成另外一个类型。不同之处在于，<strong>类型断言是对接口变量进行的操作。</strong></p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>对于<code>类型转换</code>而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：</p>
<blockquote>
<p>&lt;结果类型&gt; := &lt;目标类型&gt; ( &lt;表达式&gt; )</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> f <span class="keyword">float64</span></span><br><span class="line">	f = <span class="keyword">float64</span>(i)</span><br><span class="line">	fmt.Printf(<span class="string">"%T, %v\n"</span>, f, f) <span class="comment">//float64, 9</span></span><br><span class="line"></span><br><span class="line">	f = <span class="number">10.8</span></span><br><span class="line">	a := <span class="keyword">int</span>(f)</span><br><span class="line">	fmt.Printf(<span class="string">"%T, %v\n"</span>, a, a) <span class="comment">//int, 10</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// s := []int(i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码里，定义了一个 <code>int</code> 型和 <code>float64</code> 型的变量，尝试在它们之间相互转换，结果是成功的：<code>int</code> 型和 <code>float64</code> 是相互兼容的。</p>
<p>把最后一行代码的注释去掉，编译器会报告类型不兼容的错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cannot convert i (type int) to type []int</span><br></pre></td></tr></table></figure>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>前面说过，因为<strong>空接口 <code>interface{}</code> 没有定义任何函数</strong>，因此 <strong>Go 中所有类型都实现了空接口</strong>。<strong>当一个函数的形参是 <code>interface{}</code>，那么在函数中，需要对形参进行断言，从而得到它的真实类型。</strong></p>
<p>断言的语法为：</p>
<blockquote>
<p>&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) // <strong>安全类型断言</strong><br>&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )　　//<strong>非安全类型断言</strong></p>
</blockquote>
<p>类型转换和类型断言有些相似，不同之处，在于<strong>类型断言是对接口进行的操作</strong>。</p>
<p>还是来看一个简短的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br><span class="line">	s := i.(Student)</span><br><span class="line">	</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">panic: interface conversion: interface &#123;&#125; is *main.Student, not main.Student</span><br></pre></td></tr></table></figure>
<p>直接 <code>panic</code> 了，这是因为 <strong><code>i</code> 是 <code>*Student</code> 类型，并非 <code>Student</code> 类型，断言失败</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安全断言</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br><span class="line">	s, ok := i.(Student)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，<strong>即使断言失败也不会 <code>panic</code>。</strong></p>
<h4 id="switch语句判断接口类型"><a href="#switch语句判断接口类型" class="headerlink" title="switch语句判断接口类型"></a>switch语句判断接口类型</h4><p>断言其实还有另一种形式，就是<strong>利用 <code>switch</code> 语句判断接口的类型。每一个 <code>case</code> 会被顺序地考虑。当命中一个 <code>case</code> 时，就会执行 <code>case</code> 中的语句，因此 <code>case</code> 语句的顺序是很重要的，因为很有可能会有多个 <code>case</code> 匹配的情况。</strong></p>
<p>代码示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//var i interface&#123;&#125; = new(Student)</span></span><br><span class="line">	<span class="comment">//var i interface&#123;&#125; = (*Student)(nil)</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;i, i)</span><br><span class="line"></span><br><span class="line">	judge(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">judge</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> v := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">		fmt.Printf(<span class="string">"nil type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> Student:</span><br><span class="line">		fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">		fmt.Printf(<span class="string">"Student type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> *Student:</span><br><span class="line">		fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">		fmt.Printf(<span class="string">"*Student type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">		fmt.Printf(<span class="string">"unknow\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code> 函数里有三行不同的声明，<strong>每次运行一行，注释另外两行，得到三组运行结果：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// --- var i interface&#123;&#125; = new(Student)</span><br><span class="line">0xc000010240 &amp;&#123; 0&#125;</span><br><span class="line">0xc000010260 &amp;&#123; 0&#125;</span><br><span class="line">0xc00000e030 &amp;&#123; 0&#125;</span><br><span class="line">*Student type[*main.Student] &amp;&#123; 0&#125;</span><br><span class="line"></span><br><span class="line">// --- var i interface&#123;&#125; = (*Student)(nil)</span><br><span class="line">0xc000010240 &lt;nil&gt;</span><br><span class="line">0xc000010250 &lt;nil&gt;</span><br><span class="line">0xc00000e030 &lt;nil&gt;</span><br><span class="line">*Student type[*main.Student] &lt;nil&gt;</span><br><span class="line"></span><br><span class="line">// --- var i interface&#123;&#125;</span><br><span class="line">0xc00010a220 &lt;nil&gt;</span><br><span class="line">0xc00010a230 &lt;nil&gt;</span><br><span class="line">0xc00010a240 &lt;nil&gt;</span><br><span class="line">nil type[&lt;nil&gt;] &lt;nil&gt;</span><br></pre></td></tr></table></figure>
<p>对于第一行语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br></pre></td></tr></table></figure>
<p><strong><code>i</code> 是一个 <code>*Student</code> 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 <code>main</code> 函数里有一个局部变量 <code>i</code>；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 <code>v</code>，它是 <code>i</code> 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。</strong></p>
<p>对于第二行语句：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = (*Student)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这里想说明的其实是 <strong><code>i</code> 在这里动态类型是 <code>(*Student)</code>, 数据为 <code>nil</code>，它的类型并不是 <code>nil</code>，它与 <code>nil</code> 作比较的时候，得到的结果也是 <code>false</code>。</strong></p>
<p>最后一行语句：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这回 <code>i</code> 才是 <code>nil</code> 类型。</p>
<p>【引申1】<br><strong><code>fmt.Println</code> 函数的参数是 <code>interface</code>。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印。而对于自定义类型，首先确定该类型是否实现了 <code>String()</code> 方法，如果实现了，则直接打印输出 <code>String()</code> 方法的结果；否则，会通过反射来遍历对象的成员进行打印。</strong></p>
<p>再来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s = Student&#123;</span><br><span class="line">		Name: <span class="string">"qcrao"</span>,</span><br><span class="line">		Age: <span class="number">18</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>Student</code> 结构体没有实现 <code>String()</code> 方法，<strong>所以 <code>fmt.Println</code> 会利用反射挨个打印成员变量：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;qcrao 18&#125;</span><br></pre></td></tr></table></figure>
<p><strong>增加一个 <code>String()</code> 方法的实现：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"[Name: %s], [Age: %d]"</span>, s.Name, s.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Name: qcrao], [Age: 18]</span><br></pre></td></tr></table></figure>
<p>按照我们自定义的方法来打印了。</p>
<p>【引申2】<br>针对上面的例子，如果改一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"[Name: %s], [Age: %d]"</span>, s.Name, s.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意看两个函数的接受者类型不同，现在 <code>Student</code> 结构体只有一个接受者类型为 <code>指针类型</code> 的 <code>String()</code> 函数，打印结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;qcrao 18&#125;</span><br></pre></td></tr></table></figure>
<p>为什么？</p>
<blockquote>
<p><strong>类型 <code>T</code> 只有接受者是 <code>T</code> 的方法；而类型 <code>*T</code> 拥有接受者是 <code>T</code> 和 <code>*T</code> 的方法。语法上 <code>T</code> 能直接调 <code>*T</code> 的方法仅仅是 <code>Go</code> 的语法糖。</strong></p>
</blockquote>
<p>当 <strong><code>Student</code> 结构体定义了接受者类型是值类型的 <code>String()</code> 方法时</strong>，通过</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(&amp;s)</span><br></pre></td></tr></table></figure>
<p>均可以按照自定义的格式来打印。</p>
<p>如果 <code>Student</code> 结构体定义了<strong>接受者类型是指针类型的 <code>String()</code> 方法时</strong>，只有通过</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">fmt.Println(&amp;s)</span><br></pre></td></tr></table></figure>
<p>才能按照自定义的格式打印。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【类型转换和断言】<a href="https://www.cnblogs.com/zrtqsk/p/4157350.html" target="_blank" rel="noopener">https://www.cnblogs.com/zrtqsk/p/4157350.html</a></p>
<p>【断言】<a href="https://studygolang.com/articles/11419" target="_blank" rel="noopener">https://studygolang.com/articles/11419</a></p>
]]></content>
      <categories>
        <category>Go interface</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 接口的构造过程</title>
    <url>/2020/01/04/Go%20%E6%8E%A5%E5%8F%A3_5%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/</url>
    <content><![CDATA[<h3 id="Go-接口的构造过程"><a href="#Go-接口的构造过程" class="headerlink" title="Go 接口的构造过程"></a>Go 接口的构造过程</h3><p>博客<a href="https://dongshifu.github.io/2020/01/03/Go%20%E6%8E%A5%E5%8F%A3_3iface%20%E5%92%8C%20eface%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">Go接口的底层实现</a>源码分析可以看到 <code>iface</code> 和 <code>eface</code> 的源码，知道 <code>iface</code> 最重要的是 <code>itab</code> 和 <code>_type</code>。</p>
<p>为了研究清楚接口是如何构造的，接下来利用汇编还原背后的真相。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">	growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Student)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.age += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> qcrao = Person(Student&#123;age: <span class="number">18</span>&#125;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(qcrao)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go tool compile -S main.go</span><br></pre></td></tr></table></figure>
<p>得到 main 函数的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000 00000 (./src/main.go:30) TEXT    &quot;&quot;.main(SB), $80-0</span><br><span class="line">0x0000 00000 (./src/main.go:30) MOVQ    (TLS), CX</span><br><span class="line">0x0009 00009 (./src/main.go:30) CMPQ    SP, 16(CX)</span><br><span class="line">0x000d 00013 (./src/main.go:30) JLS     157</span><br><span class="line">0x0013 00019 (./src/main.go:30) SUBQ    $80, SP</span><br><span class="line">0x0017 00023 (./src/main.go:30) MOVQ    BP, 72(SP)</span><br><span class="line">0x001c 00028 (./src/main.go:30) LEAQ    72(SP), BP</span><br><span class="line">0x0021 00033 (./src/main.go:30) FUNCDATA$0, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">0x0021 00033 (./src/main.go:30) FUNCDATA$1, gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)</span><br><span class="line">0x0021 00033 (./src/main.go:31) MOVQ    $18, &quot;&quot;..autotmp_1+48(SP)</span><br><span class="line">0x002a 00042 (./src/main.go:31) LEAQ    go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB), AX</span><br><span class="line">0x0031 00049 (./src/main.go:31) MOVQ    AX, (SP)</span><br><span class="line">0x0035 00053 (./src/main.go:31) LEAQ    &quot;&quot;..autotmp_1+48(SP), AX</span><br><span class="line">0x003a 00058 (./src/main.go:31) MOVQ    AX, 8(SP)</span><br><span class="line">0x003f 00063 (./src/main.go:31) PCDATA  $0, $0</span><br><span class="line">0x003f 00063 (./src/main.go:31) CALL    runtime.convT2I64(SB)</span><br><span class="line">0x0044 00068 (./src/main.go:31) MOVQ    24(SP), AX</span><br><span class="line">0x0049 00073 (./src/main.go:31) MOVQ    16(SP), CX</span><br><span class="line">0x004e 00078 (./src/main.go:33) TESTQ   CX, CX</span><br><span class="line">0x0051 00081 (./src/main.go:33) JEQ     87</span><br><span class="line">0x0053 00083 (./src/main.go:33) MOVQ    8(CX), CX</span><br><span class="line">0x0057 00087 (./src/main.go:33) MOVQ    $0, &quot;&quot;..autotmp_2+56(SP)</span><br><span class="line">0x0060 00096 (./src/main.go:33) MOVQ    $0, &quot;&quot;..autotmp_2+64(SP)</span><br><span class="line">0x0069 00105 (./src/main.go:33) MOVQ    CX, &quot;&quot;..autotmp_2+56(SP)</span><br><span class="line">0x006e 00110 (./src/main.go:33) MOVQ    AX, &quot;&quot;..autotmp_2+64(SP)</span><br><span class="line">0x0073 00115 (./src/main.go:33) LEAQ    &quot;&quot;..autotmp_2+56(SP), AX</span><br><span class="line">0x0078 00120 (./src/main.go:33) MOVQ    AX, (SP)</span><br><span class="line">0x007c 00124 (./src/main.go:33) MOVQ    $1, 8(SP)</span><br><span class="line">0x0085 00133 (./src/main.go:33) MOVQ    $1, 16(SP)</span><br><span class="line">0x008e 00142 (./src/main.go:33) PCDATA  $0, $1</span><br><span class="line">0x008e 00142 (./src/main.go:33) CALL    fmt.Println(SB)</span><br><span class="line">0x0093 00147 (./src/main.go:34) MOVQ    72(SP), BP</span><br><span class="line">0x0098 00152 (./src/main.go:34) ADDQ    $80, SP</span><br><span class="line">0x009c 00156 (./src/main.go:34) RET</span><br><span class="line">0x009d 00157 (./src/main.go:34) NOP</span><br><span class="line">0x009d 00157 (./src/main.go:30) PCDATA  $0, $-1</span><br><span class="line">0x009d 00157 (./src/main.go:30) CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">0x00a2 00162 (./src/main.go:30) JMP     0</span><br></pre></td></tr></table></figure>
<p>从第 10 行开始看：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>汇编行数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>10-14</td>
<td>构造调用 <code>runtime.convT2I64(SB)</code> 的<strong>参数</strong></td>
</tr>
</tbody>
</table>
</div>
<p>函数的参数形式：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I64</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>convT2I64</code> 会构造出一个 <code>inteface</code>，也就是我们的 <code>Person</code> 接口。</strong></p>
<p><strong>第一个参数的位置是 <code>(SP)</code>，这里被赋上了 <code>go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB)</code> 的地址。</strong></p>
<p>我们从生成的汇编找到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go.itab.&quot;&quot;.Student,&quot;&quot;.Person SNOPTRDATA dupok size=40</span><br><span class="line">        0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  </span><br><span class="line">        0x0010 00 00 00 00 00 00 00 00 da 9f 20 d4              </span><br><span class="line">        rel 0+8 t=1 type.&quot;&quot;.Person+0</span><br><span class="line">        rel 8+8 t=1 type.&quot;&quot;.Student+0</span><br></pre></td></tr></table></figure>
<p><code>size=40</code> 大小为40字节，回顾一下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">	inter  *interfacetype <span class="comment">// 8字节</span></span><br><span class="line">	_type  *_type <span class="comment">// 8字节</span></span><br><span class="line">	link   *itab <span class="comment">// 8字节</span></span><br><span class="line">	hash   <span class="keyword">uint32</span> <span class="comment">// 4字节</span></span><br><span class="line">	bad    <span class="keyword">bool</span>   <span class="comment">// 1字节</span></span><br><span class="line">	inhash <span class="keyword">bool</span>   <span class="comment">// 1字节</span></span><br><span class="line">	unused [<span class="number">2</span>]<span class="keyword">byte</span> <span class="comment">// 2字节</span></span><br><span class="line">	fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized // 8字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>把每个字段的大小相加，<code>itab</code> 结构体的大小就是 40 字节。上面那一串数字实际上是 <code>itab</code> 序列化后的内容</strong>，注意到大部分数字是 0，从 24 字节开始的 4 个字节 <code>da 9f 20 d4</code> 实际上是 <code>itab</code> 的 <code>hash</code> 值，这在<strong>判断两个类型是否相同的时候会用到。</strong></p>
<p>下面两行是<strong>链接指令，简单说就是将所有源文件综合起来，给每个符号赋予一个全局的位置值。这里的意思也比较明确：前8个字节最终存储的是 <code>type.&quot;&quot;.Person</code> 的地址，对应 <code>itab</code> 里的 <code>inter</code> 字段，表示接口类型；8-16 字节最终存储的是 <code>type.&quot;&quot;.Student</code> 的地址，对应 <code>itab</code> 里 <code>_type</code> 字段，表示具体类型。</strong></p>
<p>第二个参数就比较简单了，它就是数字 <code>18</code> 的地址，这也是初始化 <code>Student</code> 结构体的时候会用到。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>汇编行数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>调用 <code>runtime.convT2I64(SB)</code></td>
</tr>
</tbody>
</table>
</div>
<p>具体看下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I64</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">	t := tab._type</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> *(*<span class="keyword">uint64</span>)(elem) == <span class="number">0</span> &#123;</span><br><span class="line">		x = unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		x = mallocgc(<span class="number">8</span>, t, <span class="literal">false</span>)</span><br><span class="line">		*(*<span class="keyword">uint64</span>)(x) = *(*<span class="keyword">uint64</span>)(elem)</span><br><span class="line">	&#125;</span><br><span class="line">	i.tab = tab</span><br><span class="line">	i.data = x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块代码比较简单，<strong>把 <code>tab</code> 赋给了 <code>iface</code> 的 <code>tab</code> 字段；<code>data</code> 部分则是在堆上申请了一块内存，然后将 <code>elem</code> 指向的 <code>18</code> 拷贝过去。这样 <code>iface</code> 就组装好了。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>汇编行数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>17</td>
<td>把 <code>i.tab</code> 赋给 <code>CX</code></td>
</tr>
<tr>
<td>18</td>
<td>把 <code>i.data</code> 赋给 <code>AX</code></td>
</tr>
<tr>
<td>19-21</td>
<td><strong>检测 <code>i.tab</code> 是否是 nil，如果不是的话，把 CX 移动 8 个字节，也就是把 <code>itab</code> 的 <code>_type</code> 字段赋给了 CX，这也是接口的实体类型，最终要作为 <code>fmt.Println</code> 函数的参数</strong></td>
</tr>
</tbody>
</table>
</div>
<p>后面，就是调用 <code>fmt.Println</code> 函数及之前的参数准备工作了.</p>
<p>这样，我们就把一个 <code>interface</code> 的构造过程说完了。</p>
<p>【引申1】<br>如何打印出接口类型的 <code>Hash</code> 值？</p>
<p>这里参考一篇文章<a href="https://xargin.com/go-and-interface/#reconstructing-an-itab-from-an-executable" target="_blank" rel="noopener">Go和interface探究</a>。具体做法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">	inter <span class="keyword">uintptr</span></span><br><span class="line">	_type <span class="keyword">uintptr</span></span><br><span class="line">	link <span class="keyword">uintptr</span></span><br><span class="line">	hash  <span class="keyword">uint32</span></span><br><span class="line">	_     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">	fun   [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> qcrao = Person(Student&#123;age: <span class="number">18</span>&#125;)</span><br><span class="line"></span><br><span class="line">	iface := (*iface)(unsafe.Pointer(&amp;qcrao))</span><br><span class="line">	fmt.Printf(<span class="string">"iface.tab.hash = %#x\n"</span>, iface.tab.hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个<code>山寨版</code>的 <code>iface</code> 和 <code>itab</code>，说它<code>山寨</code>是因为 <code>itab</code> 里的一些关键数据结构都不具体展开了，比如 <code>_type</code>，对比一下正宗的定义就可以发现，但是<code>山寨版</code>依然能工作，因为 <code>_type</code> 就是一个指针而已嘛。</p>
<p>在 <code>main</code> 函数里，先构造出一个接口对象 <code>qcrao</code>，然后强制类型转换，最后读取出 <code>hash</code> 值！</p>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iface.tab.hash = 0xd4209fda</span><br></pre></td></tr></table></figure>
<p>值得一提的是，构造接口 <code>qcrao</code> 的时候，即使把 <code>age</code> 写成其他值，得到的 <code>hash</code> 值依然不变的，这应该是可以预料的，<strong><code>hash</code> 值只和他的字段、方法相关。</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://xargin.com/go-and-interface/#reconstructing-an-itab-from-an-executable" target="_blank" rel="noopener">http://xargin.com/go-and-interface/#reconstructing-an-itab-from-an-executable</a></p>
]]></content>
      <categories>
        <category>Go interface</category>
      </categories>
      <tags>
        <tag>Go 接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 接口的动态类型和动态值</title>
    <url>/2020/01/04/Go%20%E6%8E%A5%E5%8F%A3_4%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E5%80%BC/</url>
    <content><![CDATA[<h3 id="Go-接口的动态类型和动态值"><a href="#Go-接口的动态类型和动态值" class="headerlink" title="Go 接口的动态类型和动态值"></a>Go 接口的动态类型和动态值</h3><p>从上一篇博客<a href="https://dongshifu.github.io/2020/01/03/Go%20%E6%8E%A5%E5%8F%A3_3iface%20%E5%92%8C%20eface%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">Go接口的底层实现</a>源码分析里可以看到：<code>iface</code>包含两个字段：<code>tab</code> 是接口表指针，指向类型信息；<code>data</code> 是数据指针，则指向具体的数据。它们分别被称为<strong><code>动态类型</code>和<code>动态值</code></strong>。而接口值包括<code>动态类型</code>和<code>动态值</code>。</p>
<p>【引申1】接口类型和 <code>nil</code> 作比较</p>
<p><strong>接口值的零值是指<code>动态类型</code>和<code>动态值</code>都为 <code>nil</code>。当仅且当这两部分的值都为 <code>nil</code> 的情况下，这个接口值就才会被认为 <code>接口值 == nil</code>。</strong></p>
<p>来看个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coder <span class="keyword">interface</span> &#123;</span><br><span class="line">	code()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is coding\n"</span>, g.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Coder</span><br><span class="line">	fmt.Println(c == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"c: %T, %v\n"</span>, c, c)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> g *Gopher</span><br><span class="line">	fmt.Println(g == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	c = g</span><br><span class="line">	fmt.Println(c == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"c: %T, %v\n"</span>, c, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">c: &lt;nil&gt;, &lt;nil&gt;</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">c: *main.Gopher, &lt;nil&gt;</span><br></pre></td></tr></table></figure>
<p>一开始，<strong><code>c</code> 的 动态类型和动态值都为 <code>nil</code>，<code>g</code> 也为 <code>nil</code>，当把 <code>g</code> 赋值给 <code>c</code> 后，<code>c</code> 的动态类型变成了 <code>*main.Gopher</code>，仅管 <code>c</code> 的动态值仍为 <code>nil</code>，但是当 <code>c</code> 和 <code>nil</code> 作比较的时候，结果就是 <code>false</code> 了。</strong></p>
<p>【引申2】</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"MyError"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := Process()</span><br><span class="line">	fmt.Println(err)</span><br><span class="line"></span><br><span class="line">	fmt.Println(err == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Process</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err *MyError = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p><strong>这里先定义了一个 <code>MyError</code> 结构体，实现了 <code>Error</code> 函数，也就实现了 <code>error</code> 接口。<code>Process</code> 函数返回了一个 <code>error</code> 接口，这块隐含了类型转换。所以，虽然它的值是 <code>nil</code>，其实它的类型是 <code>*MyError</code>，最后和 <code>nil</code> 比较的时候，结果为 <code>false</code>。</strong></p>
<p>【引申3】如何打印出接口的动态类型和值？</p>
<p>直接看代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	itab, data <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	x := <span class="number">5</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">interface</span>&#123;&#125; = (*<span class="keyword">int</span>)(&amp;x)</span><br><span class="line">	</span><br><span class="line">	ia := *(*iface)(unsafe.Pointer(&amp;a))</span><br><span class="line">	ib := *(*iface)(unsafe.Pointer(&amp;b))</span><br><span class="line">	ic := *(*iface)(unsafe.Pointer(&amp;c))</span><br><span class="line"></span><br><span class="line">	fmt.Println(ia, ib, ic)</span><br><span class="line"></span><br><span class="line">	fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(ic.data)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里直接定义了一个 <code>iface</code> 结构体，<strong>用两个指针来描述 <code>itab</code> 和 <code>data</code>，之后将 a, b, c 在内存中的内容强制解释成我们自定义的 <code>iface</code>。最后就可以打印出动态类型和动态值的地址。</strong></p>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;0 0&#125; &#123;4843168 0&#125; &#123;4843168 824634355376&#125;</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>a 的动态类型和动态值的地址均为 0，也就是 nil；<strong>b 的动态类型和 c 的动态类型一致，都是 <code>*int</code></strong>；最后，c 的动态值为 5。</p>
]]></content>
      <categories>
        <category>Go interface</category>
      </categories>
      <tags>
        <tag>Go 接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 接口的底层实现</title>
    <url>/2020/01/03/Go%20%E6%8E%A5%E5%8F%A3_3iface%20%E5%92%8C%20eface%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h3 id="Go-接口的底层实现"><a href="#Go-接口的底层实现" class="headerlink" title="Go 接口的底层实现"></a>Go 接口的底层实现</h3><p><code>iface</code> 和 <code>eface</code> 都是 Go 中<strong>描述接口的底层结构体</strong>，区别在于 <strong><code>iface</code> 描述的接口包含方法</strong>，<strong>而 <code>eface</code> 则是不包含任何方法的空接口：<code>interface{}</code>。</strong></p>
<p>从源码层面：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">	inter  *interfacetype</span><br><span class="line">	_type  *_type</span><br><span class="line">	link   *itab</span><br><span class="line">	hash   <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">	bad    <span class="keyword">bool</span>   <span class="comment">// type does not implement interface</span></span><br><span class="line">	inhash <span class="keyword">bool</span>   <span class="comment">// has this itab been added to hash?</span></span><br><span class="line">	unused [<span class="number">2</span>]<span class="keyword">byte</span></span><br><span class="line">	fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>iface</code> 内部维护两个指针，<code>tab</code> 指向一个 <code>itab</code> 实体， 它表示接口的类型以及赋给这个接口的实体类型。<code>data</code> 则指向接口具体的值，一般而言是一个指向堆内存的指针。</strong></p>
<p>再来仔细看一下 <code>itab</code> 结构体：</p>
<ul>
<li><code>_type</code> 字段描述了<strong>实体的类型</strong>，包括内存对齐方式，大小等；</li>
<li><code>inter</code> 字段则描述了<strong>接口的类型</strong>。</li>
<li><code>fun</code> 字段<strong>放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。</strong></li>
</ul>
<p>为什么 <code>fun</code> 数组的大小为 1，要是接口定义了多个方法可怎么办？<strong>实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响</strong>。<strong>这些方法是按照函数名称的字典序进行排列的。</strong></p>
<p>再看一下 <code>interfacetype</code> 类型，它描述的是<strong>接口的类型</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ     _type</span><br><span class="line">	pkgpath name</span><br><span class="line">	mhdr    []imethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，它<strong>包装了 <code>_type</code> 类型，<code>_type</code> 实际上是描述 Go 语言中各种数据类型的结构体</strong>。这里还包含一个 <strong><code>mhdr</code> 字段，表示接口所定义的函数列表， <code>pkgpath</code> 记录定义了接口的包名。</strong></p>
<p>这里通过一张图来看下 <code>iface</code> 结构体的全貌：</p>
<p><img src="http://note.youdao.com/yws/public/resource/8941a5b166d00686542939a34ab5b824/xmlnote/WEBRESOURCE4c3c10a3a36d081c3787db1242d05528/4518" style="zoom:50%;" /></p>
<p><code>eface</code> 的源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比 <code>iface</code>，<code>eface</code> 比较简单。只维护了一个 <code>_type</code> 字段，<strong>表示空接口所承载的具体的实体类型</strong>。<code>data</code> 描述了具体的值。</p>
<p><img src="http://note.youdao.com/yws/public/resource/8941a5b166d00686542939a34ab5b824/xmlnote/WEBRESOURCEb64a739bc6eb4c7cfe6a05b71e1d6e38/4523" alt="eface 结构体" style="zoom:50%;" /></p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">200</span></span><br><span class="line">	<span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125; = x</span><br><span class="line">	fmt.Println(any)</span><br><span class="line"></span><br><span class="line">	g := Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> c coder = g</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">	code()</span><br><span class="line">	debug()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">	language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"I am coding %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">debug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"I am debuging %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行命令，打印出汇编语言：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go tool compile -S ./src/main.go</span><br></pre></td></tr></table></figure>
<p>可以看到，main 函数里调用了两个函数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func convT2E64(t *_type, elem unsafe.Pointer) (e eface)</span><br><span class="line">func convT2I(tab *itab, elem unsafe.Pointer) (i iface)</span><br></pre></td></tr></table></figure>
<p>上面两个函数的参数和 <code>iface</code> 及 <code>eface</code> 结构体的字段是可以联系起来的：两个函数都是将参数<code>组装</code>一下，形成最终的接口。</p>
<p>作为补充，最后再来看下 <code>_type</code> 结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 类型大小</span></span><br><span class="line">	size       <span class="keyword">uintptr</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// 类型的 hash 值</span></span><br><span class="line">    hash       <span class="keyword">uint32</span></span><br><span class="line">    <span class="comment">// 类型的 flag，和反射相关</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    <span class="comment">// 内存对齐相关</span></span><br><span class="line">    align      <span class="keyword">uint8</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span></span><br><span class="line">    <span class="comment">// 类型的编号，有bool, slice, struct 等等等等</span></span><br><span class="line">	kind       <span class="keyword">uint8</span></span><br><span class="line">	alg        *typeAlg</span><br><span class="line">	<span class="comment">// gc 相关</span></span><br><span class="line">	gcdata    *<span class="keyword">byte</span></span><br><span class="line">	str       nameOff</span><br><span class="line">	ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Go 语言各种数据类型都是在 <code>_type</code> 字段的基础上，增加一些额外的字段来进行管理的：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> arraytype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ   _type</span><br><span class="line">	elem  *_type</span><br><span class="line">	slice *_type</span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  _type</span><br><span class="line">	elem *_type</span><br><span class="line">	dir  <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> slicetype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  _type</span><br><span class="line">	elem *_type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> structtype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ     _type</span><br><span class="line">	pkgPath name</span><br><span class="line">	fields  []structfield</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些数据类型的结构体定义，是反射实现的基础。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【Go Interface 源码剖析 】<a href="http://legendtkl.com/2017/07/01/golang-interface-implement/" target="_blank" rel="noopener">http://legendtkl.com/2017/07/01/golang-interface-implement/</a></p>
<p>【interface 源码解读 包含反射】<a href="http://wudaijun.com/2018/01/go-interface-implement/" target="_blank" rel="noopener">http://wudaijun.com/2018/01/go-interface-implement/</a></p>
]]></content>
      <categories>
        <category>Go interface</category>
      </categories>
      <tags>
        <tag>Go 接口底层实现</tag>
      </tags>
  </entry>
  <entry>
    <title>Go鸭子类型</title>
    <url>/2020/01/02/Go%20%E6%8E%A5%E5%8F%A3_2Go%E8%AF%AD%E8%A8%80%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h3><p>维基百科: 如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。</p>
<ul>
<li><p><code>Duck Typing</code>，鸭子类型，是<strong>动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身</strong>。</p>
</li>
<li><p>Go 语言作为一门静态语言，它通过<strong>通过接口的方式完美支持鸭子类型</strong>。</p>
</li>
</ul>
<h3 id="动态语言实现"><a href="#动态语言实现" class="headerlink" title="动态语言实现"></a>动态语言实现</h3><p>动态语言的特点：</p>
<blockquote>
<p>变量绑定的类型是不确定的，在运行期间才能确定<br>函数和方法可以接收任何类型的参数，且调用时不检查参数类型<br>不需要实现接口</p>
</blockquote>
<p>在动态语言 python 中，定义一个这样的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">(coder)</span>:</span></span><br><span class="line">    coder.say_hello()</span><br></pre></td></tr></table></figure>
<p>当调用此函数的时候，可以传入任意类型，只要它实现了 <code>say_hello()</code> 函数就可以。如果没有实现，<strong>运行过程</strong>中会出现错误。</p>
<h3 id="静态语言实现"><a href="#静态语言实现" class="headerlink" title="静态语言实现"></a>静态语言实现</h3><p>而在静态语言如 Java, C++ 中，必须要<strong>显示地声明实现了某个接后，才能用在任何需要这个接口的地方。</strong> <strong>如果你在程序中调用 <code>hello_world</code> 函数，却传入了一个根本就没有实现 <code>say_hello()</code> 的类型，那在编译阶段就不会通过。</strong>这也是静态语言比动态语言更安全的原因。</p>
<p>动态语言和静态语言的差别在此就有所体现。<strong>静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。</strong></p>
<p>静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，eg. python 。</p>
<h3 id="Go鸭子类型实现"><a href="#Go鸭子类型实现" class="headerlink" title="Go鸭子类型实现"></a>Go鸭子类型实现</h3><p>Go 语言作为一门现代静态语言，是有后发优势的。它<strong>引入了动态语言的便利，同时又会进行静态语言的类型检查</strong>，写起来是非常高效的。</p>
<p>Go 采用了折中的做法：<strong>不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。</strong></p>
<p>例子：</p>
<p>定义一个接口，和使用此接口作为参数的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IGreeting <span class="keyword">interface</span> &#123;</span><br><span class="line">	sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(i IGreeting)</span></span> &#123;</span><br><span class="line">	i.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义两个结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Go <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Go)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hi, I am GO!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PHP <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PHP)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hi, I am PHP!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在 main 函数里调用 sayHello() 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	golang := Go&#123;&#125;</span><br><span class="line">	php := PHP&#123;&#125;</span><br><span class="line"></span><br><span class="line">	sayHello(golang)</span><br><span class="line">	sayHello(php)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hi, I am GO!</span><br><span class="line">Hi, I am PHP!</span><br></pre></td></tr></table></figure>
<p><strong>在 main 函数中，调用 sayHello() 函数时，传入了 <code>golang, php</code> 对象，它们并没有显式地声明实现了 IGreeting 类型，只是实现了接口所规定的 sayHello() 函数。实际上，编译器在调用 sayHello() 函数时，会隐式地将 <code>golang, php</code> 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>鸭子类型是一种动态语言的风格，在这种风格中，<strong>一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它”当前方法和属性的集合”决定。Go 作为一种静态语言，通过接口实现了 <code>鸭子类型</code>，实际上是 Go 的编译器在其中作了隐匿的转换工作。</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【Golang 与鸭子类型，讲得比较好】<a href="https://blog.csdn.net/cszhouwei/article/details/33741731" target="_blank" rel="noopener">https://blog.csdn.net/cszhouwei/article/details/33741731</a></p>
<p>【各种面向对象的名词】<a href="https://cyent.github.io/golang/other/oo/" target="_blank" rel="noopener">https://cyent.github.io/golang/other/oo/</a></p>
]]></content>
      <categories>
        <category>Go interface</category>
      </categories>
      <tags>
        <tag>接口 鸭子类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Go接口与C++接口的异同</title>
    <url>/2020/01/02/Go%20%E6%8E%A5%E5%8F%A3_1Go%E4%B8%8E%20C++%20%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<h3 id="接口设计的意义"><a href="#接口设计的意义" class="headerlink" title="接口设计的意义"></a>接口设计的意义</h3><ul>
<li>泛型编程：使用 interface 可以实现泛型编程</li>
<li>隐藏具体实现：设计一个函数返回一个 interface，那么<strong>只能通过 interface 里面的方法来做一些操作，但是内部的具体实现是完全不知道的。</strong></li>
</ul>
<h3 id="golang中的接口"><a href="#golang中的接口" class="headerlink" title="golang中的接口"></a>golang中的接口</h3><p>接口定义了一种<strong>规范，描述了类的行为和功能，而不做具体实现</strong>。</p>
<p>Interface定义了一个或一组method(s)，<strong>这些method(s)只有函数签名，没有具体的实现代码</strong>.</p>
<p>若某个数据类型实现了Interface中定义的那些被称为”methods”的函数，则称这些<strong>数据类型实现（implement）了interface。</strong></p>
<h3 id="C-中的接口实现方法"><a href="#C-中的接口实现方法" class="headerlink" title="C++中的接口实现方法"></a>C++中的接口实现方法</h3><p>C++ 的接口是使用<strong>抽象类</strong>来实现的，如果类中至少有一个函数被声明为<strong>纯虚函数</strong>，则这个类就是抽象类。<strong>纯虚函数是通过在声明中使用 “= 0” 来指定的</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 纯虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="built_in">string</span> name;      <span class="comment">// 名称</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设计抽象类的目的:<strong>为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</strong></p>
<p><strong>派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数</strong>。</p>
<h3 id="golang接口与C-接口区别"><a href="#golang接口与C-接口区别" class="headerlink" title="golang接口与C++接口区别"></a>golang接口与C++接口区别</h3><ul>
<li><p>C++ 定义接口的方式称为“侵入式”</p>
</li>
<li><p>Go 采用的是 “非侵入式”，<strong>不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。</strong></p>
</li>
<li><p>底层实现不同</p>
<ul>
<li>实现方式：C++ 通过<strong>虚函数表来实现基类调用派生类的函数</strong>；而 Go 通过 <code>itab</code> 中的 <code>fun</code> 字段来实现接口变量调用实体类型的函数。</li>
<li>编译生成过程：C++ 中的<strong>虚函数表是在编译期生成</strong>的；而 Go 的 <code>itab</code> 中的 <code>fun</code> 字段是在<strong>运行期间动态生成</strong>的。原因在于，<strong>Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 <code>itab</code></strong>， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Go interface</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 编译器自动检测类型是否实现接口</title>
    <url>/2020/01/01/Go_struct_2%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h3 id="Go-编译器自动检测类型是否实现接口"><a href="#Go-编译器自动检测类型是否实现接口" class="headerlink" title="Go 编译器自动检测类型是否实现接口"></a>Go 编译器自动检测类型是否实现接口</h3><p>开源库里会有一些类似下面这种奇怪的用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。<strong>编译器会由此检查 <code>*myWriter</code> 类型是否实现了 <code>io.Writer</code> 接口。</strong></p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"io"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myWriter <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*func (w myWriter) Write(p []byte) (n int, err error) &#123;</span></span><br><span class="line"><span class="comment">	return</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查 *myWriter 类型是否实现了 io.Writer 接口</span></span><br><span class="line">    <span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 myWriter 类型是否实现了 io.Writer 接口</span></span><br><span class="line">    <span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释掉为 myWriter 定义的 Write 函数后，运行程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">command</span>-line-arguments</span></span><br><span class="line">src/learn/tongbu/tongbu.go:14:6: cannot use (*myWriter)(nil) (type *myWriter) as type io.Writer in assignment:</span><br><span class="line">	*myWriter does not implement io.Writer (missing Write method)</span><br><span class="line">src/learn/tongbu/tongbu.go:17:6: cannot use myWriter&#123;&#125; (type myWriter) as type io.Writer in assignment:</span><br><span class="line">	myWriter does not implement io.Writer (missing Write method)</span><br></pre></td></tr></table></figure>
<p>报错信息：<strong>*myWriter/myWriter 未实现 io.Writer 接口，也就是未实现 Write 方法。</strong></p>
<p>解除注释后，运行程序不报错。</p>
<p>实际上，上述赋值语句会发生<strong>隐式地类型转换</strong>，<strong>在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。</strong></p>
<p>总结: 可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go struct</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go struct方法的值接收者与指针接收者区别</title>
    <url>/2020/01/01/Go_struct_1%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><p>方法能<strong>给用户自定义的类型添加新的行为</strong>。和函数的区别在于<strong>方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是<code>值接收者</code>，也可以是<code>指针接收者</code>。</strong></p>
<p>在调用方法的时候，值类型既可以调用<code>值接收者</code>的方法，也可以调用<code>指针接收者</code>的方法；指针类型既可以调用<code>指针接收者</code>的方法，也可以调用<code>值接收者</code>的方法。</p>
<p>也就是说，<strong>不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。</strong></p>
<p>例1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">howOld</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// qcrao 是值类型</span></span><br><span class="line">	qcrao := Person&#123;age: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 值类型 调用接收者也是值类型的方法</span></span><br><span class="line">	fmt.Println(qcrao.howOld())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 值类型 调用接收者是指针类型的方法</span></span><br><span class="line">	qcrao.growUp()</span><br><span class="line">	fmt.Println(qcrao.howOld())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// stefno 是指针类型</span></span><br><span class="line">	stefno := &amp;Person&#123;age: <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针类型 调用接收者是值类型的方法</span></span><br><span class="line">	fmt.Println(stefno.howOld())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针类型 调用接收者也是指针类型的方法</span></span><br><span class="line">	stefno.growUp()</span><br><span class="line">	fmt.Println(stefno.howOld())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">18</span><br><span class="line">19</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td></tr></table></figure></p>
<p><strong>调用了 <code>growUp</code> 函数后，不管调用者是值类型还是指针类型，它的 <code>Age</code> 值都改变了。</strong></p>
<h3 id="编译器背后工作"><a href="#编译器背后工作" class="headerlink" title="编译器背后工作"></a>编译器背后工作</h3><p>实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>-</th>
<th>值接收者</th>
<th>指针接收者</th>
</tr>
</thead>
<tbody>
<tr>
<td>值类型调用者</td>
<td>方法会使用调用者的一个<strong>副本，类似于“传值”</strong></td>
<td>使用<strong>值的引用来调用方法，上例中，<code>qcrao.growUp()</code> 实际上是 <code>(&amp;qcrao).growUp()</code></strong></td>
</tr>
<tr>
<td>指针类型调用者</td>
<td>指针被<strong>解引用为值</strong>，上例中，<code>stefno.howOld()</code> <strong>实际上是 <code>(*stefno).howOld()</code></strong></td>
<td>实际上也是“传值”，方法里的操作会影响到调用者，<strong>类似于指针传参，拷贝了一份指针</strong></td>
</tr>
</tbody>
</table>
</div>
<h3 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h3><p>不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。</p>
<p>结论：<strong>实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。</strong></p>
<p>例2:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">	code()</span><br><span class="line">	debug()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">	language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"I am coding %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Gopher)</span> <span class="title">debug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"I am debuging %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c coder = &amp;Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line">	c.code()</span><br><span class="line">	c.debug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码里定义了一个接口 <code>coder</code>，接口定义了两个函数：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">code()</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>
<p>接着定义了一个结构体 <code>Gopher</code>，它实现了两个方法，一个值接收者，一个指针接收者。</p>
<p>最后，我们在 <code>main</code> 函数里通过接口类型的变量调用了定义的两个函数。</p>
<p>运行，结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">I am coding Go language</span><br><span class="line">I am debuging Go language</span><br></pre></td></tr></table></figure>
<p>如果把 <code>main</code> 函数的第一条语句换一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c coder = Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line">	c.code()</span><br><span class="line">	c.debug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下，报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">command</span>-line-arguments</span></span><br><span class="line">src/learn/tongbu/tongbu.go:25:6: cannot use Gopher&#123;...&#125; (type Gopher) as type coder in assignment:</span><br><span class="line">	Gopher does not implement coder (debug method has pointer receiver)</span><br></pre></td></tr></table></figure>
<p>两处代码的差别: 第一次是将 <code>&amp;Gopher</code> 赋给了 <code>coder</code>；第二次则是将 <code>Gopher</code> 赋给了 <code>coder</code>。</p>
<p>第二次报错是说，<code>Gopher</code> 没有实现 <code>coder</code>。很明显，<strong>因为 <code>Gopher</code> 类型并没有实现 <code>debug</code> 方法；表面上看， <code>*Gopher</code> 类型也没有实现 <code>code</code> 方法，但是因为 <code>Gopher</code> 类型实现了 <code>code</code> 方法，所以让 <code>*Gopher</code> 类型自动拥有了 <code>code</code> 方法。</strong></p>
<p>当然，上面的说法有一个简单的解释：<strong>接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响。</strong></p>
<p>所以，<strong>当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。</strong></p>
<p>最后，需要记住：</p>
<blockquote>
<p>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。</p>
</blockquote>
<h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p><strong>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</strong></p>
<p>使用指针作为方法的接收者的理由：</p>
<ul>
<li><strong>方法能够修改接收者指向的值。</strong></li>
<li><strong>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</strong></li>
</ul>
<p><strong>是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的<code>本质</code>。</strong></p>
<p><strong>如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 <code>header</code>， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 <code>header</code>，而 <code>header</code> 本身就是为复制设计的。</strong></p>
<p><strong>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份<code>实体</code>。</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【飞雪无情 Go实战笔记】<a href="https://www.flysnow.org/2017/04/03/go-in-action-go-interface.html" target="_blank" rel="noopener">https://www.flysnow.org/2017/04/03/go-in-action-go-interface.html</a></p>
<p>【何时使用指针接收者】<a href="http://ironxu.com/711" target="_blank" rel="noopener">http://ironxu.com/711</a></p>
<p>【理解Go Interface】<a href="http://lanlingzi.cn/post/technical/2016/0803_go_interface/" target="_blank" rel="noopener">http://lanlingzi.cn/post/technical/2016/0803_go_interface/</a></p>
]]></content>
      <categories>
        <category>Go struct</category>
      </categories>
      <tags>
        <tag>Go值接收者 指针接收者</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 用interface实现多态</title>
    <url>/2019/12/30/Go%20%E6%8E%A5%E5%8F%A3_0Go%E7%94%A8%20interface%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h3 id="Go-用interface实现多态"><a href="#Go-用interface实现多态" class="headerlink" title="Go 用interface实现多态"></a>Go 用interface实现多态</h3><p>Go 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。</p>
<p>多态是一种运行期的行为，它有以下几个特点：</p>
<blockquote>
<ol>
<li>一种类型具有多种类型的能力</li>
<li>允许不同的对象对同一消息做出灵活的反应</li>
<li>以一种通用的方式对待个使用的对象</li>
<li>非动态语言必须通过继承和接口的方式来实现</li>
</ol>
</blockquote>
<p>看一个实现了多态的代码例子：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	qcrao := Student&#123;age: <span class="number">18</span>&#125;</span><br><span class="line">	whatJob(&amp;qcrao)</span><br><span class="line"></span><br><span class="line">	growUp(&amp;qcrao)</span><br><span class="line">	fmt.Println(qcrao)</span><br><span class="line"></span><br><span class="line">	stefno := Programmer&#123;age: <span class="number">100</span>&#125;</span><br><span class="line">	whatJob(stefno)</span><br><span class="line"></span><br><span class="line">	growUp(stefno)</span><br><span class="line">	fmt.Println(stefno)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">whatJob</span><span class="params">(p Person)</span></span> &#123;</span><br><span class="line">	p.job()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growUp</span><span class="params">(p Person)</span></span> &#123;</span><br><span class="line">	p.growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">	job()</span><br><span class="line">	growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Student)</span> <span class="title">job</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"I am a student."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Student)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.age += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Programmer)</span> <span class="title">job</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"I am a programmer."</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Programmer)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 程序员老得太快 ^_^</span></span><br><span class="line">	p.age += <span class="number">10</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里先定义了 1 个 <code>Person</code> 接口，包含两个函数：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">job()</span><br><span class="line">growUp()</span><br></pre></td></tr></table></figure>
<p>然后，又定义了 2 个结构体，<code>Student</code> 和 <code>Programmer</code>，同时，类型 <code>*Student</code>、<code>Programmer</code> 实现了 <code>Person</code> 接口定义的两个函数。注意，<code>*Student</code> 类型实现了接口， <code>Student</code> 类型却没有。</p>
<p>之后，我又定义了函数参数是 <code>Person</code> 接口的两个函数：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">whatJob</span><span class="params">(p Person)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growUp</span><span class="params">(p Person)</span></span></span><br></pre></td></tr></table></figure>
<p><code>main</code> 函数里先生成 <code>Student</code> 和 <code>Programmer</code> 的对象，再将它们分别传入到函数 <code>whatJob</code> 和 <code>growUp</code>。函数中，直接调用接口函数，实际执行的时候是看最终传入的实体类型是什么，调用的是实体类型实现的函数。于是，不同对象针对同一消息就有多种表现，<code>多态</code>就实现了。</p>
<p>更深入一点来说的话，在函数 <code>whatJob()</code> 或者 <code>growUp()</code> 内部，接口 <code>person</code> 绑定了实体类型 <code>*Student</code> 或者 <code>Programmer</code>。根据前面分析的 <code>iface</code> 源码，这里会直接调用 <code>fun</code> 里保存的函数，类似于： <code>s.tab-&gt;fun[0]</code>，而因为 <code>fun</code> 数组里保存的是实体类型实现的函数，所以当函数传入不同的实体类型时，调用的实际上是不同的函数实现，从而实现多态。</p>
<p>运行一下代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">I am a student.</span><br><span class="line">&#123;19&#125;</span><br><span class="line">I am a programmer.</span><br><span class="line">&#123;100&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【各种面向对象的名词】<a href="https://cyent.github.io/golang/other/oo/" target="_blank" rel="noopener">https://cyent.github.io/golang/other/oo/</a></p>
<p>【多态与鸭子类型】<a href="https://www.jb51.net/article/116025.htm" target="_blank" rel="noopener">https://www.jb51.net/article/116025.htm</a></p>
]]></content>
      <categories>
        <category>Go interface</category>
      </categories>
      <tags>
        <tag>go interface</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言条件编译</title>
    <url>/2019/12/27/c_%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>要开发一个C语言程序，让它输出红色的文字，并且要求跨平台，在 Windows 和 Linux 下都能运行，怎么办呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> _WIN32</span></span><br><span class="line">        system(<span class="string">"color 0c"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"xxxxtest1\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">elif</span> __linux__</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\033[22;31mxxxtest2m"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"xxxxtest3n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#if、#elif、#else 和 #endif 都是预处理命令，整段代码的意思是：如果宏 <em>WIN32 的值为真，就保留第 4、5  行代码，删除第 7、9 行代码；如果宏 <em>_linux</em></em> 的值为真，就保留第 7 行代码；如果所有的宏都为假，就保留第 9 行代码。</p>
<p> <strong>这些操作都是在预处理阶段完成的，多余的代码以及所有的宏都不会参与编译，不仅保证了代码的正确性，还减小了编译后文件的体积。</strong></p>
<p> 这种能够<strong>根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。条件编译是预处理程序的功能，不是编译器的功能。</strong></p>
<h4 id="if用法"><a href="#if用法" class="headerlink" title="#if用法"></a>#if用法</h4><p>#if 用法的一般格式为：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">if</span> 整型常量表达式1</span></span><br><span class="line">  程序段<span class="number">1</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">elif</span> 整型常量表达式2</span></span><br><span class="line">  程序段<span class="number">2</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">elif</span> 整型常量表达式3</span></span><br><span class="line">  程序段<span class="number">3</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  程序段<span class="number">4</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>它的意思是：如常“表达式1”的值为真（非0），就对“程序段1”进行编译，否则就计算“表达式2”，结果为真的话就对“程序段2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 #else。这一点和 if else 非常类似。</p>
<p>#elif 和 #else 也可以省略，如下所示： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> _WIN32</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is Windows!\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Unknown platform!\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> __linux__</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is Linux!\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ifdef用法"><a href="#ifdef用法" class="headerlink" title="#ifdef用法"></a>#ifdef用法</h4><p>#ifdef 用法的一般格式为： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  宏名</span></span><br><span class="line">    程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>它的意思是，如果当前的宏已被定义过，则对“程序段1”进行编译，否则对“程序段2”进行编译。</p>
<p>也可以省略 #else： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  宏名</span></span><br><span class="line">    程序段</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>VS/VC 有两种编译模式，Debug 和 Release。在学习过程中，我们通常使用 Debug 模式，这样便于程序的调试；而最终发布的程序，要使用 Release 模式，这样编译器会进行很多优化，提高程序运行效率，删除冗余信息。</p>
<p>为了能够清楚地看到当前程序的编译模式，我们不妨在程序中增加提示，请看下面的代码： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"正在使用 Debug 模式编译程序...\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"正在使用 Release 模式编译程序...\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当以 Debug 模式编译程序时，宏 _DEBUG 会被定义，预处器会保留第 5 行代码，删除第 7 行代码。反之会删除第 5 行，保留第 7 行。</p>
<h4 id="ifndef-的用法"><a href="#ifndef-的用法" class="headerlink" title="#ifndef 的用法"></a>#ifndef 的用法</h4><p>#ifndef 用法的一般格式为： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> 宏名</span></span><br><span class="line">    程序段<span class="number">1</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">    程序段<span class="number">2</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>与 #ifdef 相比，仅仅是将 #ifdef 改为了 #ifndef。它的意思是，如果当前的宏未被定义，则对“程序段1”进行编译，否则对“程序段2”进行编译，这与 #ifdef 的功能正好相反。</p>
<h4 id="区别与注意"><a href="#区别与注意" class="headerlink" title="区别与注意"></a>区别与注意</h4><p>#if 后面跟的是“整型常量表达式”，而 #ifdef 和 #ifndef 后面跟的只能是一个宏名，不能是其他的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> NUM == 10 || NUM == 20</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NUM: %d\n"</span>, NUM);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NUM Error\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再如，两个宏都存在时编译代码A，否则编译代码B： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM1 10</span></span><br><span class="line"><span class="comment">// #define NUM2 20</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> (defined NUM1 &amp;&amp; defined NUM2)</span></span><br><span class="line">        <span class="comment">//代码A</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NUM1: %d, NUM2: %d\n"</span>, NUM1, NUM2);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">//代码B</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ifdef-可以认为是-if-defined-的缩写"><a href="#ifdef-可以认为是-if-defined-的缩写" class="headerlink" title="ifdef 可以认为是 #if defined 的缩写"></a>ifdef 可以认为是 #if defined 的缩写</h1>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C语言条件编译</tag>
      </tags>
  </entry>
  <entry>
    <title>linux环境变量设置</title>
    <url>/2019/12/26/linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="Ubuntu环境变量的添加和删除"><a href="#Ubuntu环境变量的添加和删除" class="headerlink" title="Ubuntu环境变量的添加和删除"></a>Ubuntu环境变量的添加和删除</h3><h4 id="添加环境变量的位置"><a href="#添加环境变量的位置" class="headerlink" title="添加环境变量的位置"></a>添加环境变量的位置</h4><ul>
<li>/etc/profile 该文件为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行，并从/etc/profile.d目录的配置文件中搜集shell的设置。</li>
<li>/etc/environment 登录操作系统使用的第二个文件，系统在读取自己的profile之前，设置环境文件的环境变量</li>
<li>/etc/bashrc 为每一个运行bash shell的用户执行该文件。当bash shell被打开时，该文件被读取</li>
<li>~/.profile 每个用户都可以使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次。默认情况下设置一些环境变量，执行用户的.bashrc文件</li>
<li>~/.bashrc 该文件包含专用的bash shell的bash信息，当登录以及每次打开新的shell时，该文件被读取。</li>
</ul>
<h4 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h4><ul>
<li>方法一：直接修改/etc/enviroment文件，这种方法的作用域是<strong>全局的，永久性</strong>的。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打开/etc/environment文件，其内容如下：</span></span><br><span class="line">PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games" </span><br><span class="line"><span class="meta">#</span><span class="bash">在环境变量PATH中添加你要添加的路径即可。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：修改/etc/profile文件，这种方法的作用域是<strong>全局的，永久性</strong>的。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">这个文件不是保存环境变量信息的文件，在登录时，系统只是根据它的内容对环境变量进行设置。</span></span><br><span class="line">export PATH=$PATH:[your path1]:[your path2]:[...]  </span><br><span class="line">export PATH=[your path1]:[your path2]:[...]:$PATH #其中，各个PATH之间用冒号分隔，$PATH指代添加your path前的环境变量。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法三：修改/etc/bashrc或者~/.bashrc文件，这两个文件<strong>不是为了保存环境变量，只是在使用bash shell时进行设置而已，所以设置方法和二中一样。对于/etc/bashrc文件，修改的作用于所有用户，但对于~/.bashrc文件，修改的仅仅作用于当前用户。这种修改的作用也是永久性的。</strong></p>
</li>
<li><p>方法四：<strong>修改~/.profile文件，作用仅限于当前用户，但同样也是永久性的。这种方法和修改/etc/profile本质上是一样的，这种之不过是仅仅修改了当前用户自己的配置文件。所以作用仅限于当前用户，但同样也是永久性的。</strong></p>
</li>
<li><p>方法五：在Terminal中使用shell命令，只在当前Terminal中起作用，关闭了当前Terminal就无效了。对其他Terminal也无效</p>
</li>
</ul>
<h4 id="显示环境变量"><a href="#显示环境变量" class="headerlink" title="显示环境变量"></a>显示环境变量</h4><ul>
<li>显示所有环境变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env #打印所有的环境变量</span><br></pre></td></tr></table></figure>
<ul>
<li>显示指定环境变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $PATH #打印PATH环境变量</span><br></pre></td></tr></table></figure>
<h4 id="让修改生效"><a href="#让修改生效" class="headerlink" title="让修改生效"></a>让修改生效</h4><p>使用source命令也可以让修改立即生效。使用方法为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source [file name]  # file name 指的是上面修改过的文件的file name</span><br></pre></td></tr></table></figure>
<h4 id="删除对环境变量的修改"><a href="#删除对环境变量的修改" class="headerlink" title="删除对环境变量的修改"></a>删除对环境变量的修改</h4><p>将以上方法中对配置文件的修改还原回去即可。另外，由于第五种方法由于是临时性质的且局部的，只需要关闭这个Terminal就好了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>linux相关操作笔记</title>
    <url>/2019/12/26/linux%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>linux只是操作系统的内核。</p>
<ul>
<li><p>Redhat系列：企业版：redhat，centos</p>
</li>
<li><p>Debian系列：debian，ubuntu</p>
</li>
</ul>
<p>Ubuntu:</p>
<ul>
<li>命名规则：前两位数字：发行时的年份的最后两位数字，</li>
<li>后两位：发行的月份，04表示4月份发行的稳定版;10表示10月份发行的测试版。</li>
</ul>
<p>版本：</p>
<ul>
<li>桌面版：至少三年的技术支持</li>
<li><p>服务器版：至少五年的技术支持</p>
</li>
<li><p>发布频率：一年两次</p>
<ul>
<li>单数年，段期支持</li>
<li>双数年，长期支持，LTS</li>
</ul>
</li>
</ul>
<h2 id="Linux快捷键"><a href="#Linux快捷键" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h2><h3 id="命令解析器"><a href="#命令解析器" class="headerlink" title="命令解析器"></a>命令解析器</h3><p>shell — unix操作系统</p>
<p>bash — linux操作系统 Bone重新写了shell</p>
<p>本质：<strong>根据命令的名字，调用对应的可执行程序，命令解析器调用</strong></p>
<h3 id="Linux快捷键-1"><a href="#Linux快捷键-1" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h3><p>ctrl  + p  历史命令向上</p>
<p>ctrl + n 历史命令向下</p>
<p>ctrl + b 命令光标向前</p>
<p>ctrl + f 命令光标向后</p>
<p>ctrl + a 光标到行首</p>
<p>ctrl + e 行尾部</p>
<p>字符删除：</p>
<p>删除前面的：ctrl + h</p>
<p>删除后面的：ctrl + d</p>
<p>删除一部分：</p>
<p>前面： crtl + u</p>
<p>Tab键智能提示，自动补充命令，路径</p>
<h3 id="Linux下的目录结构"><a href="#Linux下的目录结构" class="headerlink" title="Linux下的目录结构"></a>Linux下的目录结构</h3><p>/ 根目录 ls /</p>
<p>/bin  Binary 缩写，<strong>该目录存放经常使用的命令</strong>。自动配置了环境变量，执行过程自动加载目录</p>
<p>/boot <strong>存放开机启动项文件</strong>，包括一些连接文件以及镜像文件</p>
<p>/dev Device的缩写，该目录下存放Linux的外部设备，在Linux中访问设备的方式和访问文件相同。</p>
<p>/etc <strong>存放所有系统管理所需要的配置文件和子目录</strong>。</p>
<p>/home <strong>用户的主目录，在linux中，每个用户都有一个自己的目录，一般该目录名是以用户的帐号命名的。</strong></p>
<p>/lib <strong>该目录存放系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件，几乎所有的应用程序都需要这些共享库。</strong></p>
<p>/lost+found 一般情况下都是空，当系统非法关机后，这里存放一些文件碎片。</p>
<p>/media linux系统自动识别一些设备，例如U盘，光驱等。<strong>当识别后，linux会将识别的设备挂载到这个目录。</strong></p>
<p>/mnt <strong>为了让用户临时挂载别的文件系统，可以将光驱挂载在/mnt上</strong>，然后进入该目录就可以查看光驱里的内容。</p>
<p>/opt 给主机额外安装软件所摆放的目录</p>
<p>/root <strong>系统管理员，也称为超级权限者的用户主目录</strong></p>
<p><strong>/sbin S为Super User的意思，存放的是系统管理者使用的系统管理程序。</strong></p>
<p>/usr <strong>user software resource，用户的很多应用程序和文件都在这个目录下，类似windows下的program files目录</strong></p>
<p>/var 存放不断扩充的东西，习惯将经常修改的目录放在这个目录下，包括各种日志文件</p>
<h3 id="用户目录"><a href="#用户目录" class="headerlink" title="用户目录"></a>用户目录</h3><p>绝对路径:  知道如何写，从根目录开始写</p>
<p>相对路径： </p>
<ul>
<li>. 当前目录</li>
<li>.. 上一级目录</li>
<li>- 邻近的两个目录间切换</li>
</ul>
<p>dongshifu@dong:~$</p>
<ul>
<li>dongshifu:当前登录的用户</li>
<li>@ 在 dong这台主机下</li>
<li>~:用户的家目录（宿主目录）</li>
<li>$: 当前用户的普通用户。若为# 则表示超级用户</li>
</ul>
<h3 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h3><p>查看目录：</p>
<ul>
<li>tree ，一般情况下文件和目录的颜色。白色，红色，绿色，蓝色，黄色</li>
<li>ls</li>
</ul>
<p>目录切换</p>
<ul>
<li>cd +目录</li>
<li>pwd 查看当前位置</li>
</ul>
<p>创建目录</p>
<ul>
<li>mkdir dirname</li>
<li>创建复合目录（多级目录） mkdir -p </li>
</ul>
<p>删除目录</p>
<ul>
<li>rmdir 删除空目录</li>
<li>rm -rf (r表示递归，-i会提示)  -f 强制删除</li>
</ul>
<p>在目录中创建文件</p>
<ul>
<li>touch 若文件不存在，创建文件，若文件存在，修改文件的时间</li>
</ul>
<p>文件的拷贝</p>
<ul>
<li>cp eg. cp hello.c tmp（文件不存在则创建文件，文件存在则覆盖文件）</li>
</ul>
<p><strong>目录的拷贝</strong></p>
<ul>
<li><strong>cp 要拷贝目录  newdir -r</strong></li>
</ul>
<p>查看文件具体信息</p>
<ul>
<li>ls -al</li>
<li>cat 文件名 适合内容少的文件</li>
<li>more 空格翻页，q退出</li>
<li>less </li>
<li>head 文件的前多少行 - number</li>
<li>tail 文件的后多少行</li>
</ul>
<p>mv命令</p>
<ul>
<li>mv</li>
<li>移动文件 mv</li>
</ul>
<p>软链接相当于快捷方式</p>
<ul>
<li>创建软链接，源文件要使用绝对路径</li>
<li>软链接大小：源文件+路径的总字节数</li>
<li>目录可以创建软链接</li>
</ul>
<p>eg. ln -s /home/a.txt（源文件名+绝对路径） a.test(软链接的名字)</p>
<p>硬链接：映射到inode，不占用磁盘空间。 ln hello.c hello.hard</p>
<ul>
<li>以文件副本的形式存在。但不占用实际空间</li>
<li>不允许给目录创建硬链接</li>
<li>硬链接只有在同一个文件系统中才能创建</li>
</ul>
<p>硬链接能够同步更新：</p>
<ul>
<li>linux下每一个文件都对应一个Inode，创建硬链接后，两个文件的Inode是相同的</li>
<li>查看文件的Inode: stat a.txt</li>
<li>文件创建硬链接后，硬链接计数+1, 删除一个硬链接，硬链接计数-1</li>
</ul>
<p><strong>linux文件系统的存储单位是块。inode — i结点(相当于索引)，保存了一些文件信息，通过inode找到对应的文件。硬链接映射的都是文件的inode（可以理解为某一个位置）。</strong></p>
<p>软链接需要指定绝对地址。</p>
<h4 id="文件或目录属性"><a href="#文件或目录属性" class="headerlink" title="文件或目录属性"></a>文件或目录属性</h4><ul>
<li>wc 获取<strong>文本文件</strong>的基本信息（行数，单词个数[空格区分]，字节数，文件名）</li>
<li>od -t （指定数据的显示格式） 二进制文件查看 </li>
<li>du 查看当前目录的大小 du -h (human)</li>
<li>df 磁盘的使用情况 df -h</li>
</ul>
<p>which  命令：查看使用的命令（只能查看外部的命令，内建命令难以查询）所在的目录</p>
<h4 id="文件权限，用户，用户组"><a href="#文件权限，用户，用户组" class="headerlink" title="文件权限，用户，用户组"></a>文件权限，用户，用户组</h4><p>查看当前登录的用户： whoami</p>
<p>修改文件权限：</p>
<ul>
<li>文字设定法：chmod [who] [+]-[=] [mode]<ul>
<li>who: 文件所有者 u, 文件所属组：g, 其他人: o， 所有的人：a</li>
<li>+/ 增加权限 - 减少权限， = 覆盖原来的权限</li>
<li>mode ： r读，w写，x执行</li>
<li>eg： chmod o+w temp</li>
<li>chmod a=w temp</li>
</ul>
</li>
<li>数字设定法<ul>
<li>- 表示没有</li>
<li>r  4</li>
<li>w 2</li>
<li>x 1</li>
<li>765 —-rwx—-文件所有者 —-rw—-文件所属组 —-r-x—-其他人</li>
<li>chmod -001 </li>
</ul>
</li>
</ul>
<h4 id="修改文件所有者和所属组"><a href="#修改文件所有者和所属组" class="headerlink" title="修改文件所有者和所属组"></a>修改文件所有者和所属组</h4><p>chown 用户名 文件/目录名</p>
<p>chown 所有者:所属组 文件/目录名</p>
<p>chgrp ABC temp 修改temp所属组为ABC</p>
<h4 id="目录必须有的权限"><a href="#目录必须有的权限" class="headerlink" title="目录必须有的权限"></a>目录必须有的权限</h4><p>必须有执行权限，否则无法进入</p>
<p>chmod a-x mytest # mytest的用户、组以及其他用户都减执行权限</p>
<h4 id="文件的查找"><a href="#文件的查找" class="headerlink" title="文件的查找"></a>文件的查找</h4><p>查找某个目录下是否有某个文件：</p>
<p>按文件属性查找：</p>
<ul>
<li>按照文件名字查找： find + 查找的目录 + -name  +“文件的名字”</li>
<li>按照文件大小查找： find  + 查找的目录 + -size  + 大小(+表示大小， -表示小于)。 find /home -size +10K -size -100M</li>
<li>按照文件类型查找：find + 查找目录 + -type +d/f/c/s/p/l</li>
</ul>
<p>按文件内容查找：</p>
<ul>
<li>grep -r(递归查找) “查找的内容” + 查找的路径</li>
</ul>
<p>通配符： * 所有， ？一个字符</p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p><img src="./figure/install.png" alt=""></p>
<p>软件列表：存放软件的名字和下载地址</p>
<h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>磁盘设备种类：</p>
<ul>
<li>sd :SCSI Device</li>
<li>hd : Hard Disk硬盘</li>
<li>fd : Floppy Disk 软盘</li>
</ul>
<p>硬盘1:sda </p>
<ul>
<li>主分区：最多有四个<ul>
<li>主分区1：sda1</li>
<li>主分区2:  sda2</li>
<li>主分区3:  sda3</li>
<li>主分区4: sda4</li>
</ul>
</li>
<li>扩展分区：第一个逻辑分区从sda5开始：<ul>
<li>逻辑分区1:sda5</li>
<li>逻辑分区2: sda6</li>
</ul>
</li>
</ul>
<p>mount 命令会临时覆盖挂载目录，umount后则恢复。</p>
<h4 id="压缩包管理"><a href="#压缩包管理" class="headerlink" title="压缩包管理"></a>压缩包管理</h4><p>扩展版：</p>
<ul>
<li>gzip：.gz格式的压缩包<ul>
<li>不会保留原文件，默认不会打包压缩</li>
<li>gunzip 解压</li>
<li>不能压缩目录</li>
</ul>
</li>
<li>bzip: .bz2格式的压缩包<ul>
<li>不会保留原文件，默认不会打包压缩  -k选项可以保留原文件</li>
<li>bunzip 解压</li>
<li>不能压缩目录</li>
</ul>
</li>
</ul>
<p>好用版：</p>
<ul>
<li>tar<ul>
<li>参数<ul>
<li>c —创建：压缩</li>
<li>x —解压缩，释放</li>
<li>v — 显示提示信息</li>
<li>f —指定压缩文件的名字</li>
<li>z —使用gzip的方式压缩文件， 后缀为.gz</li>
<li>j —使用bzip2的方式压缩文件， —bz2</li>
</ul>
</li>
<li>压缩<ul>
<li>tar zcvf 生成压缩包的名字(xxx.tar.gz)  要压缩的文件或目录</li>
<li>tar jcvf 生成压缩包的名字(xxx.tar.bz2) 要压缩的文件或目录</li>
</ul>
</li>
<li>解压缩<ul>
<li>tar jxvf 压缩包的名字(解压到当前目录)</li>
<li>-C 指定解压目录</li>
</ul>
</li>
</ul>
</li>
<li>rar<ul>
<li>参数<ul>
<li>压缩： a</li>
<li>解压缩 : x</li>
</ul>
</li>
<li>压缩<ul>
<li>rar a 生成文件 要压缩的文件</li>
</ul>
</li>
<li>解压缩<ul>
<li>rar x 要解压的文件 解压目录</li>
</ul>
</li>
</ul>
</li>
<li>zip<ul>
<li>参数</li>
<li>压缩<ul>
<li>zip 要生成压缩包名字 压缩的文件或目录</li>
</ul>
</li>
<li>解压缩<ul>
<li>unzip 压缩包的名字</li>
<li>unzip 压缩包的名字 -d 目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="PS命令使用"><a href="#PS命令使用" class="headerlink" title="PS命令使用"></a>PS命令使用</h4><p>who 命令：查看当前终端登录情况</p>
<p>ps a :查看当前操作系统所有用户</p>
<p>ps au:  查看用户的信息</p>
<p>ps aux: 查看没有终端的应用程序(不能与用户进行交互的进程[输入、输出])，TTY为?的进程</p>
<p><strong>管道 |：指令1 | 指令2 ：指令1的输出作为指令2的输入，指令2处理完毕，将信息输出到屏幕</strong></p>
<h4 id="env和top"><a href="#env和top" class="headerlink" title="env和top"></a>env和top</h4><p>Linux下的环境变量的格式: key - value</p>
<p>key=value:value:value</p>
<h4 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h4><p>ifconfig /ipconfig</p>
<p>nslookup :查看域名对应的ip</p>
<h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p>创建用户:</p>
<ul>
<li>sudo adduser +用户名  </li>
<li>sudo useradd -s /bin/bash -g shifudong -d /home/shifudong -m shifudong <ul>
<li>-s 指定新用户登录时shell类型</li>
<li>-g 指定所属组，该组必须已经存在</li>
<li>-d 用户家目录</li>
<li>-m 用户家目录不存在时，自动创建该目录</li>
</ul>
</li>
</ul>
<p>设置用户组：</p>
<ul>
<li>sudo groupadd itcast</li>
</ul>
<p>切换用户：</p>
<ul>
<li>su + 用户名</li>
</ul>
<p>修改密码：</p>
<ul>
<li>sudo passwd +用户名</li>
</ul>
<p>删除用户：</p>
<ul>
<li>sudo deluser + 用户名</li>
<li>sudo userdel -r itcast （选项-r是把用户的主目录也一起删除）</li>
</ul>
<h4 id="ftp服务器：vsftp"><a href="#ftp服务器：vsftp" class="headerlink" title="ftp服务器：vsftp"></a>ftp服务器：vsftp</h4><p>作用：负责文件的上传和下载</p>
<p>put/get file</p>
<p>不允许操作目录，如果想操作目录，打包</p>
<p>lftp：客户端工具</p>
<h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><p>使用格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r 目标用户名@目标主机IP地址:/目标文件的绝对路径 /保存到本机的绝对（相对）路径</span><br></pre></td></tr></table></figure>
<p>拷贝目录需要加参数 -r</p>
<h4 id="man-和echo"><a href="#man-和echo" class="headerlink" title="man 和echo"></a>man 和echo</h4><p>alias 查看命令是否被封装（设置或查看别名）</p>
<ul>
<li>查看 alias</li>
<li>设置: alias pag=’ps aux | grep’（需要长久有效需要设置配置文件: .bashrc）</li>
</ul>
<h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><p>工作模式</p>
<ul>
<li><p>命令模式：打开文件之后，默认进入命令模式</p>
<ul>
<li>光标的移动：H J K L（前，下，上，后），0到行首，$到行尾。gg到文件首，G到文件尾部，500G到第五百行</li>
</ul>
</li>
<li>删除操作：X删除光标前面的，x删除光标后面的，dw删除一个单词，u撤回删除操作，d0删除当前词行之前的， d$删除后面的。D删除光标后面的。dd删除一行 。5D删除(剪切)5行=5dd<ul>
<li>粘贴：p不换行，P换行</li>
</ul>
</li>
<li><p>复制：yy复制行，<strong>可视模式下y复制，d删除</strong></p>
<ul>
<li><p>查找：</p>
<ul>
<li><p>/stdio:从光标位置，向下，最下边之后返回到头部。</p>
</li>
<li><p>?stdio:从光标位置，向上查找，顶部之后，返回到尾部。</p>
</li>
</ul>
</li>
<li>找到相应的要查找字符串，按#键盘可查找<ul>
<li>缩进：&lt;&lt;, &gt;&gt;</li>
</ul>
</li>
<li>shift+k进入man文档， 3+shift+k进入man 文档第三章</li>
</ul>
</li>
<li><p>编辑模式</p>
</li>
<li><p>末行模式：在末行模式下可以输入一些指令</p>
</li>
</ul>
<p>可视模式：命令模式下 v进入</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="C库函数"><a href="#C库函数" class="headerlink" title="C库函数"></a>C库函数</h3><p>fopen, fclose, fread, fwrite, fgets,fputs, fscanf,fprintf,fseek, fgetc, fputc, ftell, feof, flush…</p>
<p>硬盘为什么慢：大部分硬盘都是机械硬盘，读取寻道时间和写入寻道时间都是毫秒级。内存是纳秒级别。</p>
<p>通过文件描述符可以索引到文件对应的磁盘文件。</p>
<p>文件读写指针位置：读写文件过程中指针的实际位置。</p>
<p>I/O缓冲区（内存地址）：通过寻址找到对应的内存块。</p>
<p>为什么需要I/O缓冲区：减少对硬盘的访问，读的放到缓冲区，当缓冲区满之后再放入到硬盘中。</p>
<p>把缓存中的数据存到硬盘上：</p>
<ul>
<li>刷新缓冲区：fflush</li>
<li>缓冲区已满</li>
<li>正常关闭文件<ul>
<li>fclose</li>
<li>return（main函数）</li>
<li>exit（main函数）</li>
</ul>
</li>
</ul>
<p>对于32位系统，linux为每一个运行的程序（进程）分配一个0-4G的地址空间（虚拟地址空间）</p>
<p>内核空间：受保护，用户不能对该空间进行读写操作，否则会出现段错误。</p>
<p>linux内核中有PCB进程控制块：文件描述符表(数组)：存储文件描述符，每打开一个新文件则占用一个文件描述符，而且使用的是空闲的最小的一个文件描述符。默认文件描述符的0,1,2是打开的，分别对应：标准输入(STDIN_FILENO)，标准输出(STDOUT_FILENO，标准错误。</p>
<p>用户空间：</p>
<p>linux下可执行文件格式：ELF</p>
<ul>
<li>ELF区中包含的区域：.bss(未初始化全局变量)，.data(已初始化全局变量)，.txt(代码段，二进制机器指令)，其他的只读数据段，符号段等</li>
<li>受保护的地址(0-4K)， 例如：#define NULL(void *) 0</li>
<li>栈空间（小）：局部变量存储</li>
<li>堆空间（大）：用户申请内存</li>
<li>共享库：动态库，生成与位置无关的代码，相对地址</li>
<li>命令行参数</li>
<li>环境变量(env)</li>
</ul>
<p>cpu为什么需要使用虚拟地址空间与物理地址空间映射？</p>
<ul>
<li>方便编译器和操作系统安排程序的地址分离：程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区</li>
<li>方便进程之间的隔离：不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程使用的物理内存</li>
<li>方便OS使用较少的内存。程序可以使用一序列虚拟地址来访问大于可用物理内存的内容缓冲区。当物理内存供应量变小时。内存管理器会将物理内存页（通常为4KB)保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘间移动。</li>
</ul>
<h3 id="C库函数与系统函数的关系"><a href="#C库函数与系统函数的关系" class="headerlink" title="C库函数与系统函数的关系"></a>C库函数与系统函数的关系</h3><p>linux<strong>系统的API分为三层：应用层，系统调用，内核层。层层调用。</strong></p>
<p>man 2 + 函数可以查找系统调用的帮助手册</p>
<h4 id="open函数："><a href="#open函数：" class="headerlink" title="open函数："></a>open函数：</h4><p>打开方式：</p>
<p>​    必选项：</p>
<p>​        O_RDONLY</p>
<p>​        O_WRONLY</p>
<p>​        O_EDWR</p>
<p>​    可选项：</p>
<p>​        O_CREATE 文件权限：本地有一个掩码（unmask可以显示,也可以修改: unmask 0002），</p>
<p>​        文件的实际权限：给定的权限 与本地掩码取反进行按位&amp;操作 111111111&amp; 111111101 得到775</p>
<p>​        O_EXCL</p>
<p>​        O_TRUNC  文件截断为0，类似清空</p>
<p>​        O_APPEND                </p>
<p>直接看man 2 open</p>
<p>errno: 文件出错的时候的返回值，定义在errno.h中的全局变量，错误宏定义位置</p>
<p>void perror(const char  *s)，头文件 stdio.h.用来将上一个函数发生错误的原因输出到标准设备(stderr) 。参数s所指的字符串会先打印，后面再加上错误原因字符串。此错误原因依照全局变量errno的值来决定要输出的字符串。</p>
<p><strong>shift +k + 数字可以跳转到对应的帮助文档</strong></p>
<h4 id="read-write-lseek"><a href="#read-write-lseek" class="headerlink" title="read,write,lseek"></a>read,write,lseek</h4><p>read(int fd, void *buf, size_t count);</p>
<p>返回值：</p>
<p>​    -1 读文件失败</p>
<p>​    0 文件读完</p>
<p>​    >0 读取的字节数</p>
<p>write(int fd, const void *buf, size_t count);</p>
<p>off_t lseek(int fd, off_t offset, int whence); //移动文件指针，获取文件的长度</p>
<h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><p>gdb 命令</p>
<ol>
<li><p>前提条件，可执行文件必须包含调试信息 gcc -g</p>
</li>
<li><p>gdb + 文件名 启动dgb调试</p>
</li>
<li>查看代码的命令<ol>
<li>当前文件： list +行号（或函数的名字）</li>
<li>指定文件：文件名:行号（函数名）</li>
</ol>
</li>
<li>设置断点<ol>
<li>当前文件： b + 行号（函数名）</li>
<li>指定文件: b+ 行号（函数名）</li>
<li>设置条件断点： b + 行号 if value == 3</li>
<li>查看断点信息： info</li>
<li>删除断点： d + 断点编号</li>
</ol>
</li>
<li>开始调试<ol>
<li>只执行一行代码： start ,继续执行停在断点处：continue — c</li>
<li>直接停在断点处：run — r</li>
</ol>
</li>
<li>单步调试<ol>
<li>进入到函数体： step — s<ol>
<li>跳出函数体： finish(如果在循环处有断点，需要删除断点)</li>
</ol>
</li>
<li>不进入函数体： next — n</li>
</ol>
</li>
<li>追踪变量<ol>
<li>自动打印变量的值：display 变量名</li>
<li>取消变量的追踪： undisplay 编号<ol>
<li>获取编号： info display</li>
</ol>
</li>
<li>手动打印变量的值： print - p</li>
<li>获取变量对应的类型: ptype</li>
</ol>
</li>
<li>跳出当前循环： u</li>
<li>退出gdb :quit</li>
</ol>
<p>Makefile</p>
<ol>
<li><p>一个规则</p>
<ol>
<li><p>三要素：目标，依赖，命令</p>
<p>目标: 依赖</p>
<p>​    命令</p>
</li>
<li><p>第一条规则是用来生成终极目标的规则</p>
<ol>
<li>如果规则中的依赖不存在，向下查找其他的规则</li>
<li>更新机制：比较的是目标文件和依赖文件的时间</li>
</ol>
</li>
</ol>
</li>
<li><p>两个函数</p>
<ol>
<li>查找指定目录下，知道类型的文件 src = $(vildcard ~/aa/*.c)取到所有的.c文件名</li>
<li>匹配替换函数 obj = $(partsubs %.c %.o $(src))  obj得到所有.o文件</li>
</ol>
</li>
<li><p>三个自动变量</p>
<ol>
<li>$&lt; 规则中的第一个依赖</li>
<li>$” 规则中的所有依赖</li>
<li>$@ 规则中的目标</li>
<li>三个自动变量只能在规则命令中使用</li>
</ol>
</li>
<li><p>模式规则</p>
<ol>
<li>%.o:%.c    gcc -c $&lt; -o $@</li>
</ol>
</li>
</ol>
<p>Linux 系统IO函数</p>
<ol>
<li><p>文件描述符</p>
<ol>
<li>int 类型</li>
<li>一个进程最多可以打开1024个文件</li>
</ol>
</li>
<li><p>PCB ：进程控制块</p>
<ol>
<li>在其中有一个文件描述符号表 数组[1024]</li>
</ol>
</li>
<li><p>虚拟地址空间</p>
<ol>
<li>用户区，内核区</li>
<li>代码段</li>
<li>已经初始化的全局变量</li>
<li>未被初始化的全局变量</li>
<li>堆：从下往上增长</li>
<li>共享库</li>
<li>栈：从下往上</li>
<li>环境变量</li>
<li>内核区</li>
</ol>
</li>
<li>读大文件然后写入另外一个文件<ol>
<li>read write 每次读一个byte</li>
<li>getc putc 每次读一个byte 效率更高，标准c库函数内部有一个缓冲区</li>
<li>两种方式，哪个效率高</li>
</ol>
</li>
</ol>
<h4 id="read-write函数读写文件"><a href="#read-write函数读写文件" class="headerlink" title="read write函数读写文件"></a>read write函数读写文件</h4><p>read_write.c</p>
<h4 id="lseek-函数"><a href="#lseek-函数" class="headerlink" title="lseek 函数"></a>lseek 函数</h4><ol>
<li>获取文件大小</li>
<li>移动文件指针</li>
<li>文件拓展</li>
</ol>
<h4 id="Linux文件操作相关函数"><a href="#Linux文件操作相关函数" class="headerlink" title="Linux文件操作相关函数"></a>Linux文件操作相关函数</h4><ol>
<li>stat函数 对应stat命令<ol>
<li>穿透函数 — 相对软链接而言, 操作：vi</li>
</ol>
</li>
<li>lstat函数<ol>
<li>不穿透，不追踪</li>
<li>不追踪链接的操作：ls -al ,rm </li>
</ol>
</li>
<li>access函数：测试文件是否拥有某种权限</li>
<li>chmod函数</li>
<li>chown函数</li>
<li>truncate函数：文化扩展函数<ol>
<li>文件长度为100,第二个参数指定为20,20以后的被覆盖，第二个参数为300,文件拓展。</li>
</ol>
</li>
<li>链接<ol>
<li>link</li>
<li>symlink</li>
<li>readlink</li>
<li>unlink:删除一个文件的目录项并减少对它的链接数。如果是符号链接，删除符号链接。如果是硬连接，硬链接数减1,当减少为0时，释放数据块和inode。如果文件硬链接数为0,但有进程已经打开这个文件，并持有文件的描述符，则等该进程关闭该文件时，kernel才真正删除该文件。利用该特性创建临时文件（例如：缓存文件），先open,create，然后unlink,接着还可以操作文件。</li>
</ol>
</li>
<li>rename</li>
<li>chdir</li>
<li>getcwd</li>
<li>mkdir</li>
<li>rmdir</li>
<li>opendir<ol>
<li>man 3 opendir</li>
</ol>
</li>
<li>readdir</li>
<li>closedir</li>
</ol>
<p>递归获取目录个数：myFileNum.c</p>
<ol>
<li>dup 和dup2<ol>
<li>用于复制文件描述符</li>
<li>dup返回的是文件描述表中没被占用的最小的文件描述符</li>
<li>dup2(old, new)<ol>
<li>old-&gt;new 如果new是一个被打开的文件描述符，在拷贝前先关掉new</li>
<li>old和new是同一个文件描述符，new不会被关掉，直接返回old</li>
</ol>
</li>
</ol>
</li>
<li>fcntl函数：改变已经打开的文件的属性：获得/设置文件描述标记符，获得/设置文件状态标记，获得/设置异步I/O所有权，获得/设置记录锁<ol>
<li>打开文件的时候：只读</li>
<li>要向文件中添加内容，需要修改文件的属性</li>
</ol>
</li>
</ol>
<p>索引结点inode:保存的其实是实际的数据的一些信息，这些信息称为“元数据”（也就是对文件属性的描述）。例如：文件大小，设备标识符，用户组标识符，文件模式，扩展属性，文件读取或修改的时间戳，链接数量，指向存储该内容的磁盘区块的指针，文件分类等。</p>
<p>注意：数据分为：元数据+数据本身</p>
<p>注意inode号：inode号是惟一的，表示不同的文件。其实在linux内部的时候，访问文件都是通过inode号来进行的，所谓文件名仅仅是给用户容易使用的。当我们打开一个文件的时候。首先，系统找到这个文件名对应的inode号;然后通过inode号得到inode信息。最后，又inode找到文件数据所在的block，这样就可以处理文件数据了。</p>
<p>inode和文件的关系：当创建一个文件的时候，就给文件分配了一个inode。一个inode只对应一个实际文件，一个文件也只会有一个inode。inode最大数量就是文件的最大数量。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务管理</title>
    <url>/2019/11/27/linux_server/</url>
    <content><![CDATA[<h2 id="Linux服务管理"><a href="#Linux服务管理" class="headerlink" title="Linux服务管理"></a>Linux服务管理</h2><h3 id="服务分类"><a href="#服务分类" class="headerlink" title="服务分类"></a>服务分类</h3><p>Linux服务</p>
<ul>
<li><p>RPM包默认安装的服务</p>
<p>— 独立的服务</p>
<p>— 基于xinetd服务</p>
</li>
<li><p>源码包安装的服务</p>
</li>
</ul>
<p>启动与自启动</p>
<ul>
<li>服务启动：在当前系统中让服务运行，并提供功能</li>
<li>服务自启动：服务在系统开机或重启之后，随着系统的启动而自动启动服务</li>
</ul>
<p>RPM安装服务和源码安装服务区别就在于安装位置的不同。</p>
<p>service不可以启动RPM安装的软件</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux 服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux shell学习</title>
    <url>/2019/11/27/linux_shell/</url>
    <content><![CDATA[<h3 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><ul>
<li>一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。</li>
<li><p>Shell 既是一种<strong>命令语言</strong>，又是一种<strong>程序设计语言</strong>。</p>
</li>
<li><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，<strong>用户通过这个界面访问操作系统内核的服务</strong>。</p>
</li>
</ul>
<p>真正能够控制计算机硬件（CPU、内存、显示器等）的只有操作系统内核（Kernel），图形界面和<strong>命令行只是架设在用户和内核之间的一座桥梁</strong>。由于安全、复杂、繁琐等原因，用户不能直接接触内核（也没有必要），需要另外再开发一个程序，让用户直接使用这个程序；<strong>该程序的作用就是接收用户的操作（点击图标、输入命令），并进行简单的处理，然后再传递给内核</strong>。如此一来，用户和内核之间就多了一层“代理”，这层“代理”既简化了用户的操作，也保护了内核。用户界面和命令行就是这个另外开发的程序，就是这层“代理”。在Linux下，这个命令行程序叫做 <strong>Shell</strong>。</p>
<h4 id="shell的作用"><a href="#shell的作用" class="headerlink" title="shell的作用"></a>shell的作用</h4><ul>
<li>调用其他程序，给其他程序传递数据或参数，并获取程序的处理结果；</li>
<li>在多个程序之间传递数据，把一个程序的输出作为另一个程序的输入；</li>
<li>Shell 本身也可以被其他程序调用。</li>
</ul>
<p>Shell 本身支持的命令并不多，但是它可以<strong>调用其他的程序</strong>，每个程序就是一个命令，这使得 Shell 命令的数量可以无限扩展，其结果就是  Shell 的功能非常强大，完全能够胜任 Linux  的日常管理工作，如文本或字符串检索、文件的查找或创建、大规模软件的自动部署、更改系统设置、监控服务器性能、发送报警邮件、抓取网页内容、压缩文件等。</p>
<p>Shell 主要用来开发一些实用的、自动化的小工具，而不是用来开发具有复杂业务逻辑的中大型软件，例如检测计算机的硬件参数、一键搭建Web开发环境、日志分析等。</p>
<h4 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h4><p>任何代码最终都要被“翻译”成二进制的形式才能在计算机中执行。</p>
<ul>
<li><p>编译型语言：</p>
<ul>
<li>如 C/C++、Pascal、Go语言、汇编等，必须在程序运行之前将所有代码都翻译成二进制形式，也就是生成可执行文件，用户拿到的是最终生成的可执行文件，看不到源码。</li>
<li>这个过程叫做编译（Compile），这样的编程语言叫做编译型语言，完成编译过程的软件叫做<strong>编译器</strong>（Compiler）。</li>
<li>编译型语言的优点是执行速度快、对硬件要求低、保密性好，适合开发操作系统、大型应用程序、数据库等。</li>
</ul>
</li>
<li><p>解释型语言或者脚本语言（Script）</p>
<ul>
<li>如 Shell、JavaScript、Python、PHP等，需要<strong>一边执行一边翻译，不会生成任何可执行文件，用户必须拿到源码才能运行程序。程序运行后会即时翻译，翻译完一部分执行一部分，不用等到所有代码都翻译完。</strong></li>
<li>这个过程叫做解释，这样的编程语言叫做解释型语言或者脚本语言（Script），完成解释过程的软件叫做<strong>解释器</strong>。</li>
<li>脚本语言的优点是使用灵活、部署容易、跨平台性好，非常适合Web开发以及小工具的制作。</li>
<li>Shell 就是一种脚本语言，我们编写完源码后不用编译，直接运行源码即可。</li>
</ul>
</li>
</ul>
<p>Shell 脚本很适合处理纯文本类型的数据，而 Linux 中几乎所有的配置文件、日志文件（如 NFS、Rsync、Httpd、Nginx、MySQL 等），以及绝大多数的启动文件都是纯文本类型的文件。</p>
<p>Shell 脚本是实现 Linux 系统自动管理以及自动化运维所必备的工具，Linux 的底层以及基础应用软件的核心大都涉及 Shell 脚本的内容。</p>
<p>Shell 脚本的优势在于处理偏操作系统底层的业务，例如，Linux 内部的很多应用（有的是应用的一部分）都是使用 Shell 脚本开发的，因为有 1000 多个 Linux 系统命令为它作支撑。</p>
<h3 id="常见的shell：sh-bash-csh-tcsh-ash"><a href="#常见的shell：sh-bash-csh-tcsh-ash" class="headerlink" title="常见的shell：sh, bash, csh, tcsh, ash"></a>常见的shell：sh, bash, csh, tcsh, ash</h3><p>Linux由多个组织机构开发，<strong>不同的组织机构为了发展自己的 Linux 分支可能会开发出功能类似的软件，它们各有优缺点，用户可以自由选择</strong>。Shell  就是这样的一款软件，不同的组织机构开发了不同的 Shell，它们各有所长，有的占用资源少，有的支持高级编程功能，有的兼容性好，有的重视用户体验。 </p>
<p><strong>Shell 既是一种脚本编程语言，也是一个连接内核和用户的软件。</strong></p>
<p>常见的 Shell 有 sh、bash、csh、tcsh、ash 等。</p>
<h4 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h4><p>sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名。</p>
<p>sh 是 UNIX 上的标准 shell，很多 UNIX 版本都配有 sh。sh 是第一个流行的 Shell。</p>
<h4 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h4><p>sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy (Bill Joy 是一个风云人物，他创立了 BSD 操作系统，开发了 vi 编辑器，还是 Sun 公司的创始人之一)。设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</p>
<p><strong>BSD 是 UNIX 的一个重要分支</strong>，后人在此基础上发展出了很多现代的操作系统，最著名的有 FreeBSD、OpenBSD 和 NetBSD，就连 Mac OS X 在很大程度上也基于BSD。</p>
<h4 id="tcsh"><a href="#tcsh" class="headerlink" title="tcsh"></a>tcsh</h4><p>tcsh 是 csh 的增强版，加入了命令补全功能，提供了更加强大的语法支持。</p>
<h4 id="ash"><a href="#ash" class="headerlink" title="ash"></a>ash</h4><p>一个简单的轻量级的 Shell，<strong>占用资源少，适合运行于低内存环境</strong>，但是与下面讲到的 bash shell 完全兼容。</p>
<h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h4><p><strong>bash shell 是 Linux 的默认 shell</strong>. bash 兼容 sh ：<strong>针对 sh 编写的 Shell 代码可以不加修改地在 bash 中运行</strong>。</p>
<p>bash 和 sh 的一些不同之处： </p>
<ul>
<li>bash 扩展了一些命令和参数；</li>
<li>bash 并不完全和 sh 兼容，它们有些行为并不一致，但在大多数企业运维的情况下区别不大，特殊场景可以使用 bash 代替 sh。</li>
</ul>
<h4 id="shell查看"><a href="#shell查看" class="headerlink" title="shell查看"></a>shell查看</h4><p>Shell 是一个程序，一般都是放在<code>/bin</code>或者<code>/user/bin</code>目录下，当前 Linux 系统可用的 Shell 都记录在<code>/etc/shells</code>文件中。<code>/etc/shells</code>是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令（cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上）查看。</p>
<p>通过 cat 命令来查看当前 Linux 系统的可用 Shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cat /etc/shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/rbash</span><br></pre></td></tr></table></figure>
<p>在现代的 Linux 上，sh 已经被 bash 代替，<code>/bin/sh</code>往往是指向<code>/bin/bash</code>的符号链接。</p>
<p>如果希望查看当前 Linux 的默认 Shell，那么可以输出 SHELL 环境变量： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$SHELL</span></span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<p>输出结果表明默认的 Shell 是 bash。</p>
<p><code>echo</code>是一个 Shell 命令，用来输出变量的值，<code>SHELL</code>是 Linux 系统中的<strong>环境变量</strong>，它<strong>指明了当前使用的 Shell 程序的位置，也就是使用的哪个 Shell。</strong></p>
<h3 id="终端使用shell"><a href="#终端使用shell" class="headerlink" title="终端使用shell"></a>终端使用shell</h3><p>一种进入 Shell 的方法是让 Linux 系统退出图形界面模式，进入控制台模式，这样一来，显示器上只有一个简单的带着白色文字的“黑屏”，就像图形界面出现之前的样子。这种模式称为 Linux 控制台（Console）。</p>
<p>现代 Linux 系统在启动时会自动创建几个虚拟控制台（Virtual Console），其中一个供图形桌面程序使用，其他的保留原生控制台的样子。虚拟控制台其实就是 Linux 系统内存中运行的虚拟终端（Virtual Terminal）。</p>
<p>从图形界面模式进入控制台模式也很简单，往往按下<code>Ctrl + Alt + Fn(n=1,2,3,4,5...)</code>快捷键就能够来回切换。</p>
<p>例如，CentOS 在启动时会创建 6 个虚拟控制台，按下快捷键<code>Ctrl + Alt + Fn(n=2,3,4,5,6)</code>可以从图形界面模式切换到控制台模式，按下<code>Ctrl + Alt + F1</code>可以从控制台模式再切换回图形界面模式。可以发现，1号控制台被图形桌面程序占用了。</p>
<p>Ubuntu中<code>Ctrl + Alt + F7</code>对应图形界面。</p>
<p>输入用户名和密码，登录成功后就可以进入 Shell 了。<code>$</code>是命令提示符，我们可以在它后面输入 Shell 命令。 </p>
<blockquote>
<p> 在图形界面模式下，输入密码时往往会显示为<em>，密码有几个字符就显示几个</em>；而在控制台模式下，输入密码什么都不会显示，好像按键无效一样，但只要输入的密码正确就能够登录。</p>
</blockquote>
<p>图形界面也是一个程序，会占用CPU时间和内存空间，当 Linux 作为服务器系统时，安装调试完毕后，应该让 Linux 运行在控制台模式下，以节省服务器资源。正是由于这个原因，很多服务器甚至不安装图形界面程序，管理员只能使用命令来完成各项操作。</p>
<p>在Ubuntu中也可以用快捷键<code>Ctrl + Alt + t</code>快速启动一个终端。打开终端后即可输入Shell命令。</p>
<h4 id="shell提示符"><a href="#shell提示符" class="headerlink" title="shell提示符"></a>shell提示符</h4><p>启动终端模拟包或者从 Linux 控制台登录后，便可以看到 Shell 提示符。</p>
<p>对于<strong>普通用户</strong>，Base shell 默认的提示符是美元符号<code>$</code>；对于<strong>超级用户</strong>（root 用户），Bash Shell 默认的提示符是井号<code>#</code>（可使用<code>sudo su</code>切换到超级用户）。该符号表示 Shell 等待输入命令。</p>
<p>同的 Linux 发行版使用的提示符格式不同。例如在 Ubuntu中，默认的提示符格式为：<code>dongshifu@dong:~$</code></p>
<p> 这种格式包含了以下三个方面的信息： </p>
<ul>
<li>启动 Shell 的用户名，也即 dongshifu；</li>
<li>本地主机名称，也即dong；</li>
<li>当前目录，波浪号<code>~</code>是主目录的简写表示法。</li>
</ul>
<h4 id="shell脚本编辑与运行"><a href="#shell脚本编辑与运行" class="headerlink" title="shell脚本编辑与运行"></a>shell脚本编辑与运行</h4><p>打开文本编辑器，新建文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意即可。</p>
<p>输入shell代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "Hello World !"</span><br></pre></td></tr></table></figure>
<p>“#!” <strong>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。</strong>echo命令用于向窗口输出文本。</p>
<p>运行shell脚本的方法：</p>
<ul>
<li>作为可执行程序</li>
</ul>
<p>将上面的代码保存为test.sh，并 cd 到相应目录： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure>
<p>注意，<strong>一定要写成./test.sh，而不是test.sh。运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin,  /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</strong></p>
<p> 通过这种方式运行bash脚本，第一行一定要写对，好让shell查找到正确的解释器。</p>
<ul>
<li>作为解释器参数</li>
</ul>
<p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/bash test.sh</span><br></pre></td></tr></table></figure>
<p>这种方式运行的脚本<strong>，不需要在第一行指定解释器信息</strong>，写了也没用。</p>
<p>例子：用read命令从stdin获取输入并赋值给PERSON变量，最后在stdout输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "what is your name?"</span><br><span class="line">read PERSON</span><br><span class="line">echo "Hello, $PERSON"</span><br></pre></td></tr></table></figure>
<h3 id="shell变量：shell变量的定义、删除变量、只读变量、变量类型"><a href="#shell变量：shell变量的定义、删除变量、只读变量、变量类型" class="headerlink" title="shell变量：shell变量的定义、删除变量、只读变量、变量类型"></a>shell变量：shell变量的定义、删除变量、只读变量、变量类型</h3><p>脚本语言在定义变量时通常<strong>不需要指明类型，直接赋值就可以</strong>，Shell 变量也遵循这个规则。</p>
<p>在 Bash shell 中，<strong>每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储</strong>。这意味着，<strong>Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串</strong>，这一点和大部分的编程语言不同。 </p>
<p>如果有必要，你也可以<strong>使用 declare 关键字显式定义变量的类型</strong>，但在一般情况下没有这个需求。</p>
<h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><p>三种定义变量方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">variable=value</span><br><span class="line">variable='value'</span><br><span class="line">variable="value"</span><br></pre></td></tr></table></figure>
<p>variable 是<strong>变量名，value 是赋给变量的值</strong>。如<strong>果 value 不包含任何空白符（例如空格、Tab缩进等），那么可以不使用引号；如果 value 包含了空白符，那么就必须使用引号包围起来</strong>。使用单引号和使用双引号有区别。</p>
<p><strong>注意，赋值号的周围不能有空格</strong></p>
<p>Shell 变量的命名规范和大部分编程语言都一样： </p>
<ul>
<li>变量名由数字、字母、下划线组成；</li>
<li>必须以字母或者下划线开头；</li>
<li>不能使用 Shell 里的关键字（通过 help 命令可以查看保留关键字）。</li>
</ul>
<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p>使用一个定义过的变量，只要在变量名前面加美元符号<code>$</code>即可，如： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">skill="Java"</span><br><span class="line">echo "I am good at $&#123;skill&#125;Script"</span><br></pre></td></tr></table></figure>
<p>变量名外面的花括号<code>{ }</code>是可选的，加不加都行，<strong>加花括号是为了帮助解释器识别变量的边界</strong>，如果不给 skill 变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code>，解释器就会把 $skillScript 当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>
<h4 id="修改变量的值"><a href="#修改变量的值" class="headerlink" title="修改变量的值"></a>修改变量的值</h4><p>已定义的变量，可以被重新赋值，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lang=shell</span><br><span class="line">echo $&#123;lang&#125;</span><br><span class="line">lang=python</span><br><span class="line">echo $&#123;lang&#125;</span><br></pre></td></tr></table></figure>
<p>第二次对变量赋值时不能在变量名前加<script type="math/tex">`，只有在使用变量时才能加`</script>。 </p>
<h4 id="单引号与双引号的区别"><a href="#单引号与双引号的区别" class="headerlink" title="单引号与双引号的区别"></a>单引号与双引号的区别</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">test="you are so cute"</span><br><span class="line">chare='hi,$&#123;test&#125;'</span><br><span class="line">chare2="hi,$&#123;test&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">hi,<span class="variable">$&#123;test&#125;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">hi,you are so cute</span></span><br></pre></td></tr></table></figure>
<p><strong>以单引号<code>&#39; &#39;</code>包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出</strong>。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</p>
<p><strong>以双引号” “包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。</strong>这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</p>
<p>如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。</p>
<h4 id="将命令的结果赋值给变量"><a href="#将命令的结果赋值给变量" class="headerlink" title="将命令的结果赋值给变量"></a>将命令的结果赋值给变量</h4><p>shell支持将命令的执行结果赋值给变量，常见的方式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">variable=`command`</span><br><span class="line">variable=$(command)</span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test=$(ls -al)</span><br><span class="line">echo $test</span><br></pre></td></tr></table></figure>
<h4 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h4><p>使用 <strong>readonly</strong> 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test="you are so cute"</span><br><span class="line">readonly test</span><br><span class="line">test="you"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">bash: <span class="built_in">test</span>: 只读变量</span></span><br></pre></td></tr></table></figure>
<h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>使用 <strong>unset</strong>命令可以删除变量。语法： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unset variable_name</span><br></pre></td></tr></table></figure>
<p> 变量被删除后不能再次使用；unset 命令不能删除只读变量。</p>
<h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p> 运行shell时，会同时存在三种变量：</p>
<h6 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1) 局部变量"></a>1) 局部变量</h6><p>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 </p>
<h6 id="2-环境变量"><a href="#2-环境变量" class="headerlink" title="2) 环境变量"></a>2) 环境变量</h6><p><strong>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</strong> </p>
<h6 id="3-shell变量"><a href="#3-shell变量" class="headerlink" title="3) shell变量"></a>3) shell变量</h6><p>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</p>
<h4 id="shell特殊变量：Shell-0-​-和命令行参数"><a href="#shell特殊变量：Shell-0-​-和命令行参数" class="headerlink" title="shell特殊变量：Shell $0, $#, $​*, $@, $?, $$和命令行参数"></a>shell特殊变量：Shell $0, $#, $​*, $@, $?, $$和命令行参数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td>当前脚本的文件名</td>
</tr>
<tr>
<td>$n</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数。</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或函数的返回值。</td>
</tr>
<tr>
<td>$$</td>
<td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p>运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 $n$ 表示，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo "file name: $0"</span><br><span class="line">echo "First parameter: $1"</span><br><span class="line">echo "Second parameter: $2"</span><br><span class="line">echo "Quoted values: $@"</span><br><span class="line">echo "Quoted values: $*"</span><br><span class="line">echo "Total number of parameters: $#"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行结果</span></span><br><span class="line">./test1.sh shifu dong</span><br><span class="line">file name: ./test1.sh</span><br><span class="line">First parameter: shifu</span><br><span class="line">Second parameter: dong</span><br><span class="line">Quoted values: shifu dong</span><br><span class="line">Quoted values: shifu dong</span><br><span class="line">Total number of parameters: 2</span><br></pre></td></tr></table></figure>
<h4 id="的区别"><a href="#的区别" class="headerlink" title="$* ,$@的区别"></a>$* ,$@的区别</h4><p>$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。</p>
<p>但是当它们被双引号(“ “)包含时，”$*” 会将所有的参数作为一个整体，以”$1 $2 … ​$n”的形式输出所有参数；”​$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "\$*=" $*</span><br><span class="line">echo "\"\$*\"=" "$*"</span><br><span class="line"></span><br><span class="line">echo "\$@=" $@</span><br><span class="line">echo "\"\$@\"=" "$@"</span><br><span class="line"></span><br><span class="line">echo "print each param from \$*"</span><br><span class="line">for var in $*</span><br><span class="line">do </span><br><span class="line">    echo "$var"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "print each parm from \$@"</span><br><span class="line">for var in $@</span><br><span class="line">do </span><br><span class="line">    echo $var</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "print each parm form \"\$*\""</span><br><span class="line">for var in "$*"</span><br><span class="line">do </span><br><span class="line">    echo $var</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "print each parm from \"\$@\""</span><br><span class="line">for var in "$@"</span><br><span class="line">do </span><br><span class="line">    echo $var</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">./test2.sh "A" "B"</span><br><span class="line"><span class="meta">$</span><span class="bash">*= A B</span></span><br><span class="line">"$*"= A B</span><br><span class="line"><span class="meta">$</span><span class="bash">@= A B</span></span><br><span class="line">"$@"= A B</span><br><span class="line">print each param from $*</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">print each parm from $@</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">print each parm form "$*"</span><br><span class="line">A B</span><br><span class="line">print each parm from "$@"</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统管理</title>
    <url>/2019/11/27/linux_system/</url>
    <content><![CDATA[<h2 id="Linux系统管理"><a href="#Linux系统管理" class="headerlink" title="Linux系统管理"></a>Linux系统管理</h2><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h4><p>作用：判断服务器健康状态，查看系统中所有进程，杀死进程</p>
<p>查看系统中所有进程：</p>
<ul>
<li>ps aux :使用系统中所有进程，使用BSD操作系统格式</li>
<li>ps -le 查看系统中所有进程，使用Linux标准命令格式</li>
</ul>
<p>查看系统健康状态：</p>
<ul>
<li>top[选项]</li>
</ul>
<p>查看进程树：</p>
<ul>
<li>pstree</li>
</ul>
<h4 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h4><p>1.kill命令</p>
<p>kill -l 查看可用的进程信号</p>
<p>kill -1 进程id 重启进程</p>
<p>kill -9 进程id 强制杀死进程</p>
<p>2.killall命令</p>
<p>killall -9 进程名</p>
<p>3.pkill </p>
<p>按照终端号踢出用户</p>
<p>w 使用w命令查询本机已经登录的用户</p>
<p>pkill -t -9 pts/1 强制杀死从pts/1虚拟终端登录的进程</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux 系统管理</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo基本操作</title>
    <url>/2019/11/26/hexo-operate/</url>
    <content><![CDATA[<h2 id="hexo-文章管理"><a href="#hexo-文章管理" class="headerlink" title="hexo 文章管理"></a>hexo 文章管理</h2><h3 id="1-增加文章"><a href="#1-增加文章" class="headerlink" title="1.增加文章"></a>1.增加文章</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new xx</span><br></pre></td></tr></table></figure>
<p>创建的文件自动保存在source/_post文件夹下，为MarkDown格式</p>
<p>可以在文件中开头通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标题 # 自动创建，如 hello-world</span><br><span class="line">date: 日期 # 自动创建，如 2019-09-22 01:47:21</span><br><span class="line">tags: </span><br><span class="line">- 标签1</span><br><span class="line">- 标签2</span><br><span class="line">- 标签3</span><br><span class="line">categories:</span><br><span class="line">- 分类1</span><br><span class="line">- 分类2</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>来添加文章的必要信息。</p>
<h3 id="2-标签页添加"><a href="#2-标签页添加" class="headerlink" title="2.标签页添加"></a>2.标签页添加</h3><p>在项目的根目录下执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>执行命令后自动生成一个source/tags/index.md文件，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-09-26 16:44:17</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>可以为其增加type字段指定页面的类型:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: tags</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<p>在使用的主题_config.yml文件将页面的链接加到主菜单中，修改menu字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>
<p>本地服务重启，可以观察到页面状态变化(左侧导航出现标签，点击之后会显示标签的列表)。</p>
<h3 id="3-分类页"><a href="#3-分类页" class="headerlink" title="3.分类页"></a>3.分类页</h3><p>对文章进行归类，一个文章可以对应某个或多个分类，可以通过以下命令创建分类页：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>生成一个/source/categories/index.md文件。</p>
<p>在其中增加type字段来指定页面的类型：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type: categories </span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<p>然后在使用的主题_config.yml文件中将页面链接加入到主菜单中，修改menu字段：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line"><span class="meta">  #</span><span class="bash">about: /about/ || user</span></span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line"><span class="meta">  #</span><span class="bash">schedule: /schedule/ || calendar</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
<h4 id="4-添加搜索页"><a href="#4-添加搜索页" class="headerlink" title="4.添加搜索页"></a>4.添加搜索页</h4><p>需要搜索全站的内容，所以一个搜索功能的支持也是很有必要的，要添加搜索的支持，需要先安装一个插件，叫做 hexo-generator-searchdb，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>然后在<strong>项目</strong>的_config.yml中添加搜索设置如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p>然后在主题的 _config.yml 里面修改如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Local search</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Dependencies: https://github.com/wzpan/hexo-generator-search</span></span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line"><span class="meta">  #</span><span class="bash"> If auto, trigger search by changing input.</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  trigger: auto</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  top_n_per_article: 5</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Unescape html strings to the readable one.</span></span><br><span class="line">  unescape: false</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Preload the search data when the page loads.</span></span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure>
<h3 id="5-404页面添加"><a href="#5-404页面添加" class="headerlink" title="5.404页面添加"></a>5.404页面添加</h3><p>若需要添加一个 404 页面，直接在根目录 source 文件夹新建一个 404.md 文件，内容可以仿照如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 404 Not Found</span><br><span class="line">date: 2019-11-27 10:41:27</span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">&lt;center&gt;</span><br><span class="line">对不起，您所访问的页面不存在或者已删除。</span><br><span class="line">您可以&lt;a href="https://dongshifu.github.io&gt;"&gt;点击此处&lt;/a&gt;返回首页。</span><br><span class="line">或访问&lt;a href="https://blog.csdn.net/dongshifo"&gt;查看更多内容。</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"> </span><br><span class="line">&lt;blockquote class="blockquote-center"&gt;</span><br><span class="line">    Dongshifu</span><br><span class="line">&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo 基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 测试</title>
    <url>/2019/11/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>网络基础-2</title>
    <url>/2019/03/06/linux_%E7%BD%91%E7%BB%9C02%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-1/</url>
    <content><![CDATA[<h3 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h3><h4 id="数据包封装"><a href="#数据包封装" class="headerlink" title="数据包封装"></a>数据包封装</h4><p>传输层及其以下的机制由<strong>内核提供</strong>，<strong>应用层由用户进程提供</strong>。<strong>应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。</strong> <strong>应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation）</strong>，如下图所示：</p>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE943321ff202288b2913e1285069de8e5/4565" alt="数据包封装"></p>
<p>不同的协议层对数据包有不同的称谓，<strong>在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）</strong>。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p>
<h4 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h4><p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE937a40d8066c97295abb3b803bcb27ce/4567" alt="以太网帧格式"></p>
<p>其中的源地址和目的地址是指网卡的硬件地址（也叫<strong>MAC地址</strong>），长度是48位，是在网卡出厂时<strong>固化</strong>的。可在shell中使用ifconfig命令查看，“<strong>00:50:56:c0:00:01</strong>”部分就是硬件地址。类型字段有三种值，<strong>分别对应IP、ARP、RARP。帧尾是CRC校验码。</strong></p>
<p>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。<strong>最大值1500称为以太网的最大传输单元（MTU）</strong>，不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行<strong>分片</strong>（fragmentation）。ifconfig命令输出中也<strong>MTU:1500</strong>.注意，<strong>MTU指指数据帧中有效载荷的最大长度，不包括帧头长度。</strong></p>
<h4 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a>ARP数据报格式</h4><p>在网络通讯时，<strong>源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址</strong>。ARP协议就起到这个作用。<strong>源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。</strong></p>
<p>每台主机都维护一个ARP缓存表，可以用arp -a命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。</p>
<p>ARP数据报的格式如下所示：</p>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE8790e76a5bfd1e36879973c44556bb91/4569" alt="ARP数据报格式"></p>
<p>源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但<strong>如果链路层是其它类型的网络则有可能是必要的</strong>。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），op字段为1表示ARP请求，op字段为2表示ARP应答。</p>
<p>看一个具体的例子。</p>
<p>请求帧如下（为了清晰在每行的前面加了字节计数，每行16个字节）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以太网首部（14字节）</span><br><span class="line"></span><br><span class="line">0000: ff ff ff ff ff ff 00 05 5d 61 58 a8 08 06</span><br><span class="line"></span><br><span class="line">ARP帧（28字节）</span><br><span class="line"></span><br><span class="line">0000: 00 01</span><br><span class="line"></span><br><span class="line">0010: 08 00 06 04 00 01 00 05 5d 61 58 a8 c0 a8 00 37</span><br><span class="line"></span><br><span class="line">0020: 00 00 00 00 00 00 c0 a8 00 02</span><br><span class="line"></span><br><span class="line">填充位（18字节）</span><br><span class="line"></span><br><span class="line">0020: 00 77 31 d2 50 10</span><br><span class="line"></span><br><span class="line">0030: fd 78 41 d3 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>以太网首部：<strong>目的主机采用广播地址</strong>，源主机的MAC地址是00:05:5d:61:58:a8，上层协议类型0x0806表示ARP。</p>
<p>ARP帧：硬件类型0x0001表示<strong>以太网</strong>，协议类型0x0800表示<strong>IP协议</strong>，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0001表示请求目的主机的MAC地址，源主机MAC地址为00:05:5d:61:58:a8，源主机IP地址为c0 a8 00 37（192.168.0.55）<strong>，目的主机MAC地址全0待填写，目的主机IP地址为c0 a8 00 02（192.168.0.2）。</strong></p>
<p>由于以太网规定最小数据长度为46字节，ARP帧长度只有28字节，因此有18字节填充位，填充位的内容没有定义，与具体实现相关。</p>
<p><strong>应答帧</strong>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以太网首部</span><br><span class="line"></span><br><span class="line">0000: **00 05 5d 61 58 a8** 00 05 5d a1 b8 40 08 06</span><br><span class="line"></span><br><span class="line">ARP帧</span><br><span class="line"></span><br><span class="line">0000: 00 01</span><br><span class="line"></span><br><span class="line">0010: 08 00 06 04 00 02 **00 05 5d a1 b8 40** c0 a8 00 02</span><br><span class="line"></span><br><span class="line">0020: 00 05 5d 61 58 a8 c0 a8 00 37</span><br><span class="line"></span><br><span class="line">填充位</span><br><span class="line"></span><br><span class="line">0020: 00 77 31 d2 50 10</span><br><span class="line"></span><br><span class="line">0030: fd 78 41 d3 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>以太网首部：<strong>目的主机的MAC地址是00:05:5d:61:58:a8，源主机的MAC地址是00:05:5d:a1:b8:40，</strong>上层协议类型0x0806表示ARP。</p>
<p>ARP帧：硬件类型0x0001表示以太网，协议类型0x0800表示IP协议，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0002表示应答，源主机MAC地址为00:05:5d:a1:b8:40，源主机IP地址为c0 a8 00 02（192.168.0.2），目的主机MAC地址为00:05:5d:61:58:a8，目的主机IP地址为c0 a8 00 37（192.168.0.55）。</p>
<p>如果源主机和目的主机不在同一网段，ARP请求的广播帧无法穿过路由器，源主机如何与目的主机通信？</p>
<p>在网段通信时，数据包中的地址就是源IP，目标IP，源MAC，目标MAC，根本用不到网关，而当检测到需要把数据包发到远程网络时，这时，目标MAC就必须改变了，<strong>在还没有出内网时，目标MAC必须写成网关的MAC地址发出去，当网关收到时，再把目标MAC地址改成下一跳的MAC地址发出去，而源IP和源MAC以及目标IP不曾改变，就算到达了公网上，目标MAC仍然在不断改变着，直到最后，这个数据包到达目标IP的网络，最终通信结束！</strong></p>
<p><strong>不同网段的主机通信时，主机会封装网关（通常是路由器）的mac地址，然后主机将数据发送给路由器，后续路由进行路由转发，通过arp解析目标地址的mac地址，然后将数据包送达目的地。</strong>可参考：<a href="https://blog.csdn.net/weixin_43166958/article/details/86503506" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43166958/article/details/86503506</a></p>
<h4 id="IP段格式"><a href="#IP段格式" class="headerlink" title="IP段格式"></a>IP段格式</h4><p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE0e1f09c9e2bd41d557d2442aca16ef13/4571" alt="IP段格式"></p>
<ul>
<li><p>IP数据报的首部长度和数据长度都是可变长的，<strong>但总是4字节的整数倍</strong>。对于IPv4，4位版本字段是4。</p>
</li>
<li><p>4位首部长度的数值是以4字节为单位的，<strong>最小值为5</strong>，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说<strong>首部长度最大是60字节</strong>。</p>
</li>
<li>8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大吞吐量、最大可靠性、最小成本），还有一个位总是0。</li>
<li>总长度是整个数据报（包括IP首部和IP层payload）的字节数。</li>
<li><strong>每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。</strong></li>
<li><strong>3位标志和13位片偏移用于分片。</strong></li>
<li>TTL（Time to live)是这样用的：源主机为数据包设定一个<strong>生存时间</strong>，比如64，<strong>每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。</strong></li>
<li>协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。</li>
<li>校验和，<strong>只校验IP首部，数据的校验由更高层协议负责。</strong>IPv4的IP地址长度为32位。</li>
</ul>
<h4 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h4><p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCEc8142b69b8328ae98ab01b333ad577ca/4573" alt="udp数据报格式"></p>
<p>下面分析一帧<strong>基于UDP的TFTP协议帧</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以太网首部</span><br><span class="line"></span><br><span class="line">0000: 00 05 5d 67 d0 b1 00 05 5d 61 58 a8 08 00</span><br><span class="line"></span><br><span class="line">IP首部</span><br><span class="line"></span><br><span class="line">0000: 45 00</span><br><span class="line"></span><br><span class="line">0010: 00 53 93 25 00 00 80 11 25 ec c0 a8 00 37 c0 a8</span><br><span class="line"></span><br><span class="line">0020: 00 01</span><br><span class="line"></span><br><span class="line">UDP首部</span><br><span class="line"></span><br><span class="line">0020： 05 d4 00 45 00 3f ac 40</span><br><span class="line"></span><br><span class="line">TFTP协议</span><br><span class="line"></span><br><span class="line">0020: 00 01 &apos;c&apos;&apos;:&apos;&apos;\&apos;&apos;q&apos;</span><br><span class="line"></span><br><span class="line">0030: &apos;w&apos;&apos;e&apos;&apos;r&apos;&apos;q&apos;&apos;.&apos;&apos;q&apos;&apos;w&apos;&apos;e&apos;00 &apos;n&apos;&apos;e&apos;&apos;t&apos;&apos;a&apos;&apos;s&apos;&apos;c&apos;&apos;i&apos;</span><br><span class="line"></span><br><span class="line">0040: &apos;i&apos;00 &apos;b&apos;&apos;l&apos;&apos;k&apos;&apos;s&apos;&apos;i&apos;&apos;z&apos;&apos;e&apos;00 &apos;5&apos;&apos;1&apos;&apos;2&apos;00 &apos;t&apos;&apos;i&apos;</span><br><span class="line"></span><br><span class="line">0050: &apos;m&apos;&apos;e&apos;&apos;o&apos;&apos;u&apos;&apos;t&apos;00 &apos;1&apos;&apos;0&apos;00 &apos;t&apos;&apos;s&apos;&apos;i&apos;&apos;z&apos;&apos;e&apos;00 &apos;0&apos;</span><br><span class="line"></span><br><span class="line">0060: 00</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以太网首部：源MAC地址是00:05:5d:61:58:a8，目的MAC地址是00:05:5d:67:d0:b1，上层协议类型0x0800表示IP。</p>
</li>
<li><p>IP首部：</p>
<ul>
<li>每一个字节45包含4位版本号和4位首部长度，版本号为4，即IPv4。</li>
<li><strong>首部长度为5，说明IP首部不带有选项字段</strong>。</li>
<li>服务类型为0，没有使用服务。</li>
<li>16位总长度字段（<strong>包括IP首部和IP层payload的长度</strong>）为0x0053，即83字节，加上以太网首部14字节可知整个帧长度是97字节。</li>
<li>IP报标识是0x9325</li>
<li>标志字段和片偏移字段设置为0x0000，就是DF=0允许分片，MF=0此数据报没有更多分片，没有分片偏移。</li>
<li>TTL是0x80，也就是128。</li>
<li>上层协议0x11表示UDP协议。</li>
<li>IP首部校验和为0x25ec</li>
<li>源主机IP是c0 a8 00 37（192.168.0.55）</li>
<li>目的主机IP是c0 a8 00 01（192.168.0.1）。</li>
</ul>
</li>
<li><p>UDP首部：</p>
<ul>
<li>源端口号0x05d4（1492）是客户端的端口号</li>
<li>目的端口号0x0045（69）是TFTP服务的well-known端口号。</li>
<li>UDP报长度为0x003f，即63字节，包括UDP首部和UDP层pay-load的长度。</li>
<li>UDP首部和UDP层payload的校验和为0xac40。</li>
</ul>
</li>
<li><p>TFTP是基于文本的协议，各字段之间用字节0分隔，开头的00 01表示请求读取一个文件，接下来的各字段是：</p>
<ul>
<li>```text<br>c:\qwerq.qwe<br>netascii<br>blksize 512<br>timeout 10<br>tsize 0<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">一般的网络通信都是像TFTP协议这样，通信的双方分别是客户端和服务器，**客户端主动发起请求（上面的例子就是客户端发起的请求帧），而服务器被动地等待、接收和应答请求。**</span><br><span class="line"></span><br><span class="line">客户端的**IP地址和端口号唯一标识了该主机上的TFTP客户端进程**，**服务器的IP地址和端口号唯一标识了该主机上的TFTP服务进程**，由于客户端是主动发起请求的一方，它必须知道服务器的IP地址和TFTP服务进程的端口号，所以，**一些常见的网络协议有默认的服务器端口，例如HTTP服务默认TCP协议的80端口，FTP服务默认TCP协议的21端口，TFTP服务默认UDP协议的69端口**。</span><br><span class="line"></span><br><span class="line">在使用客户端程序时，必须指定服务器的主机名或IP地址，如果不明确指定端口号则采用默认端口，请读者查阅ftp、tftp等程序的man page了解如何指定端口号。</span><br><span class="line"></span><br><span class="line">/etc/services中列出了所有well-known的服务端口和对应的传输层协议，这是由IANA（Internet Assigned Numbers Authority）规定的，其中有些服务既可以用TCP也可以用UDP，为了清晰，IANA规定这样的服务采用相同的TCP或UDP默认端口号，而另外一些TCP和UDP的相同端口号却对应不同的服务。</span><br><span class="line"></span><br><span class="line">**很多服务有well-known的端口号，然而客户端程序的端口号却不必是well-known的，往往是每次运行客户端程序时由系统自动分配一个空闲的端口号，用完就释放掉，称为ephemeral的端口号**。</span><br><span class="line"></span><br><span class="line">前面提过，UDP协议不面向连接，也不保证传输的可靠性，例如：</span><br><span class="line"></span><br><span class="line">发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，**UDP协议层也不会给应用层返回任何错误信息。**</span><br><span class="line"></span><br><span class="line">接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，**UDP协议层也不保证按发送时的顺序交给应用层。**</span><br><span class="line"></span><br><span class="line">通常接收端的UDP协议层将收到的数据放在一个固定大小的**缓冲区**中等待应用程序来提取和处理，**如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误。**</span><br><span class="line"></span><br><span class="line">因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。**一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。**例如，基于UDP的TFTP协议一般只用于传送小文件（所以才叫trivial的ftp），而基于TCP的FTP协议适用于各种文件的传输。</span><br><span class="line"></span><br><span class="line">#### TCP数据报格式</span><br><span class="line"></span><br><span class="line">![TCP数据报格式](http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCEfb083f48267eafa5f86eeb2ad99a94ab/4575)</span><br><span class="line"></span><br><span class="line">与UDP协议一样也有**源端口号和目的端口号**，通讯的双方由**IP地址和端口号标识**。32位**序号**、32位**确认序号**、窗口大小稍后详细解释。**4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节，如果没有选项字段，TCP协议头最短20字节。**URG、ACK、PSH、RST、SYN、FIN是六个**控制位**。16位检验和将TCP协议头和数据都计算在内。</span><br><span class="line"></span><br><span class="line">### TCP协议</span><br><span class="line"></span><br><span class="line">#### TCP通信时序</span><br><span class="line"></span><br><span class="line">下图是一次TCP通讯的时序图。TCP连接建立断开。包含熟知的**三次握手和四次挥手**。</span><br><span class="line"></span><br><span class="line">![TCP通信时序](http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE5332ac18ccc8b5cfa278e4d6077da9af/4577)</span><br><span class="line"></span><br><span class="line">在这个例子中，首先客户端主动发起连接、发送请求，然后服务器端响应请求，然后客户端主动关闭连接。两条竖线表示通讯的两端，从上到下表示时间的先后顺序，注意，数据从一端传到网络的另一端也需要时间，所以图中的箭头都是斜的。双方发送的段按时间顺序编号为1-10，各段中的主要信息在箭头上标出，例如段2的箭头上标着SYN, 8000(0), ACK 1001，表示该段中的SYN位置1，32位**序号**是8000，**该段不携带有效载荷（数据字节数为0）**，ACK位置1，32位**确认序号是1001**，**带有一个mss（Maximum Segment Size，最大报文长度）选项值为1024。**</span><br><span class="line"></span><br><span class="line">#### 三次握手</span><br><span class="line"></span><br><span class="line">-  客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1</span><br><span class="line">  - 客户端发出段1，**SYN位表示连接请求**。</span><br><span class="line">  - **序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况**</span><br><span class="line">  - **规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001(段4)**。</span><br><span class="line">  - mss表示最大段尺寸，**如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片**，为了避免这种情况，**客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。**</span><br><span class="line"></span><br><span class="line">-  服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它**表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。**</span><br><span class="line">  - 服务器发出段2，也带有SYN位，**同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。**</span><br><span class="line"></span><br><span class="line">- 客户必须再次回应服务器端一个ACK报文，这是报文段3。</span><br><span class="line">  - 客户端发出段3，对服务器的连接请求进行应答，**确认序号**是8001。在这个过程中，**客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为“三方握手（three-way-handshake）”。**在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。</span><br><span class="line"></span><br><span class="line">在TCP通讯中，**如果一方收到另一方发来的段，读出其中的目的端口号，发现本机并没有任何进程使用这个端口，就会应答一个包含RST位的段给另一方**。例如，服务器并没有任何进程使用8080端口，我们却用telnet客户端去连接它，服务器收到客户端发来的SYN段就会应答一个RST段，**客户端的telnet程序收到RST段后报告错误Connection refused：**</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">$ telnet 192.168.0.200 8080</span><br><span class="line"></span><br><span class="line">Trying 192.168.0.200...</span><br><span class="line"></span><br><span class="line">telnet: Unable to connect to remote host: Connection refused</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h4><ul>
<li><p>客户端发出段4，包含从序号1001开始的20个字节数据。</p>
</li>
<li><p>服务器发出段5，<strong>确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback。</strong></p>
</li>
<li><p>客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。</p>
</li>
</ul>
<p>在数据传输过程中，<strong>ACK和确认序号</strong>是非常重要的，<strong>应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。</strong></p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>由于TCP连接是<strong>全双工</strong>的，因此<strong>每个方向都必须单独进行关闭</strong>。这原则是<strong>当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭</strong>。</p>
<ul>
<li><p>客户端发出段7，FIN位表示关闭连接的请求。</p>
</li>
<li><p>服务器发出段8，应答客户端的关闭连接请求。</p>
</li>
<li><p>服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。</p>
</li>
<li><p>客户端发出段10，应答服务器的关闭连接请求。</p>
</li>
</ul>
<p>建立连接的过程是三次握手，而关闭连接通常需要4个段，<strong>服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据（ACK是可以的，只是没有数据）给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。</strong></p>
<h4 id="滑动窗口-TCP流量控制"><a href="#滑动窗口-TCP流量控制" class="headerlink" title="滑动窗口(TCP流量控制)"></a>滑动窗口(TCP流量控制)</h4><p>介绍UDP时描述了这样的问题：<strong>如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会丢失数据。TCP协议通过“滑动窗口（Sliding Window）”机制解决这一问题</strong>。看下图的通讯过程：</p>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCEde02a2ac39f3de7ba31ee51751bdca95/4579" alt="滑动窗口"></p>
<ul>
<li><p>发送端发起连接，声明最大段尺寸是1460，初始序号是0，<strong>窗口大小是4K，表示“我的接收缓冲区还有4K字节空闲，你发的数据不要超过4K”</strong>。接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三次握手结束。</p>
</li>
<li><p>发送端发出段4-9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。</p>
</li>
<li><p>接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K。</p>
</li>
<li><p>接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。</p>
</li>
<li><p>发送端发出段12-13，每个段带2K数据，段13同时还包含FIN位。</p>
</li>
<li><p>接收端应答接收到的2K数据（6145-8192），<strong>再加上FIN位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。</strong></p>
</li>
<li><p>接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。</p>
</li>
<li><p>接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。</p>
</li>
<li><p>接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连接完全关闭。</p>
</li>
</ul>
<p>上图在接收端用小方块表示1K数据，实心的小方块表示已接收到的数据，<strong>虚线框表示接收缓冲区</strong>，因此套在虚线框中的空心小方块表示窗口大小，从图中可以看出，<strong>随着应用程序提走数据，虚线框是向右滑动的，因此称为滑动窗口。</strong></p>
<p>从这个例子还可以看出，发送端是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据。也就是说，<strong>应用程序所看到的数据是一个整体，或说是一个流（stream），在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。</strong>而UDP是面向消息的协议，<strong>每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据</strong>，这一点和TCP是很不同的。</p>
<h4 id="TCP-状态转移"><a href="#TCP-状态转移" class="headerlink" title="TCP 状态转移"></a>TCP 状态转移</h4><p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE11e02e250025cfccd7fa1221edf57327/4581" alt="TCP状态转移"></p>
<p>实线一部分：主动发起连接，主动关闭连接。主动发起连接才会出现FIN_WAIT_2状态。TIME_WAIT的时间：不确定对方是否收到发送的ACK。</p>
<p>虚线一部分：被动发起连接，被动关闭连接</p>
<p>小细线一部分：两端同时操作</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础-1</title>
    <url>/2019/03/06/linux_%E7%BD%91%E7%BB%9C01%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>从应用的角度出发，协议可理解为“规则”，是数据传输和数据解释的规则。</p>
<p>协议双发之间遵守的协议中可以称为<strong>原始协议</strong>。当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、完整的协议，被广泛应用于各种应用中，此时该协议就可以成为一个<strong>标准协议</strong>。</p>
<p>TCP协议注重数据的<strong>传输</strong>。http协议着重于数据的<strong>解释</strong>。</p>
<h4 id="典型协议"><a href="#典型协议" class="headerlink" title="典型协议"></a>典型协议</h4><ul>
<li>应用层 常见的协议有HTTP协议，FTP协议。<ul>
<li>HTTP(超文本传输协议，Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议</li>
<li>FTP文件传输协议（File Transfer Protocol）。</li>
</ul>
</li>
<li><p>传输层 常见协议有TCP/UDP协议。</p>
<ul>
<li>TCP（传输控制协议，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</li>
<li>UDP用户数据报协议（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</li>
</ul>
</li>
<li><p>网络层 常见协议有IP协议、ICMP协议、IGMP协议。</p>
<ul>
<li>IP协议是因特网互联协议（Internet Protocol）。</li>
<li>ICMP协议是Internet控制报文协议（Internet Control Message Protocol）它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</li>
<li>IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。</li>
</ul>
</li>
<li><p>网络接口层 常见协议有ARP协议、RARP协议。</p>
<ul>
<li>ARP协议是正向地址解析协议Address Resolution Protocol，通过已知的IP，寻找对应主机的MAC</li>
<li>RARP是反向地址转换协议，通过MAC地址确定IP地址。</li>
</ul>
</li>
</ul>
<h3 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h3><h4 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h4><p>传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要<strong>在通讯两端各自部署客户机和服务器来完成数据通信。</strong></p>
<p>优点：</p>
<ul>
<li><p>客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而<strong>提高数据传输效率</strong>。</p>
</li>
<li><p>c端和s端都需要自己定义，协议使用灵活</p>
</li>
<li>可以提前在本地进行<strong>大量数据的缓存处理，</strong>从而提高观感</li>
</ul>
<p>缺点：</p>
<ul>
<li>从用户角度出发，需要将客户端安插至用户主机上，对用户主机的<strong>安全性构成威胁</strong>。</li>
<li>开发工作量大，调试困难</li>
</ul>
<h4 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a>B/S模式</h4><p>浏览器(browser)/服务器(server)模式。只需在<strong>一端部署服务器</strong>，而另外一端使用每台PC都默认配置的<strong>浏览器</strong>即可完成数据的传输。</p>
<p>优点：</p>
<ul>
<li>使用标准浏览器作为客户端，其工作<strong>开发量较小</strong>。<strong>只需开发服务器端</strong>即可。</li>
<li>由于其采用浏览器显示数据，因此<strong>移植性非常好</strong>，<strong>不受平台限制</strong>。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>网络应用支持受限</strong>。</li>
<li>没有客户端放到对方主机上，<strong>缓存数据不尽如人意</strong>，从而传输数据量受到限制。应用的观感大打折扣。</li>
<li>必须与浏览器一样，采用标准http协议进行通信，<strong>协议选择不灵活</strong>。</li>
</ul>
<h3 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h3><p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE3d9424e51d6b2ac2e8fe2728441e3161/4555" alt="分层模型图"></p>
<p>四层模型(TCP/IP模型)：</p>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE1cf2e4cebb2017a705ff317f17e9d386/4557" alt="四层模型"></p>
<p>一般在应用开发过程中，讨论最多的是TCP/IP模型。</p>
<h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><p>两台计算机通过TCP/IP协议通讯的过程如下所示：</p>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE808825184e078024bd1e6579f8badc78/4559" alt="两台计算机通过TCP/IP协议通讯的过程"></p>
<p>上图对应两台计算机在<strong>同一网段中</strong>的情况，如果<strong>两台计算机在不同的网段</strong>中，那么数据<strong>从一台计算机到另一台计算机传输过程中要经过一个或多个路由器</strong>，如下图所示：</p>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE82ddd64ede0163775ec686aa8c4f2ef4/4561" alt="不同网段通信过程"></p>
<h6 id="链路层工作"><a href="#链路层工作" class="headerlink" title="链路层工作"></a>链路层工作</h6><p>链路层有<strong>以太网、令牌环网</strong>等标准，<strong>链路层负责网卡设备的驱动、帧同步</strong>（即从网线上检测到什么信号算作新帧的开始）、<strong>冲突检测</strong>（如果检测到冲突就自动重发）、<strong>数据差错校验</strong>等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同<strong>，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。</strong></p>
<h6 id="网络层工作"><a href="#网络层工作" class="headerlink" title="网络层工作"></a>网络层工作</h6><p>网络层的IP协议是构成Internet的基础。<strong>Internet上的主机通过IP地址来标识</strong>，Internet上有大量<strong>路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器</strong>。<strong>路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。</strong> <strong>IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。</strong></p>
<p>网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器）</p>
<h6 id="传输层工作"><a href="#传输层工作" class="headerlink" title="传输层工作"></a>传输层工作</h6><p>传输层负责<strong>端到端</strong>（end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。</p>
<p>TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。<strong>也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。</strong></p>
<p>UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。<strong>使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。</strong></p>
<p>目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示：</p>
<p><img src="http://note.youdao.com/yws/public/resource/8e6e18c29e30a8985cd881b2ee57f5c9/xmlnote/WEBRESOURCE92061dfc6ebbb29f1358200962d530e0/4563" alt="数据包传输过程"></p>
<p>以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（<strong>payload，指除去协议首部之外实际传输的数据</strong>）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。<strong>假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。</strong></p>
<p>虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
</search>
