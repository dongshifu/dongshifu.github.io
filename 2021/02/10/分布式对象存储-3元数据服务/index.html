<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="ShifuDong" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="元数据服务上一个版本的分布式对象存储实现了接口服务和数据服务的分离，对象的数据被保存在了专门的数据服务节点，而不是保存在接口服务的本地磁盘上。通过解耦后，可以往集群中添加新的接口服务结点或数据服务节点。 但也存在问题：  如果多次PUT同一个对象，会发现该对象在所有的数据服务节点上都有一份副本。这是由于在每次PUT的时候都是随机选择一个数据服务节点，只要PUT次数足够多，那么所有的节点必然都会被选">
<meta name="keywords" content="分布式,go">
<meta property="og:type" content="article">
<meta property="og:title" content="元数据服务">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;02&#x2F;10&#x2F;%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-3%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1&#x2F;index.html">
<meta property="og:site_name" content="ShifuDong">
<meta property="og:description" content="元数据服务上一个版本的分布式对象存储实现了接口服务和数据服务的分离，对象的数据被保存在了专门的数据服务节点，而不是保存在接口服务的本地磁盘上。通过解耦后，可以往集群中添加新的接口服务结点或数据服务节点。 但也存在问题：  如果多次PUT同一个对象，会发现该对象在所有的数据服务节点上都有一份副本。这是由于在每次PUT的时候都是随机选择一个数据服务节点，只要PUT次数足够多，那么所有的节点必然都会被选">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;e15401f1-6fdc-490a-9351-1131bf07b90b-11197877.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;6dfe689e-2b45-45eb-b31d-264ddbbe97b1-11197877.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;777aada2-f039-4763-b3be-9e17b1e04b08-11197877.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;9cf5cce9-c1cc-48c5-b810-19ab62954001-11197877.jpg">
<meta property="og:updated_time" content="2021-05-12T00:34:09.051Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;api2.mubu.com&#x2F;v3&#x2F;document_image&#x2F;e15401f1-6fdc-490a-9351-1131bf07b90b-11197877.jpg">

<link rel="canonical" href="http://yoursite.com/2021/02/10/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-3%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>元数据服务 | ShifuDong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShifuDong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Knowledge Sharing</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/10/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-3%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShifuDong">
      <meta itemprop="description" content="记录生活， 记录学习， 分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShifuDong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          元数据服务
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-10 15:03:58" itemprop="dateCreated datePublished" datetime="2021-02-10T15:03:58+08:00">2021-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 08:34:09" itemprop="dateModified" datetime="2021-05-12T08:34:09+08:00">2021-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/" itemprop="url" rel="index">
                    <span itemprop="name">分布式对象存储</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="元数据服务"><a href="#元数据服务" class="headerlink" title="元数据服务"></a>元数据服务</h3><p>上一个版本的分布式对象存储实现了接口服务和数据服务的分离，对象的数据被保存在了专门的数据服务节点，而不是保存在接口服务的本地磁盘上。通过解耦后，可以往集群中添加新的接口服务结点或数据服务节点。</p>
<p>但也存在问题：</p>
<ul>
<li>如果多次PUT同一个对象，会发现该<strong>对象在所有的数据服务节点上都有一份副本</strong>。这是由于在每次PUT的时候都是随机选择一个数据服务节点，只要PUT次数足够多，那么所有的节点必然都会被选中一次，结果就是每个节点上都保存着这个对象的数据。为了解决这个问题，对象存储系统提出了一个十分重要的概念，叫作<strong>数据去重。</strong><ul>
<li>最简单的办法似乎式只需要在每次PUT之前先定位一下,确保该对象不存在之后再PUT就好了。然而问题并没有那么简单，更复杂的情况是，<strong>两个名字不同的对象有可能内容相同。这样的对象也属于需要去重的范畴</strong>。这是怎么回事呢?<strong>一个对外提供服务的对象存储系统不可能只有一个用户，而是会有很多用户一起使用，这些用户上传的对象可能存在大量的重复数据。为了节省存储空间，对象存储服务通常都会尽量让数据相同的对象共享系统中的同一份数据存储</strong>。</li>
</ul>
</li>
<li>另一个问题则是<strong>数据的不一致</strong>。假设<strong>多次PUT同一个对象，且内容不同，这个对象的不同版本会被随机保存在不同的数据服务节点上。当GET它时就会随机取得不同版本的对象，这不仅破坏了对象数据的一致性，也破坏了GET方法的幂等性( 对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的)。</strong><ul>
<li>该问题似乎可以通过每次PUT之前先进行定位，如果该对象不存在则随机选择，如果存在则选择相对应的数服务节点。这时候如果客户不要求版本控制，系统的行为表现为用最新的版本覆盖上一个版本。但如果客户希望保存某个对象的所有版本，这时候用户上传的某个对象的所有版本都需要被保存起来。比如说，当用户第一次上传一个对象时，它的初始版本为1:当用户使用PUT方法改变了该对象的内容，那么新对象的版本为2，依次递增。<strong>新的版本会覆盖旧的版本，但是旧版本的对象不会被删除。在下载对象时，用户可以指定GET对象的任意一个版本。</strong> <strong>为了实现版本控制，需要一个数据库来记录系统中所有对象的所有版本。这个数据库就是元数据服务。</strong></li>
</ul>
</li>
</ul>
<h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>元数据指的是<strong>对象的描述信息</strong>。为了和对象的数据本身区分开，赋予了元数据这个名称。对象的哪些信息可以称作元数据？举例来说，有<strong>对象的名字、版本、大小以及散列值等。这些都是系统定义的元数据，因为它们的存在对一个对象存储系统有实际意义，比如说客户端和接口服务之间根据对象的名字来引用一个对象:一个对象可以有多个版本，除了删除标记外，每个版本实际都指向数据服务节点上的一份数据存储。</strong></p>
<p>用户自定义的元数据：除了系统定义的元数据以外，用户也可以为这个对象添加自定义的元数据。这些元数据通常以<strong>键值对形式保存</strong>的任意描述信息，比如一张照片的拍摄时间和拍摄地点，一首歌的作者和演唱者等。<strong>对象存储系统不关心这些元数据，但是用户需要将它们添加到对象存储系统中，作为该对象的元数据进行保存</strong>。</p>
<h4 id="散列值和散列函数"><a href="#散列值和散列函数" class="headerlink" title="散列值和散列函数"></a>散列值和散列函数</h4><p>对象的散列值是一种非常特殊的元数据，因为<strong>对象存储通常将对象的散列值作为其全局唯一的标识符。</strong>在此前，数据服务节点上的对象都是用名字来引用的，<strong>如果两个对象名字不同，那么无法知道它们的内容是否相同</strong>。如此则无法实现针对不同对象的去重。现在，<strong>以对象的散列值作为标识符，就可以将接口服务层访问的对象和数据服务存取的对象数据解耦合</strong>。<strong>客户端和接口服务通过对象的名字来引用一个对象，而实际则是通过其散列值来引用存储在数据节点上的对象数据，只要散列值相同则可以认为对象的数据相同，这样就可以实现名字不同但数据相同的对象之间的去重。</strong></p>
<p>对象的散列值是<strong>通过散列函数计算出来</strong>，散列函数会将对象的数据进行重复多轮的数学运算，这些运算操作包括按位与、按位或、按位异或等，<strong>最后计算出来一个长度固定的数字，作为对象的散列值</strong>。一个理想的散列函数具有以下5个特征。</p>
<ul>
<li>操作具有决定性，<strong>同样的数据必定计算出同样的散列值</strong>。</li>
<li>无论计算任何数据都很快。</li>
<li><strong>无法根据散列值倒推数据,只能遍历尝试所有可能的数据。</strong></li>
<li>数据上微小的变化就会导致散列值的巨大改变，新散列值和旧散列值不具有相关性。</li>
<li>无法找到两个能产生相同散列值的不同数据。</li>
</ul>
<p>实际情况无法满足所有要求，一个散列函数hash的安全级别根据3种属性决定:</p>
<ul>
<li>抗原像攻击:给定一个散列值h，难以找到一个数据m令 h=hash(m)。这个属性称为<strong>函数的单向性</strong>。欠缺单向性的散列函数易受到原像攻击。</li>
<li>抗第二原像攻击:给定一个数据m1，难以找到第二个数据m2令hash(m1)=hash(m2)。欠缺该属性的散列函数易受到第二原像攻击。</li>
<li>抗碰撞性:难以找到两个不同的数据m1和m2令hash(m1)=hash(m2)。这样的一对数据被称为散列碰撞。</li>
</ul>
<p>本项目使用的散列函数为SHA-256,该函数使用64位的数学运算，产生一个长度为256位的二进制数字作为散列值。</p>
<h4 id="分布式对象存储加入元数据服务"><a href="#分布式对象存储加入元数据服务" class="headerlink" title="分布式对象存储加入元数据服务"></a>分布式对象存储加入元数据服务</h4><p>元数据服务就是提供对元数据的存取功能的服务。本项目中实现的元数据服务较为简单，它将<strong>只保存系统定义的元数据，也就是对象的名字、版本、大小和散列值，因为这些直接影响到存储功能</strong>。</p>
<p>和上一版本的架构对，加入元数据服务的架构其他组件不变，而多了一个ElasticSearch （以下简称ES)，也就是项目种选择的元数据服务。需要说明的是能做元数据服务的并不只有ES一种，任何一个分布式数据库都可以做元数据服务。选择ES的原因是它足够好且实现方便。和RabbitMQ一样，ES本身也支持集群，但是在本书的测试环境中只使用了一个服务节点。<br><strong>ES使用的也是REST 接口</strong>，<strong>接口服务节点作为客户端通过HTTP访问ES的索引（index)。ES 的索引就相当于一个数据库，而类型（type）则相当于数据库里的一张表。项目种会创建一个名为metadata的索引，其中有一个名为objects 的类型。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/e15401f1-6fdc-490a-9351-1131bf07b90b-11197877.jpg" alt="加入元数据服务的分布式存储架构"></p>
<h5 id="REST接口"><a href="#REST接口" class="headerlink" title="REST接口"></a>REST接口</h5><p>有了元数据服务之后，就可以给接口服务增加新的功能，首先是给对象的GET方法增加一个参数version:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /objects/&lt;object_name&gt;?version=&lt;version_id&gt;</span><br></pre></td></tr></table></figure>
<p>响应正文：</p>
<ul>
<li>对象的数据:这个参数可以<strong>告诉接口服务客户端需要的是该对象的第几个版本，默认是最新的那个</strong>。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /objects/&lt;object_name&gt;</span><br></pre></td></tr></table></figure>
<p>请求头部(Request Header)</p>
<ul>
<li>Digest: SHA-256=&lt;对象散列值的Base64编码&gt;</li>
<li>Content-Length:&lt;对象数据的长度&gt;</li>
</ul>
<p>请求正文</p>
<ul>
<li>对象的内容如下:</li>
<li><strong>PUT方法没变,但是每次客户端PUT一个对象时,必须提供一个名为Digest 的HTTP请求头部，它记录了用SHA-256散列函数计算出来的对象散列值。</strong></li>
</ul>
<p>HTTP头部分为请求头部（Request Header）和响应头部(Response Header)，它允许客户端和服务器在HTTP的请求和响应中交换额外的信息。一个头部由3个部分组成:一个大小写不敏感的名字，后面跟着一个冒号“:”，然后是该头部的值。注意头部的值不能包含回车。</p>
<p>Digest头部的名字是 Digest，后面跟着一个冒号，然后是 Digest头部的值，也就是”SHA-256=&lt;对象散列值的Base64编码&gt;”。<strong>SHA-256是要求使用的散列函数,根据RFC3230的要求，客户端需要在Digest头部提供计算散列值时使用的散列函数,如果服务器发现客户端使用的散列函数跟服务器使用的散列函数不一致则会拒绝整个请求</strong>。<strong>SHA-256计算出的散列值是一个256位的二进制数字，客户端还需要对其进行Base64编码，将数字转化成ASCII字符串格式，以确保不包含回车的二进制数字。</strong></p>
<p>Base64编码规则选定了64个不同的字符，分别代表1个6位的二进制数字。对一个256位的二进制数字进行编码，首先要将其切成11个24位的二进制数字（不足的位在最后一个数字用0补齐)，然后每个数字正好用4个Base64字符来表示。</p>
<p><strong>经过Base64编码后的散列值将作为该对象的全局唯一标识符，也是数据服务节点储存的对象名。也就是说，只要对象内容发生了变化，那么原来在数据服务节点上储存的数据不会被更新，而是会储存一个新的对象。</strong></p>
<p>除了Digest头部以外，客户端还必须提供一个名为Content-Length 的HTTP请求头部用来告诉服务端该对象数据的长度。<strong>客户端提供的对象散列值和长度会作为元数据被保存在元数据服务中。</strong></p>
<p>将数据服务层存取的对象名和接口服务层访问的对象名区分开对于去重来说至关重要。现在，<strong>无论接口服务层收到的对象名是什么，只要从数据服务层角度看到的对象名一致，就可以认为是对象的内容一致，去重就只需要简单地根据数据服务层的对象名来实现就可以</strong>。</p>
<p>PUT成功后，在元数据服务中该对象就会添加一个新的版本，版本号从1开始递增。</p>
<p>除了对象的GET 和 PUT方法发生了变化以外，还可以添加新的功能，首先是对象的DELETE方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /objects/&lt;object_name&gt;</span><br></pre></td></tr></table></figure>
<p>使用DELETE方法来删除一个对象。</p>
<p>在此之前都没有实现对象的删除功能,这是有原因的<strong>。对象存储的去重会让名字不同的对象共享同一份数据存储，而删除一个对象意味着要将该对象和数据存储之间的联系断开。在把对象的名字和对象的数据存储解耦合之前，无法做到在删除一个对象的同时保留对象的数据存储。</strong> <strong>有了元数据服务，在删除一个对象时，只需要在元数据中给对象添加一个表示删除的特殊版本,而在数据节点上保留其数据。</strong></p>
<p><strong>在GET时，如果该对象的最新版本是一个删除标记，则返回404 Not Found。除了对象的删除功能之外，还需要提供对象的列表功能，用于查询所有对象或指定对象的所有版本。</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /versions/</span><br></pre></td></tr></table></figure>
<ul>
<li>响应正文<br><strong>指定对象的所有版本:客户端GET某个指定对象的版本列表，接口服务节点返回该对象的所有版本。HTTP响应内容结构同上。</strong></li>
</ul>
<h5 id="ES接口"><a href="#ES接口" class="headerlink" title="ES接口"></a>ES接口</h5><p>元数据服务的索引使用映射(mappings)结构：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">mappings":&#123;</span><br><span class="line">    "objects":&#123;</span><br><span class="line">        "properties":&#123;</span><br><span class="line">            "name" : &#123;"type" : "string" , "index" :"not analyzed"&#125;,</span><br><span class="line">            "version" :&#123;"type": "integer"&#125;,</span><br><span class="line">            "size":&#123;"type"": ""integer"&#125;,</span><br><span class="line">            "hash" : &#123;"type : "string" &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ES的索引相当于数据库而类型相当于数据库的表，那么现在这个映射则相当于定义表结构。</strong>这个映射会在创建metadata索引时作为参数一并被引入，<strong>该索引只有一个类型就是objects，其中包括4个属性分别是 name、version、size和hash，相当于数据库表的4个列。</strong></p>
<p>name属性有个额外的要求”index”:”not_analyzed”，这是<strong>为了在搜索时能够精确匹配name</strong>。<strong>默认的 analyzed index 会对name进行分词匹配。这有可能导致不相关的匹配结果。比如我们有一个元数据的name是“little cat”，如果使用analyzed index，那么它会被分成little和cat两个词，之后任何包含little或cat的搜索都会导致“little cat”被选中。</strong></p>
<h5 id="添加对象元数据"><a href="#添加对象元数据" class="headerlink" title="添加对象元数据"></a>添加对象元数据</h5><p>当客户端PUT或DELETE对象时，都需要往元数据服务添加新版本，处理步骤如图：</p>
<p><img src="https://api2.mubu.com/v3/document_image/6dfe689e-2b45-45eb-b31d-264ddbbe97b1-11197877.jpg" alt="往元数据服务添加新版本"></p>
<p>上图显示了往元数据服务添加新版本的流程，<strong>当接口服务需要给某个对象添加一个新版本时，首先会去查询该对象当前最新版本的元数据，如果该对象不存在，则新版本从1开始:否则新版本为当前最新版本加1，然后将其添加进元数据服务。</strong></p>
<p><strong>GET对象时分两种情况，如果没有指定版本号，同样需要搜索对象最新版本的元数据;如果指定了版本号，可以根据对象的名字和版本号直接获取对象指定版本的元数据。</strong></p>
<h5 id="用到的ES-API"><a href="#用到的ES-API" class="headerlink" title="用到的ES API"></a>用到的ES API</h5><p>要想荻取对象当前最新版本的元数据需要使用ES搜索API.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /metadata/_search?q=name:&lt;object_name&gt;&amp;size=1&amp;sort=version:desc</span><br></pre></td></tr></table></figure>
<p>给对象添加一个新版本需要使用ES索引API:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /metadata/objects/&lt;object_name&gt;_&lt;version&gt;?op_type=create</span><br></pre></td></tr></table></figure>
<p>在这里，特地将<code>&lt;object_name&gt;_&lt;version&gt;</code>作为<code>_i</code>d创建。这是为了<strong>当客户端指定版本GET对象时可以直接根据对象名和版本号拼出相对应的_id来从ES中获取元数据，从而免除了搜索的步骤。</strong></p>
<p>使用<code>op_type=create</code>可以确保<strong>当多个客户端同时上传同一个对象时不至于发生数据丢失，因为只有第一个请求能成功上传给ES。其他请求会收到HTTP错误代码409 Conflict，这样接口服务节点就能知道发生了版本冲突并重新上传。</strong></p>
<p>当客户端GET对象时分两种情况，如果没有指定版本号，则使用和之前同样的ES搜索API来获取对象的最新版本。</p>
<p>如果客户端指定版本号GET对象，则使用<code>ES Get API</code>直接获取对象指定版本的元数据。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /metadata/objects/&lt;object_name&gt;_&lt;version_id&gt;/_source</span><br></pre></td></tr></table></figure>
<p>当客户端GET全体对象版本列表时，使用ES<strong>搜索API</strong>方法如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /metadata/_search?sort=name,version&amp;from=&lt;from&gt;&amp;size=&lt;size&gt;</span><br></pre></td></tr></table></figure>
<p>其中，<strong>from和 size用于分页显示。在不指定from和 size的情况下，ES 默认的分页是从0开始显示10条。</strong></p>
<p>当客户端<strong>GET指定对象版本列表时</strong>，使用ES 搜索API方法如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /metadata/_search?sort=name,versions&amp;from=&lt;from&gt;&amp;size=&lt;size&gt;&amp;q=name:&lt;object_name&gt;</span><br></pre></td></tr></table></figure>
<p>这里多了一个q参数用于指定name。</p>
<h5 id="对象PUT流程"><a href="#对象PUT流程" class="headerlink" title="对象PUT流程"></a>对象PUT流程</h5><p><img src="https://api2.mubu.com/v3/document_image/777aada2-f039-4763-b3be-9e17b1e04b08-11197877.jpg" alt="加入元数据服务的对象put流程"></p>
<p>客户端的HTTP请求提供了对象的名字、散列值和大小，接口服务以散列值作为数据服务的对象名来保存对象，然后在元数据服务中根据对象的名字搜索当前最新的元数据，使其版本号加1并添加一个新版本的元数据。</p>
<h5 id="对象GET流程"><a href="#对象GET流程" class="headerlink" title="对象GET流程"></a>对象GET流程</h5><p><img src="https://api2.mubu.com/v3/document_image/9cf5cce9-c1cc-48c5-b810-19ab62954001-11197877.jpg" alt="加入元数据服务的对象get流程"></p>
<p>客户端在HTTP请求中指定对象的名字，可在 URL的查询参数中指定版本号。如果指定版本号，则接口服务根据对象的名字和版本号获取元数据;否则根据对象的名字搜索最新元数据。<strong>然后从元数据中获得对象的散列值作为数据服务的对象名来读取对象。</strong></p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>主要关注于与上一版本有变化的部分(主要在接口服务种实现元数据的互动)进行说明。</p>
<h5 id="接口服务"><a href="#接口服务" class="headerlink" title="接口服务"></a>接口服务</h5><h6 id="接口服务的main函数"><a href="#接口服务的main函数" class="headerlink" title="接口服务的main函数"></a>接口服务的main函数</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> heartbeat.ListenHeartbeat()</span><br><span class="line">	http.HandleFunc(<span class="string">"/objects/"</span>, objects.Handler)</span><br><span class="line">	http.HandleFunc(<span class="string">"/locate/"</span>, locate.Handler)</span><br><span class="line">	http.HandleFunc(<span class="string">"/versions/"</span>, versions.Handler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(os.Getenv(<span class="string">"LISTEN_ADDRESS"</span>), <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本版本的接口服务main函数多了一个用于处理<code>/vesions/</code>的函数，名字为<code>versions.Handler</code>。</p>
<h6 id="接口服务的versions包"><a href="#接口服务的versions包" class="headerlink" title="接口服务的versions包"></a>接口服务的<code>versions</code>包</h6><p>主要工作为调用es包的函数完成相关工作：</p>
<p><code>versions.Handler</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 检查HTTP方法是否为GET</span></span><br><span class="line">	m := r.Method</span><br><span class="line">	<span class="comment">// 如果不为GET，返回405 Method Not Allowed</span></span><br><span class="line">	<span class="keyword">if</span> m != http.MethodGet &#123;</span><br><span class="line">		w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 方法为GET,获取URL中的&lt;object_name&gt;部分</span></span><br><span class="line">	from := <span class="number">0</span></span><br><span class="line">	size := <span class="number">1000</span></span><br><span class="line">	name := strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="comment">// 无限循环调用es包的SearchAllVersions函数</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 返回一个元数据的数组</span></span><br><span class="line">		metas, e := es.SearchAllVersions(name, from, size)</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(e)</span><br><span class="line">			w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历数组，将元数据一一写入HTTP响应的正文</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> metas &#123;</span><br><span class="line">			b, _ := json.Marshal(metas[i])</span><br><span class="line">			w.Write(b)</span><br><span class="line">			w.Write([]<span class="keyword">byte</span>(<span class="string">"\n"</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果返回的数组长度不等于size，说明元数据服务种没有更多的数据，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(metas) != size &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 否则把from的值增加1000进行下一轮迭代</span></span><br><span class="line">		from += size</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="接口服务的objects包"><a href="#接口服务的objects包" class="headerlink" title="接口服务的objects包"></a>接口服务的objects包</h6><p>加入元数据服务以后,接口服务的objects包与上一版本相比发生了较大的变化,除了多了一个对象的DELETE方法以外，对象的PUT和GET方法也都有所改变，它们需要和元数据服务互动。</p>
<p>obejects.Handler函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	m := r.Method</span><br><span class="line">	<span class="keyword">if</span> m == http.MethodPut &#123;</span><br><span class="line">		put(w, r)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> m == http.MethodGet &#123;</span><br><span class="line">		get(w, r)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 与上一版本多一个DELETE方法处理del函数</span></span><br><span class="line">	<span class="keyword">if</span> m == http.MethodDelete &#123;</span><br><span class="line">		del(w, r)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objects.del函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">del</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	name := strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="comment">// 以name为参数调用es.SearchLaestVersion,搜索该对象最新的版本</span></span><br><span class="line">	version, e := es.SearchLatestVersion(name)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 插入新的元数据，接受元数据的name, version, size和hash</span></span><br><span class="line">	<span class="comment">// hash 为空字符串表示这个一个删除标记</span></span><br><span class="line">	e = es.PutMetadata(name, version.Version+<span class="number">1</span>, <span class="number">0</span>, <span class="string">""</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objects.put相关函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">put</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先从HTTP请求头部获取对象的散列值</span></span><br><span class="line">	hash := utils.GetHashFromHeader(r.Header)</span><br><span class="line">	<span class="keyword">if</span> hash == <span class="string">""</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"missing object hash in digest header"</span>)</span><br><span class="line">		w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以散列值作为参数调用stroreObject</span></span><br><span class="line">	c, e := storeObject(r.Body, url.PathEscape(hash))</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(c)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c != http.StatusOK &#123;</span><br><span class="line">		w.WriteHeader(c)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从URL中获取对象的名字和对象的大小</span></span><br><span class="line">	name := strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]</span><br><span class="line">	size := utils.GetSizeFromHeader(r.Header)</span><br><span class="line">	<span class="comment">// 以对象的名字、散列值和大小为参数调用es.AddVersions给对象添加新版本</span></span><br><span class="line">	e = es.AddVersion(name, hash, size)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GetHashFromHeader函数和GetSizeFromHeader函数是utils包提供的两个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetHashFromHeader</span><span class="params">(h http.Header)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取"digest"头部</span></span><br><span class="line">	digest := h.Get(<span class="string">"digest"</span>)</span><br><span class="line">	<span class="comment">// 检查diest头部的形式是否满足"SHA-256=&lt;hash&gt;"</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(digest) &lt; <span class="number">9</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> digest[:<span class="number">8</span>] != <span class="string">"SHA-256="</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> digest[<span class="number">8</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSizeFromHeader</span><span class="params">(h http.Header)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="comment">// 得到"conten-length"头部，并调用strconv.PareseInt将字符串转换为int64输出</span></span><br><span class="line">	size, _ := strconv.ParseInt(h.Get(<span class="string">"content-length"</span>), <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objects.get函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	name := strings.Split(r.URL.EscapedPath(), <span class="string">"/"</span>)[<span class="number">2</span>]</span><br><span class="line">	<span class="comment">// 获取URL并从URL的查询参数中获取"version"参数的值</span></span><br><span class="line">	<span class="comment">// Query方法返回一个保存URL所有查询参数的map，该map的键是查询参数的名字，值是一个字符串数组</span></span><br><span class="line">	<span class="comment">// HTTP的URL查询参数允许存在多个值，以"version"为key可以得到URL中查询参数的所有值</span></span><br><span class="line">	versionId := r.URL.Query()[<span class="string">"version"</span>]</span><br><span class="line">	version := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> e error</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(versionId) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 项目中不考虑多个"version"查询参数的情况</span></span><br><span class="line">		<span class="comment">// 始终以versionId数组的第一个元素作为客户端提供的版本号</span></span><br><span class="line">		<span class="comment">// 将字符串转换为整型</span></span><br><span class="line">		version, e = strconv.Atoi(versionId[<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(e)</span><br><span class="line">			w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用es的GetMetadata函数得到对象的元数据meta</span></span><br><span class="line">	meta, e := es.GetMetadata(name, version)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// meta.Hash为对象的散列值，如果为空表示该对象版本是一个删除标记</span></span><br><span class="line">	<span class="comment">// 返回404 Not Found</span></span><br><span class="line">	<span class="keyword">if</span> meta.Hash == <span class="string">""</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusNotFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以散列值为对象名从数据服务层获取对象并输出</span></span><br><span class="line">	object := url.PathEscape(meta.Hash)</span><br><span class="line">	stream, e := getStream(object)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(e)</span><br><span class="line">		w.WriteHeader(http.StatusNotFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	io.Copy(w, stream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="es包"><a href="#es包" class="headerlink" title="es包"></a>es包</h5><p>es包封装了以HTTP访问ES的各种API的操作。</p>
<p>es.getMetadata函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构与ES映射中定义的objects类型属性一一对应</span></span><br><span class="line"><span class="keyword">type</span> Metadata <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Version <span class="keyword">int</span></span><br><span class="line">	Size    <span class="keyword">int64</span></span><br><span class="line">	Hash    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据对象的名字和版本号来获取对象的元数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMetadata</span><span class="params">(name <span class="keyword">string</span>, versionId <span class="keyword">int</span>)</span> <span class="params">(meta Metadata, e error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ES服务器地址来自环境变量ES_SERVER,索引是metadata,类型是objects</span></span><br><span class="line">	<span class="comment">// 文档的id由对象的名字和版本号拼接而成。</span></span><br><span class="line">	url := fmt.Sprintf(<span class="string">"http://%s/metadata/objects/%s_%d/_source"</span>,</span><br><span class="line">		os.Getenv(<span class="string">"ES_SERVER"</span>), name, versionId)</span><br><span class="line">	<span class="comment">// GET到URL中的对象的元数据，免除耗时的搜索操作</span></span><br><span class="line">	r, e := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r.StatusCode != http.StatusOK &#123;</span><br><span class="line">		e = fmt.Errorf(<span class="string">"fail to get %s_%d: %d"</span>, name, versionId, r.StatusCode)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 读出数据</span></span><br><span class="line">	result, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">	<span class="comment">// ES返回的结果经过JSON解码后被es,SearchLatestVersion函数使用</span></span><br><span class="line">	json.Unmarshal(result, &amp;meta)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>es.SearchLatestVersion函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hit <span class="keyword">struct</span> &#123;</span><br><span class="line">	Source Metadata <span class="string">`json:"_source"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> searchResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	Hits <span class="keyword">struct</span> &#123;</span><br><span class="line">		Total <span class="keyword">int</span></span><br><span class="line">		Hits  []hit</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchLatestVersion</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(meta Metadata, e error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 调用ES搜索API.在URL中指定对象的名字，版本号以降序排列且只返回第一个结果。</span></span><br><span class="line">	url := fmt.Sprintf(<span class="string">"http://%s/metadata/_search?q=name:%s&amp;size=1&amp;sort=version:desc"</span>,</span><br><span class="line">		os.Getenv(<span class="string">"ES_SERVER"</span>), url.PathEscape(name))</span><br><span class="line">	fmt.Println(url)</span><br><span class="line">	r, e := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r.StatusCode != http.StatusOK &#123;</span><br><span class="line">		e = fmt.Errorf(<span class="string">"fail to search latest metadata: %d"</span>, r.StatusCode)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	result, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">	<span class="keyword">var</span> sr searchResult</span><br><span class="line">	<span class="comment">// ES返回的结果通过JSON解码到一个searchResult结构体中</span></span><br><span class="line">	<span class="comment">// searchResult和ES搜索API返回的结构体保持一致</span></span><br><span class="line">	<span class="comment">// 方便读取搜索到的元数据并赋值给meta返回。</span></span><br><span class="line">	json.Unmarshal(result, &amp;sr)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(sr.Hits.Hits) != <span class="number">0</span> &#123;</span><br><span class="line">		meta = sr.Hits.Hits[<span class="number">0</span>].Source</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ES的返回结果长度为0，说明没有搜到相对应的元数据，直接返回</span></span><br><span class="line">	<span class="comment">// 此时meta中各属性都为初始值：字符串为空，整型为0</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>es.GetMetadata函数：</p>
<p>GetMetadata函数的功能类似getMetadata，输入对象的名字和版本号返回对象，区别在于当version为0时会调用SearchLatestVersion获取当前最新的版本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMetadata</span><span class="params">(name <span class="keyword">string</span>, version <span class="keyword">int</span>)</span> <span class="params">(Metadata, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当version为0的时候，调用SearchLatestVersion获取当前最新的版本</span></span><br><span class="line">	<span class="keyword">if</span> version == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SearchLatestVersion(name)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> getMetadata(name, version)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>es.PutMetadata函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于向ES服务上传一个新的元数据，输入的4个参数对应元数据的4个属性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PutMetadata</span><span class="params">(name <span class="keyword">string</span>, version <span class="keyword">int</span>, size <span class="keyword">int64</span>, hash <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 生成ES文档，一个ES的文档相当于数据库的一条记录</span></span><br><span class="line">	doc := fmt.Sprintf(<span class="string">`&#123;"name":"%s","version":%d,"size":%d,"hash":"%s"&#125;`</span>,</span><br><span class="line">		name, version, size, hash)</span><br><span class="line">	client := http.Client&#123;&#125;</span><br><span class="line">	<span class="comment">// 使用op_type=create参数，如果同时又多个客户端上传同一个数据，结果会发生冲突</span></span><br><span class="line">	<span class="comment">// 只有第一个文档被成功创建，之后的PUT请求，ES会返回409Conflict</span></span><br><span class="line">	url := fmt.Sprintf(<span class="string">"http://%s/metadata/objects/%s_%d?op_type=create"</span>,</span><br><span class="line">		os.Getenv(<span class="string">"ES_SERVER"</span>), name, version)</span><br><span class="line">	<span class="comment">// 用PUT方法将文档上传到metadata索引的objects类型</span></span><br><span class="line">	request, _ := http.NewRequest(<span class="string">"PUT"</span>, url, strings.NewReader(doc))</span><br><span class="line">	r, e := client.Do(request)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> e</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果为409Conflict，函数让版本号加1并递归调用自身继续上传</span></span><br><span class="line">	<span class="keyword">if</span> r.StatusCode == http.StatusConflict &#123;</span><br><span class="line">		<span class="keyword">return</span> PutMetadata(name, version+<span class="number">1</span>, size, hash)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r.StatusCode != http.StatusCreated &#123;</span><br><span class="line">		result, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"fail to put metadata: %d %s"</span>, r.StatusCode, <span class="keyword">string</span>(result))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>es.AddVersion函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddVersion</span><span class="params">(name, hash <span class="keyword">string</span>, size <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取对象最新的版本</span></span><br><span class="line">	version, e := SearchLatestVersion(name)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> e</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在版本号上加1调用PutMetadata</span></span><br><span class="line">	<span class="keyword">return</span> PutMetadata(name, version.Version+<span class="number">1</span>, size, hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>es.SearchAllVersion函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于搜索某个对象或所有对象的全部版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchAllVersions</span><span class="params">(name <span class="keyword">string</span>, from, size <span class="keyword">int</span>)</span> <span class="params">([]Metadata, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// name表示对象的名字，如果name不为空字符粗则搜索指定对象的所有版本</span></span><br><span class="line">	<span class="comment">// 否则搜索所有对象的全部版本</span></span><br><span class="line">	<span class="comment">// from和size指定分页的显示结果</span></span><br><span class="line">	<span class="comment">// 搜索的结果按照对象的名字和版本号排序</span></span><br><span class="line">	url := fmt.Sprintf(<span class="string">"http://%s/metadata/_search?sort=name,version&amp;from=%d&amp;size=%d"</span>,</span><br><span class="line">		os.Getenv(<span class="string">"ES_SERVER"</span>), from, size)</span><br><span class="line">	<span class="keyword">if</span> name != <span class="string">""</span> &#123;</span><br><span class="line">		url += <span class="string">"&amp;q=name:"</span> + name</span><br><span class="line">	&#125;</span><br><span class="line">	r, e := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, e</span><br><span class="line">	&#125;</span><br><span class="line">	metas := <span class="built_in">make</span>([]Metadata, <span class="number">0</span>)</span><br><span class="line">	result, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">	<span class="keyword">var</span> sr searchResult</span><br><span class="line">	json.Unmarshal(result, &amp;sr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> sr.Hits.Hits &#123;</span><br><span class="line">		metas = <span class="built_in">append</span>(metas, sr.Hits.Hits[i].Source)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> metas, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试环境与上一版本相同，具体代码见<a href="https://github.com/dongshifu/distributed_object_storage_dong/tree/main/v2" target="_blank" rel="noopener">带元数据服务的分布式对象存储</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>《分布式对象存储—原理、架构及Go语言实现》</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag"># 分布式</a>
              <a href="/tags/go/" rel="tag"># go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-2%E5%8F%AF%E6%89%A9%E5%B1%95%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" rel="prev" title="可扩展分布式系统实现">
      <i class="fa fa-chevron-left"></i> 可扩展分布式系统实现
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/20/os-%E7%BD%91%E7%BB%9C-2/" rel="next" title="网络调优工具使用">
      网络调优工具使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments" id="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MjkwMy8yOTM4MA=="></div>
  </div>
  
            </div>
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments" id="gitalk-container"></div>
            </div>
        </div>
      </div>
      <script>
        window.addEventListener('tabs:register', () => {
          let activeClass = 'gitalk';
            activeClass = localStorage.getItem('comments_active') || activeClass;
          if (activeClass) {
            let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
            if (activeTab) {
              activeTab.click();
            }
          }
        });
        window.addEventListener('tabs:click', event => {
          let commentClass = event.target.classList[1];
          localStorage.setItem('comments_active', commentClass);
        });
      </script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#元数据服务"><span class="nav-number">1.</span> <span class="nav-text">元数据服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#元数据"><span class="nav-number">1.1.</span> <span class="nav-text">元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#散列值和散列函数"><span class="nav-number">1.2.</span> <span class="nav-text">散列值和散列函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式对象存储加入元数据服务"><span class="nav-number">1.3.</span> <span class="nav-text">分布式对象存储加入元数据服务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#REST接口"><span class="nav-number">1.3.1.</span> <span class="nav-text">REST接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ES接口"><span class="nav-number">1.3.2.</span> <span class="nav-text">ES接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#添加对象元数据"><span class="nav-number">1.3.3.</span> <span class="nav-text">添加对象元数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#用到的ES-API"><span class="nav-number">1.3.4.</span> <span class="nav-text">用到的ES API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对象PUT流程"><span class="nav-number">1.3.5.</span> <span class="nav-text">对象PUT流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对象GET流程"><span class="nav-number">1.3.6.</span> <span class="nav-text">对象GET流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具体实现"><span class="nav-number">1.4.</span> <span class="nav-text">具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#接口服务"><span class="nav-number">1.4.1.</span> <span class="nav-text">接口服务</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#接口服务的main函数"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">接口服务的main函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#接口服务的versions包"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">接口服务的versions包</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#接口服务的objects包"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">接口服务的objects包</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#es包"><span class="nav-number">1.4.2.</span> <span class="nav-text">es包</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试"><span class="nav-number">1.5.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考"><span class="nav-number">1.6.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShifuDong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShifuDong</p>
  <div class="site-description" itemprop="description">记录生活， 记录学习， 分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/mailto:sfd_w@foxmail.com" title="E-Mail → mailto:sfd_w@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShifuDong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  

<script>
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'a6ee5b68c97a3db64850',
      clientSecret: '1dfa06f32032431e4af79b80f9ddf9dfd13dbda2',
      repo: 'dongshifu.github.io',
      owner: 'dongshifu',
      admin: ['dongshifu'],
      id: '8329b7a91380de76d62569c89e8d31b4',
        language: 'zh-CN',
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

    </div>
</body>
</html>
